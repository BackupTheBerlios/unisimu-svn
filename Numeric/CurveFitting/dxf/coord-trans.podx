=head1 NAME

coord-trans - 坐标变换

=head1 AUTHOR

Agent Zhang (章亦春) E<lt>agent2002@126.comE<gt>

=head1 DESCRIPTION

本文档将对来自扫描图片的原始象素坐标进行变换，以便得到图纸上的理论坐标。我们
利用 GetPoint 软件的 GUI 界面已得到了几组包含有象素坐标列表的 YAML 数据文
件。

我们首期望得到有关坐标系本身的信息。事实上这儿有两个坐标系，一是象素坐标系，
一是理论坐标系。YAML 文件中的坐标是象素坐标，我们希望找到一个转换函数，可
以实现从象素坐标到理论坐标的变换。

由于 GetPoint 设计上的失误，其导出的 YAML 文件中点的坐标表示成了字符串
的形式，即横坐标与纵坐标以空格分隔的字符串。这使得我们在对坐标进行操作的
时候很不方便，因此我编写了下面的 Perl 校正函数，用来校正从 YAML 读出的
groups 数据结构：

=begin Perl

sub adjust_groups {
    my $groups = shift;
    foreach my $points (values %$groups) {
        map { $_ = [split /\s+/, $_] } @$points;
    }
    return $groups;
}

=end Perl

=head1 理论坐标系的原点

对于理论坐标系而言，其原点的象素坐标我们可以用下面的方法取得：

首先读取对应的 YAML 文件：

=begin Perl

use YAML qw(LoadFile Dump);
$groups = adjust_groups LoadFile 'data/y-coord.yml';
Dump($groups->{o});

=end Perl

这是理论坐标系原点的两组象素坐标。我们以它们的中点为准：

=begin Perl

my @points = @{ $groups->{o} };
my ($p1, $p2) = @points;

$x = ($p1->[0] + $p2->[0]) / 2;
$y = ($p1->[1] + $p2->[1]) / 2;
$origin = [$x, $y];
Dump($origin);

=end Perl

=head1 理论坐标系标度的确定

=head2 理论纵坐标刻度的确定

我们现在已经将 Y 轴“刻度点”的象素坐标值读取到了 $groups 变量中。
该变量中含有如下几组数据：

=Perl Dump($groups);

其中 o 表示原点的采样数据，y-XXX 表示 XXX 刻度上的采样数据。
每一组数据由几个采样点组成，我们需要从每一组点中得出“最佳”的一个
点。我们以 y-700 为例进行讨论。我们设要找的点为 (x, y).
则该组内所有点到 (x, y) 的距离之和为

=begin Perl

my @points = @{ $groups->{'y-400'} };
my @terms = map { 
    my ($x, $y) = @$_;
    "($x - x )^2 + ($y - y)^2";
} @points;
$distance_sum = join(' + ', @terms);

=end Perl

我们将之导入到 Maple 环境中去：

=begin Perl

use PerlMaple;
$maple = PerlMaple->new;
$maple->eval_cmd("dist_sum:=evalf($distance_sum);");

=end Perl

我们求该表示式的最小值：

=Maple res := minimize(dist_sum, location);

下面我们提取出最小值点的坐标：

=begin Perl

$maple->ReturnAST(1);
my $res = $maple->eval_cmd('res;');
my ($min, $set) = $res->ops;
my @sols = $set->ops;
my ($loc, $min2) = $sols[0]->ops;
my @eqns = $loc->ops;
my ($x, $y);
map { 
    $_->lhs eq 'x' ? ($x = $_->rhs) : ($y = $_->rhs)
} @eqns;
($x, $y);

=end Perl

下面我们将上面的代码封装成一个可以复用的 Perl 函数：

=begin Perl

sub best_points {
    use strict;
    my @points = @_;
    my @terms = map { 
        my ($x, $y) = @$_;
        "($x - x )^2 + ($y - y)^2";
    } @points;
    my $dist_sum = join(' + ', @terms);
    my $maple = PerlMaple->new(ReturnAST => 1);
    my $res = $maple->eval_cmd( "evalf($dist_sum);" );
    $res = $maple->eval_cmd( "minimize($res, location);" );
    my ($min, $set) = $res->ops;
    my @sols = $set->ops;
    my @best;
    foreach my $sol (@sols) {
        my ($loc, $min) = $sol->ops;
        my @eqns = $loc->ops;
        my ($x, $y);
        map { 
            $_->lhs eq 'x' ? ($x = $_->rhs) : ($y = $_->rhs);
        } @eqns;
        if ($x >= 0 and $y >= 0) {
            push @best, ["$x", "$y"];
        }
    }
    return @best;
}

=end Perl

我们用上面的例子来测试一下 best_points:

=begin Perl

undef $x; undef $y;
@points = @{ $groups->{'y-700'} };
@best = best_points( @points );
$y_scale{700} = $best[0];
@{ $best[0] };

=end Perl

我们不妨将采样点和“最佳点”的图像画出来：

=begin Perl

map { $_ = '['.join(',', @$_).']' } @points;
my $point_list = join(',', @points);
my $best_point = '['.join(',', @{ $best[0] }).']';
$maple->eval_cmd(<<".");
with(plots):
plotsetup(gif,plotoutput="image/diag1.gif",plotoptions="height=200,width=200"):
plot1:=pointplot({$point_list},color=red):
plot2:=pointplot({$best_point},color=blue):
display({plot1, plot2},axes=BOXED,symbol=CIRCLE);
.

=end Perl

=begin html

<pre>
    <img src="image/diag1.gif"/>
</pre>

=end html

图中，红色的点是实验测得的点，蓝色的点是我们的 best_points 得到的“最佳点”。我们看到，
“最佳点”的位置与我们的直观结论是一致的。

我们再试一个复杂一些的例子。我们任意给出 5 个点的坐标：

=Perl @points = ([2.3,5.2], [1.3, 2.7], [2.0,3.7], [1.5, 4.2], [5.2, 3.1]);

用 best_points 计算出“最佳点”的坐标：

=Perl @best = best_points(@points);

作出图象：

=begin Perl

map { $_ = '['.join(',', @$_).']' } @points;
my $point_list = join(',', @points);
my $best_point = '['.join(',', @{ $best[0] }).']';
$maple->eval_cmd(<<".");
with(plots):
plotsetup(gif,plotoutput="image/diag2.gif",plotoptions="height=200,width=200"):
plot1:=pointplot({$point_list},color=red):
plot2:=pointplot({$best_point},color=blue):
display({plot1, plot2},axes=BOXED,symbol=CIRCLE);
.

=end Perl

=begin html

<pre>
    <img src="image/diag2.gif"/>
</pre>

=end html

现在我们可以用 best_points 来计算余下所有组的坐标了：

=begin Perl

$groups->{'y-0'} = $groups->{o};
foreach my $key (qw(0 100 200 300 400 500 600 800)) {
    my @points = @{ $groups->{"y-$key"} };
    my @best = best_points( @points );
    die "not a unique solution" if @best != 1;
    $y_scale{$key} = $best[0];
}
Dump(\%y_scale);

=end Perl

下面一步是解出一单位的理论纵坐标相当于多少单位的象素纵坐标。

=begin Perl

my @s = sort { $a <=> $b } keys %y_scale;
@vals = ();
for my $i (0..@s-2) {
    my $p1 = $y_scale{ $s[$i] };
    my $p2 = $y_scale{ $s[$i+1] };
    my $d = sqrt( ($p2->[0] - $p1->[0])**2 + ($p2->[1] - $p1->[1])**2 );
    push @vals, $d / ( $s[$i+1] - $s[$i] );
}
@vals;

=end Perl

下面我们对这些值取平均值就得到一单位的理论纵坐标相当于多少单位的象素纵坐标了：

=Perl $y_scale = $maple->eval( '('.join('+', @vals).")/".scalar(@vals) );

=head2 理论横坐标刻度的确定

这是前面纵坐标刻度的确定过程是完全类似地：

=begin Perl

$groups2 = adjust_groups LoadFile 'data/x-coord.yml';
$groups2->{'x-0'} = $groups->{'y-0'};
Dump($groups2);

=end Perl

然后，找到每个刻度的“最佳点”：

=begin Perl

foreach my $key (qw(0 100 200 300 600 700 800 900)) {
    my @points = @{ $groups2->{"x-$key"} };
    my @best = best_points( @points );
    die "not a unique solution" if @best != 1;
    $x_scale{$key} = $best[0];
}
Dump(\%x_scale);

=end Perl

余下的过程也完全相同：

=begin Perl

my @s = sort { $a <=> $b } keys %x_scale;
@vals = ();
for my $i (0..@s-2) {
    my $p1 = $x_scale{ $s[$i] };
    my $p2 = $x_scale{ $s[$i+1] };
    my $d = sqrt( ($p2->[0] - $p1->[0])**2 + ($p2->[1] - $p1->[1])**2 );
    push @vals, $d / ( $s[$i+1] - $s[$i] );
}
@vals;

=end Perl

=Perl $x_scale = $maple->eval( '('.join('+', @vals).")/".scalar(@vals) );

=head1 理论坐标系相对于象素坐标系的旋转角度

=head2 理论坐标系的 Y 轴的偏转角

我们首先尝试能过最小二乘法拟合出理论坐标系 Y 轴在象素坐标系中的方程。首先读取 Y 轴上
的采样点坐标的列表：

=begin Perl

$groups = adjust_groups LoadFile 'data/y-axis.yml';
@points = @{ $groups->{'y-axis'} };
scalar(@points);

=end Perl

现在我们已将 34 个采样点的象素坐标从 F<y-axis.yml> 文件加载到 @points 数组中了。
现在我们使用 Maple 的 CurveFitting 包提供的 LeastSquares 函数进行线性拟合：

=begin Perl

my @s = map { '['.join(',', @$_).']' } @points;
$maple->eval_cmd("points:=[".join(',',@s)."];");

=end Perl

=begin Maple

with(CurveFitting):
ycurve := evalf(LeastSquares(points,x));

=end Maple

其图象如下所示：

=begin Maple

plotsetup(gif,plotoutput="image/diag3.gif",plotoptions="height=300,width=300"):
pplot := pointplot(points,symbol=CIRCLE,color=black):
yplot := plot(ycurve, x=250..300, color=red):
display([pplot,yplot],axes=BOXED);

=end Maple

=begin html

<pre>
    <img src="image/diag3.gif"/>
</pre>

=end html

注意上图中直线的倾斜角其实是很小的，之所以在图中看起来很大是因为 Maple 为了布局尽可能地好看，
改变了横坐标和纵坐标的比例。按相同的横纵坐标比例画出的图应该是下面的样子：

=begin Maple

plotsetup(gif,plotoutput="image/diag4.gif",plotoptions="height=300,width=300"):
display([pplot,yplot],axes=BOXED,scaling=CONSTRAINED);

=end Maple

=begin html

<pre>
    <img src="image/diag4.gif"/>
</pre>

=end html

我们看到点全部挤到一起了，影响视觉效果。

值得指出的是，上面两个图中的直线所对应的理论 y 轴，其正方向是向下的。因此，理论 y 轴正方向
与象素 y 轴的正方向之间的夹角在 90 度到 180 度之间，我们可以用下面的方法求出该角：

=begin Maple

with(geometry):
_EnvHorizontalName := 'x': _EnvVerticalName := 'y':
line(L1, y=ycurve), line(L2, x = 0);
theta1:=Pi - FindAngle(L1, L2);

=end Maple

为了获得直观上的印象，我们将这个弧度值化成角度：

=Maple evalf(convert(theta1, degrees));

=head2 理论坐标系的 X 轴的偏转角


=head2 偏转角的平均值

