<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
           "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>S11</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="http://dev.perl.org/css/perl.css">

<script type="text/javascript">
var agt = navigator.userAgent.toLowerCase();

var is_opera = (agt.indexOf("opera") != -1);
var is_ie = (agt.indexOf("msie") != -1) && document.all && !is_opera;
var is_ie5 = (agt.indexOf("msie 5") != -1) && document.all;

function tog() {
  // tog: toggle the visibility of html elements (arguments[1..]) from none to
  // arguments[0].  Return what should be returned in a javascript onevent().
  display = arguments[0];
  for( var i=1; i<arguments.length; i++ ) {
    var x = document.getElementById(arguments[i]);
    if (!x) continue;
    if (x.style.display == "none" || x.style.display == "") {
      x.style.display = display;
    } else {
      x.style.display = "none";
    }
  }

  var e = is_ie ? window.event : this;
  if (e) {
    if (is_ie) {
      e.cancelBubble = true;
      e.returnValue = false;
      return false;
    } else {
      return false;
    }
  }
}

function tog_quote( idnum ) {
  return tog( 'block', 'header_shown_' + idnum, 'header_hidden_' + idnum,
       'hide_' + idnum );
}

</script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.03,
  using Pod::Simple::PullParser v2.02,
  under Perl v5.008007 at Tue Sep  5 14:13:13 2006 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
            <I>This page was generated at 2006-09-05 14:13:13 GMT.
            (syn <strong>r11725</strong>, pugs <strong>r13036</strong>)</I>
        
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Overview'>Overview</a>
  <li class='indexItem indexItem1'><a href='#Modules'>Modules</a>
  <li class='indexItem indexItem1'><a href='#Exportation'>Exportation</a>
  <li class='indexItem indexItem1'><a href='#Dynamic_exportation'>Dynamic exportation</a>
  <li class='indexItem indexItem1'><a href='#Compile-time_Importation'>Compile-time Importation</a>
  <li class='indexItem indexItem1'><a href='#Runtime_Importation'>Runtime Importation</a>
  <li class='indexItem indexItem1'><a href='#Importing_from_a_pseudo-package'>Importing from a pseudo-package</a>
  <li class='indexItem indexItem1'><a href='#Versioning'>Versioning</a>
  <li class='indexItem indexItem1'><a href='#Forcing_Perl_6'>Forcing Perl 6</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 11: Modules</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Larry Wall &#60;larry@wall.org&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre>  Maintainer: Larry Wall &#60;larry@wall.org&#62;
  Date: 27 Oct 2004
  Last Modified: 6 Jul 2006
  Number: 11
  Version: 14</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Overview"
>Overview</a></h1>

<p>This synopsis discusses those portions of Apocalypse 12 that ought to have been in Apocalypse 11.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Modules"
>Modules</a></h1>

<p>As in Perl 5, a module is just a kind of package. Unlike in Perl 5, modules and classes are declared with separate keywords, but they&#39;re still just packages with extra behaviors.</p>

<p>A module is declared with the <code>module</code> keyword. There are two basic declaration syntaxes:</p>

<pre>    module Foo; # rest of scope is in module Foo
    ...

    module Bar {...}    # block is in module Bar</pre>

<p>The first form is allowed only as the first statement in the file.</p>

<p>A named module declaration can occur as part of an expression, just like named subroutine declarations.</p>

<p>Since there are no barewords in Perl 6, module names must be predeclared, or use the sigil-like <code>::ModuleName</code> syntax. The <code>::</code> prefix does not imply top-levelness as it does in Perl 5. (Use <code>::*</code> or <code>GLOBAL::</code> for that.)</p>

<p>A bare <code>module</code> declarator declares an <code>our</code> module name in the current package. At the start of the file, the current package is <code>*</code>, so the first declaration in the file is automatically global.</p>

<p>You can use <code>our module</code> to explicitly declare a module in the current package (or module, or class). To declare a lexically scoped module, use <code>my module</code>. Module names are always searched for from innermost scopes to outermost. As with an initial <code>::</code>, the presence of a <code>::</code> within the name does not imply globalness (unlike in Perl 5).</p>

<p>The <code>::*</code> namespace is not &#34;main&#34;. The default namespace for the main program is <code>::*Main</code>, which it switches to from * as soon as it sees the first declaration, if that declaration doesn&#39;t set the package name. (Putting <code>module Main;</code> at the top of your program is redundant, except insofar as it tells Perl that the code is Perl 6 code and not Perl 5 code. But it&#39;s better to say &#34;use v6&#34; for that.)</p>

<p>But note that if you say</p>

<pre>    use v6;
    module Foo {...}</pre>

<p>you&#39;ve just created Main::Foo, not *Foo.</p>

<p>Module traits are set using <code>is</code>:</p>

<pre>    module Foo is bar {...}</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Exportation"
>Exportation</a></h1>

<p>Exportation is now done by trait declaration on the exportable item:</p>

<pre>    module Foo;                                # Tagset...
    sub foo is export(:DEFAULT)         {...}  #  :DEFAULT, :ALL
    sub bar is export(:DEFAULT :others) {...}  #  :DEFAULT, :ALL, :others
    sub baz is export(:MANDATORY)       {...}  #  (always exported)
    sub bop is export                   {...}  #  :ALL
    sub qux is export(:others)          {...}  #  :ALL, :others</pre>

<p>Declarations marked as <code>is export</code> are bound into the <code>EXPORT</code> inner modules, with their tagsets as inner module names within it. For example, the <code>sub bar</code> above will bind as <code>&#38;Foo::EXPORT::DEFAULT::bar</code>, <code>&#38;Foo::EXPORT::ALL::bar</code>, and <code>&#38;Foo::EXPORT::others::bar</code>.</p>

<p>Tagset names consisting entirely of capitals are reserved for Perl.</p>

<p>Inner modules automatically add their export list to modules in all their outer scopes:</p>

<pre>    module Foo {
        sub foo is export {...}
        module Bar {
            sub bar is export {...}
            module Baz {
                sub baz is export {...}
            }
        }
    }</pre>

<p>The <code>Foo</code> module will export <code>&#38;foo</code>, <code>&#38;bar</code> and <code>&#38;baz</code> by default; calling <code>Foo::Bar.EXPORTALL</code> will export <code>&#38;bar</code> and <code>&#38;baz</code> at runtime to the caller&#39;s package.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Dynamic_exportation"
>Dynamic exportation</a></h1>

<p>The default <code>EXPORTALL</code> handles symbol exports by removing recognized export items and tagsets from the argument list, then calls the <code>EXPORT</code> subroutine in that module (if there is one), passing in the remaining arguments.</p>

<p>If the exporting module is actually a class, <code>EXPORTALL</code> will invoke its <code>EXPORT</code> method with the class itself as the invocant.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Compile-time_Importation"
>Compile-time Importation</a></h1>

<p>Importing via <code>use</code> binds into the current lexical scope by default (rather than the current package, as in Perl 5).</p>

<pre>    use Sense &#60;common @horse&#62;;</pre>

<p>You can be explicit about the desired namespace:</p>

<pre>    use Sense :MY&#60;common&#62; :OUR&#60;@horse&#62; :GLOBAL&#60;$warming&#62;;</pre>

<p>That&#39;s pretty much equivalent to:</p>

<pre>    use Sense;
    my &#38;common ::= &#38;Sense::common;
    our @horse ::= @Sense::horse;
    $*warming  ::= $Sense::warming;</pre>

<p>It is also possible to re-export the imported symbols:</p>

<pre>    use Sense :EXPORT;                  # import and re-export the defaults
    use Sense &#60;common&#62; :EXPORT;         # import &#34;common&#34; and re-export it
    use Sense &#60;common&#62; :EXPORT&#60;@horse&#62;; # import &#34;common&#34; but export &#34;@horse&#34;</pre>

<p>In the absence of a specific scoping specified by the caller, the module may also specify a different scoping default by use of <code>:MY</code> or <code>:OUR</code> tags as arguments to <code>is export</code>. (Of course, mixing incompatible scoping in different scopes is likely to lead to confusion.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Runtime_Importation"
>Runtime Importation</a></h1>

<p>Importing via <code>require</code> also binds into the current lexical scope by default, but performs the binding at runtime:</p>

<pre>    require Sense &#60;common @horse&#62;;
    require &#34;/home/non/Sense.pm&#34; &#60;common @horse&#62;;</pre>

<p>Tagsets are not recognized in the default import list to <code>:MY</code>, but you can explicitly request to put them into the <code>:OUR</code> scope:</p>

<pre>    require Sense &#60;:ALL&#62;    # does not work
    require Sense :MY&#60;ALL&#62;  # this doesn&#39;t work either
    require Sense :OUR&#60;ALL&#62; # but this works</pre>

<p>If the import list is omitted, then nothing is imported. Calling <code>.import</code> at runtime cannot import into the lexical scope:</p>

<pre>    require Sense;
    Sense.EXPORTALL;   # goes to the OUR scope by default, not MY</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Importing_from_a_pseudo-package"
>Importing from a pseudo-package</a></h1>

<p>You may also import symbols from the various pseudo-packages listed in S02. They behave as if all their symbols are in the <code>:ALL</code> export list:</p>

<pre>    use GLOBAL &#60;$IN $OUT $ERR&#62;;
    require CALLER &#60;$x $y&#62;;

    # Same as:
    #     my ($IN, $OUT, $ERR) ::= ($*IN, $*OUT, $*ERR)
    #     my ($x, $y) := ($CALLER::x, $CALLER::y)</pre>

<p>As pseudo-packages are always already preloaded, <code>use</code> and <code>require</code> will never attempt to load, for example, <code>GLOBAL.pm</code> from an external source.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Versioning"
>Versioning</a></h1>

<p>When at the top of a file you say something like</p>

<pre>    module Cat;</pre>

<p>or</p>

<pre>    class Dog;</pre>

<p>you&#39;re really only giving one part of the name of the module. The full name of the module or class includes other metadata, in particular, the version, and the author.</p>

<p>Modules posted to CPAN or entered into any standard Perl 6 library are required to declare their full name so that installations can know where to keep them, such that multiple versions by different authors can coexist, all of them available to any installed version of Perl.</p>

<p>The syntax of a versioned module or class declaration has three parts separated by hyphens. The three parts are the short name of the class/module, its version number, and a URI identifying the author (or authorizing authority). For example:</p>

<pre>    class Dog-1.2.1-cpan:JRANDOM;
    class Dog-1.2.1-http://www.some.com/~jrandom;
    class Dog-1.2.1-mailto:jrandom@some.com;</pre>

<p>Such a declaration automatically aliases the full name of the class (or module) to the short name. So for the rest of the lexical scope, <code>Dog</code> refers to the longer name.</p>

<p>If there are extra classes or modules or packages declared within the same file, they implicitly have a long name including the file&#39;s version and author, but you needn&#39;t declare them again.</p>

<p>Since these long names are the actual names of the classes, when you say:</p>

<pre>    use Dog;</pre>

<p>you&#39;re really wildcarding the unspecified bits:</p>

<pre>    use Dog-(Any)-(Any);</pre>

<p>And when you say:</p>

<pre>    use Dog-1.2.1;</pre>

<p>you&#39;re really asking for:</p>

<pre>    use Dog-1.2.1-(Any);</pre>

<p>Saying <code>1.2.1</code> specifies an <i>exact</i> match on the version number, not a minimum match. To match more than one version, put a range operator in parens:</p>

<pre>    use Dog-(1.2.1..1.2.3);
    use Dog-(1.2.1..^1.3);
    use Dog-(1.2.1..*);</pre>

<p>Subversions are wildcarded, so <code>1.2</code> really means <code>1.2.*</code>. If you say:</p>

<pre>    use v6;</pre>

<p>which is short for:</p>

<a href="#" onclick="return tog_quote(1);">
<div ID="header_shown_1" style="display: none;">
- Hide the snippet from t/packages/use_perl_6.t (line 3 ~ line 9) -
</div>
<div ID="header_hidden_1" style="display: block;">
- Show the snippet from t/packages/use_perl_6.t (line 3 ~ line 9) -
</div>
</a>
<div ID="hide_1" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S11/&quot;Versioning&quot; /which is short for/&gt;

use Perl-6;
use Test;

plan 1;
ok &quot;'use Perl-6' works (and means the same as 'use v6')&quot;;</pre>
</div>


<pre>    use Perl-6;</pre>

<p>you&#39;re asking for any version of Perl 6. You need to say:</p>

<pre>    use Perl-6.0;
    use Perl-6.0.0;
    use Perl-6.2.7.1;</pre>

<p>if you want to lock in a particular set of semantics at some greater degree of specificity. And if some large company ever forks Perl, you can say</p>

<pre>    use Perl-6-cpan:TPF</pre>

<p>to guarantee that you get the unembraced Perl. <code>:-)</code></p>

<p>Perl is the default module name, so this means the same thing:</p>

<pre>    use v6-cpan:TPF;</pre>

<p>Before the full specification of Perl 6.0.0 is released, you can use <code>alpha</code> as the author slot to denote a program using syntax that is still subject to change:</p>

<pre>    use v6-alpha;</pre>

<p>The <code>use v6-alpha</code> line also serves as the Perl 5 incantation to switch to Perl 6 parsing. In Perl 5 this actually ends up calling the v6.pm module with a <code>-alpha</code> argument, for insane-but-useful reasons.</p>

<p>For wildcards any valid smartmatch selector works:</p>

<pre>    use Dog-(1.2.1 | 1.3.4)-(/:i jrandom/);
    use Dog-(Any)-(/^cpan\:/)</pre>

<p>Parens are optional on a closure smartmatcher. The preceding may also be written:</p>

<pre>    use Dog-{$^ver ~~ 1.2.1 | 1.3.4}-{$^auth ~~ /:i jrandom/};
    use Dog-{$^ver ~~ Any}-{$^auth ~~ /^cpan\:/}</pre>

<p>In any event, however you select the module, its full name is automatically aliased to the short name for the rest of your lexical scope. So you can just say</p>

<pre>    my Dog $spot .= new(&#34;woof&#34;);</pre>

<p>and it knows (even if you don&#39;t) that you mean</p>

<pre>    my Dog-1.3.4-cpan:JRANDOM $spot .= new(&#34;woof&#34;);</pre>

<p>The <code>use</code> statement actually allows a language on the front of a module name, so that you can use modules from other languages. The language is separated by a colon. For instance:</p>

<pre>    use perl5:Acme::Bleach-1.12-DCONWAY;
    use ruby:Rails &#60;PR_MACHINE&#62;;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Forcing_Perl_6"
>Forcing Perl 6</a></h1>

<p>To get Perl 6 parsing rather than the default Perl 5 parsing, we said you could force Perl 6 mode in your main program with:</p>

<pre>    use Perl-6;</pre>

<p>Actually, you can just start your main program with any of:</p>

<pre>    use v6;
    module;
    class;</pre>

<p>Those all specify the latest Perl 6 semantics, and are equivalent to</p>

<pre>    use Perl-(v6..*)-(Any);</pre>

<p>To lock the semantics to 6.0.0, say:</p>

<pre>    use v6.0.0;</pre>

<p>In any of those cases, strictures and warnings are the default in your main program. But if you start your program with a bare version number or other literal:</p>

<pre>    v6.0.0;
    v6;
    6;
    &#34;Coolness, dude!&#34;;</pre>

<p>it runs Perl 6 in &#34;lax&#34; mode, without strictures or warnings, since obviously a bare literal in a void context <i>ought</i> to have produced a warning. (Invoking perl with <code>-e6</code> has the same effect.)</p>

<p>It&#39;s not necessary to force Perl 6 if the interpreter or command specified already implies it, such as use of a &#34;<code>#!/usr/bin/perl6</code>&#34; shebang line. Nor is it necessary to force Perl 6 in any file that begins with the &#34;class&#34; or &#34;module&#34; keywords.</p>

<!-- end doc -->

</body></html>
