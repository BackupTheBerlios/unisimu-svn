<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
           "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>S16</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="http://dev.perl.org/css/perl.css">

<script type="text/javascript">
var agt = navigator.userAgent.toLowerCase();

var is_opera = (agt.indexOf("opera") != -1);
var is_ie = (agt.indexOf("msie") != -1) && document.all && !is_opera;
var is_ie5 = (agt.indexOf("msie 5") != -1) && document.all;

function tog() {
  // tog: toggle the visibility of html elements (arguments[1..]) from none to
  // arguments[0].  Return what should be returned in a javascript onevent().
  display = arguments[0];
  for( var i=1; i<arguments.length; i++ ) {
    var x = document.getElementById(arguments[i]);
    if (!x) continue;
    if (x.style.display == "none" || x.style.display == "") {
      x.style.display = display;
    } else {
      x.style.display = "none";
    }
  }

  var e = is_ie ? window.event : this;
  if (e) {
    if (is_ie) {
      e.cancelBubble = true;
      e.returnValue = false;
      return false;
    } else {
      return false;
    }
  }
}

function tog_quote( idnum ) {
  return tog( 'block', 'header_shown_' + idnum, 'header_hidden_' + idnum,
       'hide_' + idnum );
}

</script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.03,
  using Pod::Simple::PullParser v2.02,
  under Perl v5.008007 at Mon Oct  9 11:02:51 2006 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
            <I>This page was generated at 2006-10-09 11:02:51 GMT.
            (syn <strong>r12875</strong>, pugs <strong>r14123</strong>)</I>
        
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#Title'>Title</a>
  <li class='indexItem indexItem1'><a href='#Version'>Version</a>
  <li class='indexItem indexItem1'><a href='#Filehandles%2C_files%2C_and_directories'>Filehandles, files, and directories</a>
  <li class='indexItem indexItem1'><a href='#Input_and_Output'>Input and Output</a>
  <li class='indexItem indexItem1'><a href='#Unfiled'>Unfiled</a>
  <li class='indexItem indexItem1'><a href='#Additions'>Additions</a>
  <li class='indexItem indexItem1'><a href='#POD_ERRORS'>POD ERRORS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Title"
>Title</a></h1>

<p>DRAFT: Synopsis 16: IPC / IO / Signals</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Version"
>Version</a></h1>

<pre> Author:        Largely, the authors of the related Perl 5 docs.
 Maintainer:    Larry Wall &#60;larry@wall.org&#62;
 Contributions: Mark Stosberg &#60;mark@summersault.com&#62;
 Date:          12 Sep 2006
 Last Modified: 25 Sep 2006
 Version:       15  </pre>

<p>This is a draft document. Many of these functions will work as in Perl 5, except we&#39;re trying to rationalize everything into packages. For now you can assume most of the important ones will automatically be in the * namespace.</p>

<p>As a starting point, you can help by finding the official Perl 5 documentation for these functions and copying it here.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Filehandles,_files,_and_directories"
>Filehandles, files, and directories</a></h1>

<dl>
<dt><a name="-X"
>-X</a></dt>

<dd>
<dl>
<dt><a name="-X_FILEHANDLE__"
>-X FILEHANDLE <!--
	INDEX: -r
--><!--
	INDEX: -w
--><!--
	INDEX: -x
--><!--
	INDEX: -o
--><!--
	INDEX: -R
--><!--
	INDEX: -W
--><!--
	INDEX: -X
--><!--
	INDEX: -O
--><!--
	INDEX: -e
--><!--
	INDEX: -z
--><!--
	INDEX: -s
--><!--
	INDEX: -f
--><!--
	INDEX: -d
--><!--
	INDEX: -l
--><!--
	INDEX: -p
--> <!--
	INDEX: -S
--><!--
	INDEX: -b
--><!--
	INDEX: -c
--><!--
	INDEX: -t
--><!--
	INDEX: -u
--><!--
	INDEX: -g
--><!--
	INDEX: -k
--><!--
	INDEX: -T
--><!--
	INDEX: -B
--><!--
	INDEX: -M
--><!--
	INDEX: -A
--><!--
	INDEX: -C
-->
<dt><a name="-X_EXPR"
>-X EXPR
<dt><a name="-X"
>-X</a></dt>

<dd>
<pre>  -X $file  
  $file.&#39;-X&#39;</pre>

<p>A file test, where X is one of the letters listed below. This unary operator takes one argument, either a filename or a filehandle, and tests the associated file to see if something is true about it. The argument may not be omitted unless it is <code>$_</code>, in which case you must use the <code>.&#39;-X&#39;</code> form.</p>

<p>All file test operators return a stat buffer that also carries a &#34;cumulative success&#34; boolean (or file size in the case of <code>-s</code>) so that tests may be stacked:</p>

<pre>    -r -w $filename</pre>

<p>or applied to existing stat buffers:</p>

<pre>    $b = stat($filename);
    if -r $b {...}</pre>

<p>Despite the funny names, precedence is the same as any other named unary operator, and the argument may be parenthesized like any other unary operator. The operator may be any of:</p>

<pre>    -r  File is readable by effective uid/gid.
    -w  File is writable by effective uid/gid.
    -x  File is executable by effective uid/gid.
    -o  File is owned by effective uid.

    -R  File is readable by real uid/gid.
    -W  File is writable by real uid/gid.
    -X  File is executable by real uid/gid.
    -O  File is owned by real uid.

    -e  File exists.
    -z  File has zero size (is empty).
    -s  File has nonzero size (returns size in bytes).

    -f  File is a plain file.
    -d  File is a directory.
    -l  File is a symbolic link.
    -p  File is a named pipe (FIFO), or Filehandle is a pipe.
    -S  File is a socket.
    -b  File is a block special file.
    -c  File is a character special file.
    -t  Filehandle is opened to a tty.

    -u  File has setuid bit set.
    -g  File has setgid bit set.
    -k  File has sticky bit set.

    -T  File is an ASCII text file (heuristic guess).
    -B  File is a &#34;binary&#34; file (opposite of -T).

    -M  Script start time minus file modification time, in days.
    -A  Same for access time.
    -C  Same for inode change time (Unix, may differ for other platforms)</pre>

<p>The interpretation of the file permission operators <code>-r</code>, <code>-R</code>, <code>-w</code>, <code>-W</code>, <code>-x</code>, and <code>-X</code> is by default based solely on the mode of the file and the uids and gids of the user. There may be other reasons you can&#39;t actually read, write, or execute the file. Such reasons may be for example network filesystem access controls, ACLs (access control lists), read-only filesystems, and unrecognized executable formats.</p>

<p>Also note that, for the superuser on the local filesystems, the <code>-r</code>, <code>-R</code>, <code>-w</code>, and <code>-W</code> tests always return 1, and <code>-x</code> and <code>-X</code> return 1 if any execute bit is set in the mode. Scripts run by the superuser may thus need to do a stat() to determine the actual mode of the file, or temporarily set their effective uid to something else.</p>

<p>If you are using ACLs, there is a pragma called <code>filetest</code> that may produce more accurate results than the bare stat() mode bits. When under the <code>use filetest &#39;access&#39;</code> the above-mentioned filetests will test whether the permission can (not) be granted using the access() family of system calls. Also note that the <code>-x</code> and <code>-X</code> may under this pragma return true even if there are no execute permission bits set (nor any extra execute permission ACLs). This strangeness is due to the underlying system calls&#39; definitions. Read the documentation for the <code>filetest</code> pragma for more information.</p>

<p>Note that <code>-s/a/b/</code> does not do a negated substitution. Saying <code>-exp($foo)</code> still works as expected, however--only single letters following a minus are interpreted as file tests.</p>

<p>The <code>-T</code> and <code>-B</code> switches work as follows. The first block or so of the file is examined for odd characters such as strange control codes or characters with the high bit set. If too many strange characters (&#62;30%) are found, it&#39;s a <code>-B</code> file; otherwise it&#39;s a <code>-T</code> file. Also, any file containing null in the first block is considered a binary file. If <code>-T</code> or <code>-B</code> is used on a filehandle, the current IO buffer is examined rather than the first block. Both <code>-T</code> and <code>-B</code> return true on a null file, or a file at EOF when testing a filehandle. Because you have to read a file to do the <code>-T</code> test, on most occasions you want to use a <code>-f</code> against the file first, as in <code>next unless -f $file &#38;&#38; -T $file</code>.</p>

<p>The return value of a test is both a boolean and a stat buffer. So you can say:</p>

<pre>  if -r -w -x $filename {...}</pre>

<p>Or chain tests together in OO style:</p>

<pre>  if $filename.&#39;-e&#39;.&#39;-x&#39; {...}</pre>

<dt><a name="chown"
>chown
<dt><a name="chmod_LIST___"
>chmod LIST <!--
	INDEX: chmod
--> <!--
	INDEX: permission
--> <!--
	INDEX: mode
--></a></dt>

<dd>
<a href="#" onclick="return tog_quote(1);">
<div ID="header_shown_1" style="display: none;">
- Hide the snippet from t/builtins/system/chmod.t (line 4 ~ line 97) -
</div>
<div ID="header_hidden_1" style="display: block;">
- Show the snippet from t/builtins/system/chmod.t (line 4 ~ line 97) -
</div>
</a>
<div ID="hide_1" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S16/&quot;Filehandles, files, and directories&quot;/&quot;chmod&quot;&gt;

=kwid

chmod - the unix chmod command, changing the rights on a file

Proposed behaviour
LIST = chmod MODE, LIST
Given a list of files and directories change the rights on them.
MODE should be an octet representing or a string like similar to what can be used in
&nbsp; &nbsp; the same UNIX program:
&nbsp; &nbsp; one or more of the letters ugoa, one of the symbols +-= and one or more of the letters rwxXstugo.
&nbsp; &nbsp; 
return list should be the list of files that were successfully changed
in scalar context it should be the number of files successfully changed

While some of the modes are UNIX specific, it would be nice to find similar
&nbsp; modes in other operating system and do the right thing there too.


We really need the stat() function in order to test this.

=cut

plan 19;

if $*OS eq &quot;browser&quot; {
&nbsp; skip_rest &quot;Programs running in browsers don't have access to regular IO.&quot;;
&nbsp; exit;
}

if $*OS eq any &lt;MSWin32 mingw msys cygwin&gt; {
&nbsp; &nbsp; skip 18, &quot;file tests not fully available on win32&quot;;
&nbsp; &nbsp; exit;
};


{
&nbsp; &nbsp; my $file = create_temporary_file;
&nbsp; &nbsp; my @result = chmod 0o000, $file;
&nbsp; &nbsp; is +@result, 1, &quot;One file successfully changed&quot;;
&nbsp; &nbsp; is @result[0], $file, &quot;name of the file returned&quot;, :todo;
&nbsp; &nbsp; if ($*EUID) {
&nbsp; &nbsp; &nbsp; &nbsp; ok !(-r $file), &quot;not readable after 0&quot;;
&nbsp; &nbsp; &nbsp; &nbsp; ok !(-w $file), &quot;not writabel after 0&quot;;
&nbsp; &nbsp; &nbsp; &nbsp; ok !(-x $file), &quot;not executable after 0&quot;;
&nbsp; &nbsp; }
&nbsp; &nbsp; else {
&nbsp; &nbsp; &nbsp; &nbsp; skip 3, &quot;-r -w -x can accidentally work with root permission&quot;;
&nbsp; &nbsp; }
&nbsp; &nbsp; remove_file($file);
}


{
&nbsp; &nbsp; my $file = create_temporary_file;
&nbsp; &nbsp; my @result = chmod 0o700, $file;
&nbsp; &nbsp; is +@result, 1, &quot;One file successfully changed&quot;;
&nbsp; &nbsp; is @result[0], $file, &quot;name of the file returned&quot;, :todo;

&nbsp; &nbsp; ok -r $file, &quot;readable after 700&quot;;
&nbsp; &nbsp; ok -w $file, &quot;writabel after 700&quot;;
&nbsp; &nbsp; ok -x $file, &quot;executable after 700&quot;;
&nbsp; &nbsp; remove_file($file);
}


{
&nbsp; &nbsp; my $file = create_temporary_file;
&nbsp; &nbsp; my @result = chmod 0o777, $file;
&nbsp; &nbsp; is +@result, 1, &quot;One file successfully changed&quot;;
&nbsp; &nbsp; is @result[0], $file, &quot;name of the file returned&quot;, :todo;

&nbsp; &nbsp; ok -r $file, &quot;readable after 777&quot;;
&nbsp; &nbsp; ok -w $file, &quot;writable after 777&quot;;
&nbsp; &nbsp; ok -x $file, &quot;executable after 777&quot;;
&nbsp; &nbsp; remove_file($file);
}

sub create_temporary_file {
&nbsp; &nbsp; my $time = time;
&nbsp; &nbsp; my $file = &quot;temp_$time&quot;;
&nbsp; &nbsp; my $fh = open $file, :w err die &quot;Could not create $file&quot;;
&nbsp; &nbsp; diag &quot;Using file $file&quot;;
&nbsp; &nbsp; return $file;
}
sub remove_file ($file) {
&nbsp; &nbsp; unlink $file;
&nbsp; &nbsp; ok(!(-e $file), &quot;Test file was successfully removed&quot;);
}

ok(try { !-e &quot;nonesuch&quot; }, &quot;!-e syntax works&quot;);</pre>
</div>


<p>Changes the permissions of a list of files. The first element of the list must be the numerical mode, which should probably be an octal number, and which definitely should <i>not</i> be a string of octal digits: <code>0o644</code> is okay, <code>0644</code> is not. Returns the number of files successfully changed.</p>

<pre>    $cnt = chmod 0o755, &#39;foo&#39;, &#39;bar&#39;;
    chmod 0o755, @executables;
    $mode = &#39;0644&#39;; chmod $mode, &#39;foo&#39;;      # !!! sets mode to --w----r-T
    $mode = &#39;0o644&#39;; chmod $mode, &#39;foo&#39;;     # this is better
    $mode = 0o644;   chmod $mode, &#39;foo&#39;;     # this is best</pre>

<dt><a name="close_FILEHANDLE"
>close FILEHANDLE</a></dt>

<dd>
<a href="#" onclick="return tog_quote(8);">
<div ID="header_shown_8" style="display: none;">
- Hide the snippet from t/builtins/io/io_in_for_loops.t (line 5 ~ line 96) -
</div>
<div ID="header_hidden_8" style="display: block;">
- Show the snippet from t/builtins/io/io_in_for_loops.t (line 5 ~ line 96) -
</div>
</a>
<div ID="hide_8" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S16/&quot;Filehandles, files, and directories&quot;/&quot;close&quot;&gt;

plan 37;

if $*OS eq &quot;browser&quot; {
&nbsp; skip_rest &quot;Programs running in browsers don't have access to regular IO.&quot;;
&nbsp; exit;
}

my $filename = 'tempfile';

{ # write the file first
&nbsp; &nbsp; my $fh = open($filename, :w);
&nbsp; &nbsp; for (1 .. 6) -&gt; $num {
&nbsp; &nbsp; &nbsp; &nbsp; $fh.print(&quot;$num\n&quot;);
&nbsp; &nbsp; }
&nbsp; &nbsp; $fh.close();
}

{ # now read it in and check
&nbsp; &nbsp; my $fh = open($filename);
&nbsp; &nbsp; for (1 .. 6) -&gt; $num {
&nbsp; &nbsp; &nbsp; &nbsp; my $line = =$fh;
&nbsp; &nbsp; &nbsp; &nbsp; is($line, &quot;$num&quot;, '... got the right line (array controlled loop)');
&nbsp; &nbsp; }
&nbsp; &nbsp; $fh.close();
}

{ # now read it in with the $fh controling the loop
&nbsp; &nbsp; my $fh = open($filename);
&nbsp; &nbsp; my $num = 1;
&nbsp; &nbsp; for (=$fh) -&gt; $line {
&nbsp; &nbsp; &nbsp; &nbsp; is($line, &quot;$num&quot;, '... got the right line ((=$fh) controlled loop)');
&nbsp; &nbsp; &nbsp; &nbsp; $num++;
&nbsp; &nbsp; }
&nbsp; &nbsp; $fh.close();
}

{ # now read it in with the $fh controling the loop w/out parens
&nbsp; &nbsp; my $fh = open($filename);
&nbsp; &nbsp; my $num = 1;
&nbsp; &nbsp; for =$fh -&gt; $line {
&nbsp; &nbsp; &nbsp; &nbsp; is($line, &quot;$num&quot;, '... got the right line (=$fh controlled loop)');
&nbsp; &nbsp; &nbsp; &nbsp; $num++;
&nbsp; &nbsp; }
&nbsp; &nbsp; $fh.close();
}

## more complex loops

{ # now read it in and check
&nbsp; &nbsp; my $fh = open($filename);
&nbsp; &nbsp; my $num = 1;
&nbsp; &nbsp; for (1 .. 3) -&gt; $_num {
&nbsp; &nbsp; &nbsp; &nbsp; my $line = =$fh;
&nbsp; &nbsp; &nbsp; &nbsp; is($line, &quot;$num&quot;, '... got the right line (array controlled loop)');
&nbsp; &nbsp; &nbsp; &nbsp; $num++;
&nbsp; &nbsp; &nbsp; &nbsp; my $line2 = =$fh;
&nbsp; &nbsp; &nbsp; &nbsp; is($line2, &quot;$num&quot;, '... got the right line2 (array controlled loop)'); &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; $num++; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; }
&nbsp; &nbsp; $fh.close();
}

{ # now read it in with the $fh controling the loop but call 
&nbsp; # the =$fh inside the loop inside parens (is this list context??)
&nbsp; &nbsp; my $fh = open($filename);
&nbsp; &nbsp; my $num = 1;
&nbsp; &nbsp; for =$fh -&gt; $line {
&nbsp; &nbsp; &nbsp; &nbsp; is($line, &quot;$num&quot;, '... got the right line ((=$fh) controlled loop)');
&nbsp; &nbsp; &nbsp; &nbsp; $num++;
&nbsp; &nbsp; &nbsp; &nbsp; my $line2 = =$fh;
&nbsp; &nbsp; &nbsp; &nbsp; is($line2, &quot;$num&quot;, '... got the right line2 ((=$fh) controlled loop)');
&nbsp; &nbsp; &nbsp; &nbsp; $num++;
&nbsp; &nbsp; }
&nbsp; &nbsp; $fh.close();
}

{ # now read it in with the $fh controling the loop but call 
&nbsp; # the =$fh inside the loop w/out parens (is this scalar context??)
&nbsp; &nbsp; my $fh = open($filename);
&nbsp; &nbsp; my $num = 1;
&nbsp; &nbsp; for =$fh -&gt; $line {
&nbsp; &nbsp; &nbsp; &nbsp; is($line, &quot;$num&quot;, '... got the right line (=$fh controlled loop)');
&nbsp; &nbsp; &nbsp; &nbsp; $num++;
&nbsp; &nbsp; &nbsp; &nbsp; my $line2 = =$fh;
&nbsp; &nbsp; &nbsp; &nbsp; is($line2, &quot;$num&quot;, '... got the right line2 (=$fh controlled loop)');
&nbsp; &nbsp; &nbsp; &nbsp; $num++;
&nbsp; &nbsp; }
&nbsp; &nbsp; $fh.close();
}</pre>
</div>


<p>Closes the file or pipe associated with the file handle, returning true only if IO buffers are successfully flushed and closes the system file descriptor. Closes the currently selected filehandle if the argument is omitted.</p>

<p>You don&#39;t have to close FILEHANDLE if you are immediately going to do another <code>open</code> on it, because <code>open</code> will close it for you. (See <code>open</code>.) However, an explicit <code>close</code> on an input file resets the line counter (<code>$.</code>), while the implicit close done by <code>open</code> does not.</p>

<a href="#" onclick="return tog_quote(7);">
<div ID="header_shown_7" style="display: none;">
- Hide the snippet from t/builtins/io/io_in_for_loops.t (line 4 ~ line 96) -
</div>
<div ID="header_hidden_7" style="display: block;">
- Show the snippet from t/builtins/io/io_in_for_loops.t (line 4 ~ line 96) -
</div>
</a>
<div ID="hide_7" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S16/&quot;Filehandles, files, and directories&quot;/&quot;open&quot;&gt;
# L&lt;S16/&quot;Filehandles, files, and directories&quot;/&quot;close&quot;&gt;

plan 37;

if $*OS eq &quot;browser&quot; {
&nbsp; skip_rest &quot;Programs running in browsers don't have access to regular IO.&quot;;
&nbsp; exit;
}

my $filename = 'tempfile';

{ # write the file first
&nbsp; &nbsp; my $fh = open($filename, :w);
&nbsp; &nbsp; for (1 .. 6) -&gt; $num {
&nbsp; &nbsp; &nbsp; &nbsp; $fh.print(&quot;$num\n&quot;);
&nbsp; &nbsp; }
&nbsp; &nbsp; $fh.close();
}

{ # now read it in and check
&nbsp; &nbsp; my $fh = open($filename);
&nbsp; &nbsp; for (1 .. 6) -&gt; $num {
&nbsp; &nbsp; &nbsp; &nbsp; my $line = =$fh;
&nbsp; &nbsp; &nbsp; &nbsp; is($line, &quot;$num&quot;, '... got the right line (array controlled loop)');
&nbsp; &nbsp; }
&nbsp; &nbsp; $fh.close();
}

{ # now read it in with the $fh controling the loop
&nbsp; &nbsp; my $fh = open($filename);
&nbsp; &nbsp; my $num = 1;
&nbsp; &nbsp; for (=$fh) -&gt; $line {
&nbsp; &nbsp; &nbsp; &nbsp; is($line, &quot;$num&quot;, '... got the right line ((=$fh) controlled loop)');
&nbsp; &nbsp; &nbsp; &nbsp; $num++;
&nbsp; &nbsp; }
&nbsp; &nbsp; $fh.close();
}

{ # now read it in with the $fh controling the loop w/out parens
&nbsp; &nbsp; my $fh = open($filename);
&nbsp; &nbsp; my $num = 1;
&nbsp; &nbsp; for =$fh -&gt; $line {
&nbsp; &nbsp; &nbsp; &nbsp; is($line, &quot;$num&quot;, '... got the right line (=$fh controlled loop)');
&nbsp; &nbsp; &nbsp; &nbsp; $num++;
&nbsp; &nbsp; }
&nbsp; &nbsp; $fh.close();
}

## more complex loops

{ # now read it in and check
&nbsp; &nbsp; my $fh = open($filename);
&nbsp; &nbsp; my $num = 1;
&nbsp; &nbsp; for (1 .. 3) -&gt; $_num {
&nbsp; &nbsp; &nbsp; &nbsp; my $line = =$fh;
&nbsp; &nbsp; &nbsp; &nbsp; is($line, &quot;$num&quot;, '... got the right line (array controlled loop)');
&nbsp; &nbsp; &nbsp; &nbsp; $num++;
&nbsp; &nbsp; &nbsp; &nbsp; my $line2 = =$fh;
&nbsp; &nbsp; &nbsp; &nbsp; is($line2, &quot;$num&quot;, '... got the right line2 (array controlled loop)'); &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; $num++; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; }
&nbsp; &nbsp; $fh.close();
}

{ # now read it in with the $fh controling the loop but call 
&nbsp; # the =$fh inside the loop inside parens (is this list context??)
&nbsp; &nbsp; my $fh = open($filename);
&nbsp; &nbsp; my $num = 1;
&nbsp; &nbsp; for =$fh -&gt; $line {
&nbsp; &nbsp; &nbsp; &nbsp; is($line, &quot;$num&quot;, '... got the right line ((=$fh) controlled loop)');
&nbsp; &nbsp; &nbsp; &nbsp; $num++;
&nbsp; &nbsp; &nbsp; &nbsp; my $line2 = =$fh;
&nbsp; &nbsp; &nbsp; &nbsp; is($line2, &quot;$num&quot;, '... got the right line2 ((=$fh) controlled loop)');
&nbsp; &nbsp; &nbsp; &nbsp; $num++;
&nbsp; &nbsp; }
&nbsp; &nbsp; $fh.close();
}

{ # now read it in with the $fh controling the loop but call 
&nbsp; # the =$fh inside the loop w/out parens (is this scalar context??)
&nbsp; &nbsp; my $fh = open($filename);
&nbsp; &nbsp; my $num = 1;
&nbsp; &nbsp; for =$fh -&gt; $line {
&nbsp; &nbsp; &nbsp; &nbsp; is($line, &quot;$num&quot;, '... got the right line (=$fh controlled loop)');
&nbsp; &nbsp; &nbsp; &nbsp; $num++;
&nbsp; &nbsp; &nbsp; &nbsp; my $line2 = =$fh;
&nbsp; &nbsp; &nbsp; &nbsp; is($line2, &quot;$num&quot;, '... got the right line2 (=$fh controlled loop)');
&nbsp; &nbsp; &nbsp; &nbsp; $num++;
&nbsp; &nbsp; }
&nbsp; &nbsp; $fh.close();
}</pre>
</div>


<a href="#" onclick="return tog_quote(5);">
<div ID="header_shown_5" style="display: none;">
- Hide the snippet from t/builtins/io/io_in_while_loops.t (line 4 ~ line 46) -
</div>
<div ID="header_hidden_5" style="display: block;">
- Show the snippet from t/builtins/io/io_in_while_loops.t (line 4 ~ line 46) -
</div>
</a>
<div ID="hide_5" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S16/&quot;Filehandles, files, and directories&quot;/&quot;open&quot;&gt;

plan 13; 

if $*OS eq &quot;browser&quot; {
&nbsp; skip_rest &quot;Programs running in browsers don't have access to regular IO.&quot;;
&nbsp; exit;
}


my $filename = 'tempfile';

{ # write the file first
&nbsp; &nbsp; my $fh = open($filename, :w);
&nbsp; &nbsp; for (1 .. 6) -&gt; $num {
&nbsp; &nbsp; &nbsp; &nbsp; $fh.print(&quot;$num\n&quot;);
&nbsp; &nbsp; }
&nbsp; &nbsp; $fh.close();
}

{ # now read it in and check
&nbsp; &nbsp; my $fh = open($filename);
&nbsp; &nbsp; my $num = 1;
&nbsp; &nbsp; while ($num &lt;= 6) {
&nbsp; &nbsp; &nbsp; &nbsp; my $line = =$fh;
&nbsp; &nbsp; &nbsp; &nbsp; is($line, &quot;$num&quot;, '... got the right line (array controlled loop)');
&nbsp; &nbsp; &nbsp; &nbsp; $num++;
&nbsp; &nbsp; }
&nbsp; &nbsp; $fh.close();
}

{ # now read it in with the $fh controling the loop
&nbsp; &nbsp; my $fh = open($filename);
&nbsp; &nbsp; my $num = 1;
&nbsp; &nbsp; my $line;
&nbsp; &nbsp; while ($line = =$fh) {
&nbsp; &nbsp; &nbsp; &nbsp; is($line, &quot;$num&quot;, '... got the right line (=$fh controlled loop)');
&nbsp; &nbsp; &nbsp; &nbsp; $num++;
&nbsp; &nbsp; }
&nbsp; &nbsp; $fh.close();
}

is(unlink($filename), 1, 'file has been removed');</pre>
</div>


<a href="#" onclick="return tog_quote(4);">
<div ID="header_shown_4" style="display: none;">
- Hide the snippet from t/builtins/io/open.t (line 5 ~ line 46) -
</div>
<div ID="header_hidden_4" style="display: block;">
- Show the snippet from t/builtins/io/open.t (line 5 ~ line 46) -
</div>
</a>
<div ID="hide_4" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S16/&quot;Filehandles, files, and directories&quot;/&quot;open&quot;&gt;

=pod

Some edge and error cases for open()

=cut


if $*OS eq &quot;browser&quot; {
&nbsp; skip_rest &quot;Programs running in browsers don't have access to regular IO.&quot;;
&nbsp; exit;
}

# deal with non-existent files
{
&nbsp; &nbsp; skip 1, &quot;open('nonexisting') =&gt; undef is waiting on 'use fatal'&quot;;
&nbsp; &nbsp; if 0 {
&nbsp; &nbsp; &nbsp; &nbsp; ok(!defined(open(&quot;file_which_does_not_exist&quot;)), 'open() on non-existent file returns undef');
&nbsp; &nbsp; }

&nbsp; &nbsp; open(&quot;create_this_file&quot;, :w);
&nbsp; &nbsp; ok(-e 'create_this_file', 'writing to a non-existent file creates it');
&nbsp; &nbsp; unlink('create_this_file');

&nbsp; &nbsp; open(&quot;create_this_file2&quot;, :w);
&nbsp; &nbsp; ok(-e 'create_this_file2', 'appending to a non-existent file creates it');
&nbsp; &nbsp; unlink('create_this_file2');
}


=pod

I/O Redirection to scalar tests

=cut

skip_rest(&quot;needs speccing&quot;); exit;

# XXX: gaal: dunno how this should be, but this isn't it.
ok(try { open $*OUT,&quot;&gt;&quot;,\$scalar },'Direct STDOUT to a scalar', :todo);
ok(try { open $*ERR,&quot;&gt;&quot;,\$scalar },'Direct STDERR to a scalar', :todo);</pre>
</div>


<a href="#" onclick="return tog_quote(3);">
<div ID="header_shown_3" style="display: none;">
- Hide the snippet from t/builtins/io/readline_chomped.t (line 4 ~ line 25) -
</div>
<div ID="header_hidden_3" style="display: block;">
- Show the snippet from t/builtins/io/readline_chomped.t (line 4 ~ line 25) -
</div>
</a>
<div ID="hide_3" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S16/&quot;Filehandles, files, and directories&quot;/&quot;open&quot;&gt;

plan 3;

if $*OS eq &quot;browser&quot; {
&nbsp; skip_rest &quot;Programs running in browsers don't have access to regular IO.&quot;;
&nbsp; exit;
}


my $fh = open $*PROGRAM_NAME;
ok($fh, &quot;could open self&quot;);
isa_ok($fh, 'IO');

my $line;
eval '
&nbsp; $fh is chomped;
&nbsp; $line = =$fh;
';

is($line, &quot;use v6-alpha;&quot;, &quot;first line was chomped&quot;, :todo&lt;feature&gt;,
&nbsp; &nbsp; :depends&lt;'is chomped'&gt;);</pre>
</div>


<p>If the file handle came from a piped open, <code>close</code> will additionally return false if one of the other system calls involved fails, or if the program exits with non-zero status. (If the only problem was that the program exited non-zero, <code>$!</code> will be set to <code>0</code>.) Closing a pipe also waits for the process executing on the pipe to complete, in case you want to look at the output of the pipe afterwards, and implicitly puts the exit status value of that command into <code>$!</code>.</p>

<dt><a name="closedir"
>closedir</a></dt>

<dd>
<a href="#" onclick="return tog_quote(10);">
<div ID="header_shown_10" style="display: none;">
- Hide the snippet from t/builtins/io/dir.t (line 6 ~ line 86) -
</div>
<div ID="header_hidden_10" style="display: block;">
- Show the snippet from t/builtins/io/dir.t (line 6 ~ line 86) -
</div>
</a>
<div ID="hide_10" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S16/&quot;Filehandles, files, and directories&quot;/&quot;closedir&quot;&gt;
# L&lt;S16/&quot;Filehandles, files, and directories&quot;/&quot;readdir&quot;&gt;
# L&lt;S16/&quot;Filehandles, files, and directories&quot;/&quot;rewinddir&quot;&gt;

if ($*OS eq any &lt;browser&gt;) {
&nbsp; &nbsp; skip_rest &quot;not supported on this platform&quot;;
&nbsp; &nbsp; exit;
}

=pod

opendir/readdir support

=cut

my $dir = opendir('.');
isa_ok($dir, IO::Dir, &quot;opendir worked&quot;);

my @files = readdir($dir);
ok(@files, &quot;seems readdir worked too&quot;);

my @more_files = readdir($dir);
is(+@more_files, 0, &quot;No more things to read&quot;);

my $row = readdir($dir);
ok(!defined($row), &quot;in scalar context it returns undef&quot;);

my $rew_1 = rewinddir($dir);
is($rew_1, 1, &quot;success of rewinddir 1 returns 1&quot;);

my @files_again = readdir($dir);

is_deeply(\@files_again, @files, &quot;same list of files retrieved after rewind&quot;);

my $rew_2 = rewinddir($dir);
is($rew_2, 1, &quot;success of rewinddir 2 returns 1&quot;);

my @files_scalar;
loop {
&nbsp; &nbsp; my $f = readdir($dir) err last;
&nbsp; &nbsp; @files_scalar.push($f);
}
is_deeply(\@files_scalar, @files, &quot;same list of files retrieved after rewind, using scalar context&quot;);

my $rew_3 = $dir.rewinddir;
is($rew_3, 1, 'success of rewinddir 3 using $dir.rewinddir returns 1');
my @files_dot = $dir.readdir;
is_deeply(\@files_dot, @files, 'same list of files retrieved using $dir.readdir');

my $rew_4 = $dir.rewinddir;
is($rew_4, 1, 'success of rewinddir 4 using $dir.rewinddir returns 1');

my @files_scalar_dot;
for $dir.readdir -&gt; $f {
&nbsp; &nbsp; @files_scalar_dot.push($f);
}
is_deeply(\@files_scalar_dot, @files, 'same list of files, using $dir.readdir in scalar context');

my @more_files_2 = $dir.readdir;
is(+@more_files_2, 0, &quot;No more things to read&quot;);

my $row_2 = $dir.readdir;
ok(!defined($row_2), &quot;in scalar context it returns undef&quot;);


ok(closedir($dir), &quot;as does closedir&quot;);

# on closed directory handler these calls should throw an exception
#my $undef = readdir($dir);
#my @empty = readdir($dir);
# rewinddir($dir);
# closedir


my $dh = opendir('.');
isa_ok($dh, 'IO::Dir', &quot;opendir worked&quot;);
my @files_once_more = $dh.readdir;
is_deeply(@files_once_more.sort, @files.sort, 'same list of files,after reopen');
ok($dir.closedir, 'closedir using $dir.closedir format');</pre>
</div>


<pre> closedir (IO::Dir $dir)  
 $dir.closedir</pre>

<p>Closes a directory opened by <code>opendir</code> and returns the success of that system call.</p>

<a href="#" onclick="return tog_quote(9);">
<div ID="header_shown_9" style="display: none;">
- Hide the snippet from t/builtins/io/dir.t (line 5 ~ line 86) -
</div>
<div ID="header_hidden_9" style="display: block;">
- Show the snippet from t/builtins/io/dir.t (line 5 ~ line 86) -
</div>
</a>
<div ID="hide_9" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S16/&quot;Filehandles, files, and directories&quot;/&quot;opendir&quot;&gt;
# L&lt;S16/&quot;Filehandles, files, and directories&quot;/&quot;closedir&quot;&gt;
# L&lt;S16/&quot;Filehandles, files, and directories&quot;/&quot;readdir&quot;&gt;
# L&lt;S16/&quot;Filehandles, files, and directories&quot;/&quot;rewinddir&quot;&gt;

if ($*OS eq any &lt;browser&gt;) {
&nbsp; &nbsp; skip_rest &quot;not supported on this platform&quot;;
&nbsp; &nbsp; exit;
}

=pod

opendir/readdir support

=cut

my $dir = opendir('.');
isa_ok($dir, IO::Dir, &quot;opendir worked&quot;);

my @files = readdir($dir);
ok(@files, &quot;seems readdir worked too&quot;);

my @more_files = readdir($dir);
is(+@more_files, 0, &quot;No more things to read&quot;);

my $row = readdir($dir);
ok(!defined($row), &quot;in scalar context it returns undef&quot;);

my $rew_1 = rewinddir($dir);
is($rew_1, 1, &quot;success of rewinddir 1 returns 1&quot;);

my @files_again = readdir($dir);

is_deeply(\@files_again, @files, &quot;same list of files retrieved after rewind&quot;);

my $rew_2 = rewinddir($dir);
is($rew_2, 1, &quot;success of rewinddir 2 returns 1&quot;);

my @files_scalar;
loop {
&nbsp; &nbsp; my $f = readdir($dir) err last;
&nbsp; &nbsp; @files_scalar.push($f);
}
is_deeply(\@files_scalar, @files, &quot;same list of files retrieved after rewind, using scalar context&quot;);

my $rew_3 = $dir.rewinddir;
is($rew_3, 1, 'success of rewinddir 3 using $dir.rewinddir returns 1');
my @files_dot = $dir.readdir;
is_deeply(\@files_dot, @files, 'same list of files retrieved using $dir.readdir');

my $rew_4 = $dir.rewinddir;
is($rew_4, 1, 'success of rewinddir 4 using $dir.rewinddir returns 1');

my @files_scalar_dot;
for $dir.readdir -&gt; $f {
&nbsp; &nbsp; @files_scalar_dot.push($f);
}
is_deeply(\@files_scalar_dot, @files, 'same list of files, using $dir.readdir in scalar context');

my @more_files_2 = $dir.readdir;
is(+@more_files_2, 0, &quot;No more things to read&quot;);

my $row_2 = $dir.readdir;
ok(!defined($row_2), &quot;in scalar context it returns undef&quot;);


ok(closedir($dir), &quot;as does closedir&quot;);

# on closed directory handler these calls should throw an exception
#my $undef = readdir($dir);
#my @empty = readdir($dir);
# rewinddir($dir);
# closedir


my $dh = opendir('.');
isa_ok($dh, 'IO::Dir', &quot;opendir worked&quot;);
my @files_once_more = $dh.readdir;
is_deeply(@files_once_more.sort, @files.sort, 'same list of files,after reopen');
ok($dir.closedir, 'closedir using $dir.closedir format');</pre>
</div>


<dt><a name="connect"
>connect</a></dt>

<dd>
<pre> my $fh = connect($hostname, 80);</pre>

<p>Attempts to connect to a remote host and returns an IO handle if successful. The call fails with an exception if it cannot connect.</p>

<dt><a name="fcntl"
>fcntl
<dt><a name="glob"
>glob
<dt><a name="ioctl"
>ioctl
<dt><a name="link"
>link
<dt><a name="listen"
>listen
<dt><a name="lstat"
>lstat</a></dt>

<dd>
<p>Returns a stat buffer. If the lstat succeeds, the stat buffer evaluates to true, and additional file tests may be performed on the value. If the stat fails, all subsequent tests on the stat buffer also evaluate to false.</p>

<dt><a name="mkdir"
>mkdir
<dt><a name="open"
>open</a></dt>

<dd>
<a href="#" onclick="return tog_quote(13);">
<div ID="header_shown_13" style="display: none;">
- Hide the snippet from t/var/default_scalar.t (line 18 ~ line 44) -
</div>
<div ID="header_hidden_13" style="display: block;">
- Show the snippet from t/var/default_scalar.t (line 18 ~ line 44) -
</div>
</a>
<div ID="hide_13" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S16/&quot;Filehandles, files, and directories&quot;/&quot;=item open&quot;&gt;
# L&lt;S16/&quot;Input and Output&quot;/&quot;=item say&quot;&gt;

# work around missing capabilities
# to get the output of 'say' into a test; 
&nbsp; &nbsp; my $out = open(&quot;tmpfile&quot;, :w);
&nbsp; &nbsp; $out.say(3);
&nbsp; &nbsp; close $out; 
&nbsp; &nbsp; my$in = open &quot;tmpfile&quot;; 
&nbsp; &nbsp; my $s = =$in; close $in; 
&nbsp; &nbsp; unlink &quot;tmpfile&quot;;

&nbsp; &nbsp; is $s,&quot;3&quot;, 'and is the default argument for &quot;say&quot;';

#pugs&gt; for .. { say }; 

&nbsp; &nbsp; my $out = open(&quot;tmpfile&quot;, :w);
&nbsp; &nbsp; for 1 { $out.say() };
&nbsp; &nbsp; close $out; 
&nbsp; &nbsp; my$in = open &quot;tmpfile&quot;; 
&nbsp; &nbsp; my $s = =$in; close $in;
&nbsp; &nbsp; unlink &quot;tmpfile&quot;;

&nbsp; &nbsp; isnt $s,&quot;3&quot;, 'and global $_ should not be the default topic of &quot;for&quot;'; 
&nbsp; &nbsp; lives_ok { for 1 .. 3 { $_++ } }, 'default topic is rw by default';
# #*** Error: cannot modify constant item at 1</pre>
</div>


<pre>    # Read
    my $fh = open($filename);

    # Write
    my $fh = open($filename, :w);</pre>

<dt><a name="opendir_EXPR"
>opendir EXPR</a></dt>

<dd>
<pre>  my $dir = opendir(&#39;.&#39;);</pre>

<p>Opens a directory named EXPR for processing by <code>readdir</code>, <code>telldir</code>, <code>seekdir</code>, <code>rewinddir</code>, and <code>closedir</code>. Returns an <code>IO::Dir</code> object if successful.</p>

<a href="#" onclick="return tog_quote(12);">
<div ID="header_shown_12" style="display: none;">
- Hide the snippet from t/builtins/io/dir.t (line 8 ~ line 86) -
</div>
<div ID="header_hidden_12" style="display: block;">
- Show the snippet from t/builtins/io/dir.t (line 8 ~ line 86) -
</div>
</a>
<div ID="hide_12" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S16/&quot;Filehandles, files, and directories&quot;/&quot;rewinddir&quot;&gt;

if ($*OS eq any &lt;browser&gt;) {
&nbsp; &nbsp; skip_rest &quot;not supported on this platform&quot;;
&nbsp; &nbsp; exit;
}

=pod

opendir/readdir support

=cut

my $dir = opendir('.');
isa_ok($dir, IO::Dir, &quot;opendir worked&quot;);

my @files = readdir($dir);
ok(@files, &quot;seems readdir worked too&quot;);

my @more_files = readdir($dir);
is(+@more_files, 0, &quot;No more things to read&quot;);

my $row = readdir($dir);
ok(!defined($row), &quot;in scalar context it returns undef&quot;);

my $rew_1 = rewinddir($dir);
is($rew_1, 1, &quot;success of rewinddir 1 returns 1&quot;);

my @files_again = readdir($dir);

is_deeply(\@files_again, @files, &quot;same list of files retrieved after rewind&quot;);

my $rew_2 = rewinddir($dir);
is($rew_2, 1, &quot;success of rewinddir 2 returns 1&quot;);

my @files_scalar;
loop {
&nbsp; &nbsp; my $f = readdir($dir) err last;
&nbsp; &nbsp; @files_scalar.push($f);
}
is_deeply(\@files_scalar, @files, &quot;same list of files retrieved after rewind, using scalar context&quot;);

my $rew_3 = $dir.rewinddir;
is($rew_3, 1, 'success of rewinddir 3 using $dir.rewinddir returns 1');
my @files_dot = $dir.readdir;
is_deeply(\@files_dot, @files, 'same list of files retrieved using $dir.readdir');

my $rew_4 = $dir.rewinddir;
is($rew_4, 1, 'success of rewinddir 4 using $dir.rewinddir returns 1');

my @files_scalar_dot;
for $dir.readdir -&gt; $f {
&nbsp; &nbsp; @files_scalar_dot.push($f);
}
is_deeply(\@files_scalar_dot, @files, 'same list of files, using $dir.readdir in scalar context');

my @more_files_2 = $dir.readdir;
is(+@more_files_2, 0, &quot;No more things to read&quot;);

my $row_2 = $dir.readdir;
ok(!defined($row_2), &quot;in scalar context it returns undef&quot;);


ok(closedir($dir), &quot;as does closedir&quot;);

# on closed directory handler these calls should throw an exception
#my $undef = readdir($dir);
#my @empty = readdir($dir);
# rewinddir($dir);
# closedir


my $dh = opendir('.');
isa_ok($dh, 'IO::Dir', &quot;opendir worked&quot;);
my @files_once_more = $dh.readdir;
is_deeply(@files_once_more.sort, @files.sort, 'same list of files,after reopen');
ok($dir.closedir, 'closedir using $dir.closedir format');</pre>
</div>


<a href="#" onclick="return tog_quote(11);">
<div ID="header_shown_11" style="display: none;">
- Hide the snippet from t/builtins/io/dir.t (line 7 ~ line 86) -
</div>
<div ID="header_hidden_11" style="display: block;">
- Show the snippet from t/builtins/io/dir.t (line 7 ~ line 86) -
</div>
</a>
<div ID="hide_11" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S16/&quot;Filehandles, files, and directories&quot;/&quot;readdir&quot;&gt;
# L&lt;S16/&quot;Filehandles, files, and directories&quot;/&quot;rewinddir&quot;&gt;

if ($*OS eq any &lt;browser&gt;) {
&nbsp; &nbsp; skip_rest &quot;not supported on this platform&quot;;
&nbsp; &nbsp; exit;
}

=pod

opendir/readdir support

=cut

my $dir = opendir('.');
isa_ok($dir, IO::Dir, &quot;opendir worked&quot;);

my @files = readdir($dir);
ok(@files, &quot;seems readdir worked too&quot;);

my @more_files = readdir($dir);
is(+@more_files, 0, &quot;No more things to read&quot;);

my $row = readdir($dir);
ok(!defined($row), &quot;in scalar context it returns undef&quot;);

my $rew_1 = rewinddir($dir);
is($rew_1, 1, &quot;success of rewinddir 1 returns 1&quot;);

my @files_again = readdir($dir);

is_deeply(\@files_again, @files, &quot;same list of files retrieved after rewind&quot;);

my $rew_2 = rewinddir($dir);
is($rew_2, 1, &quot;success of rewinddir 2 returns 1&quot;);

my @files_scalar;
loop {
&nbsp; &nbsp; my $f = readdir($dir) err last;
&nbsp; &nbsp; @files_scalar.push($f);
}
is_deeply(\@files_scalar, @files, &quot;same list of files retrieved after rewind, using scalar context&quot;);

my $rew_3 = $dir.rewinddir;
is($rew_3, 1, 'success of rewinddir 3 using $dir.rewinddir returns 1');
my @files_dot = $dir.readdir;
is_deeply(\@files_dot, @files, 'same list of files retrieved using $dir.readdir');

my $rew_4 = $dir.rewinddir;
is($rew_4, 1, 'success of rewinddir 4 using $dir.rewinddir returns 1');

my @files_scalar_dot;
for $dir.readdir -&gt; $f {
&nbsp; &nbsp; @files_scalar_dot.push($f);
}
is_deeply(\@files_scalar_dot, @files, 'same list of files, using $dir.readdir in scalar context');

my @more_files_2 = $dir.readdir;
is(+@more_files_2, 0, &quot;No more things to read&quot;);

my $row_2 = $dir.readdir;
ok(!defined($row_2), &quot;in scalar context it returns undef&quot;);


ok(closedir($dir), &quot;as does closedir&quot;);

# on closed directory handler these calls should throw an exception
#my $undef = readdir($dir);
#my @empty = readdir($dir);
# rewinddir($dir);
# closedir


my $dh = opendir('.');
isa_ok($dh, 'IO::Dir', &quot;opendir worked&quot;);
my @files_once_more = $dh.readdir;
is_deeply(@files_once_more.sort, @files.sort, 'same list of files,after reopen');
ok($dir.closedir, 'closedir using $dir.closedir format');</pre>
</div>


<dt><a name="readdir"
>readdir</a></dt>

<dd>
<pre> readdir (IO::Dir $dir)  
 $dir.readdir</pre>

<p>Returns the next directory entry for a directory opened by <code>opendir</code>. If used in list context, returns all the rest of the entries in the directory. If there are no more entries, returns an undefined value in scalar context or a null list in list context.</p>

<p>If you&#39;re planning to filetest the return values out of a <code>readdir</code>, you&#39;d better prepend the directory in question. Otherwise, because we didn&#39;t <code>chdir</code> there, it would have been testing the wrong file.</p>

<dt><a name="readlink"
>readlink
<dt><a name="rename"
>rename
<dt><a name="rewinddir"
>rewinddir</a></dt>

<dd>
<pre> rewinddir (IO::Dir $dir)  
 $dir.rewinddir</pre>

<p>Sets the current position to the beginning of the directory for the <code>readdir</code> routine on DIRHANDLE.</p>

<dt><a name="rmdir_FILENAME___"
>rmdir FILENAME <!--
	INDEX: rmdir
--> <!--
	INDEX: rd
--> <!--
	INDEX: directory, remove
-->
<dt><a name="rmdir"
>rmdir</a></dt>

<dd>
<p>Deletes the directory specified by FILENAME if that directory is empty. If it succeeds it returns true, otherwise it returns false and sets <code>$!</code> (errno). If FILENAME is omitted, uses <code>$_</code>.</p>

<dt><a name="stat"
>stat</a></dt>

<dd>
<p>Returns a stat buffer. If the lstat succeeds, the stat buffer evaluates to true, and additional file tests may be performed on the value. If the stat fails, all subsequent tests on the stat buffer also evaluate to false.</p>

<dt><a name="symlink"
>symlink
<dt><a name="syscall"
>syscall
<dt><a name="sysopen"
>sysopen
<dt><a name="umask"
>umask
<dt><a name="unlink_LIST____"
>unlink LIST <!--
	INDEX: unlink
--> <!--
	INDEX: delete
--> <!--
	INDEX: remove
--> <!--
	INDEX: rm
--></a></dt>

<dd>
<a href="#" onclick="return tog_quote(6);">
<div ID="header_shown_6" style="display: none;">
- Hide the snippet from t/builtins/io/io_in_for_loops.t (line 97 ~ line 99) -
</div>
<div ID="header_hidden_6" style="display: block;">
- Show the snippet from t/builtins/io/io_in_for_loops.t (line 97 ~ line 99) -
</div>
</a>
<div ID="hide_6" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S16/&quot;Filehandles, files, and directories&quot;/&quot;unlink&quot;&gt;

is(unlink($filename), 1, 'file has been removed');</pre>
</div>


<a href="#" onclick="return tog_quote(2);">
<div ID="header_shown_2" style="display: none;">
- Hide the snippet from t/builtins/io/unlink.t (line 5 ~ line 35) -
</div>
<div ID="header_hidden_2" style="display: block;">
- Show the snippet from t/builtins/io/unlink.t (line 5 ~ line 35) -
</div>
</a>
<div ID="hide_2" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S16/&quot;Filehandles, files, and directories&quot;/&quot;unlink&quot;&gt;

sub nonce() { &quot;.$*PID.&quot; ~ int rand 1000 }

if $*OS eq &quot;browser&quot; {
&nbsp; skip_rest &quot;Programs running in browsers don't have access to regular IO.&quot;;
&nbsp; exit;
}

my $fn = &quot;unlink-test-file&quot; ~ nonce;

my $iswin32 = ?($*OS eq any &lt;MSWin32 mingw msys cygwin&gt;) ?? &quot;Timely closing of file handles does not yet work&quot; !! undef;

# open, explicit close, unlink, test
{
&nbsp; my $fh = open($fn, :w);
&nbsp; close $fh;

&nbsp; ok -e $fn, &nbsp; &nbsp; &nbsp;&quot;open() created a tempfile&quot;;
&nbsp; is(unlink($fn), 1, &quot;unlink() returned true&quot;);
&nbsp; ok !(-e $fn), &nbsp; &nbsp; &quot;unlink() actually deleted the tempfile&quot;;
}

# open, implicit close because of scope exit, unlink, test
{
&nbsp; { my $fh = open($fn, :w) }

&nbsp; ok -e $fn, &nbsp; &nbsp; &nbsp;&quot;open() created a tempfile&quot;;
&nbsp; is(unlink($fn), 1, &quot;unlink() returned true&quot;, todo =&gt; $iswin32);
&nbsp; ok !(-e $fn), &nbsp; &nbsp; &quot;unlink() actually deleted the tempfile&quot;, todo =&gt; $iswin32;
}</pre>
</div>


<dt><a name="unlink"
>unlink</a></dt>

<dd>
<p>Deletes a list of files. Returns the number of files successfully deleted.</p>

<pre>    $cnt = unlink &#39;a&#39;, &#39;b&#39;, &#39;c&#39;;</pre>

<p>Be warned that unlinking a directory can inflict damage on your filesystem. Finally, using <code>unlink</code> on directories is not supported on many operating systems. Use <code>rmdir</code> instead.</p>

<p>If LIST is omitted, uses <code>$_</code>.</p>

<dt><a name="utime"
>utime</a></dt>
</dl>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Input_and_Output"
>Input and Output</a></h1>

<dl>
<dt><a name="getc_FILEHANDLE"
>getc FILEHANDLE</a></dt>

<dd>
<p>Returns the next character from the input file attached to FILEHANDLE, or the undefined value at end of file, or if there was an error (in the latter case <code>$!</code> is set).</p>

<dt><a name="print_FILEHANDLE_LIST_"
>print FILEHANDLE LIST <!--
	INDEX: print
-->
<dt><a name="print_LIST"
>print LIST
<dt><a name="print"
>print</a></dt>

<dd>
<p>Prints a string or a list of strings. Returns true if successful. FILEHANDLE may be a scalar variable name, in which case the variable contains the name of or a reference to the filehandle, thus introducing one level of indirection. (NOTE: If FILEHANDLE is a variable and the next token is a term, it may be misinterpreted as an operator unless you interpose a <code>+</code> or put parentheses around the arguments.) If FILEHANDLE is omitted, prints by default to standard output (or to the last selected output channel--see <a href="#select" class="podlinkpod"
>&#34;select&#34;</a>). If LIST is also omitted, prints <code>$_</code> to the currently selected output channel. To set the default output channel to something other than STDOUT use the select operation.</p>

<p>Because print takes a LIST, anything in the LIST is evaluated in list context, and any subroutine that you call will have one or more of its expressions evaluated in list context. Also be careful not to follow the print keyword with a left parenthesis unless you want the corresponding right parenthesis to terminate the arguments to the print--interpose a <code>+</code> or put parentheses around all the arguments.</p>

<p>Note that if you&#39;re storing FILEHANDLEs in an array, or if you&#39;re using any other expression more complex than a scalar variable to retrieve it, you will have to use a block returning the filehandle value instead:</p>

<pre>    print { @files[$i] } &#34;stuff\n&#34;;
    print { $OK ?? STDOUT !! STDERR } &#34;stuff\n&#34;;</pre>

<dt><a name="printf"
>printf
<dt><a name="say"
>say</a></dt>

<dd>
<a href="#" onclick="return tog_quote(14);">
<div ID="header_shown_14" style="display: none;">
- Hide the snippet from t/var/default_scalar.t (line 19 ~ line 44) -
</div>
<div ID="header_hidden_14" style="display: block;">
- Show the snippet from t/var/default_scalar.t (line 19 ~ line 44) -
</div>
</a>
<div ID="hide_14" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S16/&quot;Input and Output&quot;/&quot;=item say&quot;&gt;

# work around missing capabilities
# to get the output of 'say' into a test; 
&nbsp; &nbsp; my $out = open(&quot;tmpfile&quot;, :w);
&nbsp; &nbsp; $out.say(3);
&nbsp; &nbsp; close $out; 
&nbsp; &nbsp; my$in = open &quot;tmpfile&quot;; 
&nbsp; &nbsp; my $s = =$in; close $in; 
&nbsp; &nbsp; unlink &quot;tmpfile&quot;;

&nbsp; &nbsp; is $s,&quot;3&quot;, 'and is the default argument for &quot;say&quot;';

#pugs&gt; for .. { say }; 

&nbsp; &nbsp; my $out = open(&quot;tmpfile&quot;, :w);
&nbsp; &nbsp; for 1 { $out.say() };
&nbsp; &nbsp; close $out; 
&nbsp; &nbsp; my$in = open &quot;tmpfile&quot;; 
&nbsp; &nbsp; my $s = =$in; close $in;
&nbsp; &nbsp; unlink &quot;tmpfile&quot;;

&nbsp; &nbsp; isnt $s,&quot;3&quot;, 'and global $_ should not be the default topic of &quot;for&quot;'; 
&nbsp; &nbsp; lives_ok { for 1 .. 3 { $_++ } }, 'default topic is rw by default';
# #*** Error: cannot modify constant item at 1</pre>
</div>


<p>This is a version of print() that auto-appends a newline:</p>

<pre>    Was:    print &#34;Hello, world!\n&#34;;
    Now:    say   &#34;Hello, world!&#34;;</pre>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Unfiled"
>Unfiled</a></h1>

<dl>
<dt><a name="fileno"
>fileno
<dt><a name="flock"
>flock
<dt><a name="getpeername"
>getpeername
<dt><a name="eof"
>eof
<dt><a name="accept"
>accept
<dt><a name="/[get|set][host|net|proto|serv|sock].*/"
>/[get|set][host|net|proto|serv|sock].*/
<dt><a name="alarm"
>alarm
<dt><a name="bind"
>bind
<dt><a name="binmode"
>binmode
<dt><a name="lines"
>lines</a></dt>

<dd>
<pre>    our List multi method lines (IO $handle:) is export;
    our List multi lines (Str $filename);</pre>

<p>Returns all the lines of a file as a (lazy) List regardless of context. See also <code>slurp</code>.</p>

<dt><a name="pipe"
>pipe
<dt><a name="read"
>read
<dt><a name="readline"
>readline
<dt><a name="readpipe"
>readpipe
<dt><a name="recv"
>recv
<dt><a name="seek"
>seek
<dt><a name="seekdir"
>seekdir
<dt><a name="select(both)"
>select(both)
<dt><a name="send"
>send
<dt><a name="setsockopt"
>setsockopt
<dt><a name="shutdown"
>shutdown
<dt><a name="slurp"
>slurp</a></dt>

<dd>
<pre>    our Item multi method slurp (IO $handle: *%opts) is export;
    our Item multi slurp (Str $filename, *%opts);</pre>

<p>Slurps the entire file into a Str or Buf regardless of context. (See also <code>lines</code>.) Whether a Str or Buf is returneded depends on the options.</p>

<dt><a name="socket"
>socket
<dt><a name="socketpair"
>socketpair
<dt><a name="sysread"
>sysread
<dt><a name="sysseek"
>sysseek
<dt><a name="syswrite"
>syswrite
<dt><a name="tell"
>tell
<dt><a name="telldir"
>telldir
<dt><a name="truncate"
>truncate
<dt><a name="warn"
>warn</a></dt>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Additions"
>Additions</a></h1>

<p>Please post errors and feedback to perl6-language. If you are making a general laundry list, please separate messages by topic.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="POD_ERRORS"
>POD ERRORS</a></h1>

<p>Hey! <b>The above document had some coding errors, which are explained below:</b></p>

<dl>
<dt><a name="Around_line_357:"
>Around line 357:</a></dt>

<dd>
<p>You forgot a &#39;=back&#39; before &#39;=head1&#39;</p>
</dd>
</dl>

<!-- end doc -->

</body></html>
