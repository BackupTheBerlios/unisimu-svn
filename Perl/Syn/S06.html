<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
           "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>S06</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="http://dev.perl.org/css/perl.css">

<script type="text/javascript">
var agt = navigator.userAgent.toLowerCase();

var is_opera = (agt.indexOf("opera") != -1);
var is_ie = (agt.indexOf("msie") != -1) && document.all && !is_opera;
var is_ie5 = (agt.indexOf("msie 5") != -1) && document.all;

function tog() {
  // tog: toggle the visibility of html elements (arguments[1..]) from none to
  // arguments[0].  Return what should be returned in a javascript onevent().
  display = arguments[0];
  for( var i=1; i<arguments.length; i++ ) {
    var x = document.getElementById(arguments[i]);
    if (!x) continue;
    if (x.style.display == "none" || x.style.display == "") {
      x.style.display = display;
    } else {
      x.style.display = "none";
    }
  }

  var e = is_ie ? window.event : this;
  if (e) {
    if (is_ie) {
      e.cancelBubble = true;
      e.returnValue = false;
      return false;
    } else {
      return false;
    }
  }
}

function tog_quote( idnum ) {
  return tog( 'block', 'header_shown_' + idnum, 'header_hidden_' + idnum,
       'hide_' + idnum );
}

</script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.03,
  using Pod::Simple::PullParser v2.02,
  under Perl v5.008008 at Mon Sep 11 11:27:25 2006 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
            <I>This page was generated at 2006-09-11 11:27:25 GMT.
            (syn <strong>r11817</strong>, pugs <strong>r13179</strong>)</I>
        
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Subroutines_and_other_code_objects'>Subroutines and other code objects</a>
  <li class='indexItem indexItem1'><a href='#Routine_modifiers'>Routine modifiers</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Named_subroutines'>Named subroutines</a>
    <li class='indexItem indexItem2'><a href='#Anonymous_subroutines'>Anonymous subroutines</a>
    <li class='indexItem indexItem2'><a href='#Perl5ish_subroutine_declarations'>Perl5ish subroutine declarations</a>
    <li class='indexItem indexItem2'><a href='#Blocks'>Blocks</a>
    <li class='indexItem indexItem2'><a href='#%22Pointy_blocks%22'>&#34;Pointy blocks&#34;</a>
    <li class='indexItem indexItem2'><a href='#Stub_declarations'>Stub declarations</a>
    <li class='indexItem indexItem2'><a href='#Globally_scoped_subroutines'>Globally scoped subroutines</a>
    <li class='indexItem indexItem2'><a href='#Lvalue_subroutines'>Lvalue subroutines</a>
    <li class='indexItem indexItem2'><a href='#Operator_overloading'>Operator overloading</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Parameters_and_arguments'>Parameters and arguments</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Named_arguments'>Named arguments</a>
    <li class='indexItem indexItem2'><a href='#Invocant_parameters'>Invocant parameters</a>
    <li class='indexItem indexItem2'><a href='#Longname_parameters'>Longname parameters</a>
    <li class='indexItem indexItem2'><a href='#Required_parameters'>Required parameters</a>
    <li class='indexItem indexItem2'><a href='#Optional_parameters'>Optional parameters</a>
    <li class='indexItem indexItem2'><a href='#Named_parameters'>Named parameters</a>
    <li class='indexItem indexItem2'><a href='#List_parameters'>List parameters</a>
    <li class='indexItem indexItem2'><a href='#Slurpy_block'>Slurpy block</a>
    <li class='indexItem indexItem2'><a href='#Argument_list_binding'>Argument list binding</a>
    <li class='indexItem indexItem2'><a href='#Flattening_argument_lists'>Flattening argument lists</a>
    <li class='indexItem indexItem2'><a href='#Multidimensional_argument_list_binding'>Multidimensional argument list binding</a>
    <li class='indexItem indexItem2'><a href='#Zero-dimensional_argument_list'>Zero-dimensional argument list</a>
    <li class='indexItem indexItem2'><a href='#Feed_operators'>Feed operators</a>
    <li class='indexItem indexItem2'><a href='#Closure_parameters'>Closure parameters</a>
    <li class='indexItem indexItem2'><a href='#Type_parameters'>Type parameters</a>
    <li class='indexItem indexItem2'><a href='#Unpacking_array_parameters'>Unpacking array parameters</a>
    <li class='indexItem indexItem2'><a href='#Unpacking_a_single_list_argument'>Unpacking a single list argument</a>
    <li class='indexItem indexItem2'><a href='#Unpacking_hash_parameters'>Unpacking hash parameters</a>
    <li class='indexItem indexItem2'><a href='#Unpacking_tree_node_parameters'>Unpacking tree node parameters</a>
    <li class='indexItem indexItem2'><a href='#Attributive_parameters'>Attributive parameters</a>
    <li class='indexItem indexItem2'><a href='#Placeholder_variables'>Placeholder variables</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Built-in_Types'>Built-in Types</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Native_types'>Native types</a>
    <li class='indexItem indexItem2'><a href='#Undefined_types'>Undefined types</a>
    <li class='indexItem indexItem2'><a href='#Immutable_types'>Immutable types</a>
    <li class='indexItem indexItem2'><a href='#Mutable_types'>Mutable types</a>
    <li class='indexItem indexItem2'><a href='#Value_types'>Value types</a>
    <li class='indexItem indexItem2'><a href='#Implementation_types'>Implementation types</a>
    <li class='indexItem indexItem2'><a href='#Hierarchical_types'>Hierarchical types</a>
    <li class='indexItem indexItem2'><a href='#Polymorphic_types'>Polymorphic types</a>
    <li class='indexItem indexItem2'><a href='#Parameter_types'>Parameter types</a>
    <li class='indexItem indexItem2'><a href='#Generic_types'>Generic types</a>
    <li class='indexItem indexItem2'><a href='#Return_types'>Return types</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Properties_and_traits'>Properties and traits</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Subroutine_traits'>Subroutine traits</a>
    <li class='indexItem indexItem2'><a href='#Parameter_traits'>Parameter traits</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Advanced_subroutine_features'>Advanced subroutine features</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#The_return_function'>The return function</a>
    <li class='indexItem indexItem2'><a href='#The_caller_function'>The caller function</a>
    <li class='indexItem indexItem2'><a href='#The_want_function'>The want function</a>
    <li class='indexItem indexItem2'><a href='#The_leave_function'>The leave function</a>
    <li class='indexItem indexItem2'><a href='#Temporization'>Temporization</a>
    <li class='indexItem indexItem2'><a href='#Wrapping'>Wrapping</a>
    <li class='indexItem indexItem2'><a href='#The_%26%3FROUTINE_object'>The &#38;?ROUTINE object</a>
    <li class='indexItem indexItem2'><a href='#The_%26%3FBLOCK_object'>The &#38;?BLOCK object</a>
    <li class='indexItem indexItem2'><a href='#Currying'>Currying</a>
    <li class='indexItem indexItem2'><a href='#Macros'>Macros</a>
    <li class='indexItem indexItem2'><a href='#Quasiquoting'>Quasiquoting</a>
    <li class='indexItem indexItem2'><a href='#Splicing'>Splicing</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Other_matters'>Other matters</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Anonymous_hashes_vs_blocks'>Anonymous hashes vs blocks</a>
    <li class='indexItem indexItem2'><a href='#Pairs_as_lvalues'>Pairs as lvalues</a>
    <li class='indexItem indexItem2'><a href='#Out-of-scope_names'>Out-of-scope names</a>
    <li class='indexItem indexItem2'><a href='#Declaring_a_MAIN_subroutine'>Declaring a MAIN subroutine</a>
  </ul>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 6: Subroutines</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Damian Conway &#60;damian@conway.org&#62; and Allison Randal &#60;al@shadowed.net&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre>  Maintainer: Larry Wall &#60;larry@wall.org&#62;
  Date: 21 Mar 2003
  Last Modified: 25 Aug 2006
  Number: 6
  Version: 53</pre>

<p>This document summarizes Apocalypse 6, which covers subroutines and the new type system.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Subroutines_and_other_code_objects"
>Subroutines and other code objects</a></h1>

<a href="#" onclick="return tog_quote(3);">
<div ID="header_shown_3" style="display: none;">
- Hide the snippet from t/blocks/sub_return_values.t (line 8 ~ line 228) -
</div>
<div ID="header_hidden_3" style="display: block;">
- Show the snippet from t/blocks/sub_return_values.t (line 8 ~ line 228) -
</div>
</a>
<div ID="hide_3" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S06/&quot;Subroutines and other code objects&quot;&gt;

See also t/blocks/return.t, which overlaps in scope.

=cut

# NOTE: the smart link above actually doesn't go to a good
# reference for the spec for 'return', but I couldn't find
# one either. 

plan 63;

# These test the returning of values from a subroutine.
# We test each data-type with 4 different styles of return.
#
# The datatypes are:
# &nbsp; &nbsp; Scalar
# &nbsp; &nbsp; Array
# &nbsp; &nbsp; Array-ref (aka List)
# &nbsp; &nbsp; Hash
# &nbsp; &nbsp; Hash-ref
#
# The 4 return styles are:
# &nbsp; &nbsp; create a variable, and return it with the return statement
# &nbsp; &nbsp; create a variable, and make it the last value in the sub (implied return)
# &nbsp; &nbsp; create the value inline and return it with the return statement
# &nbsp; &nbsp; create the value inline and make it the last value in the sub (implied return)
#
# NOTE:
# we do not really check return context here. That should be
# in it's own test file

# TODO-NOTE:
# Currently the Hash and Hash-ref tests are not complete, becuase hashes seem to be
# broken in a number of ways. I will get back to those later.

## void
# eval_ok('sub ret { return }; 1', &quot;return without value parses ok&quot;);

sub bare_return { return };

ok(! bare_return(), &quot;A bare return is a false value&quot;);

my @l = &lt;some values&gt;;
@l = bare_return();
is( @l, [], &quot;A bare return is an empty list in array/list context&quot;);

my $s = &quot;hello&quot;;
$s = bare_return();
is($s, undef, &quot;A bare return is undef in scalar context&quot;);

## scalars

sub foo_scalar {
&nbsp; &nbsp; my $foo = 'foo';
&nbsp; &nbsp; return $foo;
}
is(foo_scalar(), 'foo', 'got the right return value');

# ... w/out return statement

sub foo_scalar2 {
&nbsp; &nbsp; my $foo = 'foo';
&nbsp; &nbsp; $foo;
}
is(foo_scalar2(), 'foo', 'got the right return value');

# ... returning constant

sub foo_scalar3 {
&nbsp; &nbsp; return 'foo';
}
is(foo_scalar3(), 'foo', 'got the right return value');

# ... returning constant w/out return statement

sub foo_scalar4 {
&nbsp; &nbsp; 'foo';
}
is(foo_scalar4(), 'foo', 'got the right return value');

## arrays

sub foo_array {
&nbsp; &nbsp; my @foo = ('foo', 'bar', 'baz');
&nbsp; &nbsp; return @foo;
}
my @foo_array_return = foo_array();
isa_ok(@foo_array_return, 'Array');
is(+@foo_array_return, 3, 'got the right number of return value');
is(@foo_array_return[0], 'foo', 'got the right return value');
is(@foo_array_return[1], 'bar', 'got the right return value');
is(@foo_array_return[2], 'baz', 'got the right return value');

# ... without the last return statement

sub foo_array2 {
&nbsp; &nbsp; my @foo = ('foo', 'bar', 'baz');
&nbsp; &nbsp; @foo;
}
my @foo_array_return2 = foo_array2();
isa_ok(@foo_array_return2, 'Array');
is(+@foo_array_return2, 3, 'got the right number of return value');
is(@foo_array_return2[0], 'foo', 'got the right return value');
is(@foo_array_return2[1], 'bar', 'got the right return value');
is(@foo_array_return2[2], 'baz', 'got the right return value');

# ... returning an Array constructed &quot;on the fly&quot;

sub foo_array3 {
&nbsp; &nbsp; return ('foo', 'bar', 'baz');
}
my @foo_array_return3 = foo_array3();
isa_ok(@foo_array_return3, 'Array');
is(+@foo_array_return3, 3, 'got the right number of return value');
is(@foo_array_return3[0], 'foo', 'got the right return value');
is(@foo_array_return3[1], 'bar', 'got the right return value');
is(@foo_array_return3[2], 'baz', 'got the right return value');

# ... returning an Array constructed &quot;on the fly&quot; w/out return statement

sub foo_array4 {
&nbsp; &nbsp; ('foo', 'bar', 'baz');
}
my @foo_array_return4 = foo_array4();
isa_ok(@foo_array_return4, 'Array');
is(+@foo_array_return4, 3, 'got the right number of return value');
is(@foo_array_return4[0], 'foo', 'got the right return value');
is(@foo_array_return4[1], 'bar', 'got the right return value');
is(@foo_array_return4[2], 'baz', 'got the right return value');

## Array Refs aka - Lists

sub foo_array_ref {
&nbsp; my $foo = ['foo', 'bar', 'baz'];
&nbsp; return $foo;
}
my $foo_array_ref_return = foo_array_ref();
isa_ok($foo_array_ref_return, 'List');
is(+$foo_array_ref_return, 3, 'got the right number of return value');
is($foo_array_ref_return[0], 'foo', 'got the right return value');
is($foo_array_ref_return[1], 'bar', 'got the right return value');
is($foo_array_ref_return[2], 'baz', 'got the right return value');

# ... w/out the return statement

sub foo_array_ref2 {
&nbsp; my $foo = ['foo', 'bar', 'baz'];
&nbsp; $foo;
}
my $foo_array_ref_return2 = foo_array_ref2();
isa_ok($foo_array_ref_return2, 'List');
is(+$foo_array_ref_return2, 3, 'got the right number of return value');
is($foo_array_ref_return2[0], 'foo', 'got the right return value');
is($foo_array_ref_return2[1], 'bar', 'got the right return value');
is($foo_array_ref_return2[2], 'baz', 'got the right return value');

# ... returning list constructed &quot;on the fly&quot;

sub foo_array_ref3 {
&nbsp; return ['foo', 'bar', 'baz'];
}
my $foo_array_ref_return3 = foo_array_ref3();
isa_ok($foo_array_ref_return3, 'List');
is(+$foo_array_ref_return3, 3, 'got the right number of return value');
is($foo_array_ref_return3[0], 'foo', 'got the right return value');
is($foo_array_ref_return3[1], 'bar', 'got the right return value');
is($foo_array_ref_return3[2], 'baz', 'got the right return value');

# ... returning list constructed &quot;on the fly&quot; w/out return statement

sub foo_array_ref4 {
&nbsp; ['foo', 'bar', 'baz'];
}
my $foo_array_ref_return4 = foo_array_ref4();
isa_ok($foo_array_ref_return4, 'List');
is(+$foo_array_ref_return4, 3, 'got the right number of return value');
is($foo_array_ref_return4[0], 'foo', 'got the right return value');
is($foo_array_ref_return4[1], 'bar', 'got the right return value');
is($foo_array_ref_return4[2], 'baz', 'got the right return value');

## hashes

sub foo_hash {
&nbsp; &nbsp; my %foo = ('foo', 1, 'bar', 2, 'baz', 3);
&nbsp; &nbsp; return %foo;
}

my %foo_hash_return = foo_hash();
isa_ok(%foo_hash_return, 'Hash');
is(+%foo_hash_return.keys, 3, 'got the right number of return value');
is(%foo_hash_return&lt;foo&gt;, 1, 'got the right return value');
is(%foo_hash_return&lt;bar&gt;, 2, 'got the right return value');
is(%foo_hash_return&lt;baz&gt;, 3, 'got the right return value');

my $keys;
lives_ok({ $keys = +(foo_hash().keys) },
&nbsp; &nbsp; &quot;can call method on return value (hashref)&quot;);
is($keys, 3, &quot;got right result&quot;);
lives_ok({ foo_hash()&lt;foo&gt; },
&nbsp; &nbsp; &quot;can hash de-ref return value (hashref)&quot;);

# now hash refs

sub foo_hash_ref {
&nbsp; &nbsp; my %foo = ( 'foo', 1, 'bar', 2, 'baz', 3 );
&nbsp; &nbsp; return \%foo;
}

my $foo_hash_ref_return = foo_hash_ref();
isa_ok($foo_hash_ref_return, 'Hash');
is(+$foo_hash_ref_return.keys, 3, 'got the right number of return value');
is($foo_hash_ref_return&lt;foo&gt;, 1, 'got the right return value');
is($foo_hash_ref_return&lt;bar&gt;, 2, 'got the right return value');
is($foo_hash_ref_return&lt;baz&gt;, 3, 'got the right return value');

lives_ok({ $keys = +(foo_hash_ref().keys) },
&nbsp; &nbsp; &quot;can call method on return value (hashref)&quot;);
is($keys, 3, &quot;got right result&quot;);
lives_ok({ foo_hash_ref()&lt;foo&gt; },
&nbsp; &nbsp; &quot;can hash de-ref return value (hashref)&quot;);</pre>
</div>


<p><b>Subroutines</b> (keyword: <code>sub</code>) are non-inheritable routines with parameter lists.</p>

<p><b>Methods</b> (keyword: <code>method</code>) are inheritable routines which always have an associated object (known as their invocant) and belong to a particular kind or class.</p>

<p><b>Submethods</b> (keyword: <code>submethod</code>) are non-inheritable methods, or subroutines masquerading as methods. They have an invocant and belong to a particular kind or class.</p>

<p><b>Regexes</b> (keyword: <code>regex</code>) are methods (of a grammar) that perform pattern matching. Their associated block has a special syntax (see Synopsis 5). (We also use the term &#34;regex&#34; for anonymous patterns of the traditional form.)</p>

<p><b>Tokens</b> (keyword: <code>token</code>) are regexes that perform low-level non-backtracking (by default) pattern matching.</p>

<p><b>Rules</b> (keyword: <code>rule</code>) are regexes that perform non-backtracking (by default) pattern matching (and also enable rules to do whitespace dwimmery).</p>

<p><b>Macros</b> (keyword: <code>macro</code>) are routines whose calls execute as soon as they are parsed (i.e. at compile-time). Macros may return another source code string or a parse-tree.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Routine_modifiers"
>Routine modifiers</a></h1>

<a href="#" onclick="return tog_quote(17);">
<div ID="header_shown_17" style="display: none;">
- Hide the snippet from t/blocks/multi_sub.t (line 51 ~ line 69) -
</div>
<div ID="header_hidden_17" style="display: block;">
- Show the snippet from t/blocks/multi_sub.t (line 51 ~ line 69) -
</div>
</a>
<div ID="hide_17" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S06/&quot;Routine modifiers&quot;&gt;

multi declared_wo_sub (Int $x) { 1 }
multi declared_wo_sub (Str $x) { 2 }
is declared_wo_sub(42), &nbsp; 1, &quot;omitting 'sub' when declaring 'multi sub's works (1)&quot;;
is declared_wo_sub(&quot;42&quot;), 2, &quot;omitting 'sub' when declaring 'multi sub's works (2)&quot;;

# Test for slurpy MMDs

proto mmd () {...} &nbsp;# L&lt;S06/&quot;Routine modifiers&quot;&gt;
multi mmd () { 1 }
multi mmd (*$x, *@xs) { 2 }

is(mmd(), 1, 'Slurpy MMD to nullary');
is(mmd(1,2,3), 2, 'Slurpy MMD to listop via args');
is(mmd(1..3), 2, 'Slurpy MMD to listop via list');

# Test for proto definitions</pre>
</div>


<p><b>Multimethods</b> (keyword: <code>multi</code>) are routines that can have multiple variants that share the same name, selected by arity, types, or some other constraints.</p>

<p><b>Prototypes</b> (keyword: <code>proto</code>) specify the commonalities (such as parameter names, fixity, and associativity) shared by all multis of that name in the scope of the <code>proto</code> declaration.</p>

<p>A modifier keyword may occur before the routine keyword in a named routine:</p>

<pre>    proto sub foo {...}
    multi sub foo {...}
    proto method bar {...}
    multi method bar {...}</pre>

<p>If the routine keyword is omitted, it defaults to <code>sub</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Named_subroutines"
>Named subroutines</a></h2>

<p>The general syntax for named subroutines is any of:</p>

<pre>     my RETTYPE sub NAME ( PARAMS ) TRAITS {...}    # lexical only
    our RETTYPE sub NAME ( PARAMS ) TRAITS {...}    # also package-scoped
                sub NAME ( PARAMS ) TRAITS {...}    # same as &#34;our&#34;</pre>

<p>The return type may also be put inside the parentheses:</p>

<pre>    sub NAME (PARAMS --&#62; RETTYPE) {...}</pre>

<p>Unlike in Perl 5, named subroutines are considered expressions, so this is valid Perl 6:</p>

<pre>    my @subs = (sub foo { ... }, sub bar { ... });</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Anonymous_subroutines"
>Anonymous subroutines</a></h2>

<p>The general syntax for anonymous subroutines is:</p>

<pre>    sub ( PARAMS ) TRAITS {...}</pre>

<p>But one can also use a scope modifier to introduce the return type first:</p>

<pre>     my RETTYPE sub ( PARAMS ) TRAITS {...}
    our RETTYPE sub ( PARAMS ) TRAITS {...} # means the same as &#34;my&#34; here</pre>

<p><b>Trait</b> is the name for a compile-time (<code>is</code>) property. See <a href="#Properties_and_traits" class="podlinkpod"
>&#34;Properties and traits&#34;</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Perl5ish_subroutine_declarations"
>Perl5ish subroutine declarations</a></h2>

<p>You can declare a sub without parameter list, as in Perl 5:</p>

<pre>    sub foo {...}</pre>

<p>Arguments implicitly come in via the <code>@_</code> array, but they are <code>readonly</code> aliases to actual arguments:</p>

<pre>    sub say { print qq{&#34;@_[]&#34;\n}; }   # args appear in @_

    sub cap { $_ = uc $_ for @_ }   # Error: elements of @_ are read-only</pre>

<p>If you need to modify the elements of <code>@_</code>, declare the array explicitly with the <code>is rw</code> trait:</p>

<pre>    sub swap (*@_ is rw) { @_[0,1] = @_[1,0] }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Blocks"
>Blocks</a></h2>

<a href="#" onclick="return tog_quote(33);">
<div ID="header_shown_33" style="display: none;">
- Hide the snippet from t/data_types/anon_block.t (line 12 ~ line 104) -
</div>
<div ID="header_hidden_33" style="display: block;">
- Show the snippet from t/data_types/anon_block.t (line 12 ~ line 104) -
</div>
</a>
<div ID="hide_33" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S06/&quot;Blocks&quot;&gt;
L&lt;S04/&quot;The Relationship of Blocks and Declarations&quot;&gt;

=cut

plan 32;

# anon blocks L&lt;S06/&quot;Standard Subroutines&quot;&gt;
my $anon_sub = sub { 1 };
isa_ok($anon_sub, 'Sub');
is($anon_sub(), 1, 'sub { } works');

my $anon_sub_w_arg = sub ($arg) { 1 + $arg };
isa_ok($anon_sub_w_arg, 'Sub');
is($anon_sub_w_arg(3), 4, 'sub ($arg) {} works');

# anon blocks L&lt;S06/&quot;Blocks&quot;&gt;
my $anon_block = { 1 };
isa_ok($anon_block, 'Block');
is($anon_block(), 1, '{} &lt;anon block&gt; works');

# pointy subs L&lt;S06/&quot;Pointy subs&quot;&gt;
my $pointy_block = -&gt; { 1 };
isa_ok($pointy_block, 'Block');
is($pointy_block(), 1, '-&gt; {} &lt;&quot;pointy&quot; block&gt; works');

my $pointy_block_w_arg = -&gt; $arg { 1 + $arg };
isa_ok($pointy_block_w_arg, 'Block');
is($pointy_block_w_arg(3), 4, '-&gt; $arg {} &lt;&quot;pointy&quot; block w/args&gt; works');

my $pointy_block_w_multiple_args = -&gt; $arg1, $arg2 { $arg1 + $arg2 };
isa_ok($pointy_block_w_multiple_args, 'Block');
is($pointy_block_w_multiple_args(3, 4), 7, '-&gt; $arg1, $arg2 {} &lt;&quot;pointy&quot; block w/multiple args&gt; works');

my $pointy_block_nested = -&gt; $a { -&gt; $b { $a + $b }};
isa_ok($pointy_block_nested, Block);
isa_ok($pointy_block_nested(5), Block);
is $pointy_block_nested(5)(6), 11, '-&gt; $a { -&gt; $b { $a+$b }} nested &lt;&quot;pointy&quot; block&gt; works';

# bare blocks L&lt;S06/&quot;Blocks&quot;&gt;

my $foo;
{$foo = &quot;blah&quot;};
is($foo, &quot;blah&quot;, &quot;lone block actually executes it's content&quot;);

my $foo2;
{$foo2 = &quot;blah&quot;};
is($foo2, &quot;blah&quot;, &quot;lone block w/out a semicolon actually executes it's content&quot;);

my $foo3;
({$foo3 = &quot;blah&quot;});
ok(!defined($foo3), &quot;block enclosed by parentheses should not auto-execute (1)&quot;, :todo&lt;bug&gt;);

my $foo4;
({$foo4 = &quot;blah&quot;},);
ok(!defined($foo4), &quot;block enclosed by parentheses should not auto-execute (2)&quot;);

my ($one, $two);
# The try's here because it should die: $foo{...} should only work if $foo isa
# Hash (or sth. which provides appropriate tieing/&amp;postcircumfix:&lt;{
# }&gt;/whatever, but a Code should surely not support hash access).
# Additionally, a smart compiler will detect thus errors at compile-time, so I
# added an eval(). &nbsp;--iblech
try { eval '{$one = 1}{$two = 2}' };
is($one, undef, 'two blocks ({} {}) no semicolon after either,.. first block does not execute');
is($two, 2, '... but second block does (parsed as hash subscript)');

my ($one_a, $two_a);
{$one_a = 1}; {$two_a = 2}
is($one_a, 1, '... two blocks ({}; {}) semicolon after the first only,.. first block does execute');
is($two_a, 2, '... and second block does too');

my ($one_b, $two_b);
{
&nbsp; &nbsp; $one_b = 1
}
{
&nbsp; &nbsp; $two_b = 2
};
is($one_b, 1, '... two stand-alone blocks ({\n...\n}\n{\n...\n}),.. first block does execute');
is($two_b, 2, '... and second block does too');

my ($one_c, $two_c);
{$one_c = 1}; {$two_c = 2};
is($one_c, 1, '... two blocks ({}; {};) semicolon after both,.. first block does execute');
is($two_c, 2, '... and second block does too');

sub f { { 3 } }
is(f(), 3, 'bare blocks immediately runs even as the last statement');
is((sub { { 3 } }).(), 3, 'ditto for anonymous subs');
is((sub { { { 3 } } }).(), 3, 'ditto, even if nested');
dies_ok({(sub { { $^x } }).()}, 'implicit params become errors');
isnt((sub { -&gt; { 3 } }).(), 3, 'as are pointies');</pre>
</div>


<p>Raw blocks are also executable code structures in Perl 6.</p>

<p>Every block defines an object of type <code>Code</code>, which may either be executed immediately or passed on as a <code>Code</code> object. A bare block where an operator is expected is bound to the current statement level control syntax. A bare block where a term is expected merely produces a <code>Code</code> object. If the term bare block occurs in a list, it is considered the final element of that list unless followed immediately by a comma or comma surrogate.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="&#34;Pointy_blocks&#34;"
>&#34;Pointy blocks&#34;</a></h2>

<a href="#" onclick="return tog_quote(29);">
<div ID="header_shown_29" style="display: none;">
- Hide the snippet from t/blocks/pointy.t (line 11 ~ line 14) -
</div>
<div ID="header_hidden_29" style="display: block;">
- Show the snippet from t/blocks/pointy.t (line 11 ~ line 14) -
</div>
</a>
<div ID="hide_29" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S06/&quot;&quot;Pointy blocks&quot;&quot;&gt;

=cut</pre>
</div>


<p>Semantically the arrow operator <code>-&#62;</code> is almost a synonym for the anonymous <code>sub</code> keyword, except that the parameter list of a pointy block does not require parentheses, and a pointy block may not be given traits. Syntactically, a pointy block is parsed exactly like a bare block:</p>

<pre>    my $sq = -&#62; $val { $val**2 };
    say $sq(10); # 100

    my @list = 1..3;
    for @list -&#62; $elem {
        say $elem; # prints &#34;1\n2\n3\n&#34;
    }</pre>

<p>It also behaves like a block with respect to control exceptions. If you <code>return</code> from within a pointy block, it will return from the innermost enclosing <code>sub</code> or <code>method</code>, not the block itself. It is referenced by <code>&#38;?BLOCK</code>, not <code>&#38;?ROUTINE</code>.</p>

<a href="#" onclick="return tog_quote(28);">
<div ID="header_shown_28" style="display: none;">
- Hide the snippet from t/blocks/pointy.t (line 50 ~ line 60) -
</div>
<div ID="header_hidden_28" style="display: block;">
- Show the snippet from t/blocks/pointy.t (line 50 ~ line 60) -
</div>
</a>
<div ID="hide_28" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S06/&quot;&quot;Pointy blocks&quot;&quot; /behaves like a block with respect to control exceptions/&gt;
my $n = 1;
my $s = -&gt; { 
&nbsp; &nbsp; last if $n == 10;
&nbsp; &nbsp; $n++;
&nbsp; &nbsp; redo if $n &lt; 10;
};
try { $s.() };
is($!, undef, 'pointy with block control exceptions', :todo&lt;feature&gt;);
is $n, 10, &quot;pointy control exceptions ran&quot;, :todo&lt;feature&gt;;</pre>
</div>


<a href="#" onclick="return tog_quote(27);">
<div ID="header_shown_27" style="display: none;">
- Hide the snippet from t/blocks/pointy.t (line 61 ~ line 81) -
</div>
<div ID="header_hidden_27" style="display: block;">
- Show the snippet from t/blocks/pointy.t (line 61 ~ line 81) -
</div>
</a>
<div ID="hide_27" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S06/&quot;&quot;Pointy blocks&quot;&quot; /will return from the innermost enclosing sub or method&gt;
my $str = '';

sub outer { &nbsp;
&nbsp; &nbsp; my $s = -&gt; { 
&nbsp; &nbsp; &nbsp; &nbsp; is(&amp;?ROUTINE.name, '&amp;main::outer', 'pointy still sees outer\'s &amp;?ROUTINE'); 

&nbsp; &nbsp; &nbsp; &nbsp; $str ~= 'inner'; 
&nbsp; &nbsp; &nbsp; &nbsp; return 'inner ret'; 
&nbsp; &nbsp; };
&nbsp; &nbsp; $s.(); 
&nbsp; &nbsp; $str ~= 'outer';
&nbsp; &nbsp; return 'outer ret';
}

is outer(), 'inner ret', 'return in pointy returns from enclosing sub';
is $str, 'inner', 'return in pointy returns from enclosing sub';

# What about nested pointies -&gt; { ... -&gt; {} }?</pre>
</div>


<h2><a class='u' href='#___top' title='click to go to top of document'
name="Stub_declarations"
>Stub declarations</a></h2>

<p>To predeclare a subroutine without actually defining it, use a &#34;stub block&#34;:</p>

<pre>    sub foo {...}     # Yes, those three dots are part of the actual syntax</pre>

<p>The old Perl 5 form:</p>

<pre>    sub foo;</pre>

<p>is a compile-time error in Perl 6 (because it would imply that the body of the subroutine extends from that statement to the end of the file, as <code>class</code> and <code>module</code> declarations do). The only allowed use of the semicolon form is to declare a <code>MAIN</code> sub--see <a href="#Declaring_a_MAIN_subroutine" class="podlinkpod"
>&#34;Declaring a MAIN subroutine&#34;</a> below.</p>

<p>Redefining a stub subroutine does not produce an error, but redefining an already-defined subroutine does. If you wish to redefine a defined sub, you must explicitly use the &#34;<code>is instead</code>&#34; trait.</p>

<p>The <code>...</code> is the &#34;yadayadayada&#34; operator, which is executable but returns a failure. You can also use <code>???</code> to produce a warning, or <code>!!!</code> to always die. These also officially define stub blocks if used as the only expression in the block.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Globally_scoped_subroutines"
>Globally scoped subroutines</a></h2>

<p>Subroutines and variables can be declared in the global namespace, and are thereafter visible everywhere in a program.</p>

<p>Global subroutines and variables are normally referred to by prefixing their identifiers with <code>*</code> (short for &#34;<code>GLOBAL::</code>&#34;). The <code>*</code> is normally required on the declaration but may be omitted on use if the reference is unambiguous:</p>

<pre>    $*next_id = 0;
    sub *saith($text)  { print &#34;Yea verily, $text&#34; }

    module A {
        my $next_id = 2;    # hides any global or package $next_id
        saith($next_id);    # print the lexical $next_id;
        saith($*next_id);   # print the global $next_id;
    }

    module B {
        saith($next_id);    # Unambiguously the global $next_id
    }</pre>

<p>Only the name is installed into the <code>GLOBAL</code> package by <code>*</code>. To define subs completely within the scope of the <code>GLOBAL</code> namespace you should use &#34;<code>package GLOBAL {...}</code>&#34; around the declaration.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Lvalue_subroutines"
>Lvalue subroutines</a></h2>

<a href="#" onclick="return tog_quote(14);">
<div ID="header_shown_14" style="display: none;">
- Hide the snippet from t/blocks/lvalue_subroutines.t (line 11 ~ line 112) -
</div>
<div ID="header_hidden_14" style="display: block;">
- Show the snippet from t/blocks/lvalue_subroutines.t (line 11 ~ line 112) -
</div>
</a>
<div ID="hide_14" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S06/&quot;Lvalue subroutines&quot;&gt;

=cut

# Lvalue subrefs
{
&nbsp; my $var1 = 1;
&nbsp; my $var2 = 2;

&nbsp; my $lastvar = sub () is rw { return $var2 &nbsp; &nbsp; &nbsp;};
&nbsp; my $prevvar = sub () is rw { return $lastvar() };

&nbsp; $lastvar() = 3;
&nbsp; is $var2, 3, &quot;lvalue subroutine references work (simple)&quot;;

&nbsp; $prevvar() = 4;
&nbsp; is $var2, 4, &quot;lvalue subroutine references work (nested)&quot;;
}

{
&nbsp; my $var = 42;
&nbsp; my $notlvalue = sub () { return $var };

&nbsp; dies_ok { $notlvalue() = 23 },
&nbsp; &nbsp; &quot;assigning to non-rw subrefs should die&quot;, :todo&lt;bug&gt;;
&nbsp; is $var, 42,
&nbsp; &nbsp; &quot;assigning to non-rw subrefs shouldn't modify the original variable&quot;, :todo&lt;bug&gt;;
}

{
&nbsp; my $var1 = 1;
&nbsp; my $var2 = 2;

&nbsp; sub lastvar is rw { return $var2; }
&nbsp; sub prevvar is rw { return lastvar(); }

&nbsp; lastvar() = 3;
&nbsp; is($var2, 3, &quot;lvalue subroutines work (simple)&quot;);

&nbsp; prevvar() = 4;
&nbsp; is($var2, 4, &quot;lvalue subroutines work (nested)&quot;);
}

{
&nbsp; my $var = 42;

&nbsp; # S6 says that lvalue subroutines are marked out by 'is rw'
&nbsp; sub notlvalue { return $val1; } # without rw

&nbsp; dies_ok { notlvalue() = 5 },
&nbsp; &nbsp; &quot;assigning to non-rw subs should die&quot;;
&nbsp; is $var, 42,
&nbsp; &nbsp; &quot;assigning to non-rw subs shouldn't modify the original variable&quot;;
}

sub check ($passwd) { return $password eq &quot;fish&quot;; };

eval 'sub checklastval ($passwd) is rw {
&nbsp; &nbsp; my $proxy is Proxy(
&nbsp; &nbsp; FETCH =&gt; sub ($self) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return lastval();
&nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; STORE =&gt; sub ($self, $val) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; die &quot;wrong password&quot; unless check($passwd);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastval() = $val;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; );
&nbsp; &nbsp; return $proxy;
};';

my $errors;
eval 'try { checklastval(&quot;octopus&quot;) = 10 }; $errors=$!;';
is($errors, &quot;wrong password&quot;, 'checklastval STORE can die', :todo&lt;feature&gt;);

# Above test may well die for the wrong reason, if the Proxy stuff didn't
# parse OK, it will complain that it couldn't find the desired subroutine
eval_is('checklastval(&quot;fish&quot;) = 12; $val2', 12, 'proxy lvalue subroutine STORE works', :todo&lt;feature&gt;);
my $resultval;
eval '$resultval = checklastval(&quot;fish&quot;);';
is($resultval, 12, 'proxy lvalue subroutine FETCH works', :todo&lt;feature&gt;);

my $realvar = &quot;foo&quot;;
sub proxyvar ($prefix) is rw {
&nbsp; &nbsp; return Proxy.new(
&nbsp; &nbsp; &nbsp; &nbsp; FETCH =&gt; { $prefix ~ lc($realvar) },
&nbsp; &nbsp; &nbsp; &nbsp; STORE =&gt; { lc($realvar = $^val) },
&nbsp; &nbsp; );
}
is try { proxyvar(&quot;PRE&quot;) }, 'PREfoo', 'proxy lvalue subroutine FETCH works', :todo&lt;feature&gt;;
# Return value of assignments of Proxy objects is decided now.
# See thread &quot;Assigning Proxy objects&quot; on p6l,
# L&lt;<a href="http://www.nntp.perl.org/group/perl.perl6.language/21838">&quot;http://www.nntp.perl.org/group/perl.perl6.language/21838&quot;</a>&gt;.
# Quoting Larry:
# &nbsp; The intention is that lvalue subs behave in all respects as if they
# &nbsp; were variables.  So consider what
# &nbsp; 
# &nbsp; &nbsp; &nbsp; say $nonproxy = 40;
# &nbsp; 
# &nbsp; should do.
is try { proxyvar(&quot;PRE&quot;) = &quot;BAR&quot; }, 'BAR',
&nbsp; &nbsp; 'proxy lvalue subroutine STORE works and returns the correct value', :todo&lt;feature&gt;;
is $realvar, 'BAR', 'variable was modified', :todo&lt;feature&gt;;</pre>
</div>


<p>Lvalue subroutines return a &#34;proxy&#34; object that can be assigned to. It&#39;s known as a proxy because the object usually represents the purpose or outcome of the subroutine call.</p>

<p>Subroutines are specified as being lvalue using the <code>is rw</code> trait.</p>

<p>An lvalue subroutine may return a variable:</p>

<pre>    my $lastval;
    sub lastval () is rw { return $lastval }</pre>

<p>or the result of some nested call to an lvalue subroutine:</p>

<pre>    sub prevval () is rw { return lastval() }</pre>

<p>or a specially tied proxy object, with suitably programmed <code>FETCH</code> and <code>STORE</code> methods:</p>

<pre>    sub checklastval ($passwd) is rw {
        return new Proxy:
                FETCH =&#62; method {
                            return lastval();
                         },
                STORE =&#62; method ($val) {
                            die unless check($passwd);
                            lastval() = $val;
                         };
    }</pre>

<p>Other methods may be defined for specialized purposes such as temporizing the value of the proxy.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Operator_overloading"
>Operator overloading</a></h2>

<a href="#" onclick="return tog_quote(16);">
<div ID="header_shown_16" style="display: none;">
- Hide the snippet from t/operators/operator_overloading.t (line 11 ~ line 119) -
</div>
<div ID="header_hidden_16" style="display: block;">
- Show the snippet from t/operators/operator_overloading.t (line 11 ~ line 119) -
</div>
</a>
<div ID="hide_16" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S06/&quot;Operator overloading&quot;&gt;

=cut

# This set of tests is very basic for now.

sub prefix:&lt;X&gt; ($thing) { return &quot;ROUGHLY$thing&quot;; };

is(X &quot;fish&quot;, &quot;ROUGHLYfish&quot;,
&nbsp; 'prefix operator overloading for new operator');

sub prefix:&lt;±&gt; ($thing) { return &quot;AROUND$thing&quot;; };
is ± &quot;fish&quot;, &quot;AROUNDfish&quot;, 'prefix operator overloading for new operator (unicode)';
sub prefix:&lt;(+-)&gt; ($thing) { return &quot;ABOUT$thing&quot;; };
is (+-) &quot;fish&quot;, &quot;ABOUTfish&quot;, 'prefix operator overloading for new operator (nasty)';

{
&nbsp; my sub prefix:&lt;-&gt;($thing) { return &quot;CROSS$thing&quot;; };
&nbsp; is(-&quot;fish&quot;, &quot;CROSSfish&quot;,
&nbsp; &nbsp; 'prefix operator overloading for existing operator (but only lexically so we don\'t mess up runtime internals (needed at least for PIL2JS, probably for PIL-Run, too)');
}

sub infix:&lt;×&gt; ($a, $b) { $a * $b }
is(5 × 3, 15, &quot;infix Unicode operator&quot;);

sub infix:&lt;C&gt; ($text, $owner) { return &quot;$text copyright $owner&quot;; };
is &quot;romeo &amp; juliet&quot; C &quot;Shakespeare&quot;, &quot;romeo &amp; juliet copyright Shakespeare&quot;,
&nbsp; &nbsp; 'infix operator overloading for new operator';

sub infix:&lt;©&gt; ($text, $owner) { return &quot;$text Copyright $owner&quot;; };
is &quot;romeo &amp; juliet&quot; © &quot;Shakespeare&quot;, &quot;romeo &amp; juliet Copyright Shakespeare&quot;,
&nbsp; &nbsp; 'infix operator overloading for new operator (unicode)';

sub infix:&lt;(C)&gt; ($text, $owner) { return &quot;$text CopyRight $owner&quot;; };
is &quot;romeo &amp; juliet&quot; (C) &quot;Shakespeare&quot;, &quot;romeo &amp; juliet CopyRight Shakespeare&quot;,
&nbsp; &nbsp; 'infix operator overloading for new operator (nasty)';

sub infix:«_&lt;_»($one, $two) { return 42 }
is 3 _&lt;_ 5, 42, &quot;frenchquoted infix sub&quot;;

sub postfix:&lt;W&gt; ($wobble) { return &quot;ANDANDAND$wobble&quot;; };

is(&quot;boop&quot; W, &quot;ANDANDANDboop&quot;, 
&nbsp; 'postfix operator overloading for new operator');

sub postfix:&lt;&amp;&amp;&amp;&amp;&amp;&gt; ($wobble) { return &quot;ANDANDANDANDAND$wobble&quot;; };
is(&quot;boop&quot;&amp;&amp;&amp;&amp;&amp;, &quot;ANDANDANDANDANDboop&quot;,
&nbsp; &quot;postfix operator overloading for new operator (weird)&quot;);

my $var = 0;
eval_ok('macro circumfix:{&quot;&lt;!--&quot;,&quot;--&gt;&quot;} ($text) is parsed / .*? / { &quot;&quot; }; &lt;!-- $var = 1; --&gt;; $var == 0;', 'circumfix macro {&quot;&quot;,&quot;&quot;}', :todo&lt;feature&gt;);
eval_ok('macro circumfix:«&lt;!-- --&gt;» ($text) is parsed / .*? / { &quot;&quot; }; &lt;!-- $var = 1; --&gt;; $var == 0;', 'circumfix macro «»', :todo&lt;feature&gt;);

# demonstrate sum prefix

sub prefix:&lt;Σ&gt; ($x) { [+] *$x }
is(Σ [1..10], 55, &quot;sum prefix operator&quot;);

# check that the correct overloaded method is called
multi postfix:&lt;!&gt; ($x) { [*] 1..$x }
multi postfix:&lt;!&gt; (Str $x) { return($x.uc ~ &quot;!!!&quot;) }

is(10!, 3628800, &quot;factorial postfix operator&quot;);
is(&quot;boobies&quot;!, &quot;BOOBIES!!!&quot;, &quot;correct overloaded method called&quot;);

# Overloading by setting the appropriate code variable
{
&nbsp; my &amp;infix:&lt;plus&gt;;
&nbsp; BEGIN {
&nbsp; &nbsp; &amp;infix:&lt;plus&gt; := { $^a + $^b };
&nbsp; }

&nbsp; is 3 plus 5, 8, 'overloading an operator using &quot;my &amp;infix:&lt;...&gt;&quot; worked';
}

# Overloading by setting the appropriate code variable using symbolic
# dereferentiation
{
&nbsp; my &amp;infix:&lt;times&gt;;
&nbsp; BEGIN {
&nbsp; &nbsp; &amp;::(&quot;infix:&lt;times&gt;&quot;) := { $^a * $^b };
&nbsp; }

&nbsp; is 3 times 5, 15, 'operator overloading using symbolic dereferentiation';
}

# Accessing an operator using its subroutine name
{
&nbsp; is &amp;infix:&lt;+&gt;(2, 3), 5, &quot;accessing a builtin operator using its subroutine name&quot;;

&nbsp; my &amp;infix:&lt;z&gt; := { $^a + $^b };
&nbsp; is &amp;infix:&lt;z&gt;(2, 3), 5, &quot;accessing a userdefined operator using its subroutine name&quot;;

&nbsp; is ~(&amp;infix:&lt;»+«&gt;([1,2,3],[4,5,6])), &quot;5 7 9&quot;, &quot;accessing a hyperoperator using its subroutine name&quot;;
}

# Overriding infix:&lt;;&gt;
{
&nbsp; &nbsp; my proto infix:&lt;;&gt; ($a, $b) { $a + $b }
&nbsp; &nbsp; is (3 ; 2), 5 &nbsp;# XXX correct?
}

# [NOTE]
# pmichaud ruled that prefix:&lt;;&gt; and postfix:&lt;;&gt; shouldn't be defined by
# the synopses:
# &nbsp; http://colabti.de/irclogger/irclogger_log/perl6?date=2006-07-29,Sat&amp;sel=189#l299
# so we won't test them here.

# Overriding prefix:&lt;if&gt;</pre>
</div>


<a href="#" onclick="return tog_quote(15);">
<div ID="header_shown_15" style="display: none;">
- Hide the snippet from t/oo/methods/overload.t (line 7 ~ line 76) -
</div>
<div ID="header_hidden_15" style="display: block;">
- Show the snippet from t/oo/methods/overload.t (line 7 ~ line 76) -
</div>
</a>
<div ID="hide_15" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S06/&quot;Operator overloading&quot;&gt;
# Later, we want to run the same tests with two classes, Foo and Bar.
# Foo overloads the operators by using multi methods, Bar by using multi subs.
# But as currently both Foo and Bar do not compile, we have to create a
# stubclass, which is then given to &amp;run_tests_with.
# But if the class does compile, $foo_class and $bar_class will be set to the
# correct classes (Foo and Bar), and the tests have a chance to succeed.
class StubClass {}
my ($foo_class, $bar_class) = (StubClass, StubClass);

eval '
&nbsp; &nbsp; class Foo {
&nbsp; &nbsp; has $.bar is rw;
&nbsp; &nbsp; multi method prefix:&lt;~&gt; ($self) &nbsp;{ return $.bar }
&nbsp; &nbsp; mutli method infix:&lt;+&gt; &nbsp;($a, $b) { return &quot;$a $b&quot; }
&nbsp; &nbsp; }

&nbsp; &nbsp; $foo_class = Foo;
';

eval '
&nbsp; &nbsp; class Bar {
&nbsp; &nbsp; has $.bar is rw;
&nbsp; &nbsp; }

&nbsp; &nbsp; multi sub prefix:&lt;~&gt; (Bar $self) &nbsp; &nbsp; &nbsp;{ return $self.bar }
&nbsp; &nbsp; mutli sub infix:&lt;+&gt; &nbsp;(Bar $a, Bar $b) { return &quot;$a $b&quot; }

&nbsp; &nbsp; $bar_class = Bar;
';

run_tests_with($foo_class);
run_tests_with($bar_class);

sub run_tests_with($class) {
&nbsp; &nbsp; {
&nbsp; &nbsp; my $val;
&nbsp; &nbsp; lives_ok {
&nbsp; &nbsp; &nbsp; &nbsp; my $foo = $class.new();
&nbsp; &nbsp; &nbsp; &nbsp; $foo.bar = 'software';
&nbsp; &nbsp; &nbsp; &nbsp; $val = &quot;$foo&quot;
&nbsp; &nbsp; }, '... class methods work for class', :todo&lt;feature&gt;;
&nbsp; &nbsp; is($val, 'software', '... basic prefix operator overloading worked', :todo&lt;feature&gt;);

&nbsp; &nbsp; lives_ok {
&nbsp; &nbsp; &nbsp; &nbsp; my $foo = $class.new();
&nbsp; &nbsp; &nbsp; &nbsp; $foo.bar = 'software';
&nbsp; &nbsp; &nbsp; &nbsp; $val = $foo + $foo;
&nbsp; &nbsp; }, '... class methods work for class', :todo&lt;feature&gt;;
&nbsp; &nbsp; is($val, 'software software', '... basic infix operator overloading worked', :todo&lt;feature&gt;);
&nbsp; &nbsp; }

&nbsp; &nbsp; # Test that the object is correctly stringified when it is in an array.
&nbsp; &nbsp; # And test that »...« automagically work, too.
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; my $obj;
&nbsp; &nbsp; &nbsp; lives_ok {
&nbsp; &nbsp; &nbsp; $obj &nbsp; &nbsp; = $class.new;
&nbsp; &nbsp; &nbsp; $obj.bar = &quot;pugs&quot;;
&nbsp; &nbsp; &nbsp; }, &quot;instantiating a class which defines operators worked&quot;, :todo&lt;feature&gt;;

&nbsp; &nbsp; &nbsp; my @foo = ($obj, $obj, $obj);
&nbsp; &nbsp; &nbsp; my $res;
&nbsp; &nbsp; &nbsp; lives_ok { $res = ~@foo }, &quot;stringification didn't die&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; &nbsp; is $res, &quot;pugs pugs pugs&quot;, &quot;stringification overloading worked in array stringification&quot;, :todo&lt;feature&gt;;

&nbsp; &nbsp; &nbsp; lives_ok { $res = ~[@foo »~« &quot;!&quot;] }, &quot;stringification with hyperization didn't die&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; &nbsp; is $res, &quot;pugs! pugs! pugs!&quot;, &quot;stringification overloading was hyperized correctly&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; }
}</pre>
</div>


<p>Operators are just subroutines with special names and scoping. An operator name consists of a grammatical category name followed by a single colon followed by an operator name specified as if it were a hash subscript (but evaluated at compile time). So any of these indicates the same binary addition operator:</p>

<pre>    infix:&#60;+&#62;
    infix:&#171;+&#187;
    infix:&#60;&#60;+&#62;&#62;
    infix:{&#39;+&#39;}
    infix:{&#34;+&#34;}</pre>

<p>Use the <code>&#38;</code> sigil just as you would on ordinary subs.</p>

<p>Unary operators are defined as <code>prefix</code> or <code>postfix</code>:</p>

<pre>    sub prefix:&#60;OPNAME&#62;  ($operand) {...}
    sub postfix:&#60;OPNAME&#62; ($operand) {...}</pre>

<p>Binary operators are defined as <code>infix</code>:</p>

<pre>    sub infix:&#60;OPNAME&#62; ($leftop, $rightop) {...}</pre>

<p>Bracketing operators are defined as <code>circumfix</code> where a term is expected or <code>postcircumfix</code> where a postfix is expected. A two-element slice containing the leading and trailing delimiters is the name of the operator.</p>

<pre>    sub circumfix:&#60;LEFTDELIM RIGHTDELIM&#62; ($contents) {...}
    sub circumfix:{&#39;LEFTDELIM&#39;,&#39;RIGHTDELIM&#39;} ($contents) {...}</pre>

<p>Contrary to Apocalypse 6, there is no longer any rule about splitting an even number of characters. You must use a two element slice. Such names are canonicalized to a single form within the symbol table, so you must use the canonical name if you wish to subscript the symbol table directly (as in <code>PKG::{&#39;infix:&#60;+&#62;&#39;}</code>). Otherwise any form will do. (Symbolic references do not count as direct subscripts since they go through a parsing process.) The canonical form always uses angle brackets and a single space between slice elements. The elements are not escaped, so <code>PKG::circumfix:{&#39;&#60;&#39;,&#39;&#62;&#39;}</code> is canonicalized to <code>PKG::{&#39;circumfix:&#60;&#60; &#62;&#62;&#39;}</code>, and decanonicalizing always involves stripping the outer angles and splitting on space, if any. This works because a hash key knows how long it is, so there&#39;s no ambiguity about where the final angle is. And space works because operators are not allowed to contain spaces.</p>

<p>Operator names can be any sequence of non-whitespace characters including Unicode characters. For example:</p>

<pre>    sub infix:&#60;(c)&#62; ($text, $owner) { return $text but Copyright($owner) }
    method prefix:&#60;&#177;&#62; (Num $x --&#62; Num) { return +$x | -$x }
    multi sub postfix:&#60;!&#62; (Int $n) { $n &#60; 2 ?? 1 !! $n*($n-1)! }
    macro circumfix:&#171;&#60;!-- --&#62;&#187; ($text) is parsed / .*? / { &#34;&#34; }

    my $document = $text (c) $me;

    my $tolerance = &#177;7!;

    &#60;!-- This is now a comment --&#62;</pre>

<p>Whitespace may never be part of the name (except as separator within a <code>&#60;...&#62;</code> or <code>&#171;...&#187;</code> slice, as in the example above).</p>

<p>A null operator name does not define a null or whitespace operator, but a default matching subrule for that syntactic category, which is useful when there is no fixed string that can be recognized, such as tokens beginning with digits. Such an operator <i>must</i> supply an <code>is parsed</code> trait. The Perl grammar uses a default subrule for the <code>:1st</code>, <code>:2nd</code>, <code>:3rd</code>, etc. regex modifiers, something like this:</p>

<pre>    sub regex_mod_external:&#60;&#62; ($x) is parsed(token { \d+[st|nd|rd|th] }) {...}</pre>

<p>Such default rules are attempted in the order declared. (They always follow any rules with a known prefix, by the longest-token-first rule.)</p>

<p>Although the name of an operator can be installed into any package or lexical namespace, the syntactic effects of an operator declaration are always lexically scoped. Operators other than the standard ones should not be installed into the <code>*</code> namespace. Always use exportation to make non-standard syntax available to other scopes.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Parameters_and_arguments"
>Parameters and arguments</a></h1>

<p>Perl 6 subroutines may be declared with parameter lists.</p>

<p>By default, all parameters are readonly aliases to their corresponding arguments--the parameter is just another name for the original argument, but the argument can&#39;t be modified through it. To allow modification, use the <code>is rw</code> trait. To pass-by-copy, use the <code>is copy</code> trait.</p>

<p>Parameters may be required or optional. They may be passed by position, or by name. Individual parameters may confer a scalar or list context on their corresponding arguments, but unlike in Perl 5, this is decided lazily at parameter binding time.</p>

<p>Arguments destined for required positional parameters must come before those bound to optional positional parameters. Arguments destined for named parameters may come before and/or after the positional parameters. (To avoid confusion it is highly recommended that all positional parameters be kept contiguous in the call syntax, but this is not enforced, and custom arg list processors are certainly possible on those arguments that are bound to a final slurpy or arglist variable.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Named_arguments"
>Named arguments</a></h2>

<p>Named arguments are recognized syntactically at the &#34;comma&#34; level. Since parameters are identified using identifiers, the recognized syntaxes are those where the identifier in question is obvious. You may use either the adverbial form, <code>:name($value)</code>, or the autoquoted arrow form, <code>name =&#62; $value</code>. These must occur at the top &#34;comma&#34; level, and no other forms are taken as named pairs by default. Pairs intended as positional arguments rather than named arguments may be indicated by extra parens or by explicitly quoting the key to suppress autoquoting:</p>

<pre>    doit :when&#60;now&#62;,1,2,3;      # always a named arg
    doit (:when&#60;now&#62;),1,2,3;    # always a positional arg

    doit when =&#62; &#39;now&#39;,1,2,3;   # always a named arg
    doit (when =&#62; &#39;now&#39;),1,2,3; # always a positional arg
    doit &#39;when&#39; =&#62; &#39;now&#39;,1,2,3; # always a positional arg</pre>

<p>Only bare keys with valid identifier names are recognized as named arguments:</p>

<pre>    doit when =&#62; &#39;now&#39;;         # always a named arg
    doit &#39;when&#39; =&#62; &#39;now&#39;;       # always a positional arg
    doit 123  =&#62; &#39;now&#39;;         # always a positional arg
    doit :123&#60;now&#62;;             # always a positional arg</pre>

<p>Going the other way, pairs intended as named arguments that don&#39;t look like pairs must be introduced with the <code>[,]</code> reduction operator:</p>

<pre>    $pair = :when&#60;now&#62;;
    doit $pair,1,2,3;                   # always a positional arg
    doit [,] %$pair,1,2,3;              # always a named arg
    doit [,] %(get_pair()),1,2,3;       # always a named arg
    doit [,] %(&#39;when&#39; =&#62; &#39;now&#39;),1,2,3;  # always a named arg</pre>

<p>Note that, to apply <code>[,]</code> to a single arg you may need to use parentheses. In general it doesn&#39;t matter.</p>

<p>Likewise, if you wish to pass a hash and have its entries treated as named arguments, you must dereference it with a <code>[,]</code>:</p>

<pre>    %pairs = {:when&#60;now&#62; :what&#60;any&#62;};
    doit %pairs,1,2,3;          # always a positional arg
    doit [,](%pairs),1,2,3;     # always named args</pre>

<p>Variables with a <code>:</code> prefix in rvalue context autogenerate pairs, so you can also say this:</p>

<pre>    $when = &#39;now&#39;;
    doit $when,1,2,3;   # always a positional arg of &#39;now&#39;
    doit :$when,1,2,3;  # always a named arg of :when&#60;now&#62;</pre>

<p>In other words <code>:$when</code> is shorthand for <code>:when($when)</code>. This works for any sigil:</p>

<pre>    :$what      :what($what)
    :@what      :what(@what)
    :%what      :what(%what)
    :&#38;what      :what(&#38;what)</pre>

<p>There is a corresponding shortcut for hash keys if you prefix the subscript instead of the sigil. The <code>:</code> is not functioning as an operator here, but as a modifier of the following token:</p>

<pre>    doit %hash:&#60;a&#62;,1,2,3;
    doit %hash:{&#39;b&#39;},1,2,3;</pre>

<p>are short for</p>

<pre>    doit :a(%hash&#60;a&#62;),1,2,3;
    doit :b(%hash{&#39;b&#39;}),1,2,3;</pre>

<p>Ordinary hash notation will just pass the value of the hash entry as a positional argument regardless of whether it is a pair or not. To pass both key and value out of hash as a positional pair, use <code>:p</code> instead:</p>

<pre>    doit %hash&#60;a&#62;:p,1,2,3;
    doit %hash{&#39;b&#39;}:p,1,2,3;</pre>

<p>(The <code>:p</code> stands for &#34;pairs&#34;, not &#34;positional&#34;--the <code>:p</code> adverb may be placed on any Hash objects to make it mean &#34;pairs&#34; instead of &#34;values&#34;.)</p>

<p>Pair constructors are recognized syntactically at the call level and put into the named slot of the <code>Capture</code> structure. Hence they may be bound to positionals only by name, not as ordinary positional <code>Pair</code> objects. Leftover named arguments can be slurped into a slurpy hash.</p>

<p>Because named and positional arguments can be freely mixed, the programmer always needs to disambiguate pairs literals from named arguments with parentheses or quotes:</p>

<pre>    # Named argument &#34;a&#34;
    push @array, 1, 2, :a&#60;b&#62;;

    # Pair object (a=&#62;&#39;b&#39;)
    push @array, 1, 2, (:a&#60;b&#62;);
    push @array, 1, 2, &#39;a&#39; =&#62; &#39;b&#39;;</pre>

<p>Perl 6 allows multiple same-named arguments, and records the relative order of arguments with the same name. When there are more than one argument, the <code>@</code> sigil in the parameter list causes the arguments to be concatenated:</p>

<pre>    sub fun (Int @x) { ... }
    fun( x =&#62; 1, x =&#62; 2 );              # @x := (1, 2)
    fun( x =&#62; (1, 2), x =&#62; (3, 4) );    # @x := (1, 2, 3, 4)</pre>

<p>Other sigils bind only to the <i>last</i> argument with that name:</p>

<pre>    sub fun (Int $x) { ... }
    f( x =&#62; 1, x =&#62; 2 );                # $x := 2
    fun( x =&#62; (1, 2), x =&#62; (3, 4) );    # $x := (3, 4)</pre>

<p>This means a hash holding default values must come <i>before</i> known named parameters, similar to how hash constructors work:</p>

<pre>    # Allow &#34;x&#34; and &#34;y&#34; in %defaults to be overridden
    f( [,](%defaults), x =&#62; 1, y =&#62; 2 );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Invocant_parameters"
>Invocant parameters</a></h2>

<p>A method invocant may be specified as the first parameter in the parameter list, with a colon (rather than a comma) immediately after it:</p>

<pre>    method get_name ($self:) {...}
    method set_name ($_: $newname) {...}</pre>

<p>The corresponding argument (the invocant) is evaluated in scalar context and is passed as the left operand of the method call operator:</p>

<pre>    print $obj.get_name();
    $obj.set_name(&#34;Sam&#34;);</pre>

<p>For the purpose of matching positional arguments against invocant parameters, the invocant argument passed via the method call syntax is considered the first positional argument when failover happens from single dispatch to multiple dispatch:</p>

<pre>    handle_event($w, $e, $m);   # calls the multi sub
    $w.handle_event($e, $m);    # ditto, but only if there is no
                                # suitable $w.handle_event method</pre>

<p>Invocants may also be passed using the indirect object syntax, with a colon after them. The colon is just a special form of the comma, and has the same precedence:</p>

<pre>    set_name $obj: &#34;Sam&#34;;   # try $obj.set_name(&#34;Sam&#34;) first, then
                            # fall-back to set_name($obj, &#34;Sam&#34;)
    $obj.set_name(&#34;Sam&#34;);   # same as the above</pre>

<p>An invocant is the topic of the corresponding method if that formal parameter is declared with the name <code>$_</code>. A method&#39;s invocant always has the alias <code>self</code>. Other styles of self can be declared with the <code>self</code> pragma.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Longname_parameters"
>Longname parameters</a></h2>

<a href="#" onclick="return tog_quote(10);">
<div ID="header_shown_10" style="display: none;">
- Hide the snippet from t/blocks/multi_named_vs_pos.t (line 7 ~ line 64) -
</div>
<div ID="header_hidden_10" style="display: block;">
- Show the snippet from t/blocks/multi_named_vs_pos.t (line 7 ~ line 64) -
</div>
</a>
<div ID="hide_10" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;S06/&quot;Longname parameters&quot;&gt;
#L&lt;S12/&quot;Multisubs and Multimethods&quot;&gt;

multi earth (:$me) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {&quot;me $me&quot;};
multi earth (:$him) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{&quot;him $him&quot;};
multi earth (:$me, :$him) &nbsp; &nbsp; &nbsp; &nbsp;{&quot;me $me him $him&quot;};
multi earth (:$me, :$him, :$her) {&quot;me $me him $him her $her&quot;};
multi earth ($me) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{&quot;pos $me&quot;};
multi earth ($me, :$you) &nbsp; &nbsp; &nbsp; &nbsp; {&quot;pos $me you $you&quot;};
multi earth ($me, :$her) &nbsp; &nbsp; &nbsp; &nbsp; {&quot;pos $me her $her&quot;};
multi earth ($me, $you) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{&quot;pos $me pos $you&quot;};
multi earth ($me, $you, :$her) &nbsp; {&quot;pos $me pos $you her $her&quot;};

is( try { earth(me =&gt; 1) }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'me 1', &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'named me', :todo&lt;feature&gt;);
is( try { earth(him =&gt; 2) }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'him 2', &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'named you', :todo&lt;feature&gt;);
is( try { earth(me =&gt; 1, him =&gt; 2) }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'me 1 him 2', &nbsp; &nbsp; &nbsp; 'named me, named him', :todo&lt;feature&gt;);
is( try { earth(him =&gt; 2, me =&gt; 1) }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'me 1 him 2', &nbsp; &nbsp; &nbsp; 'named him, named me', :todo&lt;feature&gt;);
is( try { earth(me =&gt; 1, him =&gt; 2, her =&gt; 3) }, 'me 1 him 2 her 3', 'named me named him named her', :todo&lt;feature&gt;);
is( try { earth(him =&gt; 2, me =&gt; 1, her =&gt; 3) }, 'me 1 him 2 her 3', 'named him named me named her', :todo&lt;feature&gt;);
is( try { earth(her =&gt; 3, me =&gt; 1, him =&gt; 2) }, 'me 1 him 2 her 3', 'named her named me named him', :todo&lt;feature&gt;);
is( try { earth(her =&gt; 3, him =&gt; 2, me =&gt; 1) }, 'me 1 him 2 her 3', 'named her named him named me', :todo&lt;feature&gt;);

is( try { earth('a') }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'pos a', &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'pos');
is( try { earth('b', you =&gt; 4) }, &nbsp; &nbsp; &nbsp;'pos b you 4', &nbsp; &nbsp; &nbsp; 'pos, named you', :todo&lt;feature&gt;);
is( try { earth('c', her =&gt; 3) }, &nbsp; &nbsp; &nbsp;'pos c her 3', &nbsp; &nbsp; &nbsp; 'pos, named her', :todo&lt;feature&gt;);
is( try { earth('d', 'e') }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'pos d pos e', &nbsp; &nbsp; &nbsp; 'pos, pos');
is( try { earth('f', 'g', her =&gt; 3) }, 'pos f pos g her 3', 'pos, pos, named');


# ensure we get the same results when the subroutines are 
# defined in reverse order
#

multi wind ($me, $you, :$her) &nbsp; {&quot;pos $me pos $you her $her&quot;};
multi wind ($me, $you) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{&quot;pos $me pos $you&quot;};
multi wind ($me, :$her) &nbsp; &nbsp; &nbsp; &nbsp; {&quot;pos $me her $her&quot;};
multi wind ($me, :$you) &nbsp; &nbsp; &nbsp; &nbsp; {&quot;pos $me you $you&quot;};
multi wind ($me) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{&quot;pos $me&quot;};
multi wind (:$me, :$him, :$her) {&quot;me $me him $him her $her&quot;};
multi wind (:$me, :$him) &nbsp; &nbsp; &nbsp; &nbsp;{&quot;me $me him $him&quot;};
multi wind (:$him) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{&quot;him $him&quot;};
multi wind (:$me) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {&quot;me $me&quot;};

is( try { wind(me =&gt; 1) }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'me 1', &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'named me', :todo&lt;feature&gt;);
is( try { wind(him =&gt; 2) }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'him 2', &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'named you', :todo&lt;feature&gt;);
is( try { wind(me =&gt; 1, him =&gt; 2) }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'me 1 him 2', &nbsp; &nbsp; &nbsp; 'named me, named him', :todo&lt;feature&gt;);
is( try { wind(him =&gt; 2, me =&gt; 1) }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'me 1 him 2', &nbsp; &nbsp; &nbsp; 'named him, named me', :todo&lt;feature&gt;);
is( try { wind(me =&gt; 1, him =&gt; 2, her =&gt; 3) }, 'me 1 him 2 her 3', 'named me named him named her', :todo&lt;feature&gt;);
is( try { wind(him =&gt; 2, me =&gt; 1, her =&gt; 3) }, 'me 1 him 2 her 3', 'named him named me named her', :todo&lt;feature&gt;);
is( try { wind(her =&gt; 3, me =&gt; 1, him =&gt; 2) }, 'me 1 him 2 her 3', 'named her named me named him', :todo&lt;feature&gt;);
is( try { wind(her =&gt; 3, him =&gt; 2, me =&gt; 1) }, 'me 1 him 2 her 3', 'named her named him named me', :todo&lt;feature&gt;);

is( try { wind('a') }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'pos a', &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'pos');
is( try { wind('b', you =&gt; 4) }, &nbsp; &nbsp; &nbsp;'pos b you 4', &nbsp; &nbsp; &nbsp; 'pos, named you', :todo&lt;feature&gt;);
is( try { wind('c', her =&gt; 3) }, &nbsp; &nbsp; &nbsp;'pos c her 3', &nbsp; &nbsp; &nbsp; 'pos, named her', :todo&lt;feature&gt;);
is( try { wind('d', 'e') }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'pos d pos e', &nbsp; &nbsp; &nbsp; 'pos, pos');
is( try { wind('f', 'g', her =&gt; 3) }, 'pos f pos g her 3', 'pos, pos, named');</pre>
</div>


<a href="#" onclick="return tog_quote(9);">
<div ID="header_shown_9" style="display: none;">
- Hide the snippet from t/blocks/multi_sub.t (line 7 ~ line 50) -
</div>
<div ID="header_hidden_9" style="display: block;">
- Show the snippet from t/blocks/multi_sub.t (line 7 ~ line 50) -
</div>
</a>
<div ID="hide_9" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;S06/&quot;Longname parameters&quot;&gt;
#L&lt;S12/&quot;Multisubs and Multimethods&quot;&gt;

multi foo (Int $bar) &nbsp; { &quot;Int &quot; &nbsp;~ $bar &nbsp;}
multi foo (Str $bar) &nbsp; { &quot;Str &quot; &nbsp;~ $bar &nbsp;}
multi foo (Num $bar) &nbsp; { &quot;Num &quot; &nbsp;~ $bar &nbsp;}
multi foo (Rat $bar) &nbsp; { &quot;Rat &quot; &nbsp;~ $bar &nbsp;}
multi foo (Bool $bar) &nbsp;{ &quot;Bool &quot; ~ $bar &nbsp;}
multi foo (Rule $bar) &nbsp;{ &quot;Rule &quot; ~ ref( $bar ) } # since Rule's don't stringify
multi foo (Sub $bar) &nbsp; { &quot;Sub &quot; ~ $bar() }
multi foo (Array @bar) { &quot;Array &quot; ~ join(', ', @bar) }
multi foo (Hash %bar) &nbsp;{ &quot;Hash &quot; ~ join(', ', %bar.keys) }
multi foo (IO $fh) &nbsp; &nbsp; { &quot;IO&quot; }

is(foo('test'), 'Str test', 'dispatched to the Str sub');
is(foo(2), 'Int 2', 'dispatched to the Int sub');

my $num = '4';
is(foo(+$num), 'Num 4', 'dispatched to the Num sub');
is(foo(1.5), 'Rat 1.5', 'dispatched to the Rat sub');
is(foo(1 == 1), 'Bool 1', 'dispatched to the Bool sub');
is(foo(rx:P5/a/),'Rule Rule','dispatched to the Rule sub', :todo&lt;bug&gt;);
is(foo(sub { 'baz' }), 'Sub baz', 'dispatched to the Sub sub');

my @array = ('foo', 'bar', 'baz');
is(foo(@array), 'Array foo, bar, baz', 'dispatched to the Array sub');

my %hash = ('foo' =&gt; 1, 'bar' =&gt; 2, 'baz' =&gt; 3);
is(foo(%hash), 'Hash foo, bar, baz', 'dispatched to the Hash sub', :todo&lt;bug&gt;);

is(foo($*ERR), 'IO', 'dispatched to the IO sub');

eval_ok('multi sub foo( (Int, Str) $tuple: ) '
&nbsp; &nbsp; ~ '{ &quot;Tuple(2) &quot; ~ $tuple.join(&quot;,&quot;) }',
&nbsp; &nbsp; &quot;declare sub with tuple argument&quot;, :todo&lt;feature&gt;);

eval_ok('multi sub foo( (Int, Str, Str) $tuple: ) '
&nbsp; &nbsp; ~ '{ &quot;Tuple(3) &quot; ~ $tuple.join(&quot;,&quot;) }',
&nbsp; &nbsp; &quot;declare multi sub with tuple argument&quot;, :todo&lt;feature&gt;);

is(foo([3, &quot;Four&quot;]), &quot;Tuple(2) 3,Four&quot;, &quot;call tuple multi sub&quot;, :todo&lt;feature&gt;);
is(foo([3, &quot;Four&quot;, &quot;Five&quot;]), &quot;Tuple(3) 3,Four,Five&quot;, &quot;call tuple multi sub&quot;, :todo&lt;feature&gt;);

# You're allowed to omit the &quot;sub&quot; when declaring a multi sub.</pre>
</div>


<p>Much like ordinary methods give preference to the invocant, multimethods and multisubs can give preference to earlier parameters. These are called <i>longnames</i>; see S12 for more about the semantics of multiple dispatch. Syntactically, longnames are declared by terminating the list of important parameters with a semicolon:</p>

<pre>    multi sub handle_event ($window, $event; $mode) {...}
    multi method set_name ($self: $name; $nick) {...}</pre>

<p>If the parameter list for a <code>multi</code> contains no semicolon to delimit the list of important parameters, then all positional parameters are considered important. If it&#39;s a <code>multi method</code> or <code>multi submethod</code>, an additional implicit unnamed <code>self</code> invocant is added to the signature list unless the first parameter is explicitly marked with a colon.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Required_parameters"
>Required parameters</a></h2>

<p>Required parameters are specified at the start of a subroutine&#39;s parameter list:</p>

<pre>    sub numcmp ($x, $y) { return $x &#60;=&#62; $y }</pre>

<p>Required parameters may optionally be declared with a trailing <code>!</code>, though that&#39;s already the default for positional parameters:</p>

<a href="#" onclick="return tog_quote(21);">
<div ID="header_shown_21" style="display: none;">
- Hide the snippet from t/blocks/sub_named_params.t (line 77 ~ line 170) -
</div>
<div ID="header_hidden_21" style="display: block;">
- Show the snippet from t/blocks/sub_named_params.t (line 77 ~ line 170) -
</div>
</a>
<div ID="hide_21" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S06/&quot;Required parameters&quot; /declared with a trailing/&gt;
sub mandatory (:$param!) {
&nbsp; &nbsp; return $param;
}

is(mandatory(param =&gt; 5) , 5, &quot;named mandatory parameter is returned&quot;);
is(try { mandatory() }, undef, &quot;not specifying a mandatory parameter fails&quot;);

sub mandatory_by_trait (:$param is required) {
&nbsp; &nbsp; return $param;
}

is(mandatory_by_trait(param =&gt; 5) , 5, &quot;named mandatory parameter is returned&quot;);
is(try { mandatory_by_trait() }, undef, &quot;not specifying a mandatory parameter fails&quot;);


# From L&lt;S06/&quot;Named parameters&quot; /sub formalize/&gt;
sub formalize($text, :$case, :$justify) &nbsp;returns List {
&nbsp; return($text,$case,$justify); 
}

{
my ($text,$case,$justify) &nbsp;= formalize('title', case=&gt;'upper');
is($text,'title', &quot;text param was positional&quot;);
is($justify, undef, &quot;justification param was not given&quot;);
is($case, 'upper', &quot;case param was named, and in justification param's position&quot;);
}


{
my ($text,$case,$justify) &nbsp; = formalize('title', justify=&gt;'left');
is($text,'title', &quot;text param was positional&quot;);
is($justify, 'left', &quot;justify param was named&quot;);
is($case, undef, &quot;case was not given at all&quot;);
}

{
my &nbsp;($text,$case,$justify) = formalize(&quot;title&quot;, :justify&lt;right&gt;, :case&lt;title&gt;);

is($text,'title', &quot;title param was positional&quot;);
is($justify, 'right', &quot;justify param was named with funny syntax&quot;);
is($case, 'title', &quot;case param was named with funny syntax&quot;);
}

{
sub h($a,$b,$d) { $d ?? h($b,$a,$d-1) !! $a~$b }

is(h('a','b',1),'ba',&quot;parameters don\'t bind incorrectly&quot;);
}

# Slurpy Hash Params
{
sub slurpee(*%args) { return %args }
my %fellowship = slurpee(hobbit =&gt; 'Frodo', wizard =&gt; 'Gandalf');
is(%fellowship&lt;hobbit&gt;, 'Frodo', &quot;hobbit arg was slurped&quot;);
is(%fellowship&lt;wizard&gt;, 'Gandalf', &quot;wizard arg was slurped&quot;);
is(+%fellowship, 2, &quot;exactly 2 arguments were slurped&quot;);
is(%fellowship&lt;dwarf&gt;, undef, &quot;dwarf arg was not given&quot;);
}

{
&nbsp; if $*OS eq &quot;browser&quot; {
&nbsp; &nbsp; skip 5, &quot;skipping tests which infloop under PIL2JS&quot;;
&nbsp; } else {
&nbsp; &nbsp; sub named_and_slurp(:$grass, *%rest) { return($grass, %rest) }
&nbsp; &nbsp; my ($grass, %rest) = named_and_slurp(sky =&gt; 'blue', grass =&gt; 'green', fire =&gt; 'red');
&nbsp; &nbsp; is($grass, 'green', &quot;explicit named arg received despite slurpy hash&quot;);
&nbsp; &nbsp; is(+%rest, 2, &quot;exactly 2 arguments were slurped&quot;);
&nbsp; &nbsp; is(%rest&lt;sky&gt;, 'blue', &quot;sky argument was slurped&quot;);
&nbsp; &nbsp; is(%rest&lt;fire&gt;, 'red', &quot;fire argument was slurped&quot;);
&nbsp; &nbsp; is(%rest&lt;grass&gt;, undef, &quot;grass argument was NOT slurped&quot;);
&nbsp; }
}

{
my $ref;
sub setref($refin) {
&nbsp; &nbsp; $ref = $refin;
}
my $aref = [0];
setref(refin =&gt; $aref);
$aref[0]++;
is($aref[0], 1, &quot;aref actually implemented&quot;);
is($ref[0], 1, &quot;ref is the same as aref&quot;);
}

=kwid

= AUTHOR

Jesse Vincent &lt;jesse@bestpractical.com&gt;
Carl Masak &lt;cmasak@gmail.com&gt;

=cut</pre>
</div>


<pre>    sub numcmp ($x!, $y!) { return $x &#60;=&#62; $y }</pre>

<p>The corresponding arguments are evaluated in scalar context and may be passed positionally or by name. To pass an argument by name, specify it as a pair: <code><i>parameter_name</i> =&#62; <i>argument_value</i></code>.</p>

<pre>    $comparison = numcmp(2,7);
    $comparison = numcmp(x=&#62;2, y=&#62;7);
    $comparison = numcmp(y=&#62;7, x=&#62;2);</pre>

<p>Pairs may also be passed in adverbial pair notation:</p>

<pre>    $comparison = numcmp(:x(2), :y(7));
    $comparison = numcmp(:y(7), :x(2));</pre>

<p>Passing the wrong number of required arguments to a normal subroutine is a fatal error. Passing a named argument that cannot be bound to a normal subroutine is also a fatal error. (Methods are different.)</p>

<p>The number of required parameters a subroutine has can be determined by calling its <code>.arity</code> method:</p>

<a href="#" onclick="return tog_quote(20);">
<div ID="header_shown_20" style="display: none;">
- Hide the snippet from t/builtins/arity.t (line 7 ~ line 37) -
</div>
<div ID="header_hidden_20" style="display: block;">
- Show the snippet from t/builtins/arity.t (line 7 ~ line 37) -
</div>
</a>
<div ID="hide_20" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S06/&quot;Required parameters&quot; /method:/&gt;
{
&nbsp; &nbsp; my sub foo () {}
&nbsp; &nbsp; is &amp;foo.arity, 0;
}

{
&nbsp; &nbsp; my sub foo ($a) {}
&nbsp; &nbsp; is &amp;foo.arity, 1;
}

{
&nbsp; &nbsp; my sub foo ($a, $b) {}
&nbsp; &nbsp; is &amp;foo.arity, 2;
}

{
&nbsp; &nbsp; my sub foo ($a, $b, @c) {}
&nbsp; &nbsp; is &amp;foo.arity, 3;
}

{
&nbsp; &nbsp; my sub foo ($a, $b, @c, %d) {}
&nbsp; &nbsp; is &amp;foo.arity, 4;
}

# It's not really specced in what way (*@slurpy_params) should influence
# .arity. Also it's unclear what the result of &amp;multisub.arity is.
# See the thread &quot;&amp;multisub.arity?&quot; on p6l started by Ingo Blechschmidt for
# details:
# L&lt;<a href="http://thread.gmane.org/gmane.comp.lang.perl.perl6.language/4915">&quot;http://thread.gmane.org/gmane.comp.lang.perl.perl6.language/4915&quot;</a>&gt;</pre>
</div>


<pre>    $args_required = &#38;foo.arity;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Optional_parameters"
>Optional parameters</a></h2>

<p>Optional positional parameters are specified after all the required parameters and each is marked with a <code>?</code> after the parameter:</p>

<pre>    sub my_substr ($str, $from?, $len?) {...}</pre>

<p>Alternately, optional fields may be marked by supplying a default value. The <code>=</code> sign introduces a default value:</p>

<pre>    sub my_substr ($str, $from = 0, $len = Inf) {...}</pre>

<p>Default values can be calculated at run-time. They may even use the values of preceding parameters:</p>

<a href="#" onclick="return tog_quote(36);">
<div ID="header_shown_36" style="display: none;">
- Hide the snippet from t/blocks/defaults.t (line 8 ~ line 33) -
</div>
<div ID="header_hidden_36" style="display: block;">
- Show the snippet from t/blocks/defaults.t (line 8 ~ line 33) -
</div>
</a>
<div ID="hide_36" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S06/&quot;Optional parameters&quot; /Default values can be calculated at run-time/&gt;
=cut

plan 2;

sub doubler($x) { return 2 * $x }

sub value_v(Code :$func = &amp;doubler) {
&nbsp; &nbsp; return $func(5);
}

is(value_v, 10, &quot;default sub called&quot;);

package MyPack {

sub double($x) { return 2 * $x }

sub val_v(Code :$func = &amp;double) is export {
&nbsp; &nbsp; return $func(5);
}

}

use Test;

ok((MyPack::val_v), &quot;default sub called in package namespace&quot;);</pre>
</div>


<pre>    sub xml_tag ($tag, $endtag = matching_tag($tag) ) {...}</pre>

<p>Arguments that correspond to optional parameters are evaluated in scalar context. They can be omitted, passed positionally, or passed by name:</p>

<pre>    my_substr(&#34;foobar&#34;);            # $from is 0, $len is infinite
    my_substr(&#34;foobar&#34;,1);          # $from is 1, $len is infinite
    my_substr(&#34;foobar&#34;,1,3);        # $from is 1, $len is 3
    my_substr(&#34;foobar&#34;,len=&#62;3);     # $from is 0, $len is 3</pre>

<p>Missing optional arguments default to their default values, or to an undefined value if they have no default. (A supplied argument that is undefined is not considered to be missing, and hence does not trigger the default. Use <code>//=</code> within the body for that.)</p>

<a href="#" onclick="return tog_quote(35);">
<div ID="header_shown_35" style="display: none;">
- Hide the snippet from t/builtins/undef.t (line 261 ~ line 263) -
</div>
<div ID="header_hidden_35" style="display: block;">
- Show the snippet from t/builtins/undef.t (line 261 ~ line 263) -
</div>
</a>
<div ID="hide_35" style="display:none; border:1px solid">
<pre style="margin-left: 6px">&nbsp; &nbsp; &nbsp; &nbsp; # L&lt;&lt;S06/&quot;Optional parameters&quot; /Missing optional arguments/&gt;&gt;
&nbsp; &nbsp; &nbsp; &nbsp; ok(!defined($baz), &quot;unspecified optional param&quot;);</pre>
</div>


<p>(Conjectural: Within the body you may also use <code>exists</code> on the parameter name to determine whether it was passed. Maybe this will have to be restricted to the <code>?</code> form, unless we&#39;re willing to admit that a parameter could be simultaneously defined and non-existent.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Named_parameters"
>Named parameters</a></h2>

<p>Named-only parameters follow any required or optional parameters in the signature. They are marked by a prefix <code>:</code>:</p>

<pre>    sub formalize($text, :$case, :$justify) {...}</pre>

<p>This is actually shorthand for:</p>

<pre>    sub formalize($text, :case($case), :justify($justify)) {...}</pre>

<p>If the longhand form is used, the label name and variable name can be different:</p>

<pre>    sub formalize($text, :case($required_case), :justify($justification)) {...}</pre>

<p>so that you can use more descriptive internal parameter names without imposing inconveniently long external labels on named arguments.</p>

<p>Arguments that correspond to named parameters are evaluated in scalar context. They can only be passed by name, so it doesn&#39;t matter what order you pass them in, so long as they don&#39;t intermingle with any positional arguments:</p>

<pre>    $formal = formalize($title, case=&#62;&#39;upper&#39;);
    $formal = formalize($title, justify=&#62;&#39;left&#39;);
    $formal = formalize($title, :justify&#60;right&#62;, :case&#60;title&#62;);</pre>

<p>Named parameters are optional unless marked with a following <code>!</code>. Default values for optional named parameters are defined in the same way as for positional parameters, but may depend only on the values of parameters that have already been bound. (Note that binding happens in the call order, not declaration order.) Named optional parameters default to <code>undef</code> if they have no default. Named required parameters fail unless an argument pair of that name is supplied.</p>

<a href="#" onclick="return tog_quote(19);">
<div ID="header_shown_19" style="display: none;">
- Hide the snippet from t/builtins/undef.t (line 264 ~ line 272) -
</div>
<div ID="header_hidden_19" style="display: block;">
- Show the snippet from t/builtins/undef.t (line 264 ~ line 272) -
</div>
</a>
<div ID="hide_19" style="display:none; border:1px solid">
<pre style="margin-left: 6px">&nbsp; &nbsp; &nbsp; &nbsp; # L&lt;&lt;S06/&quot;Named parameters&quot; /Named parameters are optional/&gt;&gt;
&nbsp; &nbsp; &nbsp; &nbsp; ok(!defined($quux), &quot;unspecified optional param&quot;);
&nbsp; &nbsp; }

&nbsp; &nbsp; bar(&quot;BAR&quot;);

}

# autoloading</pre>
</div>


<p>Again, note the use of adverbial pairs in the argument list. See S02 for the correspondence between adverbial form and arrow notation.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="List_parameters"
>List parameters</a></h2>

<p>List parameters capture a variable length list of data. They&#39;re used in subroutines like <code>print</code>, where the number of arguments needs to be flexible. They&#39;re also called &#34;variadic parameters&#34;, because they take a <i>variable</i> number of arguments. But generally we call them &#34;slurpy&#34; parameters because they slurp up arguments.</p>

<p>Slurpy parameters follow any required or optional parameters. They are marked by a <code>*</code> before the parameter:</p>

<pre>    sub duplicate($n, *%flag, *@data) {...}</pre>

<p>Named arguments are bound to the slurpy hash (<code>*%flag</code> in the above example). Such arguments are evaluated in scalar context. Any remaining variadic arguments at the end of the argument list are bound to the slurpy array (<code>*@data</code> above) and are evaluated in list context.</p>

<p>For example:</p>

<pre>    duplicate(3, reverse =&#62; 1, collate =&#62; 0, 2, 3, 5, 7, 11, 14);
    duplicate(3, :reverse, :!collate, 2, 3, 5, 7, 11, 14);  # same

    # The @data parameter receives [2, 3, 5, 7, 11, 14]
    # The %flag parameter receives { reverse =&#62; 1, collate =&#62; 0 }</pre>

<p>Slurpy scalar parameters capture what would otherwise be the first elements of the variadic array:</p>

<a href="#" onclick="return tog_quote(26);">
<div ID="header_shown_26" style="display: none;">
- Hide the snippet from t/blocks/slurpy_param.t (line 133 ~ line 147) -
</div>
<div ID="header_hidden_26" style="display: block;">
- Show the snippet from t/blocks/slurpy_param.t (line 133 ~ line 147) -
</div>
</a>
<div ID="hide_26" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;&lt;S06/&quot;List parameters&quot; /Slurpy scalar parameters capture what would otherwise be the first elements of the variadic array:/&gt;&gt;

=cut

sub first(*$f, *$s, *@r){ return $f };
sub second(*$f, *$s, *@r){ return $s };
sub rest(*$f, *$s, *@r){ return @r.sum };
diag 'Testing with slurpy scalar';
is first(1, 2, 3, 4, 5), 1,
&nbsp; 'Testing the first slurpy scalar...';
is second(1, 2, 3, 4, 5), 2,
&nbsp; 'Testing the second slurpy scalar...';
is rest(1, 2, 3, 4, 5), 12,
&nbsp; 'Testing the rest slurpy *@r';</pre>
</div>


<pre>    sub head(*$head, *@tail)         { return $head }
    sub neck(*$head, *$neck, *@tail) { return $neck }
    sub tail(*$head, *@tail)         { return @tail }

    head(1, 2, 3, 4, 5);        # $head parameter receives 1
                                # @tail parameter receives [2, 3, 4, 5]

    neck(1, 2, 3, 4, 5);        # $head parameter receives 1
                                # $neck parameter receives 2
                                # @tail parameter receives [3, 4, 5]</pre>

<p>Slurpy scalars still impose list context on their arguments.</p>

<p>Slurpy parameters are treated lazily -- the list is only flattened into an array when individual elements are actually accessed:</p>

<pre>    @fromtwo = tail(1..Inf);        # @fromtwo contains a lazy [2..Inf]</pre>

<p>You can&#39;t bind to the name of a slurpy parameter: the name is just there so you can refer to it within the body.</p>

<pre>    sub foo(*%flag, *@data) {...}

    foo(:flag{ a =&#62; 1 }, :data[ 1, 2, 3 ]);
        # %flag has elements (flag =&#62; (a =&#62; 1)) and (data =&#62; [1,2,3])
        # @data has nothing</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Slurpy_block"
>Slurpy block</a></h2>

<p>It&#39;s also possible to declare a slurpy block: <code>*&#38;block</code>. It slurps up any nameless block, specified by <code>{...}</code>, at either the current positional location or the end of the syntactic list. Put it first if you want the option of putting a block either first or last in the arguments. Put it last if you want to force it to come in as the last argument.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Argument_list_binding"
>Argument list binding</a></h2>

<p>The underlying <code>Capture</code> object may be bound to a single scalar parameter marked with a <code>\</code>.</p>

<a href="#" onclick="return tog_quote(1);">
<div ID="header_shown_1" style="display: none;">
- Hide the snippet from t/data_types/capture.t (line 54 ~ line 107) -
</div>
<div ID="header_hidden_1" style="display: block;">
- Show the snippet from t/data_types/capture.t (line 54 ~ line 107) -
</div>
</a>
<div ID="hide_1" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S06/&quot;Argument list binding&quot; /single scalar parameter marked/&gt;
{
&nbsp; &nbsp; my sub bar ($a, $b, $c) { &quot;$a!$b!$c&quot; }
&nbsp; &nbsp; my sub foo (\$arglist) &nbsp;{ bar *$arglist }

&nbsp; &nbsp; is try { foo(1,2,3) }, &quot;1!2!3&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;arglist creation with \\$ works (1)&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; dies_ok { foo(1,2,3,4) }, &nbsp;# too many args
&nbsp; &nbsp; &nbsp; &nbsp; &quot;arglist creation with \\$ works (2)&quot;;
&nbsp; &nbsp; dies_ok { foo(1,2) }, &nbsp; &nbsp; &nbsp;# too few args
&nbsp; &nbsp; &nbsp; &nbsp; &quot;arglist creation with \\$ works (3)&quot;;
&nbsp; &nbsp; is try { foo(a =&gt; 1, b =&gt; 2, c =&gt; 3) }, &quot;1!2!3&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;arglist creation with \\$ works (4)&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; is try { foo(1, b =&gt; 2, c =&gt; 3) }, &quot;1!2!3&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;arglist creation with \\$ works (5)&quot;, :todo&lt;feature&gt;;
}

# Arglists are first-class objects
{
&nbsp; &nbsp; my $arglist;
&nbsp; &nbsp; my sub foo (\$args) { $arglist = $args }

&nbsp; &nbsp; lives_ok { foo(1,2,3,4) }, &quot;arglists are first-class objects (1)&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; ok $arglist, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;arglists are first-class objects (2)&quot;, :todo&lt;feature&gt;;

&nbsp; &nbsp; my $old_arglist = $arglist;
&nbsp; &nbsp; lives_ok { foo(5,6,7,8) }, &quot;arglists are first-class objects (3)&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; ok $arglist, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;arglists are first-class objects (4)&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; ok !($arglist === $old_arglist), &quot;arglists are first-class objects (5)&quot;, :todo&lt;feature&gt;;
}

{
&nbsp; &nbsp; my $arglist1;
&nbsp; &nbsp; my sub foo ($args) { $arglist1 = $args }

&nbsp; &nbsp; my $arglist2 = \(1,2,3);
&nbsp; &nbsp; try { foo $arglist2 }; &nbsp;# note: no *$args here

&nbsp; &nbsp; cmp_ok $arglist1, &amp;infix:&lt;===&gt;, $arglist2,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;unflattened arglists can be passed to subs&quot;;
}

# Mixing ordinary args with arglists
{
&nbsp; &nbsp; my $arglist = \(:foo&lt;bar&gt;, :baz&lt;grtz&gt;);
&nbsp; &nbsp; my sub foo ($a,$b, :$foo, :$baz) { &quot;$a!$b!$foo!$baz&quot; }

&nbsp; &nbsp; dies_ok { foo *$arglist }, &nbsp;# too few args
&nbsp; &nbsp; &nbsp; &nbsp; &quot;mixing ordinary args with arglists (1)&quot;;
&nbsp; &nbsp; is try { foo 1,2, *$arglist }, &quot;1!2!bar!grtz&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;mixing ordinary args with arglists (2)&quot;, :todo&lt;feature&gt;;
}

# XXX sub foo (\@arglist)</pre>
</div>


<pre>    sub bar ($a,$b,$c,:$mice) { say $mice }
    sub foo (\$args) { say $args.perl; &#38;bar.call($args); }</pre>

<p>The <code>.call</code> method of <code>Code</code> objects accepts a single <code>Capture</code> object, and calls it without introducing a <code>CALLER</code> frame.</p>

<pre>    foo 1,2,3,:mice&#60;blind&#62;;     # says &#34;\(1,2,3,:mice&#60;blind&#62;)&#34; then &#34;blind&#34;</pre>

<p>It is allowed to specify a return type:</p>

<pre>    sub foo (\$args --&#62; Num) { ... }</pre>

<p>Apart from that, no other parameters are allowed in the signature after the <code>Capture</code>. Parameters before the <code>Capture</code> either do not show up in the <code>Capture</code> or are marked as already bound somehow. In other words, parameters are bound normally up to the <code>Capture</code> parameter, and then <code>\$args</code> takes a snapshot of the remaining input without further attempts at binding.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Flattening_argument_lists"
>Flattening argument lists</a></h2>

<p>The reduce operator <code>[,]</code> casts each of its arguments to a <code>Capture</code> object, then splices each of those captures into the argument list it occurs in.</p>

<p>Casting <code>Capture</code> to <code>Capture</code> is a no-op:</p>

<pre>    [,](\(1, x=&#62;2));    # Capture, becomes \(1, x=&#62;2)</pre>

<p><code>Pair</code> and <code>Hash</code> become named arguments:</p>

<pre>    [,](x=&#62;1);          # Pair, becomes \(x=&#62;1)
    [,]{x=&#62;1, y=&#62;2};    # Hash, becomes \(x=&#62;1, y=&#62;2)</pre>

<p><code>List</code> (also <code>Seq</code>, <code>Range</code>, etc.) are simply turned into positional arguments:</p>

<pre>    [,](1,2,3);         # Seq, becomes \(1,2,3)
    [,](1..3);          # Range, becomes \(1,2,3)
    [,](1..2, 3);       # List, becomes \(1,2,3)
    [,]([x=&#62;1, x=&#62;2]);  # List (from an Array), becomes \((x=&#62;1), (x=&#62;2))</pre>

<p>For example:</p>

<pre>    sub foo($x, $y, $z) {...}    # expects three scalars
    @onetothree = 1..3;          # array stores three scalars

    foo(1,2,3);                  # okay:  three args found
    foo(@onetothree);            # error: only one arg
    foo([,]@onetothree);         # okay:  @onetothree flattened to three args</pre>

<p>The <code>[,]</code> operator flattens lazily -- the array is flattened only if flattening is actually required within the subroutine. To flatten before the list is even passed into the subroutine, use the <code>eager</code> list operator:</p>

<pre>    foo([,] eager @onetothree);          # array flattened before &#38;foo called</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Multidimensional_argument_list_binding"
>Multidimensional argument list binding</a></h2>

<a href="#" onclick="return tog_quote(13);">
<div ID="header_shown_13" style="display: none;">
- Hide the snippet from t/blocks/multidimensional_arglists.t (line 7 ~ line 41) -
</div>
<div ID="header_hidden_13" style="display: block;">
- Show the snippet from t/blocks/multidimensional_arglists.t (line 7 ~ line 41) -
</div>
</a>
<div ID="hide_13" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S06/&quot;Multidimensional argument list binding&quot;&gt;

sub get_multidim_arglist (*@;AoA) { @;AoA }

{
&nbsp; &nbsp; my @array1 = &lt;a b c&gt;;
&nbsp; &nbsp; my @array2 = &lt;d e f&gt;;

&nbsp; &nbsp; my @AoA = try { get_multidim_arglist(@array1, @array2) };
&nbsp; &nbsp; is +@AoA, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2, &quot;basic multidim arglist binding (1)&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; is ~@AoA[0], &quot;a b c&quot;, &quot;basic multidim arglist binding (2)&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; is ~@AoA[1], &quot;d e f&quot;, &quot;basic multidim arglist binding (3)&quot;, :todo&lt;feature&gt;;
}

{
&nbsp; &nbsp; my @array1 = &lt;a b c&gt;;

&nbsp; &nbsp; my @AoA = try { get_multidim_arglist(@array1) };
&nbsp; &nbsp; is +@AoA, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1, &quot;multidim arglist binding with only one array (1)&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; is ~@AoA[0], &quot;a b c&quot;, &quot;multidim arglist binding with only one array (2)&quot;, :todo&lt;feature&gt;;
}

{
&nbsp; &nbsp; dies_ok { get_multidim_arglist(1,2,3) },
&nbsp; &nbsp; &nbsp; &nbsp; &quot;three scalars are not compatible with a sub expecting a multidim arglist&quot;, :todo&lt;feature&gt;;
}

# Unspecced
{
&nbsp; &nbsp; my $array1 = &lt;a b c&gt;;
&nbsp; &nbsp; my $array2 = &lt;d e f&gt;;

&nbsp; &nbsp; dies_ok { get_multidim_arglist($array1, $array2) },
&nbsp; &nbsp; &nbsp; &nbsp; &quot;two arrayrefs are not compatible with a sub expecting a multidim arglist&quot;, :todo&lt;feature&gt;;
}</pre>
</div>


<p>Some functions take more than one list of positional and/or named arguments, that they wish not to be flattened into one list. For instance, <code>zip()</code> wants to iterate several lists in parallel, while array and hash subscripts want to process multidimensional slices. The set of underlying argument lists may be bound to a single array parameter declared with a double <code>@@</code> sigil:</p>

<pre>    sub foo (*@@slices) { ... }</pre>

<p>Note that this is different from</p>

<pre>    sub foo (\$slices) { ... }</pre>

<p>insofar as <code>\$slices</code> is bound to a single argument-list object that makes no commitment to processing its structure (and maybe doesn&#39;t even know its own structure yet), while <code>*@@slices</code> has to create an array that binds the incoming dimensional lists to the array&#39;s dimensions, and make that commitment visible to the rest of the scope via the sigil so that constructs expecting multidimensional lists know that multidimensionality is the intention.</p>

<p>It is allowed to specify a return type:</p>

<pre>    sub foo (*@@slices --&#62; Num) { ... }</pre>

<p>The invocant does not participate in multi-dimensional argument lists, so <code>self</code> is not present in the <code>@@slices</code> below:</p>

<pre>    method foo (*@@slices) { ... }</pre>

<p>The <code>@@</code> sigil is just a variant of the <code>@</code> sigil, so <code>@@slices</code> and <code>@slices</code> are really the same array. In particular, <code>@@_</code> is really the good old <code>@_</code> array viewed as multidimensional.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Zero-dimensional_argument_list"
>Zero-dimensional argument list</a></h2>

<p>If you call a function without parens and supply no arguments, the argument list becomes a zero-dimensional slice. It differs from <code>\()</code> in several ways:</p>

<pre>    sub foo (*@@slices) {...}
    foo;        # +@@slices == 0
    foo();      # +@@slices == 1

    sub bar (\$args = \(1,2,3)) {...}
    bar;        # $args === \(1,2,3)
    bar();      # $args === \()</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Feed_operators"
>Feed operators</a></h2>

<a href="#" onclick="return tog_quote(8);">
<div ID="header_shown_8" style="display: none;">
- Hide the snippet from t/operators/feed.t (line 11 ~ line 57) -
</div>
<div ID="header_hidden_8" style="display: block;">
- Show the snippet from t/operators/feed.t (line 11 ~ line 57) -
</div>
</a>
<div ID="hide_8" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S06/&quot;Feed operators&quot;&gt;
L&lt;S03/&quot;Feed operators&quot;&gt;

=cut

plan 7;

{
&nbsp; &nbsp; my @a = (1, 2);
&nbsp; &nbsp; my (@b, @c);
&nbsp; &nbsp; 
&nbsp; &nbsp; eval '@a ==&gt; @b';
&nbsp; &nbsp; #eval '@c &lt;== @a'; # this yields the error:
&nbsp; &nbsp; #Fail: cannot cast into a handle: VList [VInt 1,VInt 2]

&nbsp; &nbsp; is(~@b, ~@a, &quot;ltr feed as simple assignment&quot;, :todo);
&nbsp; &nbsp; is(~@c, ~@a, &quot;rtl feed as simple assignment&quot;, :todo);
};

{
&nbsp; &nbsp; my @a = (1 .. 5);
&nbsp; &nbsp; my @e = (2, 4);

&nbsp; &nbsp; my (@b, @c);
&nbsp; &nbsp; eval '@a ==&gt; grep { ($_ % 2) == 0 } ==&gt; @b';
&nbsp; &nbsp; #eval '@c &lt;== grep { ($_ % 2) == 0 } &lt;== @a';

&nbsp; &nbsp; is(~@b, ~@e, &quot;array ==&gt; grep ==&gt; result&quot;, :todo);
&nbsp; &nbsp; is(~@c, ~@e, &quot;result &lt;== grep &lt;== array&quot;, :todo);
};

{
&nbsp; &nbsp; my ($got_x, $got_y, @got_z);
&nbsp; &nbsp; sub foo ($x, $y?, *@z) {
&nbsp; &nbsp; &nbsp; &nbsp; $got_x = $x;
&nbsp; &nbsp; &nbsp; &nbsp; $got_y = $y;
&nbsp; &nbsp; &nbsp; &nbsp; @got_z = @z;
&nbsp; &nbsp; }

&nbsp; &nbsp; my @a = (1 .. 5);

&nbsp; &nbsp; eval '@a ==&gt; foo &quot;x&quot;';

&nbsp; &nbsp; is($got_x, &quot;x&quot;, &quot;x was passed as explicit param&quot;, :todo);
&nbsp; &nbsp; is($got_y, undef, &quot;optional param y was not bound to fed list&quot;);
&nbsp; &nbsp; is(~@got_z, ~@a, '...slurpy array *@z got it', :todo);
};</pre>
</div>


<p>The variadic list of a subroutine call can be passed in separately from the normal argument list, by using either of the <i>feed</i> operators: <code>&#60;==</code> or <code>==&#62;</code>.</p>

<p>Each operator expects to find a call to a variadic receiver on its &#34;sharp&#34; end, and a list of values on its &#34;blunt&#34; end:</p>

<pre>    grep { $_ % 2 } &#60;== @data;

    @data ==&#62; grep { $_ % 2 };</pre>

<p>It binds the (potentially lazy) list from the blunt end to the slurpy parameter(s) of the receiver on the sharp end. In the case of a receiver that is a variadic function, the feed is received as part of its slurpy list. So both of the calls above are equivalent to:</p>

<pre>    grep { $_ % 2 }, @data;</pre>

<p>Note that all such feeds (and indeed all lazy argument lists) supply an implicit promise that the code producing the lists may execute in parallel with the code receiving the lists. (Feeds, hyperops, and junctions all have this promise of parallelizability in common, but differ in interface. Code which violates these promises is erroneous, and will produce undefined results when parallelized.)</p>

<p>In particular, a chain of feeds may not begin and end with the same array. (You may, however, assign to an array that is used within a chain on the right side of the assignment, since list assignment will clear and copy as necessary to make it work.) That is, this doesn&#39;t work:</p>

<pre>    @data &#60;== grep { $_ % 2 } &#60;== @data;</pre>

<p>but this does:</p>

<pre>    @data = grep { $_ % 2 } &#60;== @data;</pre>

<p>Leftward feeds are a convenient way of explicitly indicating the typical right-to-left flow of data through a chain of operations:</p>

<pre>    @oddsquares = map { $_**2 }, sort grep { $_ % 2 }, @nums;

    # more clearly written as...

    @oddsquares = map { $_**2 } &#60;== sort &#60;== grep { $_ % 2 } &#60;== @nums;</pre>

<p>Rightward feeds are a convenient way of reversing the normal data flow in a chain of operations, to make it read left-to-right:</p>

<pre>    @oddsquares =
            (@nums ==&#62; grep { $_ % 2 } ==&#62; sort ==&#62; map { $_**2 });</pre>

<p>Note that the parens are necessary there due to precedence.</p>

<p>If the operand on the sharp end of a feed is not a call to a variadic operation, it must be something else that can be interpreted as a list receiver.</p>

<p>Any list operator is considered a variadic operation, so ordinarily a list operator adds any feed input to the end of its list. But sometimes you want to interpolate elsewhere, so the <code>***</code> term may be used to indicate the target of a feed without the use of a temporary array:</p>

<pre>    foo() ==&#62; say ***, &#34; is what I meant&#34;;
    bar() ==&#62; ***.baz();</pre>

<p>Feeding into the <code>*</code> &#34;whatever&#34; term will extend the lexically following <code>***</code> term:</p>

<pre>    0..*       ==&#62; *;
    &#39;a&#39;..*     ==&#62; *;
    pidigits() ==&#62; *;

    # outputs &#34;(0, &#39;a&#39;, 3)\n&#34;...
    for zip(***) { .perl.say }</pre>

<p>You may use a variable (or variable declaration) as a receiver, in which case the list value is bound as the &#34;todo&#34; of the variable. Do not think of it as an assignment, nor as an ordinary binding. Think of it as iterator creation. In the case of a scalar variable, that variable contains the newly created iterator itself. In the case of an array, the new iterator is installed as the method for extending the array. Unlike with assignment, no clobbering of the array is implied. It&#39;s therefore more like a push than an assignment.</p>

<p>In general you can simply think of a receiver array as representing the results of the chain, so you can equivalently write any of:</p>

<pre>    my @oddsquares &#60;== map { $_**2 } &#60;== sort &#60;== grep { $_ % 2 } &#60;== @nums;

    my @oddsquares
        &#60;== map { $_**2 }
        &#60;== sort
        &#60;== grep { $_ % 2 }
        &#60;== @nums;

    @nums ==&#62; grep { $_ % 2 } ==&#62; sort ==&#62; map { $_**2 } ==&#62; my @oddsquares;

    @nums
    ==&#62; grep { $_ % 2 }
    ==&#62; sort
    ==&#62; map { $_**2 }
    ==&#62; my @oddsquares;</pre>

<p>Since the feed iterator is bound into the final variable, the variable can be just as lazy as the feed that is producing the values.</p>

<p>Because feeds are bound to arrays with &#34;push&#34; semantics, you can have a receiver for multiple feeds:</p>

<pre>    my @foo;
    0..2       ==&#62; @foo;
    &#39;a&#39;..&#39;c&#39;   ==&#62; @foo;
    say @foo;   # 0,1,2,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;</pre>

<p>Note how the feeds are concatenated in <code>@foo</code> so that <code>@foo</code> is a list of 6 elements. This is the default behavior. However, sometimes you want to capture the outputs as a list of two iterators, namely the two iterators that represent the two input feeds. You can get at those two iterators by using the name <code>@@foo</code> instead, where the &#34;feed&#34; twigil marks a multidimensional array, that is, an array of slices.</p>

<pre>    0..*       ==&#62; @@foo;
    &#39;a&#39;..*     ==&#62; @@foo;
    pidigits() ==&#62; @@foo;

    for zip(@@foo) { say }

        [0,&#39;a&#39;,3]
        [1,&#39;b&#39;,1]
        [2,&#39;c&#39;,4]
        [3,&#39;d&#39;,1]
        [4,&#39;e&#39;,5]
        [5,&#39;f&#39;,9]
        ...</pre>

<p>Here <code>@@foo</code> is an array of three iterators, so</p>

<pre>    zip(@@foo)</pre>

<p>is equivalent to</p>

<pre>    zip(@@foo[0]; @@foo[1]; @@foo[2])</pre>

<p>A semicolon inside brackets is equivalent to stacked feeds. The code above could be rewritten as:</p>

<pre>    (0..*; &#39;a&#39;..*; pidigits()) ==&#62; my @@foo;
    for @@foo.zip { say }</pre>

<p>which is in turn equivalent to</p>

<pre>    for zip(0..*; &#39;a&#39;..*; pidigits()) { say }</pre>

<p>A named receiver array is useful when you wish to feed into an expression that is not an ordinary list operator, and you wish to be clear where the feed&#39;s destination is supposed to be:</p>

<pre>    picklist() ==&#62; my @baz;
    my @foo = @bar[@baz];</pre>

<p>Various contexts may or may not be expecting multi-dimensional slices or feeds. By default, ordinary arrays are flattened, that is, they have &#34;cat&#34; semantics. If you say</p>

<pre>    (0..2; &#39;a&#39;..&#39;c&#39;) ==&#62; my @tmp;
    for @tmp { say }</pre>

<p>then you get 0,1,2,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;. If you have a multidim array, you can ask for cat semantics explicitly with cat():</p>

<pre>    (0..2; &#39;a&#39;..&#39;c&#39;) ==&#62; my @@tmp;
    for @@tmp.cat { say }</pre>

<p>As we saw earlier, &#34;zip&#34; produces little arrays by taking one element from each list in turn, so</p>

<pre>    (0..2; &#39;a&#39;..&#39;c&#39;) ==&#62; my @@tmp;
    for @@tmp.zip { say }</pre>

<p>produces [0,&#39;a&#39;],[1,&#39;b&#39;],[2,&#39;c&#39;]. If you don&#39;t want the subarrays, then use <code>each()</code> instead:</p>

<pre>    (0..2; &#39;a&#39;..&#39;c&#39;) ==&#62; my @@tmp;
    for @@tmp.each { say }</pre>

<p>and then you just get 0,&#39;a&#39;,1,&#39;b&#39;,2,&#39;c&#39;. This is good for</p>

<pre>    for @@tmp.each -&#62; $i, $a { say &#34;$i: $a&#34; }</pre>

<p>In list context the <code>@@foo</code> notation is really a shorthand for <code>[;](@@foo)</code>. In particular, you can use <code>@@foo</code> to interpolate a multidimensional slice in an array or hash subscript.</p>

<p>If <code>@@foo</code> is currently empty, then <code>for zip(@@foo) {...}</code> acts on a zero-dimensional slice (i.e. <code>for (zip) {...}</code>), and outputs nothing at all.</p>

<p>Note that with the current definition, the order of feeds is preserved left to right in general regardless of the position of the receiver.</p>

<p>So</p>

<pre>    (&#39;a&#39;..*; 0..*) ==&#62; *;
     for zip(*** &#60;== @foo) -&#62; [$a, $i, $x] { ... }</pre>

<p>is the same as</p>

<pre>    &#39;a&#39;..* ==&#62; *;
     0..*  ==&#62; *;
     for zip(*** &#60;== @foo) -&#62; [$a, $i, $x] { ... }</pre>

<p>which is the same as</p>

<pre>    for zip(&#39;a&#39;..*; 0..*; @foo) -&#62; [$a, $i, $x] { ... }</pre>

<p>Likewise,</p>

<pre>    @foo ==&#62; *;
    0..* ==&#62; *;
    for each(***) -&#62; $x, $i { ... }</pre>

<p>is the same as</p>

<pre>    0..* ==&#62; *;
    for each(@foo; ***) -&#62; $x, $i { ... }</pre>

<p>and also</p>

<pre>    for each(@foo; 0..*) -&#62; $x, $i { ... }</pre>

<p>Note that the <code>each</code> method is also sensitive to multislicing, so you could also just write that as:</p>

<pre>    (@foo; 0..*).each: -&#62; $x, $i { ... }</pre>

<p>Also note that these come out to be identical for ordinary arrays:</p>

<pre>    @foo.each
    @foo.cat</pre>

<p>The <code>@@($foo)</code> coercer can be used to pull a multidim out of some object that contains one, such as a <code>Capture</code> or <code>Match</code> object. Like <code>@()</code>, <code>@@()</code> defaults to <code>@@($/)</code>, and returns a multidimensional view of any match that repeatedly applies itself with <code>:g</code> and the like. In contrast, <code>@()</code> would flatten those into one list.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Closure_parameters"
>Closure parameters</a></h2>

<p>Parameters declared with the <code>&#38;</code> sigil take blocks, closures, or subroutines as their arguments. Closure parameters can be required, optional, named, or slurpy.</p>

<pre>    sub limited_grep (Int $count, &#38;block, *@list) {...}

    # and later...

    @first_three = limited_grep 3, {$_&#60;10}, @data;</pre>

<p>(The comma is required after the closure.)</p>

<p>Within the subroutine, the closure parameter can be used like any other lexically scoped subroutine:</p>

<pre>    sub limited_grep (Int $count, &#38;block, *@list) {
        ...
        if block($nextelem) {...}
        ...
    }</pre>

<p>The closure parameter can have its own signature in a type specification written with <code>:(...)</code>:</p>

<pre>    sub limited_Dog_grep ($count, &#38;block:(Dog), Dog *@list) {...}</pre>

<p>and even a return type:</p>

<pre>    sub limited_Dog_grep ($count, &#38;block:(Dog --&#62; Bool), Dog *@list) {...}</pre>

<p>When an argument is passed to a closure parameter that has this kind of signature, the argument must be a <code>Code</code> object with a compatible parameter list and return type.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Type_parameters"
>Type parameters</a></h2>

<p>Unlike normal parameters, type parameters often come in piggybacked on the actual value as &#34;kind&#34;, and you&#39;d like a way to capture both the value and its kind at once. (A &#34;kind&#34; is a class or type that an object is allowed to be. An object is not officially allowed to take on a constrained or contravariant type.) A type variable can be used anywhere a type name can, but instead of asserting that the value must conform to a particular type, it captures the actual &#34;kind&#34; of the object and also declares a package/type name by which you can refer to that kind later in the signature or body. For instance, if you wanted to match any two Dogs as long as they were of the same kind, you can say:</p>

<pre>    sub matchedset (Dog ::T $fido, T $spot) {...}</pre>

<p>(Note that <code>::T</code> is not required to contain <code>Dog</code>, only a type that is compatible with <code>Dog</code>.)</p>

<p>The <code>::</code> sigil is short for &#34;subset&#34; in much the same way that <code>&#38;</code> is short for &#34;sub&#34;. Just as <code>&#38;</code> can be used to name any kind of code, so too <code>::</code> can be used to name any kind of type. Both of them insert a bare identifier into the symbol table, though they fill different syntactic spots.</p>

<p>Note that it is not required to capture the object associated with the class unless you want it. The sub above could be written as</p>

<pre>    sub matchedset (Dog ::T, T) {...}</pre>

<p>if we&#39;re not interested in <code>$fido</code> or <code>$spot</code>. Or just</p>

<pre>    sub matchedset (::T, T) {...}</pre>

<p>if we don&#39;t care about anything but the matching.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Unpacking_array_parameters"
>Unpacking array parameters</a></h2>

<a href="#" onclick="return tog_quote(12);">
<div ID="header_shown_12" style="display: none;">
- Hide the snippet from t/blocks/subroutine.t (line 80 ~ line 98) -
</div>
<div ID="header_hidden_12" style="display: block;">
- Show the snippet from t/blocks/subroutine.t (line 80 ~ line 98) -
</div>
</a>
<div ID="hide_12" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S06/&quot;Unpacking array parameters&quot;&gt;

=cut

sub argShifter (@a is rw) {
&nbsp; &nbsp; my $first := shift @a;
&nbsp; &nbsp; return $first;
}

is argShifter([1]), 1, &nbsp; &nbsp;&quot;use shift on an array argument&quot;;
is argShifter([3..5]), 3, &quot;use shift on multiple array arguments&quot;;

eval 'sub unpack_array ([$first, *@rest]) { return $first; }';

my @array = 3..7;
is(try { unpack_array(@array) }, 3, 'unpacking an array parameter', :todo&lt;feature&gt;);

=pod</pre>
</div>


<p>Instead of specifying an array parameter as an array:</p>

<pre>    sub quicksort (@data, $reverse?, $inplace?) {
        my $pivot := shift @data;
        ...
    }</pre>

<p>it may be broken up into components in the signature, by specifying the parameter as if it were an anonymous array of parameters:</p>

<pre>    sub quicksort ([$pivot, *@data], $reverse?, $inplace?) {
        ...
    }</pre>

<p>This subroutine still expects an array as its first argument, just like the first version.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Unpacking_a_single_list_argument"
>Unpacking a single list argument</a></h2>

<p>To match the first element of the slurpy list, use a &#34;slurpy&#34; scalar:</p>

<pre>    sub quicksort (:$reverse, :$inplace, *$pivot, *@data)</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Unpacking_hash_parameters"
>Unpacking hash parameters</a></h2>

<a href="#" onclick="return tog_quote(34);">
<div ID="header_shown_34" style="display: none;">
- Hide the snippet from t/blocks/subroutine.t (line 99 ~ line 106) -
</div>
<div ID="header_hidden_34" style="display: block;">
- Show the snippet from t/blocks/subroutine.t (line 99 ~ line 106) -
</div>
</a>
<div ID="hide_34" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S06/&quot;Unpacking hash parameters&quot;&gt;

=cut

eval 'sub unpack_hash({:$yo, *%other}){ return $yo; }';

my %params = yo =&gt; 3, nope =&gt; 4;
is(try { unpack_hash(%params) }, 3, 'unpacking a hash parameter', :todo);</pre>
</div>


<p>Likewise, a hash argument can be mapped to a hash of parameters, specified as named parameters within curlies. Instead of saying:</p>

<pre>    sub register (%guest_data, $room_num) {
        my $name := delete %guest_data&#60;name&#62;;
        my $addr := delete %guest_data&#60;addr&#62;;
        ...
    }</pre>

<p>you can get the same effect with:</p>

<pre>    sub register ({:$name, :$addr, *%guest_data}, $room_num) {
        ...
    }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Unpacking_tree_node_parameters"
>Unpacking tree node parameters</a></h2>

<p>You can unpack tree nodes in various dwimmy ways by enclosing the bindings of child nodes and attributes in parentheses following the declaration of the node itself:</p>

<pre>    sub traverse ( BinTree $top ( $left, $right ) ) {
        traverse($left);
        traverse($right);
    }</pre>

<p>In this, <code>$left</code> and <code>$right</code> are automatically bound to the left and right nodes of the tree. If $top is an ordinary object, it binds the <code>$top.left</code> and <code>$top.right</code> attributes. If it&#39;s a hash, it binds <code>$top&#60;left&#62;</code> and <code>$top&#60;right&#62;</code>. If <code>BinTree</code> is a signature type and $top is a List (argument list) object, the child types of the signature are applied to the actual arguments in the argument list object. (Signature types have the benefit that you can view them inside-out as constructors with positional arguments, such that the transformations can be reversible.)</p>

<p>However, the full power of signatures can be applied to pattern match just about any argument or set of arguments, even though in some cases the reverse transformation is not derivable. For instance, to bind to an array of children named <code>.kids</code> or <code>.&#60;kids&#62;</code>, use something like:</p>

<pre>    sub traverse ( NAry $top ( :kids [$eldest, *@siblings] ) ) {
        traverse($eldest);
        traverse(@siblings);
    }</pre>

<p>Likewise, to bind to a hash element of the node and then bind to keys in that hash by name:</p>

<pre>    sub traverse ( AttrNode $top ( :%attr{ :$vocalic, :$tense } ) {
        say &#34;Has {+%attr} attributes, of which&#34;;
        say &#34;vocalic = $vocalic&#34;;
        say &#34;tense = $tense&#34;;
    }</pre>

<p>You may omit the top variable if you prefix the parentheses with a colon to indicate a signature. Otherwise you must at least put the sigil of the variable, or we can&#39;t correctly differentiate:</p>

<pre>    my Dog ($fido, $spot)   := twodogs();       # list of two dogs
    my Dog $ ($fido, $spot) := twodogs();       # one twodog object
    my Dog :($fido, $spot)  := twodogs();       # one twodog object</pre>

<p>Sub signatures can be matched directly within regexes by using <code>:(...)</code> notation.</p>

<pre>    push @a, &#34;foo&#34;;
    push @a, \(1,2,3);
    push @a, &#34;bar&#34;;
    ...
    my ($i, $j, $k);
    @a ~~ rx/
            &#60;,&#62;                         # match initial elem boundary
            :(Int $i,Int $j,Int? $k)    # match lists with 2 or 3 ints
            &#60;,&#62;                         # match final elem boundary
          /;
    say &#34;i = $&#60;i&#62;&#34;;
    say &#34;j = $&#60;j&#62;&#34;;
    say &#34;k = $&#60;k&#62;&#34; if defined $&#60;k&#62;;</pre>

<p>If you want a parameter bound into <code>$/</code>, you have to say <code>$&#60;i&#62;</code> within the signature. Otherwise it will try to bind an external <code>$i</code> instead, and fail if no such variable is declared.</p>

<p>Note that unlike a sub declaration, a regex-embedded signature has no associated &#34;returns&#34; syntactic slot, so you have to use <code>--&#62;</code> within the signature to specify the <code>of</code> type of the signature, or match as an arglist:</p>

<pre>    :(Num, Num --&#62; Coord)
    :(\Coord(Num, Num))</pre>

<p>A consequence of the latter form is that you can match the type of an object with <code>:(\Dog)</code> without actually breaking it into its components. Note, however, that it&#39;s not equivalent to say</p>

<pre>    :(--&#62; Dog)</pre>

<p>which would be equivalent to</p>

<pre>    :(\Dog())</pre>

<p>that is, match a nullary function of type <code>Dog</code>. Nor is it equivalent to</p>

<pre>    :(Dog)</pre>

<p>which would be equivalent to</p>

<pre>    :(\Any(Dog))</pre>

<p>and match a function taking a single parameter of type Dog.</p>

<p>Note also that bare <code>\(1,2,3)</code> is never legal in a regex since the first (escaped) paren would try to match literally.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Attributive_parameters"
>Attributive parameters</a></h2>

<p>If a submethod&#39;s parameter is declared with a <code>.</code> or <code>!</code> after the sigil (like an attribute):</p>

<pre>    submethod initialize($.name, $!age) {}</pre>

<p>then the argument is assigned directly to the object&#39;s attribute of the same name. This avoids the frequent need to write code like:</p>

<pre>    submethod initialize($name, $age) {
        $.name = $name;
        $!age  = $age;
    }</pre>

<p>To rename an attribute parameter you can use the explicit pair form:</p>

<pre>    submethod initialize(:moniker($.name), :youth($!age)) {}</pre>

<p>The <code>:$name</code> shortcut may be combined with the <code>$.name</code> shortcut, but the twigil is ignored for the parameter name, so</p>

<pre>    submethod initialize(:$.name, :$!age) {}</pre>

<p>is the same as:</p>

<pre>    submethod initialize(:name($.name), :age($!age)) {}</pre>

<p>Note that <code>$!age</code> actually refers to the private &#34;<code>has</code>&#34; variable that can be referred to as either <code>$age</code> or <code>$!age</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Placeholder_variables"
>Placeholder variables</a></h2>

<a href="#" onclick="return tog_quote(2);">
<div ID="header_shown_2" style="display: none;">
- Hide the snippet from t/builtins/ref.t (line 47 ~ line 76) -
</div>
<div ID="header_hidden_2" style="display: block;">
- Show the snippet from t/builtins/ref.t (line 47 ~ line 76) -
</div>
</a>
<div ID="hide_2" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S06/&quot;Placeholder variables&quot;&gt;
my $s2a = { $^a };
isa_ok($s2a, 'Block', 'it is a Parametric type (bare block with placeholder parameters)');

my $s3 = -&gt; {};
isa_ok($s3, 'Block', 'it is a Block type (pointy block)');

# ref() on different types of scalars

my $int = 0;
isa_ok($int, 'Int', 'it is an Int type');

# the only way I can seem to get Num is to force numeric context
my $num = '';
isa_ok(+$num, 'Num', 'it is an Num type');

my $float = 0.5;
isa_ok($float, 'Rat', 'it is an Rat type');

my $string = &quot;Hello World&quot;;
isa_ok($string, 'Str', 'it is a Str type');

my $bool = (0 == 0);
isa_ok($bool, 'Bool', 'it is a Bool type');

my $pair = (&quot;foo&quot; =&gt; &quot;bar&quot;);
isa_ok($pair, 'Pair', 'it is a Pair type');

my $rule = rx:perl5{^hello\sworld$};
isa_ok($rule, 'Pugs::Internals::VRule', 'it is a Rule type');</pre>
</div>


<p>Even though every bare block is a closure, bare blocks can&#39;t have explicit parameter lists. Instead, they use &#34;placeholder&#34; variables, marked by a caret (<code>^</code>) after their sigils.</p>

<p>Using placeholders in a block defines an implicit parameter list. The signature is the list of distinct placeholder names, sorted in Unicode order. So:</p>

<pre>    { $^y &#60; $^z &#38;&#38; $^x != 2 }</pre>

<p>is a shorthand for:</p>

<pre>    -&#62; $x,$y,$z { $y &#60; $z &#38;&#38; $x != 2 }</pre>

<p>Note that placeholder variables syntactically cannot have type constraints. Also, it is illegal to use placeholder variables in a block that already has a signature, because the autogenerated signature would conflict with that.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Built-in_Types"
>Built-in Types</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Native_types"
>Native types</a></h2>

<p>[This stuff belongs in S02.]</p>

<p>Values with these types autobox to their uppercase counterparts when you treat them as objects:</p>

<pre>    bit         single native bit
    int         native signed integer
    uint        native unsigned integer (autoboxes to Int)
    buf         native buffer (finite seq of native ints or uints, no Unicode)
    num         native floating point
    complex     native complex number
    bool        native boolean</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Undefined_types"
>Undefined types</a></h2>

<p>These can behave as values or objects of any class, except that <code>defined</code> always returns false. One can create them with the built-in <code>undef</code> and <code>fail</code> functions. (See S02 for how failures are handled.)</p>

<pre>    Undef       Undefined (can serve as a prototype object of any class)
    Whatever    Wildcard (like undef, but subject to do-what-I-mean via MMD)
    Failure     Failure (throws an exception if not handled properly)</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Immutable_types"
>Immutable types</a></h2>

<p>Objects with these types behave like values, i.e. <code>$x === $y</code> is true if and only if their types and contents are identical (that is, if <code>$x.SKID</code> eqv <code>$y.SKID</code>).</p>

<pre>    Bit         Perl single bit (allows traits, aliasing, undef, etc.)
    Int         Perl integer (allows Inf/NaN, arbitrary precision, etc.)
    Str         Perl string (finite sequence of Unicode characters)
    Num         Perl number
    Complex     Perl complex number
    Bool        Perl boolean
    Exception   Perl exception
    Code        Base class for all executable objects
    Block       Executable objects that have lexical scopes
    List        Lazy Perl list (composed of Seq and Range parts)
    Seq         Completely evaluated (hence immutable) sequence
    Range       Incrementally generated (hence lazy) sequence
    Set         Unordered Seqs that allow no duplicates
    Junction    Sets with additional behaviours
    Pair        Seq of two elements that serves as a one-element Mapping</pre>

<a href="#" onclick="return tog_quote(4);">
<div ID="header_shown_4" style="display: none;">
- Hide the snippet from t/data_types/pair.t (line 87 ~ line 303) -
</div>
<div ID="header_hidden_4" style="display: block;">
- Show the snippet from t/data_types/pair.t (line 87 ~ line 303) -
</div>
</a>
<div ID="hide_4" style="display:none; border:1px solid">
<pre style="margin-left: 6px">&nbsp; &nbsp; # L&lt;S06/Immutable types/Pair &quot;one-element Mapping&quot;&gt;
&nbsp; &nbsp; my $pair = :when&lt;now&gt;;
&nbsp; &nbsp; is ~(%$pair), &quot;when\tnow&quot;;
&nbsp; &nbsp; # hold back this one according to audreyt
&nbsp; &nbsp; #ok $pair.does(Hash), 'Pair does Hash';
&nbsp; &nbsp; ok (%$pair).does(Hash), '%() makes Pair to does Hash';
}

# lvalue Pair assignments from S06 and thread starting with
# L&lt;<a href="http://www.nntp.perl.org/group/perl.perl6.language/19425">&quot;http://www.nntp.perl.org/group/perl.perl6.language/19425&quot;</a>&gt;

my $val;
(&quot;foo&quot; =&gt; $val) = &quot;baz&quot;;
is($val, &quot;baz&quot;, &quot;lvalue pairs&quot;);

# illustrate a bug

my $var &nbsp; = 'foo' =&gt; 'bar';
sub test1 (Any|Pair $pair) {
&nbsp; &nbsp; isa_ok($pair,'Pair');
&nbsp; &nbsp; my $testpair = $pair;
&nbsp; &nbsp; isa_ok($testpair,'Pair'); # new lvalue variable is also a Pair
&nbsp; &nbsp; my $boundpair := $pair;
&nbsp; &nbsp; isa_ok($boundpair,'Pair'); # bound variable is also a Pair
&nbsp; &nbsp; is($pair.key, 'foo', 'in sub test1 got the right $pair.key');
&nbsp; &nbsp; is($pair.value, 'bar', 'in sub test1 got the right $pair.value');

}
test1 $var;

my %hash &nbsp;= ('foo' =&gt; 'bar');
for &nbsp;%hash.pairs -&gt; $pair {
&nbsp; &nbsp; isa_ok($pair,'Pair') ; 
&nbsp; &nbsp; my $testpair = $pair;
&nbsp; &nbsp; isa_ok($testpair, 'Pair', :todo&lt;bug&gt;); # new lvalue variable is also a Pair
&nbsp; &nbsp; my $boundpair := $pair;
&nbsp; &nbsp; isa_ok($boundpair,'Pair'); # bound variable is also a Pair
&nbsp; &nbsp; is($pair.key, 'foo', 'in for loop got the right $pair.key');
&nbsp; &nbsp; is($pair.value, 'bar', 'in for loop got the right $pair.value');
}

sub test2 (Hash %h){
&nbsp; &nbsp; for %h.pairs -&gt; $pair {
&nbsp; &nbsp; &nbsp; &nbsp; isa_ok($pair,'Pair') ; 
&nbsp; &nbsp; &nbsp; &nbsp; is($pair.key, 'foo', 'in sub test2 got the right $pair.key');
&nbsp; &nbsp; &nbsp; &nbsp; is($pair.value, 'bar', 'in sub test2 got the right $pair.value');
&nbsp; &nbsp; }
}
test2 %hash;

# See thread &quot;$pair[0]&quot; on p6l started by Ingo Blechschmidt:
# L&lt;<a href="http://www.nntp.perl.org/group/perl.perl6.language/22593">&quot;http://www.nntp.perl.org/group/perl.perl6.language/22593&quot;</a>&gt;

sub test3 (Hash %h){
&nbsp; &nbsp; for %h.pairs -&gt; $pair {
&nbsp; &nbsp; &nbsp; &nbsp; isa_ok($pair,'Pair');
&nbsp; &nbsp; &nbsp; &nbsp; dies_ok({$pair[0]}, 'sub test3: access by $pair[0] should not work', :todo&lt;bug&gt;);
&nbsp; &nbsp; &nbsp; &nbsp; dies_ok({$pair[1]}, 'sub test3: access by $pair[1] should not work', :todo&lt;bug&gt;);
&nbsp; &nbsp; }
}
test3 %hash;

=begin p6l

Hm, Hash::pair? Never heard of that. &nbsp;--iblech

sub test4 (Hash %h){
&nbsp; &nbsp; for %h.pair -&gt; $pair {
&nbsp; &nbsp; &nbsp; &nbsp; isa_ok($pair,'Pair',:todo&lt;bug&gt;) ; 
&nbsp; &nbsp; &nbsp; &nbsp; is($pair.key, 'foo', 'sub test4: access by unspecced &quot;pair&quot; got the right $pair.key');
&nbsp; &nbsp; &nbsp; &nbsp; is($pair.value, 'bar', 'sub test4: access by unspecced &quot;pair&quot; got the right $pair.value');

&nbsp; &nbsp; }
}
test4 %hash;

=end p6l

=cut

my $should_be_a_pair = (a =&gt; 25/1);
isa_ok $should_be_a_pair, &quot;Pair&quot;, &quot;=&gt; has correct precedence&quot;;

=pod

Stated by Larry on p6l in:
L&lt;<a href="http://www.nntp.perl.org/group/perl.perl6.language/20122">&quot;http://www.nntp.perl.org/group/perl.perl6.language/20122&quot;</a>&gt;

&quot;Oh, and we recently moved =&gt; to assignment precedence so it would
more naturally be right associative, and to keep the non-chaining
binaries consistently non-associative. &nbsp;Also lets you say:

&nbsp; key =&gt; $x ?? $y !! $z;

plus it moves it closer to the comma that it used to be in Perl 5.&quot;

(iblech) XXX: this contradicts current S03 so I could be wrong.

=cut

{
&nbsp; # This should always work.
&nbsp; my %x = ( &quot;Zaphod&quot; =&gt; (0 ?? 1 !! 2), &quot;Ford&quot; =&gt; 42 );
&nbsp; is %x{&quot;Zaphod&quot;}, 2, &quot;Zaphod is 2&quot;;
&nbsp; is %x{&quot;Ford&quot;}, &nbsp;42, &quot;Ford is 42&quot;;

&nbsp; # This should work only if =&gt; is lower precedence than ?? !!
&nbsp; my %z = ( &quot;Zaphod&quot; =&gt; 0 ?? 1 !! 2, &quot;Ford&quot; =&gt; 42 );
&nbsp; is %z{&quot;Zaphod&quot;}, 2, &quot;Zaphod is still 2&quot;;
&nbsp; is %z{&quot;Ford&quot;}, &nbsp;42, &quot;Ford is still 42&quot;;
}

# This is per the pairs-behave-like-one-element-hashes-rule.
# (I asked p6l once, but the &quot;thread&quot; got warnocked. &nbsp;--iblech)
# (I asked p6l again, now the thread did definitely not get warnocked:
# L&lt;<a href="http://groups.google.de/group/perl.perl6.language/browse_thread/thread/e0e44be94bd31792/6de6667398a4d2c7?q=perl6.language+Stringification+pairs&amp;">&quot;http://groups.google.de/group/perl.perl6.language/browse_thread/thread/e0e44be94bd31792/6de6667398a4d2c7?q=perl6.language+Stringification+pairs&amp;&quot;</a>&gt;
# Also see L&lt;<a href="http://www.nntp.perl.org/group/perl.perl6.language/23224">&quot;http://www.nntp.perl.org/group/perl.perl6.language/23224&quot;</a>&gt;
{
&nbsp; my $pair = (a =&gt; 1);
&nbsp; is try { ~$pair &nbsp;}, &quot;a\t1&quot;, &quot;pairs stringify correctly (1)&quot;;
&nbsp; is try { &quot;$pair&quot; }, &quot;a\t1&quot;, &quot;pairs stringify correctly (2)&quot;;
}

{
&nbsp; my $pair = (a =&gt; [1,2,3]);
&nbsp; is try { ~$pair &nbsp;}, &quot;a\t1 2 3&quot;, &quot;pairs with arrayrefs as values stringify correctly (1)&quot;;
&nbsp; is try { &quot;$pair&quot; }, &quot;a\t1 2 3&quot;, &quot;pairs with arrayrefs as values stringify correctly (2)&quot;;
}

# Per Larry L&lt;<a href="http://www.nntp.perl.org/group/perl.perl6.language/23525">&quot;http://www.nntp.perl.org/group/perl.perl6.language/23525&quot;</a>&gt;:
# &nbsp; Actually, it looks like the bug is probably that =&gt; is forcing
# &nbsp; stringification on its left argument too agressively. &nbsp;It should only do
# &nbsp; that for an identifier.
{
&nbsp; my $arrayref = [&lt; a b c &gt;];
&nbsp; my $hashref &nbsp;= { :d(1), :e(2) };

&nbsp; my $pair = ($arrayref =&gt; $hashref);
&nbsp; is ~$pair.key, &nbsp; ~$arrayref, &quot;=&gt; should not stringify the key (1)&quot;;
&nbsp; is ~$pair.value, ~$hashref, &nbsp;&quot;=&gt; should not stringify the key (2)&quot;;

&nbsp; push $pair.key, &quot;d&quot;;
&nbsp; $pair.value&lt;f&gt; = 3;
&nbsp; is ~$pair.key, &nbsp; ~$arrayref, &quot;=&gt; should not stringify the key (3)&quot;;
&nbsp; is ~$pair.value, ~$hashref, &nbsp;&quot;=&gt; should not stringify the key (4)&quot;;
&nbsp; is +$pair.key, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4, &quot;=&gt; should not stringify the key (5)&quot;;
&nbsp; is +$pair.value, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3, &quot;=&gt; should not stringify the key (6)&quot;;
}

{
&nbsp; my $arrayref = [&lt; a b c &gt;];
&nbsp; my $hashref &nbsp;= { :d(1), :e(2) };

&nbsp; my $pair = ($arrayref =&gt; $hashref);
&nbsp; my sub pair_key (Pair $pair) { $pair.key }

&nbsp; is ~pair_key($pair), ~$arrayref,
&nbsp; &nbsp; &quot;the keys of pairs should not get auto-stringified when passed to a sub (1)&quot;;

&nbsp; push $pair.key, &quot;d&quot;;
&nbsp; is ~pair_key($pair), ~$arrayref,
&nbsp; &nbsp; &quot;the keys of pairs should not get auto-stringified when passed to a sub (2)&quot;;
&nbsp; is +pair_key($pair), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4,
&nbsp; &nbsp; &quot;the keys of pairs should not get auto-stringified when passed to a sub (3)&quot;;
}

# Per Larry: http://www.nntp.perl.org/group/perl.perl6.language/23984
{
&nbsp; my ($key, $val) = &lt;key val&gt;;
&nbsp; my $pair &nbsp; &nbsp; &nbsp; &nbsp;= ($key =&gt; $val);

&nbsp; lives_ok { $pair.key = &quot;KEY&quot; }, &quot;setting .key does not die&quot;, :todo&lt;bug&gt;;
&nbsp; is $pair.key, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;KEY&quot;, &nbsp; &quot;setting .key actually changes the key&quot;, :todo&lt;bug&gt;;
&nbsp; is $key, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;key&quot;, &nbsp; &quot;setting .key does not change the original var&quot;;

&nbsp; lives_ok { $pair.value = &quot;VAL&quot; }, &quot;setting .value does not die&quot;, :todo&lt;bug&gt;;
&nbsp; is $pair.value, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;VAL&quot;, &nbsp; &quot;setting .value actually changes the value&quot;, :todo&lt;bug&gt;;
&nbsp; is $val, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;val&quot;, &nbsp; &quot;setting .value does not change the original var&quot;;
}

{
&nbsp; my ($key, $val) = &lt;key val&gt;;
&nbsp; my $pair &nbsp; &nbsp; &nbsp; &nbsp;= ($key =&gt; $val);

&nbsp; lives_ok { $pair.key := &quot;KEY&quot; }, &quot;binding .key does not die&quot;, :todo&lt;bug&gt;;
&nbsp; is $pair.key, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;KEY&quot;, &nbsp; &quot;binding .key actually changes the key&quot;, :todo&lt;bug&gt;;
&nbsp; is $key, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;key&quot;, &nbsp; &quot;binding .key does not change the original var&quot;;
&nbsp; dies_ok { $pair.key = 42 }, &nbsp; &nbsp; &nbsp;&quot;the .key was really bound&quot;; &nbsp;# (can't modify constant)

&nbsp; lives_ok { $pair.value := &quot;VAL&quot; }, &quot;binding .value does not die&quot;, :todo&lt;bug&gt;;
&nbsp; is $pair.value, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;VAL&quot;, &nbsp; &quot;binding .value actually changes the value&quot;, :todo&lt;bug&gt;;
&nbsp; is $val, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;val&quot;, &nbsp; &quot;binding .value does not change the original var&quot;;
&nbsp; dies_ok { $pair.value = 42 }, &nbsp; &nbsp; &nbsp;&quot;the .value was really bound&quot;; &nbsp;# (can't modify constant)
}

{
&nbsp; my ($key, $val) = &lt;key val&gt;;
&nbsp; my $pair &nbsp; &nbsp; &nbsp; &nbsp;= (abc =&gt; &quot;def&quot;);

&nbsp; lives_ok { $pair.key := $key }, &quot;binding .key does not die&quot;, :todo&lt;bug&gt;;
&nbsp; is $pair.key, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;key&quot;, &nbsp;&quot;binding .key actually changes the key&quot;, :todo&lt;bug&gt;;
&nbsp; $key = &quot;KEY&quot;;
&nbsp; is $key, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;KEY&quot;, &nbsp;&quot;binding .key to a var works (1)&quot;;
&nbsp; is $pair.key, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;KEY&quot;, &nbsp;&quot;binding .key to a var works (2)&quot;, :todo&lt;bug&gt;;
&nbsp; try { $pair.key = &quot;new&quot; };
&nbsp; is $key, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;new&quot;, &nbsp;&quot;binding .key to a var works (3)&quot;, :todo&lt;bug&gt;;
&nbsp; is $pair.key, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;new&quot;, &nbsp;&quot;binding .key to a var works (4)&quot;, :todo&lt;bug&gt;;

&nbsp; lives_ok { $pair.value := $val }, &quot;binding .value does not die&quot;, :todo&lt;bug&gt;;
&nbsp; is $pair.value, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;val&quot;, &nbsp;&quot;binding .value actually changes the value&quot;, :todo&lt;bug&gt;;
&nbsp; $val = &quot;VAL&quot;;
&nbsp; is $val, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;VAL&quot;, &nbsp;&quot;binding .value to a var works (1)&quot;;
&nbsp; is $pair.value, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;VAL&quot;, &nbsp;&quot;binding .value to a var works (2)&quot;, :todo&lt;bug&gt;;
&nbsp; try { $pair.value = &quot;new&quot; };
&nbsp; is $val, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;new&quot;, &nbsp;&quot;binding .value to a var works (3)&quot;, :todo&lt;bug&gt;;
&nbsp; is $pair.value, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;new&quot;, &nbsp;&quot;binding .value to a var works (4)&quot;, :todo&lt;bug&gt;;
}</pre>
</div>


<pre>    Mapping     Pairs with no duplicate keys
    Signature   Function parameters (left-hand side of a binding)
    Capture     Function call arguments (right-hand side of a binding)
    Blob        An undifferentiated mass of bits</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Mutable_types"
>Mutable types</a></h2>

<p>Objects with these types have distinct <code>.SKID</code> values that do not change even if the object&#39;s contents change.</p>

<pre>    Array       Perl array
    Hash        Perl hash
    Scalar      Perl scalar
    Buf         Perl buffer (a stringish array of memory locations)
    IO          Perl filehandle
    Routine     Base class for all wrappable executable objects
    Sub         Perl subroutine
    Method      Perl method
    Submethod   Perl subroutine acting like a method
    Macro       Perl compile-time subroutine
    Regex       Perl pattern
    Match       Perl match, usually produced by applying a pattern
    Package     Perl 5 compatible namespace
    Module      Perl 6 standard namespace
    Class       Perl 6 standard class namespace
    Role        Perl 6 standard generic interface/implementation
    Object      Perl 6 object
    Grammar     Perl 6 pattern matching namespace</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Value_types"
>Value types</a></h2>

<p>Explicit types are optional. Perl variables have two associated types: their &#34;value type&#34; and their &#34;implementation type&#34;. (More generally, any container has an implementation type, including subroutines and modules.) The value type is stored as its <code>of</code> property, while the implementation type of the container is just the object type of the container itself.</p>

<p>The value type specifies what kinds of values may be stored in the variable. A value type is given as a prefix or with the <code>of</code> keyword:</p>

<pre>    my Dog $spot;
    my $spot of Dog;</pre>

<p>In either case this sets the <code>of</code> property of the container to <code>Dog</code>.</p>

<p>Subroutines have a variant of the <code>of</code> property, <code>returns</code>, that sets the <code>returns</code> property instead. The <code>returns</code> property specifies a constraint (or perhaps coercion) to be enforced on the return value (either by explicit call to <code>return</code> or by implicit fall-off-the-end return). This constraint, unlike the <code>of</code> property, is not advertised as the type of the routine. You can think of it as the implicit type signature of the (possibly implicit) return statement. It&#39;s therefore available for type inferencing within the routine but not outside it. If no inner type is declared, it is assumed to be the same as the <code>of</code> type, if declared.</p>

<pre>    sub get_pet() of Animal {...}       # of type, obviously
    our Animal sub get_pet() {...}      # of type
    sub get_pet() returns Animal {...}  # inner type</pre>

<p>A value type on an array or hash specifies the type stored by each element:</p>

<pre>    my Dog @pound;  # each element of the array stores a Dog

    my Rat %ship;   # the value of each entry stores a Rat</pre>

<p>The key type of a hash may be specified as a shape trait--see S09.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Implementation_types"
>Implementation types</a></h2>

<p>The implementation type specifies how the variable itself is implemented. It is given as a trait of the variable:</p>

<pre>    my $spot is Scalar;             # this is the default
    my $spot is PersistentScalar;
    my $spot is DataBase;</pre>

<p>Defining an implementation type is the Perl 6 equivalent to tying a variable in Perl 5. But Perl 6 variables are tied directly at declaration time, and for performance reasons may not be tied with a run-time <code>tie</code> statement unless the variable is explicitly declared with an implementation type that does the <code>Tieable</code> role.</p>

<p>However, package variables are always considered <code>Tieable</code> by default. As a consequence, all named packages are also <code>Tieable</code> by default. Classes and modules may be viewed as differently tied packages. Looking at it from the other direction, classes and modules that wish to be bound to a global package name must be able to do the <code>Package</code> role.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Hierarchical_types"
>Hierarchical types</a></h2>

<p>A non-scalar type may be qualified, in order to specify what type of value each of its elements stores:</p>

<pre>    my Egg $cup;                       # the value is an Egg
    my Egg @carton;                    # each elem is an Egg
    my Array of Egg @box;              # each elem is an array of Eggs
    my Array of Array of Egg @crate;   # each elem is an array of arrays of Eggs
    my Hash of Array of Recipe %book;  # each value is a hash of arrays of Recipes</pre>

<p>Each successive <code>of</code> makes the type on its right a parameter of the type on its left. Parametric types are named using square brackets, so:</p>

<pre>    my Hash of Array of Recipe %book;</pre>

<p>actually means:</p>

<pre>    my Hash[of =&#62; Array[of =&#62; Recipe]] %book; </pre>

<p>Because the actual variable can be hard to find when complex types are specified, there is a postfix form as well:</p>

<pre>    my Hash of Array of Recipe %book;           # HoHoAoRecipe
    my %book of Hash of Array of Recipe;        # same thing</pre>

<p>The <code>returns</code> form may be used in subroutines:</p>

<pre>    my sub get_book ($key) returns Hash of Array of Recipe {...}</pre>

<p>Alternately, the return type may be specified within the signature:</p>

<pre>    my sub get_book ($key --&#62; Hash of Array of Recipe) {...}</pre>

<p>There is a slight difference, insofar as the type inferencer will ignore a <code>returns</code> but pay attention to <code>--&#62;</code> or prefix type declarations, also known as the <code>of</code> type. Only the inside of the subroutine pays attention to <code>returns</code>.</p>

<p>You may also specify the <code>of</code> type as the <code>of</code> trait:</p>

<pre>    my Hash of Array of Recipe sub get_book ($key) {...}
    my sub get_book ($key) of Hash of Array of Recipe {...}</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Polymorphic_types"
>Polymorphic types</a></h2>

<p>Anywhere you can use a single type you can use a set of types, for convenience specifiable as if it were an &#34;or&#34; junction:</p>

<pre>    my Int|Str $error = $val;              # can assign if $val~~Int or $val~~Str</pre>

<p>Fancier type constraints may be expressed through a subtype:</p>

<pre>    subset Shinola of Any where {.does(DessertWax) and .does(FloorTopping)};
    if $shimmer ~~ Shinola {...}  # $shimmer must do both interfaces</pre>

<p>Since the terms in a parameter could be viewed as a set of constraints that are implicitly &#34;anded&#34; together (the variable itself supplies type constraints, and <code>where</code> clauses or tree matching just add more constraints), we relax this to allow juxtaposition of types to act like an &#34;and&#34; junction:</p>

<pre>    # Anything assigned to the variable $mitsy must conform
    # to the type Fish and either the Cat or Dog type...
    my Cat|Dog Fish $mitsy = new Fish but { int rand 2 ?? .does Cat
                                                       !! .does Dog };</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Parameter_types"
>Parameter types</a></h2>

<p>Parameters may be given types, just like any other variable:</p>

<pre>    sub max (int @array is rw) {...}
    sub max (@array of int is rw) {...}</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Generic_types"
>Generic types</a></h2>

<p>Within a declaration, a class variable (either by itself or following an existing type name) declares a new type name and takes its parametric value from the actual type of the parameter it is associated with. It declares the new type name in the same scope as the associated declaration.</p>

<pre>    sub max (Num ::X @array) {
        push @array, X.new();
    }</pre>

<p>The new type name is introduced immediately, so two such types in the same signature must unify compatibly if they have the same name:</p>

<pre>    sub compare (Any ::T $x, T $y) {
        return $x eqv $y;
    }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Return_types"
>Return types</a></h2>

<p>On a scoped subroutine, a return type can be specified before or after the name. We call all return types &#34;return types&#34;, but distinguish two kinds of return types, the <code>inner</code> type and the <code>of</code> type, because the <code>of</code> type is normally an &#34;official&#34; named type and declares the official interface to the routine, while the <code>inner</code> type is merely a constraint on what may be returned by the routine from the routine&#39;s point of view.</p>

<pre>    our sub lay returns Egg {...}       # inner type
    our Egg sub lay {...}               # of type
    our sub lay of Egg {...}            # of type
    our sub lay (--&#62; Egg) {...}         # of type

    my sub hat returns Rabbit {...}     # inner type
    my Rabbit sub hat {...}             # of type
    my sub hat of Rabbit {...}          # of type
    my sub hat (--&#62; Rabbit) {...}       # of type</pre>

<p>If a subroutine is not explicitly scoped, it belongs to the current namespace (module, class, grammar, or package), as if it&#39;s scoped with the <code>our</code> scope modifier. Any return type must go after the name:</p>

<pre>    sub lay returns Egg {...}           # inner type
    sub lay of Egg {...}                # of type
    sub lay (--&#62; Egg) {...}             # of type</pre>

<p>On an anonymous subroutine, any return type can only go after the <code>sub</code> keyword:</p>

<pre>    $lay = sub returns Egg {...};       # inner type
    $lay = sub of Egg {...};            # of type
    $lay = sub (--&#62; Egg) {...};         # of type</pre>

<p>but you can use a scope modifier to introduce an <code>of</code> prefix type:</p>

<pre>    $lay = my Egg sub {...};            # of type
    $hat = my Rabbit sub {...};         # of type</pre>

<p>Because they are anonymous, you can change the <code>my</code> modifier to <code>our</code> without affecting the meaning.</p>

<p>The return type may also be specified after a <code>--&#62;</code> token within the signature. This doesn&#39;t mean exactly the same thing as <code>returns</code>. The <code>of</code> type is the &#34;official&#34; return type, and may therefore be used to do type inferencing outside the sub. The <code>inner</code> type only makes the return type available to the internals of the sub so that the <code>return</code> statement can know its context, but outside the sub we don&#39;t know anything about the return value, as if no return type had been declared. The prefix form specifies the <code>of</code> type rather than the <code>inner</code> type, so the return type of</p>

<pre>    my Fish sub wanda ($x) { ... }</pre>

<p>is known to return an object of type Fish, as if you&#39;d said:</p>

<pre>    my sub wanda ($x --&#62; Fish) { ... }</pre>

<p><i>not</i> as if you&#39;d said</p>

<pre>    my sub wanda ($x) returns Fish { ... }</pre>

<p>It is possible for the <code>of</code> type to disagree with the <code>inner</code> type:</p>

<pre>    my Squid sub wanda ($x) returns Fish { ... }</pre>

<p>or equivalently,</p>

<pre>    my sub wanda ($x --&#62; Squid) returns Fish { ... }</pre>

<p>This is not lying to yourself--it&#39;s lying to the world. Having a different inner type is useful if you wish to hold your routine to a stricter standard than you let on to the outside world, for instance.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Properties_and_traits"
>Properties and traits</a></h1>

<p>Compile-time properties are called &#34;traits&#34;. The <code>is <i>NAME</i> (<i>DATA</i>)</code> syntax defines traits on containers and subroutines, as part of their declaration:</p>

<pre>    constant $pi is Approximated = 3;   # variable $pi has Approximated trait

    my $key is Persistent(:file&#60;.key&#62;);

    sub fib is cached {...}</pre>

<p>The <code>will <i>NAME</i> <i>BLOCK</i></code> syntax is a synonym for <code>is <i>NAME</i> (<i>BLOCK</i>)</code>:</p>

<pre>    my $fh will undo { close $fh };    # Same as: my $fh is undo({ close $fh });</pre>

<p>The <code>but <i>NAME</i> (<i>DATA</i>)</code> syntax specifies run-time properties on values:</p>

<pre>    constant $pi = 3 but Inexact;       # value 3 has Inexact property

    sub system {
        ...
        return $error but False if $error;
        return 0 but True;
    }</pre>

<p>Properties are predeclared as roles and implemented as mixins--see S12.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Subroutine_traits"
>Subroutine traits</a></h2>

<p>These traits may be declared on the subroutine as a whole (individual parameters take other traits). Trait syntax depends on the particular auxiliary you use, but for <code>is</code>, the subsequent syntax is identical to adverbial syntax, except that that colon may be omitted or doubled depending on the degree of ambiguity desired:</p>

<pre>    is ::Foo[...]       # definitely a parameterized typename
    is :Foo[...]        # definitely a pair with a list
    is Foo[...]         # depends on whether Foo is predeclared as type</pre>

<dl>
<dt><a name="is_signature"
><code>is signature</code></a></dt>

<dd>
<p>The signature of a subroutine. Normally declared implicitly, by providing a parameter list and/or return type.</p>

<dt><a name="returns/is_returns"
><code>returns</code>/<code>is returns</code></a></dt>

<dd>
<p>The <code>inner</code> type constraint that a routine imposes on its return value.</p>

<dt><a name="of/is_of"
><code>of</code>/<code>is of</code></a></dt>

<dd>
<p>The <code>of</code> type that is the official return type of the routine.</p>

<dt><a name="will_do"
><code>will do</code></a></dt>

<dd>
<p>The block of code executed when the subroutine is called. Normally declared implicitly, by providing a block after the subroutine&#39;s signature definition.</p>

<dt><a name="is_rw"
><code>is rw</code></a></dt>

<dd>
<p>Marks a subroutine as returning an lvalue.</p>

<dt><a name="is_parsed"
><code>is parsed</code></a></dt>

<dd>
<p>Specifies the subrule by which a macro call is parsed. The parse always starts after the macro token, but the token may be referred to within the subrule as <code>$&#60;KEY&#62;</code>.</p>

<dt><a name="is_cached"
><code>is cached</code></a></dt>

<dd>
<p>Marks a subroutine as being memoized.</p>

<dt><a name="is_inline"
><code>is inline</code></a></dt>

<dd>
<p><i>Suggests</i> to the compiler that the subroutine is a candidate for optimization via inlining.</p>

<dt><a name="is_tighter/is_looser/is_equiv"
><code>is tighter</code>/<code>is looser</code>/<code>is equiv</code></a></dt>

<dd>
<p>Specifies the precedence of an operator relative to an existing operator. <code>tighter</code> and <code>looser</code> operators default to being left associative.</p>

<p><code>equiv</code> on the other hand also clones other traits, so it specifies the default associativity to be the same as the operator to which the new operator is equivalent. The following are the default equivalents for various syntactic categories if neither <code>equiv</code> nor <code>assoc</code> is specified. (Many of these have no need of precedence or associativity because they are parsed specially. Nevertheless, <code>equiv</code> may be useful for cloning other traits of these operators.)</p>

<pre>    term:&#60;*&#62;
    quote:&#60;q&#62;
    prefix:&#60;++&#62;
    infix:&#60;+&#62;
    postfix:&#60;++&#62;
    circumfix:&#60;( )&#62;
    postcircumfix:&#60;( )&#62;
    regex_metachar:&#60;.&#62;
    regex_backslash:&#60;w&#62;
    regex_assertion:&#60;?&#62;
    regex_mod_internal:&#60;i&#62;
    regex_mod_external:&#60;i&#62;
    trait_verb:&#60;of&#62;
    trait_auxiliary:&#60;is&#62;
    scope_declarator:&#60;my&#62;
    statement_control:&#60;if&#62;
    statement_modifier:&#60;if&#62;
    infix_prefix_meta_operator:&#60;!&#62;
    infix_postfix_meta_operator:&#60;=&#62;
    postfix_prefix_meta_operator:{&#39;&#187;&#39;}
    prefix_postfix_meta_operator:{&#39;&#171;&#39;}
    infix_circumfix_meta_operator:{&#39;&#187;&#39;,&#39;&#171;&#39;}
    prefix_circumfix_meta_operator:{&#39;[&#39;,&#39;]&#39;} </pre>

<p>The existing operator may be specified either as a function name or as a string slice equivalent to the one that would be used in the complete function name. In string slice form the syntactic category will be assumed to be the same as the new declaration. Therefore these all have the same effect:</p>

<pre>    sub postfix:&#60;!&#62; ($x) is equiv(&#38;postfix:&#60;++&#62;) {...}
    sub postfix:&#60;!&#62; ($x) is equiv&#60;++&#62; {...}
    sub postfix:&#60;!&#62; ($x) {...}      # since equiv&#60;++&#62; is the default</pre>

<p>Prefix operators that are identifiers are handled specially. Both of</p>

<pre>    sub foo ($) {...}
    sub prefix:&#60;foo&#62; ($) {...}</pre>

<p>default to named unary precedence despite declaring a prefix operator. Likewise postfix operators that look like method calls are forced to default to the precedence of method calls.</p>

<dt><a name="is_assoc"
><code>is assoc</code></a></dt>

<dd>
<p>Specifies the associativity of an operator explicitly. Valid values are:</p>

<pre>    Tag         Examples        Meaning of $a op $b op $c       Default equiv
    ===         ========        =========================       =============
    left        + - * / x       ($a op $b) op $c                +
    right       ** =            $a op ($b op $c)                **
    non         cmp &#60;=&#62; ..      ILLEGAL                         cmp
    chain       == eq ~~        ($a op $b) and ($b op $c)       eqv
    list        | &#38; ^ &#165;         op($a, $b, $c)                  |</pre>

<p>Note that operators &#34;<code>equiv</code>&#34; to relationals are automatically considered chaining operators. When creating a new precedence level, the chaining is determined by the presence or absence of &#34;<code>is assoc&#60;chain&#62;</code>&#34;, and other operators defined at that level are required to be the same.</p>

<p>Specifying an <code>assoc</code> without an explicit <code>equiv</code> substitutes a default <code>equiv</code> consistent with the associativity, as shown in the final column above.</p>

<dt><a name="PRE/POST"
><code>PRE</code>/<code>POST</code></a></dt>

<dd>
<p>Mark blocks that are to be unconditionally executed before/after the subroutine&#39;s <code>do</code> block. These blocks must return a true value, otherwise an exception is thrown.</p>

<p>When applied to a method, a <code>PRE</code> block automatically also calls all <code>PRE</code> blocks on any method of the same long name in each parent class. The precondition is satisfied if either the method&#39;s own <code>PRE</code> block returns true, or <i>all</i> of its parents&#39; <code>PRE</code> blocks return true. This &#34;me-or-all-my-parents&#34; requirement applies recursively to each parent&#39;s <code>PRE</code> block as well.</p>

<p>When applied to a method, a <code>POST</code> block automatically also calls all <code>POST</code> blocks on any method of the same long name in every ancestral class. The postcondition is satisfied only if the method&#39;s own <code>POST</code> block <i>and</i> every one of its ancestral <code>POST</code> blocks all return true.</p>

<dt><a name="ENTER/LEAVE/KEEP/UNDO/etc."
><code>ENTER</code>/<code>LEAVE</code>/<code>KEEP</code>/<code>UNDO</code>/etc.</a></dt>

<dd>
<p>These supply closures that are to be conditionally executed before or after the subroutine&#39;s <code>do</code> block (only if used at the outermost level within the subroutine; technically, these are block traits on the <code>do</code> block, not subroutine traits). These blocks are generally used only for their side effects, since most return values will be ignored.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Parameter_traits"
>Parameter traits</a></h2>

<a href="#" onclick="return tog_quote(7);">
<div ID="header_shown_7" style="display: none;">
- Hide the snippet from t/blocks/sub_parameter_traits.t (line 11 ~ line 49) -
</div>
<div ID="header_hidden_7" style="display: block;">
- Show the snippet from t/blocks/sub_parameter_traits.t (line 11 ~ line 49) -
</div>
</a>
<div ID="hide_7" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S06/&quot;Parameter traits&quot;&gt;

=cut

my $foo=1;
sub mods_param ($x) { $x++; }
dies_ok &nbsp;{ mods_param($foo) }, 'can\'t modify parameter, constant by default';

# is readonly
sub mods_param_constant ($x is readonly) { $x++; }
dies_ok &nbsp;{ mods_param_constant($foo) }, 'can\'t modify constant parameter, constant by default';

sub mods_param_rw ($x is rw) { $x++; }
dies_ok &nbsp;{ mods_param_rw(1) }, 'can\'t modify constant even if we claim it\'s rw';
sub mods_param_rw_does_nothing ($x is rw) { $x; }
lives_ok { mods_param_rw_does_nothing(1) }, 'is rw with non-lvalue should autovivify';

lives_ok &nbsp;{ mods_param_rw($foo) }, 'pass by reference doesn\'t die';
is($foo, 2, 'pass by reference works');

#icopy
$foo=1;
sub mods_param_copy ($x is copy) {$x++;}
lives_ok { mods_param_copy($foo) }, 'is copy';
is($foo, 1, 'pass by value works');

# is ref
$foo=1;
sub mods_param_ref ($x is ref) { $x++; &nbsp;}
dies_ok { mods_param_ref(1); }, 'is ref with non-lvalue';
lives_ok { mods_param_ref($foo); }, 'is ref with non-lvalue', :todo;
is($foo, 2, 'is ref works', :todo);

# is context
# Doesn't even compile, which is lucky, because I don't understand it well
# enough to write an actual test...
eval_ok('sub my_format (*@data is context(Item)) { }; 1', &quot;is context - compile check&quot;);

# To do - check that is context actually works</pre>
</div>


<p>The following traits can be applied to many types of parameters.</p>

<dl>
<dt><a name="is_readonly"
><code>is readonly</code></a></dt>

<dd>
<p>Specifies that the parameter cannot be modified (e.g. assigned to, incremented). It is the default for parameters.</p>

<dt><a name="is_rw"
><code>is rw</code></a></dt>

<dd>
<p>Specifies that the parameter can be modified (assigned to, incremented, etc). Requires that the corresponding argument is an lvalue or can be converted to one.</p>

<p>When applied to a variadic parameter, the <code>rw</code> trait applies to each element of the list:</p>

<pre>    sub incr (*@vars is rw) { $_++ for @vars }</pre>

<p>(The variadic array as a whole is always modifiable, but such modifications have no effect on the original argument list.)</p>

<dt><a name="is_ref"
><code>is ref</code></a></dt>

<dd>
<p>Specifies that the parameter is passed by reference. Unlike <code>is rw</code>, the corresponding argument must already be a suitable lvalue. No attempt at coercion or autovivification is made, so unsuitable values throw an exception when you try to modify them.</p>

<dt><a name="is_copy"
><code>is copy</code></a></dt>

<dd>
<p>Specifies that the parameter receives a distinct, read-writable copy of the original argument. This is commonly known as &#34;pass-by-value&#34;.</p>

<pre>    sub reprint ($text, $count is copy) {
        print $text while $count-- &#62; 0;
    }</pre>

<dt><a name="is_context(TYPE)"
><code>is context(<i>TYPE</i>)</code></a></dt>

<dd>
<p>Specifies the context that a parameter applies to its argument. Typically used to cause a final list parameter to apply a series of scalar contexts:</p>

<pre>    # &#38;format may have as many arguments as it likes,
    # each of which is evaluated in scalar context

    sub format(*@data is context(Scalar)) {...}</pre>

<p>Note that the compiler may not be able to propagate such a scalar context to a function call used as an argument to a method or multisub whose signature is not visible until dispatch time. Such function call arguments are called in list context by default, and must be coerced to scalar context explicitly if that is desired.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Advanced_subroutine_features"
>Advanced subroutine features</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_return_function"
>The <code>return</code> function</a></h2>

<p>The <code>return</code> function notionally throws a control exception that is caught by the current lexically enclosing <code>Routine</code> to force a return through the control logic code of any intermediate block constructs. With normal blocks this can be optimized away to a &#34;goto&#34;. All <code>Routine</code> declarations have an explicit declarator such as <code>sub</code> or <code>method</code>; bare blocks and &#34;pointy&#34; blocks are never considered to be routines in that sense. To return from a block, use <code>leave</code> instead--see below.</p>

<p>The <code>return</code> function preserves its argument list as a <code>Capture</code> object, and responds to the left-hand <code>Signature</code> in a binding. This allows named return values if the caller expects one:</p>

<pre>    sub f { return :x&#60;1&#62; }
    sub g ($x) { print $x }

    my $x := *f();  # binds 1 to $x, via a named argument
    g(*f());        # prints 1, via a named argument</pre>

<a href="#" onclick="return tog_quote(5);">
<div ID="header_shown_5" style="display: none;">
- Hide the snippet from t/blocks/return_function.t (line 3 ~ line 22) -
</div>
<div ID="header_hidden_5" style="display: block;">
- Show the snippet from t/blocks/return_function.t (line 3 ~ line 22) -
</div>
</a>
<div ID="hide_5" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S06/The C&lt;return&gt; function/prints 1 via named argument&gt;

{
&nbsp; &nbsp; sub f { return :x&lt;1&gt; }
&nbsp; &nbsp; sub g ($x) { $x }

&nbsp; &nbsp; my $x := *f(); &nbsp;# binds 1 to $x, via a named argument
&nbsp; &nbsp; is $x, 1, 'binds 1 to $x, via a named argument';
&nbsp; &nbsp; is( g(*f()), 1, &quot;prints 1, via a named argument&quot;);
}

{
&nbsp; # return two positional Pair objects
&nbsp; sub t2 &nbsp;{ return( (:x&lt;1&gt;), (:y&lt;2&gt;) ) }
&nbsp; my ($rv1,$rv2);
&nbsp; $rv1,$rv2 := *t2();
&nbsp; is($rv1, Pair, &quot;returned Pair object 1&quot;); &nbsp;
&nbsp; is($rv2, Pair, &quot;returned Pair object 2&quot;); &nbsp;
}</pre>
</div>


<p>To return a literal <code>Pair</code> object, always put it in an additional set of parentheses:</p>

<pre>    return( (:x&#60;1&#62;), (:y&#60;2&#62;) ); # two positional Pair objects</pre>

<p>Note that the postfix parentheses on the function call don&#39;t count as being &#34;additional&#34;. However, as with any function, whitespace after the <code>return</code> keyword prevents that interpretation and turns it instead into a list operator:</p>

<pre>    return :x&#60;1&#62;, :y&#60;2&#62;; # two named arguments (if caller uses *)
    return ( :x&#60;1&#62;, :y&#60;2&#62; ); # two positional Pair objects</pre>

<p>If the function ends with an expression without an explicit <code>return</code>, that expression is also taken to be a <code>Capture</code>, just as if the expression were the argument to a <code>return</code> list operator (with whitespace):</p>

<pre>    sub f { :x&#60;1&#62; } # named-argument binding (if caller uses *)
    sub f { (:x&#60;1&#62;) } # always just one positional Pair object </pre>

<p>On the caller&#39;s end, the <code>Capture</code> is interpolated into any new argument list much like an array would be, that is, as a scalar in scalar context, and as a list in list context. This is the default behavior, but as with an array, the caller may use <code>prefix:&#60;[,]&#62;</code> to inline the returned values as part of the new argument list. The caller may also bind the returned <code>Capture</code> directly.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_caller_function"
>The <code>caller</code> function</a></h2>

<a href="#" onclick="return tog_quote(37);">
<div ID="header_shown_37" style="display: none;">
- Hide the snippet from t/builtins/caller.t (line 7 ~ line 62) -
</div>
<div ID="header_hidden_37" style="display: block;">
- Show the snippet from t/builtins/caller.t (line 7 ~ line 62) -
</div>
</a>
<div ID="hide_37" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S06/&quot;The C&lt;caller&gt; function&quot;&gt;

# caller.subname
sub a_sub { b_sub() }
sub b_sub { try { caller.subname } }
is ~a_sub(), &quot;foo&quot;, &quot;caller.sub works&quot;, :todo;

# caller.file
ok index(~(try { caller.file }), &quot;caller&quot;) &gt;= 0, &quot;caller.file works&quot;, :todo;

# caller.line (XXX: make sure to edit the expected line number!)
is +(try { caller.line }), 19, &quot;caller.line works&quot;, :todo;

# caller exposes a bug in the MMD mechanism where directy using autogenerated
# accessors on an object returned by a factory, rather than storing the object
# in an intermediate variable, works only when you chain methods with an
# explicit () between them: caller().subname - ok; caller.subname - error.

sub try_it {
&nbsp; &nbsp; my ($code, $expected, $desc) = @_;
&nbsp; &nbsp; is($code(), $expected, $desc);
}
sub try_it_caller { try_it(*@_) } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# (line 30.)
class A { method try_it_caller_A { &amp;main::try_it_caller(*@_) } }
sub try_it_caller_caller { A.try_it_caller_A(*@_) }
class B { method try_it_caller_B { &amp;main::try_it_caller_caller(*@_) } }
sub chain { B.try_it_caller_B(*@_) }

# must use parentheses after caller

# basic tests of caller object
chain({ ref caller() }, &nbsp; &nbsp; &quot;Control::Caller&quot;, &quot;caller object type&quot;);
chain({ caller().package }, &quot;main&quot;, &quot;caller package&quot;);
chain({ caller().file }, &nbsp; &nbsp;$?FILE, &quot;caller filename&quot;);
chain({ caller().line }, &nbsp; &nbsp;&quot;30&quot;, &quot;caller line&quot;);
chain({ caller().subname }, &quot;&amp;main::try_it_caller&quot;, &quot;caller subname&quot;);
chain({ caller().subtype }, &quot;SubRoutine&quot;, &quot;caller subtype&quot;); # specme
chain({ caller().sub }, &nbsp; &nbsp; &amp;try_it_caller, &quot;caller sub (code)&quot;);

# select by code type
chain({ caller(Any).subname }, &nbsp; &nbsp;&quot;&amp;main::try_it_caller&quot;, &quot;code type - Any&quot;);
chain({ caller(&quot;Any&quot;).subname }, &nbsp;&quot;&amp;main::try_it_caller&quot;, &quot;code type - Any (string)&quot;);
chain({ caller(Method).subname }, &quot;&amp;A::try_it_caller_A&quot;, &quot;code type - Method&quot;);
chain({ caller(&quot;Moose&quot;) }, &nbsp; &nbsp; &nbsp; &nbsp; undef, &quot;code type - not found&quot;);

# :skip
chain({ caller(:skip&lt;1&gt;).subname }, &quot;&amp;A::try_it_caller_A&quot;, &quot;:skip&lt;1&gt;&quot;);
chain({ caller(:skip&lt;128&gt;) }, &nbsp; &nbsp; &nbsp; undef, &quot;:skip&lt;128&gt; - not found&quot;);

# type + :skip
chain({ caller(Sub, :skip&lt;1&gt;).subname }, &quot;&amp;main::try_it_caller_caller&quot;, &quot;Sub, :skip&lt;1&gt;&quot;);
chain({ caller(Sub, :skip&lt;2&gt;).subname }, &quot;&amp;main::chain&quot;, &quot;Sub, :skip&lt;2&gt;&quot;);
chain({ caller(Method, :skip&lt;1&gt;).subname }, &quot;&amp;B::try_it_caller_B&quot;, &quot;Method, :skip&lt;1&gt;&quot;);

# WRITEME: label tests</pre>
</div>


<p>The <code>caller</code> function returns an object that describes a particular &#34;higher&#34; dynamic scope, from which the current scope was called.</p>

<pre>    say &#34;In &#34;,           caller.sub,
        &#34; called from &#34;, caller.file,
        &#34; line &#34;,        caller.line;</pre>

<p><code>caller</code> may be given arguments telling it what kind of higher scope to look for, and how many such scopes to skip over when looking:</p>

<pre>    $caller = caller;                      # immediate caller
    $caller = caller Method;               # nearest caller that is method
    $caller = caller Bare;                 # nearest caller that is bare block
    $caller = caller Sub, :skip(2);        # caller three levels up
    $caller = caller Block, :label&#60;Foo&#62;;   # caller whose label is &#39;Foo&#39;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_want_function"
>The <code>want</code> function</a></h2>

<p>The <code>want</code> function returns a <code>Signature</code> object that contains information about the context in which the current block, closure, or subroutine was called.</p>

<p>As with normal function signatures, you can test the result of <code>want</code> with a smart match (<code>~~</code>) or a <code>when</code>:</p>

<pre>   given want {
        when :($)       {...}   # called in scalar context
        when :(*@)      {...}   # called in list context
        when :($ is rw) {...}   # expected to return an lvalue
        when :($,$)     {...}   # expected to return two values
        ...
    }</pre>

<p>Or use its shorthand methods to reduce line noise:</p>

<pre>    if    want.item      {...}  # called in non-lvalue scalar context
    elsif want.list      {...}  # called in list context
    elsif want.void      {...}  # called in void context
    elsif want.rw        {...}  # expected to return an lvalue</pre>

<p>The <code>.arity</code> and <code>.count</code> methods also work here:</p>

<pre>    if want.arity &#62; 2    {...}  # must return more than two values
    if want.count &#62; 2    {...}  # can return more than two values</pre>

<p>Their difference is that <code>.arity</code> considers only mandatory parts, while <code>.count</code> considers also optional ones, including <code>*$</code>:</p>

<pre>    ($x, $y) = f();     # Within &#38;f, want === :(*$?, *$?, *@)
                        #            want.arity === 0
                        #            want.count === 2</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_leave_function"
>The <code>leave</code> function</a></h2>

<a href="#" onclick="return tog_quote(6);">
<div ID="header_shown_6" style="display: none;">
- Hide the snippet from t/builtins/control_flow/leave.t (line 6 ~ line 84) -
</div>
<div ID="header_hidden_6" style="display: block;">
- Show the snippet from t/builtins/control_flow/leave.t (line 6 ~ line 84) -
</div>
</a>
<div ID="hide_6" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S06/&quot;The C&lt;leave&gt; function&quot;&gt;

plan 5;

flunk &quot;leave() not implemented in Pugs's interpreter core yet&quot;, :todo&lt;feature&gt;;
skip_rest; exit;

{
&nbsp; my $bare = { leave 42; 23 };

&nbsp; is $bare(), 42, &quot;basic leave() works&quot;;
}

{
&nbsp; my $sub = sub () {
&nbsp; &nbsp; my $bare = { leave 42; 23 };

&nbsp; &nbsp; my $ret = $bare();
&nbsp; &nbsp; return 1000 + $ret;
&nbsp; };

&nbsp; is $sub(), 1042, &quot;leave() works and leaves only the innermost block&quot;;
}

{
&nbsp; my $sub = sub () {
&nbsp; &nbsp; leave &amp;?ROUTINE, 42;
&nbsp; &nbsp; return 23;
&nbsp; };

&nbsp; is $sub(), 42, &quot;leave() works with &amp;?ROUTINE as parameter&quot;;
}

{
&nbsp; my $outer = sub () {
&nbsp; &nbsp; my $inner = sub () {
&nbsp; &nbsp; &nbsp; my $most_inner = sub () {
&nbsp; &nbsp; &nbsp; &nbsp; leave $outer, 42;
&nbsp; &nbsp; &nbsp; &nbsp; return 23;
&nbsp; &nbsp; &nbsp; };

&nbsp; &nbsp; &nbsp; $most_inner();
&nbsp; &nbsp; &nbsp; return 22;
&nbsp; &nbsp; };

&nbsp; &nbsp; $inner();
&nbsp; &nbsp; return 21;
&nbsp; }

&nbsp; is $outer(), 42, &quot;nested leave() works with a subref as parameter&quot;;
}

{
&nbsp; my $sub = sub () {
&nbsp; &nbsp; my $bare = sub () {
&nbsp; &nbsp; &nbsp; leave Block, 42;
&nbsp; &nbsp; &nbsp; return 23;
&nbsp; &nbsp; };

&nbsp; &nbsp; my $ret = $bare();
&nbsp; &nbsp; return 1000 + $ret;
&nbsp; };

&nbsp; is $sub(), 1042, &quot;leave() works with a Class (Block) as parameter&quot;;
}

{
&nbsp; my $sub = sub () {
&nbsp; &nbsp; my $bare = sub () {
&nbsp; &nbsp; &nbsp; leave Sub, 42;
&nbsp; &nbsp; &nbsp; return 23;
&nbsp; &nbsp; };

&nbsp; &nbsp; my $ret = $bare();
&nbsp; &nbsp; return 1000 + $ret;
&nbsp; };

&nbsp; is $sub(), 42, &quot;leave() works with a Class (Sub) as parameter&quot;;
}</pre>
</div>


<p>As mentioned above, a <code>return</code> call causes the innermost surrounding subroutine, method, rule, token, regex (as a keyword), macro, or multimethod to return. Only declarations with an explicit keyword such as &#34;sub&#34; may be returned from. You may not return from a quotelike operator such as <code>rx//</code>.</p>

<p>To return from other types of code structures, the <code>leave</code> function is used. The first argument, if supplied, specifies a <code>Selector</code> for the control structure to leave. The <code>Selector</code> will be smart-matched against the dynamic scope objects from inner to outer. The first that matches is the scope that is left.</p>

<p>The remainder of the arguments are taken to be a Capture holding the return values.</p>

<pre>    leave;                      # return from innermost block of any kind
    leave *;                    # same thing
    leave Method;               # return from innermost calling method
    leave &#38;?ROUTINE, 1,2,3;     # Return from current sub. Same as: return 1,2,3
    leave &#38;?ROUTINE &#60;== 1,2,3;  # same thing, force return as feed
    leave &#38;foo, 1,2,3;          # Return from innermost surrounding call to &#38;foo</pre>

<p>Note that these are equivalent:</p>

<pre>    leave Loop where { .label eq &#39;COUNT&#39; };
    last COUNT;</pre>

<p>and, in fact, you can return a final loop value that way:</p>

<pre>    last COUNT, 42;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Temporization"
>Temporization</a></h2>

<p>The <code>temp</code> function temporarily replaces the value of an existing variable, subroutine, context of a function call, or other object in a given scope:</p>

<pre>    {
       temp $*foo = &#39;foo&#39;;      # Temporarily replace global $foo
       temp &#38;bar := sub {...};  # Temporarily replace sub &#38;bar
       ...
    } # Old values of $*foo and &#38;bar reinstated at this point</pre>

<p><code>temp</code> invokes its argument&#39;s <code>.TEMP</code> method. The method is expected to return a <code>Code</code> object that can later restore the current value of the object. At the end of the lexical scope in which the <code>temp</code> was applied, the subroutine returned by the <code>.TEMP</code> method is executed.</p>

<a href="#" onclick="return tog_quote(30);">
<div ID="header_shown_30" style="display: none;">
- Hide the snippet from t/var/temp.t (line 151 ~ line 173) -
</div>
<div ID="header_hidden_30" style="display: block;">
- Show the snippet from t/var/temp.t (line 151 ~ line 173) -
</div>
</a>
<div ID="hide_30" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S06/&quot;Temporization&quot; /temp invokes its argument's .TEMP method./&gt;
{
&nbsp; my $was_in_own_temp_handler = 0;

&nbsp; class WierdTemp is Int {
&nbsp; &nbsp; method TEMP {
&nbsp; &nbsp; &nbsp; $was_in_own_temp_handler++;
&nbsp; &nbsp; &nbsp; return { $was_in_own_temp_handler++ };
&nbsp; &nbsp; }
&nbsp; }

&nbsp; my $a = WierdTemp.new();
&nbsp; ok defined($a), &quot;instantiating a WierdTemp worked&quot;;
&nbsp; is $was_in_own_temp_handler, 0, &quot;.TEMP method wasn't yet executed&quot;;

&nbsp; {
&nbsp; &nbsp; temp $a;
&nbsp; &nbsp; is $was_in_own_temp_handler, 1, &quot;.TEMP method was executed on temporization&quot;;
&nbsp; }
&nbsp; is $was_in_own_temp_handler, 2, &quot;.TEMP method was executed on restoration&quot;;
}</pre>
</div>


<p>The default <code>.TEMP</code> method for variables simply creates a closure that assigns the variable&#39;s pre-<code>temp</code> value back to the variable.</p>

<p>New kinds of temporization can be created by writing storage classes with their own <code>.TEMP</code> methods:</p>

<pre>    class LoudArray is Array {
        method TEMP {
            print &#34;Replacing $.SKID() at {caller.location}\n&#34;;
            my $restorer = $.SUPER::TEMP();
            return { 
                print &#34;Restoring $.SKID() at {caller.location}\n&#34;;
                $restorer();
            };
        }
    }</pre>

<p>You can also modify the behaviour of temporized code structures, by giving them a <code>TEMP</code> block. As with <code>.TEMP</code> methods, this block is expected to return a closure, which will be executed at the end of the temporizing scope to restore the subroutine to its pre-<code>temp</code> state:</p>

<a href="#" onclick="return tog_quote(31);">
<div ID="header_shown_31" style="display: none;">
- Hide the snippet from t/var/temp.t (line 108 ~ line 150) -
</div>
<div ID="header_hidden_31" style="display: block;">
- Show the snippet from t/var/temp.t (line 108 ~ line 150) -
</div>
</a>
<div ID="hide_31" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S06/&quot;Temporization&quot; /You can also modify the behaviour of temporized code structures/&gt;
# (Test is more or less directly from S06.)
{
&nbsp; my $next &nbsp; &nbsp;= 0;

&nbsp; # Here is the real implementation of &amp;advance.
&nbsp; sub advance() {
&nbsp; &nbsp; my $curr = $next++;
&nbsp; &nbsp; TEMP {{ $next = $curr }} &nbsp;# TEMP block returns the closure { $next = $curr }
&nbsp; &nbsp; return $curr;
&nbsp; };

&nbsp; # and later...

&nbsp; is advance(), 0, &quot;TEMP{} block (1)&quot;;
&nbsp; is advance(), 1, &quot;TEMP{} block (2)&quot;;
&nbsp; is advance(), 2, &quot;TEMP{} block (3)&quot;;
&nbsp; is $next, &nbsp; &nbsp; 3, &quot;TEMP{} block (4)&quot;;

&nbsp; flunk &quot;TEMP{} block (5)&quot;, :todo&lt;feature&gt;;
&nbsp; flunk &quot;TEMP{} block (6)&quot;, :todo&lt;feature&gt;;
&nbsp; flunk &quot;TEMP{} block (7)&quot;, :todo&lt;feature&gt;;
&nbsp; flunk &quot;TEMP{} block (8)&quot;, :todo&lt;feature&gt;;

&nbsp; # Following does parse, but isn't executed (don't know why).
&nbsp; # If the &quot;{&quot; on the following line is changed to &quot;if 1 {&quot;, it is executed,
&nbsp; # too, but then it dies complaining about not finding a matching temp()
&nbsp; # function. &nbsp;So, for now, we just comment the following block and add
&nbsp; # unconditional flunk()s.
&nbsp; #{
&nbsp; # &nbsp;is temp(advance()), 3, &quot;TEMP{} block (5)&quot;, :todo&lt;feature&gt;;
&nbsp; # &nbsp;is $next, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4, &quot;TEMP{} block (6)&quot;, :todo&lt;feature&gt;;
&nbsp; # &nbsp;is temp(advance()), 4, &quot;TEMP{} block (7)&quot;, :todo&lt;feature&gt;;
&nbsp; # &nbsp;is temp(advance()), 5, &quot;TEMP{} block (8)&quot;, :todo&lt;feature&gt;;
&nbsp; #} &nbsp;# $next = 3

&nbsp; is $next, &nbsp; &nbsp; 3, &quot;TEMP{} block (9)&quot;;
&nbsp; is advance(), 3, &quot;TEMP{} block (10)&quot;;
&nbsp; is $next, &nbsp; &nbsp; 4, &quot;TEMP{} block (11)&quot;;
}

# Following are OO tests, but I think they fit better in var/temp.t than in
# oo/.</pre>
</div>


<pre>    my $next = 0;
    sub next {
        my $curr = $next++;
        TEMP {{ $next = $curr }}  # TEMP block returns the closure { $next = $curr }
        return $curr;
    }

    # and later...

    say next();     # prints 0; $next == 1
    say next();     # prints 1; $next == 2
    say next();     # prints 2; $next == 3
    if ($hiccough) {
        say temp next();  # prints 3; closes $curr at 3; $next == 4
        say next();       # prints 4; $next == 5
        say next();       # prints 5; $next == 6
    }                     # $next = 3
    say next();     # prints 3; $next == 4
    say next();     # prints 4; $next == 5</pre>

<p>Hypothetical variables use the same mechanism, except that the restoring closure is called only on failure.</p>

<p>Note that contextual variables may be a better solution than temporized globals in the face of multithreading.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Wrapping"
>Wrapping</a></h2>

<a href="#" onclick="return tog_quote(32);">
<div ID="header_shown_32" style="display: none;">
- Hide the snippet from t/blocks/wrap.t (line 5 ~ line 99) -
</div>
<div ID="header_hidden_32" style="display: block;">
- Show the snippet from t/blocks/wrap.t (line 5 ~ line 99) -
</div>
</a>
<div ID="hide_32" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S06/Wrapping&gt;

# TODO
# named wrapping/unwrapping
# unwrap with no args pops the top most
#
# mutating wraps -- those should be &quot;deep&quot;, as in not touching coderefs
# but actually mutating how the coderef works.
#
# of course, if we allow assigning into coderefs, then the wrap semantic
# could become a simple reassignment; but that is unspecced.

plan 20;

my @log;

sub foo {
&nbsp; &nbsp; push @log, &quot;foo&quot;;
}

sub wrapper {
&nbsp; &nbsp; push @log, &quot;wrapper before&quot;;
&nbsp; &nbsp; try { call };
&nbsp; &nbsp; push @log, &quot;wrapper after&quot;;
}

sub other_wrapper {
&nbsp; &nbsp; push @log, &quot;wrapper2&quot;;
&nbsp; &nbsp; try { call };
}

foo();
is(+@log, 1, &quot;one event logged&quot;);
is(@log[0], &quot;foo&quot;, &quot;it's foo&quot;);

@log = ();

wrapper();
is(+@log, 2, &quot;two events logged&quot;);
is(@log[0], &quot;wrapper before&quot;, &quot;wrapper before&quot;);
is(@log[1], &quot;wrapper after&quot;, &quot;wrapper after&quot;);

@log = ();

my $wrapped;
try {
&nbsp; &nbsp; $wrapped = &amp;foo.wrap(&amp;wrapper);
};

isa_ok($wrapped, &quot;Sub&quot;, :todo);

$wrapped ||= -&gt; { };
try { $wrapped.() };

is(+@log, 3, &quot;three events logged&quot;, :todo);
is(@log[0], &quot;wrapper before&quot;, &quot;wrapper before&quot;, :todo);
is(@log[1], &quot;foo&quot;, &quot;the wrapped sub&quot;, :todo);
is(@log[2], &quot;wrapper after&quot;, &quot;wrapper after&quot;, :todo);

@log = ();

my $doublywrapped;
try {
&nbsp; &nbsp; $doublywrapped = $wrapped.wrap(&amp;other_wrapper);
};

isa_ok($doublywrapped, &quot;Sub&quot;, :todo);
$doublywrapped ||= -&gt; { };
try { $doublywrapped.() };

is(+@log, 4, &quot;four events&quot;, :todo);
is(@log[0], &quot;wrapper2&quot;, &quot;additional wrapping takes effect&quot;, :todo);
is(@log[1], &quot;wrapper before&quot;, &quot;... on top of initial wrapping&quot;, :todo);

@log = ();

try { $wrapped.() };
is(+@log, 3, &quot;old wrapped sub was not destroyed&quot;, :todo);
is(@log[0], &quot;wrapper before&quot;, &quot;the original wrapper is still in effect&quot;, :todo);


@log = ();

my $unwrapped;
try {
&nbsp; &nbsp; $unwrapped = $wrapped.unwrap(&amp;wrapper);
};

isa_ok($unwrapped, &quot;Sub&quot;, :todo);
$unwrapped ||= -&gt; {};
try { $unwrapped.() };

is(+@log, 2, &quot;two events for unwrapped&quot;, :todo);
is(@log[0], &quot;wrapper2&quot;, :todo);
is(@log[1], &quot;foo&quot;, :todo);</pre>
</div>


<p>Every <code>Routine</code> object has a <code>.wrap</code> method. This method expects a single <code>Code</code> argument. Within the code, the special <code>call</code> function will invoke the original routine, but does not introduce a <code>CALLER</code> frame:</p>

<pre>    sub thermo ($t) {...}   # set temperature in Celsius, returns old value

    # Add a wrapper to convert from Fahrenheit...
    $handle = &#38;thermo.wrap( { call( ($^t-32)/1.8 ) } );</pre>

<p>The call to <code>.wrap</code> replaces the original <code>Routine</code> with the <code>Code</code> argument, and arranges that the call to <code>call</code> invokes the previous version of the routine. In other words, the call to <code>.wrap</code> has more or less the same effect as:</p>

<pre>    &#38;old_thermo := &#38;thermo;
    &#38;thermo := sub ($t) { old_thermo( ($t-32)/1.8 ) }</pre>

<p>Except that <code>&#38;thermo</code> is mutated in-place, so <code>&#38;thermo.SKID</code> stays the same after the <code>.wrap</code>.</p>

<p>The call to <code>.wrap</code> returns a unique handle that can later be passed to the <code>.unwrap</code> method, to undo the wrapping:</p>

<pre>    &#38;thermo.unwrap($handle);</pre>

<p>This does not affect any other wrappings placed to the routine.</p>

<p>A wrapping can also be restricted to a particular dynamic scope with temporization:</p>

<pre>    # Add a wrapper to convert from Kelvin
    # wrapper self-unwraps at end of current scope
    temp &#38;thermo.wrap( { call($^t + 273.16) } );</pre>

<p>The entire argument list may be captured by the <code>\$args</code> parameter. It can then be passed to <code>call</code> as <code>*$args</code>:</p>

<pre>    # Double the return value for &#38;thermo
    &#38;thermo.wrap( -&#62; \$args { call(*$args) * 2 } );</pre>

<p>The wrapper is not required to call the original routine; it can call another <code>Code</code> object by passing the <code>Capture</code> to its <code>call</code> method:</p>

<pre>    # Transparently redirect all calls to &#38;thermo to &#38;other_thermo
    &#38;thermo.wrap( -&#62; \$args { &#38;other_thermo.call(*$args) } );</pre>

<p>Outside a wrapper, <code>call</code> implicitly calls the next-most-likely method or multi-sub; see S12 for details.</p>

<p>As with any return value, you may capture the returned <code>Capture</code> of <code>call</code> by binding:</p>

<pre>    my \$retval := call(*$args);
    ... # postprocessing
    return *$retval;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_&#38;?ROUTINE_object"
>The <code>&#38;?ROUTINE</code> object</a></h2>

<a href="#" onclick="return tog_quote(25);">
<div ID="header_shown_25" style="display: none;">
- Hide the snippet from t/magicals/sub.t (line 9 ~ line 14) -
</div>
<div ID="header_hidden_25" style="display: block;">
- Show the snippet from t/magicals/sub.t (line 9 ~ line 14) -
</div>
</a>
<div ID="hide_25" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S06/&quot;The C&lt;&amp;?ROUTINE&gt; object&quot;&gt;

=cut

plan 4;</pre>
</div>


<a href="#" onclick="return tog_quote(24);">
<div ID="header_shown_24" style="display: none;">
- Hide the snippet from t/magicals/sub.t (line 15 ~ line 31) -
</div>
<div ID="header_hidden_24" style="display: block;">
- Show the snippet from t/magicals/sub.t (line 15 ~ line 31) -
</div>
</a>
<div ID="hide_24" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S06/&quot;The C&lt;&amp;?ROUTINE&gt; object&quot;&gt;
# L&lt;S02/&quot;Names&quot; /Which sub am I in/&gt;
sub factorial { @_[0] &lt; 2 ?? 1 !! @_[0] * &amp;?ROUTINE(@_[0] - 1) }

my $result1 = factorial(3);
is($result1, 6, 'the &amp;?ROUTINE magical works correctly');

my $factorial = sub { @_[0] &lt; 2 ?? 1 !! @_[0] * &amp;?ROUTINE(@_[0] - 1) };
my $result2 = $factorial(3);
is($result2, 6, 'the &amp;?ROUTINE magical works correctly in anon-subs');

sub postfix:&lt;!&gt; (Int $n) { $n &lt; 2 ?? 1 !! $n * &amp;?ROUTINE($n - 1) }
my $result3 = 3!;
is($result3, 6, 'the &amp;?ROUTINE magical works correctly in overloaded operators' };

my $baz = try { &amp;?ROUTINE };
ok(!defined($baz), '&amp;?ROUTINE not defined outside of a sub');</pre>
</div>


<p><code>&#38;?ROUTINE</code> is always an alias for the lexically innermost <code>Routine</code> (which may be a <code>Sub</code>, <code>Method</code>, or <code>Submethod</code>), so you can specify tail-recursion on an anonymous sub:</p>

<pre>    my $anonfactorial = sub (Int $n) {
                            return 1 if $n&#60;2;
                            return $n * &#38;?ROUTINE($n-1);
                        };</pre>

<p>You can get the current routine name by calling <code>&#38;?ROUTINE.name</code>. (The outermost routine at a file-scoped compilation unit is always named <code>&#38;MAIN</code> in the file&#39;s package.)</p>

<a href="#" onclick="return tog_quote(23);">
<div ID="header_shown_23" style="display: none;">
- Hide the snippet from t/magicals/subname.t (line 8 ~ line 24) -
</div>
<div ID="header_hidden_23" style="display: block;">
- Show the snippet from t/magicals/subname.t (line 8 ~ line 24) -
</div>
</a>
<div ID="hide_23" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S06/&quot;The C&lt;&amp;?ROUTINE&gt; object&quot; /current routine name/&gt;
# L&lt;S02/&quot;Names&quot; /Which routine am I in/&gt;
sub foo { return &amp;?ROUTINE.name }
is(foo(), '&amp;main::foo', 'got the right routine name in the default package');

{
	# This testcase might be really redundant
&nbsp; &nbsp; package Bar;
&nbsp; &nbsp; sub bar { return &amp;?ROUTINE.name }
	is(bar(), '&amp;Bar::bar', 'got the right routine name outside the default package');
};

my $bar = sub { return &amp;?ROUTINE.name };
is($bar(), '&lt;anon&gt;', 'got the right routine name (anon-block)');

my $baz = try { &amp;?ROUTINE.name };
ok(not(defined $baz), '&amp;?ROUTINE.name not defined outside of a routine');</pre>
</div>


<p>Note that <code>&#38;?ROUTINE</code> refers to the current single sub, even if it is declared &#34;multi&#34;. To redispatch to the entire suite under a given short name, just use the named form, since there are no anonymous multis.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_&#38;?BLOCK_object"
>The <code>&#38;?BLOCK</code> object</a></h2>

<a href="#" onclick="return tog_quote(22);">
<div ID="header_shown_22" style="display: none;">
- Hide the snippet from t/magicals/block.t (line 9 ~ line 14) -
</div>
<div ID="header_hidden_22" style="display: block;">
- Show the snippet from t/magicals/block.t (line 9 ~ line 14) -
</div>
</a>
<div ID="hide_22" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S06/&quot;The C&lt;&amp;?BLOCK&gt; object&quot;&gt;

=cut

plan 1;</pre>
</div>


<p><code>&#38;?BLOCK</code> is always an alias for the current block, so you can specify tail-recursion on an anonymous block:</p>

<pre>    my $anonfactorial = -&#62; Int $n { $n &#60; 2
                                        ?? 1
                                        :: $n * &#38;?BLOCK($n-1)
                                  };</pre>

<p><code>&#38;?BLOCK.label</code> contains the label of the current block, if any.</p>

<p>If the innermost lexical block happens to be the main block of a <code>Routine</code>, then <code>&#38;?BLOCK</code> just returns the <code>Block</code> object, not the <code>Routine</code> object that contains it.</p>

<p>[Note: to refer to any <code>$?</code> or <code>&#38;?</code> variable at the time the sub or block is being compiled, use the <code>COMPILING::</code> pseudopackage.]</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Currying"
>Currying</a></h2>

<p>Every <code>Code</code> object has a <code>.assuming</code> method. This method does a partial binding of a set of arguments to a signature and returns a new function that takes only the remaining arguments.</p>

<pre>    &#38;textfrom := &#38;substr.assuming(str=&#62;$text, len=&#62;Inf);</pre>

<p>or equivalently:</p>

<pre>    &#38;textfrom := &#38;substr.assuming(:str($text) :len(Inf));</pre>

<p>or even:</p>

<pre>    &#38;textfrom := &#38;substr.assuming:str($text):len(Inf);</pre>

<p>It returns a <code>Code</code> object that implements the same behaviour as the original subroutine, but has the values passed to <code>.assuming</code> already bound to the corresponding parameters:</p>

<pre>    $all  = textfrom(0);   # same as: $all  = substr($text,0,Inf);
    $some = textfrom(50);  # same as: $some = substr($text,50,Inf);
    $last = textfrom(-1);  # same as: $last = substr($text,-1,Inf);</pre>

<p>The result of a <code>use</code> statement is a (compile-time) object that also has a <code>.assuming</code> method, allowing the user to bind parameters in all the module&#39;s subroutines/methods/etc. simultaneously:</p>

<a href="#" onclick="return tog_quote(11);">
<div ID="header_shown_11" style="display: none;">
- Hide the snippet from t/blocks/currying.t (line 44 ~ line 71) -
</div>
<div ID="header_hidden_11" style="display: block;">
- Show the snippet from t/blocks/currying.t (line 44 ~ line 71) -
</div>
</a>
<div ID="hide_11" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S06/&quot;Currying&quot; /The result of a use statement/&gt;
try {
(eval('use t::packages::Test') // {}).assuming(arg1 =&gt; &quot;foo&quot;);
}
is try { dummy_sub_with_params(arg2 =&gt; &quot;bar&quot;) }, &quot;[foo] [bar]&quot;,
&nbsp; &quot;(use ...).assuming works&quot;, :todo&lt;feature&gt;;

sub __hyper ($op?, Array @a, Array @b) {
&nbsp; my Array @ret;
&nbsp; for 0..(@a.end, @b.end).max -&gt; $i {
&nbsp; &nbsp; if $i &gt; @a.end {
&nbsp; &nbsp; &nbsp; push @ret, @b[$i];
&nbsp; &nbsp; }
&nbsp; &nbsp; elsif $i &gt; @b.end {
&nbsp; &nbsp; &nbsp; push @ret, @a[$i];
&nbsp; &nbsp; }
&nbsp; &nbsp; else {
&nbsp; &nbsp; &nbsp; push @ret, $op(@a[$i], @b[$i]);
&nbsp; &nbsp; }
&nbsp; }
&nbsp; return @ret;
}

my @x = (1,2,23);
is( try { &amp;__hyper.assuming(op =&gt; &amp;infix:&lt;+&gt;)(@x, @x) },
&nbsp; &nbsp; (2,4,46), 'currying functions with array arguments' );
is( try { &amp;__hyper.assuming(op =&gt; &amp;infix:&lt;+&gt;)(a =&gt; @x, b =&gt; @x) },
&nbsp; &nbsp; (2,4,46), 'currying functions with named array arguments' );</pre>
</div>


<pre>    (use IO::Logging).assuming(logfile =&#62; &#34;.log&#34;);</pre>

<p>This special form should generally be restricted to named parameters.</p>

<p>To curry a particular multimethod it may be necessary to specify the type for one or more of its parameters:</p>

<pre>    &#38;woof ::= &#38;bark:(Dog).assuming :pitch&#60;low&#62;;
    &#38;pine ::= &#38;bark:(Tree).assuming :pitch&#60;yes&#62;;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Macros"
>Macros</a></h2>

<p>Macros are functions or operators that are called by the compiler as soon as their arguments are parsed (if not sooner). The syntactic effect of a macro declaration or importation is always lexically scoped, even if the name of the macro is visible elsewhere. As with ordinary operators, macros may be classified by their grammatical category. For a given grammatical category, a default parsing rule or set of rules is used, but those rules that have not yet been &#34;used&#34; by the time the macro keyword or token is seen can be replaced by use of &#34;is parsed&#34; trait. (This means, for instance, that an infix operator can change the parse rules for its right operand but not its left operand.)</p>

<p>In the absence of a signature to the contrary, a macro is called as if it were a method on the current match object returned from the grammar rule being reduced; that is, all the current parse information is available by treating <code>self</code> as if it were a <code>$/</code> object. [Conjecture: alternate representations may be available if arguments are declared with particular AST types.]</p>

<p>Macros may return either a string to be reparsed, or a syntax tree that needs no further parsing. The textual form is handy, but the syntax tree form is generally preferred because it allows the parser and debugger to give better error messages. Textual substitution on the other hand tends to yield error messages that are opaque to the user. Syntax trees are also better in general because they are reversible, so things like syntax highlighters can get back to the original language and know which parts of the derived program come from which parts of the user&#39;s view of the program. Nevertheless, it&#39;s difficult to return a syntax tree for an unbalanced construct, and in such cases a textual macro may be a clearer expression of the evil thing you&#39;re trying to do.</p>

<p>If you call a macro at runtime, the result of the macro is automatically evaluated again, so the two calls below print the same thing:</p>

<pre>    macro f { &#39;1 + 1&#39; }
    say f();    # compile-time call to &#38;f
    say &#38;f();   # runtime call to &#38;f</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Quasiquoting"
>Quasiquoting</a></h2>

<p>In aid of returning syntax tree, Perl provides a &#34;quasiquoting&#34; mechanism using the quote <code>q:code</code>, followed by a block intended to represent an AST:</p>

<pre>    return q:code { say &#34;foo&#34; };</pre>

<p>Modifiers to the <code>:code</code> adverb can modify the operation:</p>

<pre>    :ast(MyAst)         # Default :ast(AST)
    :lang(Ruby)         # Default :lang($?PARSER)
    :unquote&#60;[: :]&#62;     # Default &#34;triple rule&#34;</pre>

<p>Within a quasiquote, variable and function names resolve according to the lexical scope of the macro definition. Unrecognized symbols raise errors when the macro is being compiled, <i>not</i> when it&#39;s being used.</p>

<p>To make a symbol resolve to the (partially compiled) scope of the macro call, use the <code>COMPILING::</code> pseudo-package:</p>

<pre>    macro moose () { q:code { $COMPILING::x } }

    moose(); # macro-call-time error
    my $x;
    moose(); # resolves to &#39;my $x&#39;</pre>

<p>If you want to mention symbols from the scope of the macro call, use the import syntax as modifiers to <code>:code</code>:</p>

<pre>    :COMPILING&#60;$x&#62;      # $x always refers to $x in caller&#39;s scope
    :COMPILING          # All free variables fallback to caller&#39;s scope</pre>

<p>If those symbols do not exist in the scope of the compiling scope, a compile-time exception is thrown at macro call time.</p>

<p>Similarly, in the macro body you may either refer to the <code>$x</code> declared in the scope of the macro call as <code>$COMPILING::x</code>, or bind to them explicitly:</p>

<pre>    my $x := $COMPILING::x;</pre>

<p>You may also use an import list to bind multiple symbols into the macro&#39;s lexical scope:</p>

<pre>    require COMPILING &#60;$x $y $z&#62;;</pre>

<p>Note that you need to use the run-time <code>:=</code> and <code>require</code> forms, not <code>::=</code> and <code>use</code>, because the macro caller&#39;s compile-time is the macro&#39;s runtime.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Splicing"
>Splicing</a></h2>

<p>Bare AST variables (such as the arguments to the macro) may not be spliced directly into a quasiquote because they would be taken as normal bindings. Likewise, program text strings to be inserted need to be specially marked or they will be bound normally. To insert a &#34;unquoted&#34; expression of either type within a quasiquote, use the quasiquote delimiter tripled, typically a bracketing quote of some sort:</p>

<pre>    return q:code { say $a + {{{ $ast }}} }
    return q:code [ say $a + [[[ $ast ]]] ]
    return q:code &#60; say $a + &#60;&#60;&#60; $ast &#62;&#62;&#62; &#62;
    return q:code ( say $a + ((( $ast ))) )</pre>

<p>The delimiters don&#39;t have to be bracketing quotes, but the following is probably to be construed as Bad Style:</p>

<pre>    return q:code / say $a + /// $ast /// /</pre>

<p>(Note to implementors: this must not be implemented by finding the final closing delimiter and preprocessing, or we&#39;ll violate our one-pass parsing rule. Perl 6 parsing rules are parameterized to know their closing delimiter, so adding the opening delimiter should not be a hardship. Alternately the opening delimiter can be deduced from the closing delimiter. Writing a rule that looks for three opening delimiters in a row should not be a problem. It has to be a special grammar rule, though, not a fixed token, since we need to be able to nest code blocks with different delimiters. Likewise when parsing the inner expression, the inner parser subrule is parameterized to know that <code>}}}</code> or whatever is its closing delimiter.)</p>

<p>Unquoted expressions are inserted appropriately depending on the type of the variable, which may be either a syntax tree or a string. (Again, syntax tree is preferred.) The case is similar to that of a macro called from within the quasiquote, insofar as reparsing only happens with the string version of interpolation, except that such a reparse happens at macro call time rather than macro definition time, so its result cannot change the parser&#39;s expectations about what follows the interpolated variable.</p>

<p>Hence, while the quasiquote itself is being parsed, the syntactic interpolation of a unquoted expression into the quasiquote always results in the expectation of an operator following the variable. (You must use a call to a submacro if you want to expect something else.) Of course, the macro definition as a whole can expect whatever it likes afterwards, according to its syntactic category. (Generally, a term expects a following postfix or infix operator, and an operator expects a following term or prefix operator. This does not matter for textual macros, however, since the reparse of the text determines subsequent expectations.)</p>

<p>Quasiquotes default to hygienic lexical scoping, just like closures. The visibility of lexical variables is limited to the q:code expression by default. A variable declaration can be made externally visible using the <code>COMPILING::</code> pseudo-package. Individual variables can be made visible, or all top-level variable declarations can be exposed using the <code>q:code(:COMPILING)</code> form.</p>

<p>Both examples below will add <code>$new_variable</code> to the lexical scope of the macro call:</p>

<pre>  q:code {  my $COMPILING::new_variable;   my $private_var; ... }
  q:code(:COMPILING) { my $new_variable; { my $private_var; ... } }</pre>

<p>(Note that <code>:COMPILING</code> has additional effects described in <a href="http://search.cpan.org/perldoc?Macros" class="podlinkpod"
>Macros</a>.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Other_matters"
>Other matters</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Anonymous_hashes_vs_blocks"
>Anonymous hashes vs blocks</a></h2>

<p><code>{...}</code> is always a block. However, if it is completely empty or consists of a single list, the first element of which is either a hash or a pair, it is executed immediately to compose a Hash object.</p>

<p>The standard <code>pair</code> list operator is equivalent to:</p>

<pre>    sub pair (*@LIST) {
        my @pairs;
        for @LIST -&#62; $key, $val {
            push @pairs, $key =&#62; $val;
        }
        return @pairs;
    }</pre>

<p>or more succinctly (and lazily):</p>

<pre>    sub pair (*@LIST) {
        gather {
            for @LIST -&#62; $key, $val {
                take $key =&#62; $val;
            }
        }
    }</pre>

<p>The standard <code>hash</code> list operator is equivalent to:</p>

<pre>    sub hash (*@LIST) {
        return { pair @LIST };
    }</pre>

<p>So you may use <code>sub</code> or <code>hash</code> or <code>pair</code> to disambiguate:</p>

<a href="#" onclick="return tog_quote(18);">
<div ID="header_shown_18" style="display: none;">
- Hide the snippet from t/data_types/hash_ref.t (line 74 ~ line 92) -
</div>
<div ID="header_hidden_18" style="display: block;">
- Show the snippet from t/data_types/hash_ref.t (line 74 ~ line 92) -
</div>
</a>
<div ID="hide_18" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S06/&quot;Anonymous hashes vs blocks&quot; /So you may use sub or hash or pair to disambiguate:/&gt;
{
&nbsp; my $hash_a = { a =&gt; 1, b =&gt; 2 }; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;isa_ok $hash_a, &quot;Hash&quot;;
&nbsp; my $hash_b = { a =&gt; 1, &quot;b&quot;, 2 }; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;isa_ok $hash_b, &quot;Hash&quot;;
&nbsp; my $hash_c = hash('a', 1, &quot;b&quot;, 2); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;isa_ok $hash_c, &quot;Hash&quot;;
&nbsp; my $hash_d = hash 'a', 1, &quot;b&quot;, 2; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isa_ok $hash_d, &quot;Hash&quot;;
&nbsp; my $hash_e = { pair &quot;a&quot;, 1, &quot;b&quot;, 2 }; &nbsp; &nbsp; &nbsp; &nbsp; isa_ok $hash_e, &quot;Hash&quot;;
}

# infinity HoHoHoH...
{
&nbsp; my %hash = (val =&gt; 42);
&nbsp; %hash&lt;ref&gt; = \%hash;
&nbsp; isa_ok %hash, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;Hash&quot;;
&nbsp; isa_ok %hash&lt;ref&gt;, &nbsp; &nbsp; &nbsp;&quot;Hash&quot;;
&nbsp; isa_ok %hash&lt;ref&gt;&lt;ref&gt;, &quot;Hash&quot;;
&nbsp; is %hash&lt;ref&gt;&lt;val&gt;, &nbsp; &nbsp; &nbsp;42, &quot;access to infinite HoHoHoH... (1)&quot;;
&nbsp; is %hash&lt;ref&gt;&lt;ref&gt;&lt;val&gt;, 42, &quot;access to infinite HoHoHoH... (2)&quot;;
}</pre>
</div>


<pre>    $ref =  sub { 1, 2, 3, 4, 5, 6 };   # Anonymous sub returning list
    $ref =      { 1, 2, 3, 4, 5, 6 };   # Anonymous sub returning list
    $ref =      { 1=&#62;2, 3=&#62;4, 5=&#62;6 };   # Anonymous hash
    $ref =      { 1=&#62;2, 3, 4, 5, 6 };   # Anonymous hash
    $ref =  hash( 1, 2, 3, 4, 5, 6 );   # Anonymous hash
    $ref =  hash  1, 2, 3, 4, 5, 6  ;   # Anonymous hash
    $ref = { pair 1, 2, 3, 4, 5, 6 };   # Anonymous hash</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Pairs_as_lvalues"
>Pairs as lvalues</a></h2>

<p>Pairs can be used as lvalues. The value of the pair is the recipient of the assignment:</p>

<pre>    (key =&#62; $var) = &#34;value&#34;;</pre>

<p>When binding pairs, names can be used to &#34;match up&#34; lvalues and rvalues, provided you write the left side as a signature using <code>:(...)</code> notation:</p>

<pre>    :(:who($name), :why($reason)) := (why =&#62; $because, who =&#62; &#34;me&#34;);</pre>

<p>(Otherwise the parser doesn&#39;t know it should parse the insides as a signature and not as an ordinary expression until it gets to the <code>:=</code>, and that would be bad. Possibly we should require a &#34;<code>my</code>&#34; out front as well...)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Out-of-scope_names"
>Out-of-scope names</a></h2>

<p><code>GLOBAL::&#60;$varname&#62;</code> specifies the <code>$varname</code> declared in the <code>*</code> namespace. Or maybe it&#39;s the other way around...</p>

<p><code>CALLER::&#60;$varname&#62;</code> specifies the <code>$varname</code> visible in the dynamic scope from which the current block/closure/subroutine was called, provided that variable is declared with the &#34;<code>is context</code>&#34; trait. (Implicit lexicals such as <code>$_</code> are automatically assumed to be contextual.)</p>

<p><code>CONTEXT::&#60;$varname&#62;</code> specifies the <code>$varname</code> visible in the innermost dynamic scope that declares the variable with the &#34;<code>is context</code>&#34; trait.</p>

<p><code>MY::&#60;$varname&#62;</code> specifies the lexical <code>$varname</code> declared in the current lexical scope.</p>

<p><code>OUR::&#60;$varname&#62;</code> specifies the <code>$varname</code> declared in the current package&#39;s namespace.</p>

<p><code>COMPILING::&#60;$varname&#62;</code> specifies the <code>$varname</code> declared (or about to be declared) in the lexical scope currently being compiled.</p>

<p><code>OUTER::&#60;$varname&#62;</code> specifies the <code>$varname</code> declared in the lexical scope surrounding the current lexical scope (i.e. the scope in which the current block was defined).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Declaring_a_MAIN_subroutine"
>Declaring a <code>MAIN</code> subroutine</a></h2>

<p>Ordinarily a top-level Perl &#34;script&#34; just evaluates its anonymous mainline code and exits. During the mainline code, the program&#39;s arguments are available in raw form from the <code>@ARGS</code> array. At the end of the mainline code, however, a <code>MAIN</code> subroutine will be called with whatever command-line arguments remain in <code>@ARGS</code>. This call is performed if and only if:</p>

<dl>
<dt><a name="a)"
>a)</a></dt>

<dd>
<p>the compilation unit was directly invoked rather than by being required by another compilation unit, and</p>

<dt><a name="b)"
>b)</a></dt>

<dd>
<p>the compilation unit declares a <code>Routine</code> named &#34;<code>MAIN</code>&#34;, and</p>

<dt><a name="c)"
>c)</a></dt>

<dd>
<p>the mainline code is not terminated prematurely, such as with an explicit call to <code>exit</code>, or an uncaught exception.</p>
</dd>
</dl>

<p>The command line arguments (or what&#39;s left of them after mainline processing) is magically converted into a <code>Capture</code> and passed to <code>MAIN</code> as its arguments, so switches may be bound as named args and other arguments to the program may be bound to positional parameters or the slurpy array:</p>

<pre>    sub MAIN ($directory, :$verbose, *%other, *@filenames) {
        for @filenames { ... }
    }</pre>

<p>If <code>MAIN</code> is declared as a set of multi subs, MMD dispatch is performed.</p>

<p>As with module and class declarations, a sub declaration ending in semicolon is allowed at the outermost file scope if it is the first such declaration, in which case the rest of the file is the body:</p>

<pre>    sub MAIN ($directory, :$verbose, *%other, *@filenames);
    for @filenames { ... }</pre>

<p>This form is allowed only for simple subs named <code>MAIN</code> that are intended to be run from the command line. Proto or multi definitions may not be written in semicolon form, nor may <code>MAIN</code> subs within a module or class. (A <code>MAIN</code> routine is allowed in a module or class, but is not usually invoked unless the file is run directly (see a above). This corresponds to the &#34;unless caller&#34; idiom of Perl 5.) In general, you may have only one semicolon-style declaration that controls the whole file.</p>

<p>If the dispatch to <code>MAIN</code> fails the <code>USAGE</code> routine is called. If there is no such routine, a default message is printed. This usage message is automatically generated from the signature (or signatures) of <code>MAIN</code>. This message is generated at compile time, and hence is available at &#34;mainline&#34; time as the rw property <code>&#38;USAGE.text</code>. You may also access it from your own <code>USAGE</code> routine.</p>

<p>Common Unix command-line conventions are mapped onto the capture as follows:</p>

<pre>     On command line...         $ARGS capture gets...

    -name                      :name
    -name=value                :name&#60;value&#62;
    -name=&#34;spacy value&#34;        :name&#171;&#39;spacy value&#39;&#187;
    -name=&#39;spacy value&#39;        :name&#171;&#39;spacy value&#39;&#187;
    -name=val1,&#39;val 2&#39;, etc    :name&#171;val1 &#39;val 2&#39; etc&#187;

    --name                     :name            # only if declared Bool
    --name=value               :name&#60;value&#62;     # don&#39;t care
    --name value               :name&#60;value&#62;     # only if not declared Bool

    --name=&#34;spacy value&#34;       :name&#171;&#39;spacy value&#39;&#187;
    --name &#34;spacy value&#34;       :name&#171;&#39;spacy value&#39;&#187;
    --name=&#39;spacy value&#39;       :name&#171;&#39;spacy value&#39;&#187;
    --name &#39;spacy value&#39;       :name&#171;&#39;spacy value&#39;&#187;
    --name=val1,&#39;val 2&#39;, etc   :name&#171;val1 &#39;val 2&#39; etc&#187;
    --name val1 &#39;val 2&#39; etc    :name&#171;val1 &#39;val 2&#39; etc&#187; # only if declared @
    --                                 # end named argument processing

    +name                      :!name
    +name=value                :name&#60;value&#62; but False
    +name=&#34;spacy value&#34;        :name&#171;&#39;spacy value&#39;&#187; but False
    +name=&#39;spacy value&#39;        :name&#171;&#39;spacy value&#39;&#187; but False
    +name=val1,&#39;val 2&#39;, etc    :name&#171;val1 &#39;val 2&#39; etc&#187; but False

    :name                      :name
    :!name                     :!name   # potential conflict with ! histchar
    :/name                     :!name   # potential workaround?
    :name=value                :name&#60;value&#62;
    :name=&#34;spacy value&#34;        :name&#171;&#39;spacy value&#39;&#187;
    :name=&#39;spacy value&#39;        :name&#171;&#39;spacy value&#39;&#187;
    :name=val1,&#39;val 2&#39;, etc    :name&#171;val1 &#39;val 2&#39; etc&#187;</pre>

<p>Exact Perl 6 forms are okay if quoted from shell processing:</p>

<pre>    &#39;:name&#60;value&#62;&#39;             :name&#60;value&#62;
    &#39;:name(42)&#39;                :name(42)</pre>

<p>For security reasons, only constants are allowed as arguments, however.</p>

<p>The default <code>Capture</code> mapper pays attention to declaration of <code>MAIN</code>&#39;s parameters to resolve certain ambiguities. A <code>--foo</code> switch needs to know whether to treat the next word from the command line as an argument. (Allowing the spacey form gives the shell room to do various things to the argument.) The short <code>-foo</code> form never assumes a separate argument, and you must use <code>=</code>. For the <code>--foo</code> form, if there is a named parameter corresponding to the switch name, and it is of type <code>Bool</code>, then no argument is expected. Otherwise an argument is expected. If the parameter is of a non-slurpy array type, all subsequent words up to the next command-line switch (or the end of the list) are bound to that parameter.</p>

<p>As usual, switches are assumed to be first, and everything after the first non-switch, or any switches after a <code>--</code>, are treated as positionals or go into the slurpy array (even if they look like switches). Other policies may easily be introduced by calling <code>MAIN</code> explicitly. For instance, you can parse your arguments with a grammar and pass the resulting <code>Match</code> object as a <code>Capture</code> to <code>MAIN</code>:</p>

<pre>    @*ARGS ~~ /&#60;MyGrammar::top&#62;/;
    MAIN([,] =$/);
    exit;

    sub MAIN ($frompart, $topart, *@rest) {
        if $frompart&#60;foo&#62; { ... }
        if $topart&#60;bar&#62;&#60;baz&#62; { ... }
    }</pre>

<p>This will conveniently bind top-level named matches to named parameters, but still give you access to nested matches through those parameters, just as any <code>Match</code> object would. Of course, in this example, there&#39;s no particular reason the sub has to be named <code>MAIN</code>.</p>

<p>To give both a long and a short switch name, you may use the pair notation. The key will be considered the short switch name, while the variable name will be considered the long switch name. So if the previous declaration had been:</p>

<pre>    sub MAIN (:f($frompart), :t($topart), *@rest)</pre>

<p>then you could invoke the program with either <code>-f</code> or <code>--frompart</code> to specify the first parameter. Likewise you could use either <code>-t</code> or <code>--topart</code> for the second parameter.</p>

<p>If a switch of the form <code>-abc</code> cannot be matched against any particular parameter, an attempt will be made to match it as if it had been written <code>-a -b -c</code>.</p>

<!-- end doc -->

</body></html>
