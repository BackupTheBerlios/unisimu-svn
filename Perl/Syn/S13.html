<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>S13</title>
<link rel="stylesheet" href="http://dev.perl.org/css/perl.css" type="text/css" />
<meta HTTP-EQUIV="content-type" CONTENT="text/html; charset=UTF-8" />
<link rev="made" href="mailto:" />
<script type="text/javascript"><!--
var agt = navigator.userAgent.toLowerCase();

var is_opera = (agt.indexOf("opera") != -1);
var is_ie = (agt.indexOf("msie") != -1) && document.all && !is_opera;
var is_ie5 = (agt.indexOf("msie 5") != -1) && document.all;

function tog() {
  // tog: toggle the visibility of html elements (arguments[1..]) from none to
  // arguments[0].  Return what should be returned in a javascript onevent().
  display = arguments[0];
  for( var i=1; i<arguments.length; i++ ) {    
    var x = document.getElementById(arguments[i]);
    if (!x) continue;
    if (x.style.display == "none" || x.style.display == "") {
      x.style.display = display;
    } else {
      x.style.display = "none";
    }
  } 

  var e = is_ie ? window.event : this;
  if (e) {
    if (is_ie) {
      e.cancelBubble = true;
      e.returnValue = false;
      return false;
    } else {
      return false;
    }
  }
}

function tog_quote( idnum ) {
  return tog( 'block', 'header_shown_' + idnum, 'header_hidden_' + idnum,
	   'hide_' + idnum );
}

//--></script>
</head>

<body>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" valign="middle">
<big><strong><span class="block">&nbsp;TITLE</span></strong></big>
</td></tr>
</table>

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#TITLE">TITLE</a></li>
	<li><a href="#AUTHOR">AUTHOR</a></li>
	<li><a href="#VERSION">VERSION</a></li>
	<li><a href="#Overview">Overview</a></li>
	<li><a href="#Multiple20dispatch">Multiple dispatch</a></li>
	<li><a href="#Syntax">Syntax</a></li>
	<li><a href="#Fallbacks">Fallbacks</a></li>
	<li><a href="#Type20Casting">Type Casting</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="TITLE">TITLE</a></h1>
<p>Synopsis 13: Overloading</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="AUTHOR">AUTHOR</a></h1>
<p>Larry Wall &lt;<a href="mailto:larry@wall.org">larry@wall.org</a>&gt;</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="VERSION">VERSION</a></h1>
<pre>
  Maintainer: Larry Wall &lt;larry@wall.org&gt;
  Date: 2 Nov 2004
  Last Modified: 18 Aug 2006
  Number: 13
  Version: 5</pre>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Overview">Overview</a></h1>
<p>This synopsis discusses those portions of Apocalypse 12 that ought to have
been in Apocalypse 13.</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Multiple20dispatch">Multiple dispatch</a></h1>
<p>The overloading mechanism of Perl 5 has been superseded by Perl
6's multiple dispatch mechanism.  Nearly all internal functions
are defined as <code>multi</code> subs or <code>multi</code> methods on generic types.
Built-in operators are merely oddly named functions with an alternate
call syntax.  All you have to do to overload them is to define your
own <code>multi</code> subs and methods that operate on arguments with more
specific types.</p>
<p>For unary operators, this makes little effective difference, but for
binary operators, multiple dispatch fixes the Perl 5 problem of paying
attention only to the type of the left argument.  Since both argument
types are used in deciding which routine to call, there is no longer
any trickery involving swapping the arguments to use the right argument's
type instead of the left one.  And there's no longer any need to
examine a special flag to see if the arguments were reversed.</p>
<p>For much more about multiple dispatch, see S12.</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Syntax">Syntax</a></h1>
<p>There is no longer any special <code>use overload</code> syntax separate from the
declarations of the <code>multi</code> routines themselves.  To overload an
existing built-in sub, say something like:</p>
<pre>
    multi sub *uc (TurkishStr $s) {...}</pre>
<p>Now if you call <code>uc()</code> on any Turkish string, it will call your function
rather than the built-in one.  Putting the <code>multi</code> into the <code>*</code>
namespace makes it show up in everyone's packages, but as long as no one
else defines a version of <code>uc</code> on <code>TurkishStr</code>, there's no collision.</p>
<p>The types of the parameters are included in the <em>longname</em> of any <code>multi</code>
sub or method.  So if you want to overload string concatenation for Arabic
strings so you can handle various ligatures, you can say:</p>
<pre>
    multi sub *infix:&lt;~&gt;(ArabicStr $s1, ArabicStr $s2) {...}
    multi sub *infix:&lt;~&gt;(Str $s1, ArabicStr $s2) {...}
    multi sub *infix:&lt;~&gt;(ArabicStr $s1, Str $s2) {...}</pre>
<p>Binary operators may be declared as commutative:</p>
<pre>
    multi sub infix:&lt;+&gt; (Us $us, Them $them) is commutative { myadd($us,$them) }</pre>
<p>That's equivalent to:</p>
<pre>
    multi sub infix:&lt;+&gt; (Us $us, Them $them) { myadd($us,$them) }
    multi sub infix:&lt;+&gt; (Them $them, Us $us) { myadd($us,$them) }</pre>
<p>Note the lack of <code>*</code> on those definitions.  That means this definition
of addition is only in effect within the scope of the package in which
<code>infix:&lt;+&gt;</code> is defined.  Similar constraints apply to lexically scoped
multi subs.  Generally you want to put your multi subs into the <code>*</code>
space, however, so that they work everywhere.</p>
<p>The <code>use overload</code> syntax had one benefit over Perl 6's syntax in that
it was easy to alias several different operators to the same service
routine.  This can easily be handled with Perl 6's aliasing:</p>
<a name="msg_1"></a>
<a href="?hide_quotes=no#msg_1" onclick="return tog_quote(1);">
<div ID="header_shown_1" style="display: none;">
- Hide the snippet from t/oo/methods/ref.t (line 7 ~ line 33) -
</div>
<div ID="header_hidden_1" style="display: block;">
- Show the snippet from t/oo/methods/ref.t (line 7 ~ line 33, 27 lines) -
</div>
</a>
<div ID="hide_1" style="display:none; border:1px solid">
<pre>
# L&lt;S13/"Syntax" /This can easily be handled with Perl 6's aliasing:/&gt;

class Foo {
  method bar()     { 42 }
  method bar_ref() { &amp;bar }
}

{
  my $foo = Foo.new;
  lives_ok { $foo.bar_ref }, "returning a method reference works";
}

try {
  class Baz {
    method bar() { 42 }
    our &amp;baz ::= &amp;bar;
  }
};

{
  my $ret;
  lives_ok {
    my $baz = Baz.new;
    $ret    = $baz.baz();
  }, "calling an aliased method worked";
  is $ret, 42, "the aliased method returned the right thing";
}

</pre>
</div>

<pre>
    multi sub unimpl (MyFoo $x, MyFoo $y) { upchuck(); }
    &amp;infix:&lt;+&gt; ::= &amp;unimpl;
    &amp;infix:&lt;-&gt; ::= &amp;unimpl;
    &amp;infix:&lt;*&gt; ::= &amp;unimpl;
    &amp;infix:&lt;/&gt; ::= &amp;unimpl;</pre>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Fallbacks">Fallbacks</a></h1>
<p>Dispatch is based on a routine's signature declaration without regard
to whether the routine is defined yet.  If an attempt is made to
dispatch to a declared but undefined routine, Perl will redispatch
to an <code>AUTODEF</code> submethod [conjectural] as appropriate to define the routine.  This provides
a run-time mechanism for fallbacks.  By default, these declarations
are taken at face value and do not specify any underlying semantics.
As such, they're a ``shallow'' interpretation.</p>
<p>However, sometimes you want to specify a ``deep'' interpretation of
your operators.  That is, you're specifying the abstract operation,
which may be used by various shallow operators.  Any deep multi
declarations will be ``amplified'' into all the shallow operators that
can be logically based on it.  If you say:</p>
<pre>
    multi sub infix:&lt;%&gt; (Us $us, Them $them) is deep { mymod($us,$them) }</pre>
<p>then</p>
<pre>
    multi sub infix:&lt;%=&gt; (Us $us, Them $them) { $us = $us % $them }</pre>
<p>is also generated for you (unless you define it yourself).
The mappings of magical names to sub definitions is controlled by the
<code>%?DEEPMAGIC</code> compiler hash.  Pragmas can influence the contents of
this hash over a lexical scope, so you could have different policies
on magical autogeneration.  The default mappings correspond to the
standard fallback mappings of Perl 5 overloading.</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Type20Casting">Type Casting</a></h1>
<p>A class can use the <code>*infix:&lt;as&gt;</code> submethod to declare that its objects
can be cast to some other class:</p>
<pre>
    multi submethod *infix:&lt;as&gt; (IO)  { $*OUT }
    multi submethod *infix:&lt;as&gt; (Int) { 1 }
    multi submethod *infix:&lt;as&gt; (Str) { &quot;Hello&quot; }</pre>
<p>With the above declaration, <code>$obj as &quot;foo&quot;</code> is equivalent to <code>$obj as Str</code>,
because the multi dispatch cares only about the class.</p>
<p><a href="#__index__"><small>Back to Top</small></a></p>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" valign="middle">
<big><strong><span class="block">&nbsp;TITLE</span></strong></big>
</td></tr>
</table>

</body>

</html>
