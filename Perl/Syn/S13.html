<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
           "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>S13</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="http://dev.perl.org/css/perl.css">

<script type="text/javascript">
var agt = navigator.userAgent.toLowerCase();

var is_opera = (agt.indexOf("opera") != -1);
var is_ie = (agt.indexOf("msie") != -1) && document.all && !is_opera;
var is_ie5 = (agt.indexOf("msie 5") != -1) && document.all;

function tog() {
  // tog: toggle the visibility of html elements (arguments[1..]) from none to
  // arguments[0].  Return what should be returned in a javascript onevent().
  display = arguments[0];
  for( var i=1; i<arguments.length; i++ ) {
    var x = document.getElementById(arguments[i]);
    if (!x) continue;
    if (x.style.display == "none" || x.style.display == "") {
      x.style.display = display;
    } else {
      x.style.display = "none";
    }
  }

  var e = is_ie ? window.event : this;
  if (e) {
    if (is_ie) {
      e.cancelBubble = true;
      e.returnValue = false;
      return false;
    } else {
      return false;
    }
  }
}

function tog_quote( idnum ) {
  return tog( 'block', 'header_shown_' + idnum, 'header_hidden_' + idnum,
       'hide_' + idnum );
}

</script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.03,
  using Pod::Simple::PullParser v2.02,
  under Perl v5.008007 at Wed Aug 23 14:43:20 2006 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Overview'>Overview</a>
  <li class='indexItem indexItem1'><a href='#Multiple_dispatch'>Multiple dispatch</a>
  <li class='indexItem indexItem1'><a href='#Syntax'>Syntax</a>
  <li class='indexItem indexItem1'><a href='#Fallbacks'>Fallbacks</a>
  <li class='indexItem indexItem1'><a href='#Type_Casting'>Type Casting</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 13: Overloading</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Larry Wall &#60;larry@wall.org&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre>  Maintainer: Larry Wall &#60;larry@wall.org&#62;
  Date: 2 Nov 2004
  Last Modified: 18 Aug 2006
  Number: 13
  Version: 5</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Overview"
>Overview</a></h1>

<p>This synopsis discusses those portions of Apocalypse 12 that ought to have been in Apocalypse 13.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Multiple_dispatch"
>Multiple dispatch</a></h1>

<p>The overloading mechanism of Perl 5 has been superseded by Perl 6&#39;s multiple dispatch mechanism. Nearly all internal functions are defined as <code>multi</code> subs or <code>multi</code> methods on generic types. Built-in operators are merely oddly named functions with an alternate call syntax. All you have to do to overload them is to define your own <code>multi</code> subs and methods that operate on arguments with more specific types.</p>

<p>For unary operators, this makes little effective difference, but for binary operators, multiple dispatch fixes the Perl 5 problem of paying attention only to the type of the left argument. Since both argument types are used in deciding which routine to call, there is no longer any trickery involving swapping the arguments to use the right argument&#39;s type instead of the left one. And there&#39;s no longer any need to examine a special flag to see if the arguments were reversed.</p>

<p>For much more about multiple dispatch, see S12.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Syntax"
>Syntax</a></h1>

<p>There is no longer any special <code>use overload</code> syntax separate from the declarations of the <code>multi</code> routines themselves. To overload an existing built-in sub, say something like:</p>

<pre>    multi sub *uc (TurkishStr $s) {...}</pre>

<p>Now if you call <code>uc()</code> on any Turkish string, it will call your function rather than the built-in one. Putting the <code>multi</code> into the <code>*</code> namespace makes it show up in everyone&#39;s packages, but as long as no one else defines a version of <code>uc</code> on <code>TurkishStr</code>, there&#39;s no collision.</p>

<p>The types of the parameters are included in the <i>longname</i> of any <code>multi</code> sub or method. So if you want to overload string concatenation for Arabic strings so you can handle various ligatures, you can say:</p>

<pre>    multi sub *infix:&#60;~&#62;(ArabicStr $s1, ArabicStr $s2) {...}
    multi sub *infix:&#60;~&#62;(Str $s1, ArabicStr $s2) {...}
    multi sub *infix:&#60;~&#62;(ArabicStr $s1, Str $s2) {...}</pre>

<p>Binary operators may be declared as commutative:</p>

<pre>    multi sub infix:&#60;+&#62; (Us $us, Them $them) is commutative { myadd($us,$them) }</pre>

<p>That&#39;s equivalent to:</p>

<pre>    multi sub infix:&#60;+&#62; (Us $us, Them $them) { myadd($us,$them) }
    multi sub infix:&#60;+&#62; (Them $them, Us $us) { myadd($us,$them) }</pre>

<p>Note the lack of <code>*</code> on those definitions. That means this definition of addition is only in effect within the scope of the package in which <code>infix:&#60;+&#62;</code> is defined. Similar constraints apply to lexically scoped multi subs. Generally you want to put your multi subs into the <code>*</code> space, however, so that they work everywhere.</p>

<p>The <code>use overload</code> syntax had one benefit over Perl 6&#39;s syntax in that it was easy to alias several different operators to the same service routine. This can easily be handled with Perl 6&#39;s aliasing:</p>

<a name="msg_1"></a>
<a href="?hide_quotes=no#msg_1" onclick="return tog_quote(1);">
<div ID="header_shown_1" style="display: none;">
- Hide the snippet from t/oo/methods/ref.t (line 7 ~ line 33) -
</div>
<div ID="header_hidden_1" style="display: block;">
- Show the snippet from t/oo/methods/ref.t (line 7 ~ line 33, 27 lines) -
</div>
</a>
<div ID="hide_1" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S13/"Syntax" /This can easily be handled with Perl 6's aliasing:/&gt;

class Foo {
  method bar()     { 42 }
  method bar_ref() { &amp;bar }
}

{
  my $foo = Foo.new;
  lives_ok { $foo.bar_ref }, "returning a method reference works";
}

try {
  class Baz {
    method bar() { 42 }
    our &amp;baz ::= &amp;bar;
  }
};

{
  my $ret;
  lives_ok {
    my $baz = Baz.new;
    $ret    = $baz.baz();
  }, "calling an aliased method worked";
  is $ret, 42, "the aliased method returned the right thing";
}</pre>
</div>


<pre>    multi sub unimpl (MyFoo $x, MyFoo $y) { upchuck(); }
    &#38;infix:&#60;+&#62; ::= &#38;unimpl;
    &#38;infix:&#60;-&#62; ::= &#38;unimpl;
    &#38;infix:&#60;*&#62; ::= &#38;unimpl;
    &#38;infix:&#60;/&#62; ::= &#38;unimpl;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Fallbacks"
>Fallbacks</a></h1>

<p>Dispatch is based on a routine&#39;s signature declaration without regard to whether the routine is defined yet. If an attempt is made to dispatch to a declared but undefined routine, Perl will redispatch to an <code>AUTODEF</code> submethod [conjectural] as appropriate to define the routine. This provides a run-time mechanism for fallbacks. By default, these declarations are taken at face value and do not specify any underlying semantics. As such, they&#39;re a &#34;shallow&#34; interpretation.</p>

<p>However, sometimes you want to specify a &#34;deep&#34; interpretation of your operators. That is, you&#39;re specifying the abstract operation, which may be used by various shallow operators. Any deep multi declarations will be &#34;amplified&#34; into all the shallow operators that can be logically based on it. If you say:</p>

<pre>    multi sub infix:&#60;%&#62; (Us $us, Them $them) is deep { mymod($us,$them) }</pre>

<p>then</p>

<pre>    multi sub infix:&#60;%=&#62; (Us $us, Them $them) { $us = $us % $them }</pre>

<p>is als