<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>S02</title>
<link rel="stylesheet" href="http://dev.perl.org/css/perl.css" type="text/css" />
<meta HTTP-EQUIV="content-type" CONTENT="text/html; charset=UTF-8" />
<link rev="made" href="mailto:" />
<script type="text/javascript"><!--
var agt = navigator.userAgent.toLowerCase();

var is_opera = (agt.indexOf("opera") != -1);
var is_ie = (agt.indexOf("msie") != -1) && document.all && !is_opera;
var is_ie5 = (agt.indexOf("msie 5") != -1) && document.all;

function tog() {
  // tog: toggle the visibility of html elements (arguments[1..]) from none to
  // arguments[0].  Return what should be returned in a javascript onevent().
  display = arguments[0];
  for( var i=1; i<arguments.length; i++ ) {
    var x = document.getElementById(arguments[i]);
    if (!x) continue;
    if (x.style.display == "none" || x.style.display == "") {
      x.style.display = display;
    } else {
      x.style.display = "none";
    }
  }

  var e = is_ie ? window.event : this;
  if (e) {
    if (is_ie) {
      e.cancelBubble = true;
      e.returnValue = false;
      return false;
    } else {
      return false;
    }
  }
}

function tog_quote( idnum ) {
  return tog( 'block', 'header_shown_' + idnum, 'header_hidden_' + idnum,
       'hide_' + idnum );
}

//--></script>
</head>

<body>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" valign="middle">
<big><strong>S02</strong></big>
</td></tr>
</table>

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#TITLE">TITLE</a></li>
	<li><a href="#AUTHOR">AUTHOR</a></li>
	<li><a href="#VERSION">VERSION</a></li>
	<li><a href="#Lexical20Conventions">Lexical Conventions</a></li>
	<li><a href="#Whitespace20and20Comments">Whitespace and Comments</a></li>
	<li><a href="#Built2dIn20Data20Types">Built-In Data Types</a></li>
	<li><a href="#Names20and20Variables">Names and Variables</a></li>
	<li><a href="#Names">Names</a></li>
	<li><a href="#Literals">Literals</a></li>
	<li><a href="#Context">Context</a></li>
	<li><a href="#Lists">Lists</a></li>
	<li><a href="#Files">Files</a></li>
	<li><a href="#Properties">Properties</a></li>
	<li><a href="#Grammatical20Categories">Grammatical Categories</a></li>
</ul>
<!-- INDEX END -->


<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>

<h1><a name="TITLE">TITLE</a></h1>
<p>Synopsis 2: Bits and Pieces</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>

<h1><a name="AUTHOR">AUTHOR</a></h1>
<p>Larry Wall &lt;<a href="mailto:larry@wall.org">larry@wall.org</a>&gt;</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>

<h1><a name="VERSION">VERSION</a></h1>
<pre>
  Maintainer: Larry Wall &lt;larry@wall.org&gt;
  Date: 10 Aug 2004
  Last Modified: 15 Aug 2006
  Number: 2
  Version: 65</pre>
<p>This document summarizes Apocalypse 2, which covers small-scale
lexical items and typological issues.  (These Synopses also contain
updates to reflect the evolving design of Perl 6 over time, unlike the
Apocalypses, which are frozen in time as ``historical documents''.
These updates are not marked--if a Synopsis disagrees with its
Apocalypse, assume the Synopsis is correct.)</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>

<h1><a name="Lexical20Conventions">Lexical Conventions</a></h1>
<ul>
<li></li>
In the abstract, Perl is written in Unicode, and has consistent Unicode
semantics regardless of the underlying text representations.
<a name="msg_27"></a>
<a href="?hide_quotes=no#msg_27" onclick="return tog_quote(27);">
<div ID="header_shown_27" style="display: none;">
- Hide the snippet from t/syntax/unicode.t (line 7 ~ line 80) -
</div>
<div ID="header_hidden_27" style="display: block;">
- Show the snippet from t/syntax/unicode.t (line 7 ~ line 80, 74 lines) -
</div>
</a>
<div ID="hide_27" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
# L&lt;S02/"Lexical Conventions"/"Perl is written in Unicode"&gt;

# Unicode variables
# english ;-)
ok(try {my $foo; sub foo {}; 1}, "ascii declaration");
is(try {my $bar = 2; sub id ($x) { $x }; id($bar)}, 2, "evaluation"); 

# umlauts
ok(try {my $übervar; sub fü {}; 1}, "umlauts declaration");
is(try {my $schloß = 2; sub öok ($x) { $x }; öok($schloß)}, 2, "evaluation");

# monty python
ok(try {my $møøse; sub bïte {}; 1}, "a møøse once bit my sister");
is(try {my $møøse = 2; sub såck ($x) { $x }; såck($møøse)}, 2, "møøse bites kan be preti nasti");

# french
ok(try {my $un_variable_français; sub blâ {}; 1}, "french declaration");
is(try {my $frénch = 2; sub bléch ($x) { $x }; bléch($frénch)}, 2, "evaluation");

# Some Chinese Characters
ok(try {my $一; 1}, "chinese declaration");
is(try {my $二 = 2; sub 恆等($x) {$x}; 恆等($二)}, 2, "evaluation");

# Tibetan Characters
ok(try {my $ཀ; 1}, "tibetan declaration");
is(try {my $ཁ = 2; $ཁ}, 2, "evaluation");

# Japanese
ok(try {my $い; 1}, "japanese declaration");
is(try {my $に = 2; $に}, 2, "evaluation");

# arabic
ok(try {my $الصفحة ; 1}, "arabic declaration");
is(try {my $الصفحة = 2; $الصفحة}, 2, "evaluation");

# hebrew
ok(try {my $פוו; sub לה {}; 1}, "hebrew declaration");
is(try {my $באר = 2; sub זהות ($x) { $x }; זהות($באר)}, 2, "evaluation");

# russian
ok(try {my $один; sub раз {}; 1}, "russian declaration");
is(try {my $два = 2; sub идентичный ($x) { $x }; идентичный($два)}, 2, "evaluation");

# Unicode subs
{
    my sub äöü () { 42 }
    is äöü, 42, "Unicode subs with no parameters";
}
{
    my sub äöü ($x) { 1000 + $x }
    is äöü 17, 1017, "Unicode subs with one parameter (parsed as prefix ops)";
}

# Unicode parameters
{
    my sub abc (:$äöü) { 1000 + $äöü }

    is abc(äöü =&gt; 42), 1042, "Unicode named params (1)";
    is abc(:äöü(42)),  1042, "Unicode named params (2)";
}

# Unicode placeholder variables
{
    is
        ~(&lt; foostraße barstraße fakestraße &gt;.map:{ ucfirst $^straßenname }),
        "Foostraße Barstraße Fakestraße",
        "Unicode placeholder variables";
}

# Unicode methods
{
    my method Str::äöü { ucfirst self }
    is "pugs".äöü, "Pugs", "Unicode methods";
}

</pre>
</div>

<p></p>
<li></li>
Perl can count Unicode line and paragraph separators as line markers,
but that behavior had better be configurable so that Perl's idea of
line numbers matches what your editor thinks about Unicode lines.
<p></p>
<li></li>
Unicode horizontal whitespace is counted as whitespace, but it's better
not to use thin spaces where they will make adjoining tokens look like
a single token.  On the other hand, Perl doesn't use indentation as syntax,
so you are free to use any whitespace anywhere that whitespace makes sense.
Comments always count as whitespace.
<p></p>
<li></li>
For some syntactic purposes, Perl distinguishes bracketing characters
from non-bracketing.  Bracketing characters are defined as any Unicode
characters with either bidirectional mirrorings or Ps/Pe properties.
<p>In practice, though, you're safest using matching characters with
Ps/Pe properties, though ASCII angle brackets are a notable exception,
since they're bidirectional but not in the Ps/Pe set.</p>
<p>Characters with no corresponding closing character do not qualify
as opening brackets.  This includes the second section of the Unicode
BidiMirroring data table, as well as <code>U+201A</code> and <code>U+201E</code>.</p>
<p>If a character is already used in Ps/Pe mappings, then its entry in
BidiMirroring is ignored.  Therefore <code>U+298D</code> maps to <code>U+298E</code>,
not <code>U+2990</code>, and <code>U+298E</code> itself is not a valid bracket opener.</p>
<p>The <code>U+301D</code> has two closing alternatives, <code>U+301E</code> and <code>U+301F</code>;
Perl 6 only recognizes the one with lower code point number, <code>U+301E</code>,
as the closing brace.  This policy also applies to new one-to-many
mappings introduced in the future.</p>
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>

<h1><a name="Whitespace20and20Comments">Whitespace and Comments</a></h1>
<ul>
<li></li>
Single-line comments work as in Perl 5, starting with a <code>#</code> character
and ending at the subsequent newline.  They count as whitespace
equivalent to newline for purposes of separation.  Unlike in Perl 5,
<code>#</code> may not be used as the delimiter in quoting constructs.
<p></p>
<li></li>
Multiline comments are provided by extending the syntax of POD
to nest <code>=begin comment</code>/<code>=end comment</code> correctly without the need
for <code>=cut</code>.  The format name does not have to be <code>comment</code> -- any
unrecognized format name will do to make it a comment.  (However,
bare <code>=begin</code> and <code>=end</code> probably aren't good enough, because all
comments in them will show up in the formatted output.)
<a name="msg_25"></a>
<a href="?hide_quotes=no#msg_25" onclick="return tog_quote(25);">
<div ID="header_shown_25" style="display: none;">
- Hide the snippet from t/syntax/POD.t (line 7 ~ line 53) -
</div>
<div ID="header_hidden_25" style="display: block;">
- Show the snippet from t/syntax/POD.t (line 7 ~ line 53, 47 lines) -
</div>
</a>
<div ID="hide_25" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
# L&lt;S02/"Whitespace and Comments"/"Multiline comments" extending POD&gt;
# others will be added later, or you can do it.

eval_ok '
=begin DATA LABEL1
LABEL1.1
LABEL1.2
LABEL1.3
=end DATA

=begin DATA LABEL2
LABEL2.1
LABEL2.2
=end DATA
', "=begin DATA works", :todo;

eval_is('%=DATA&lt;LABEL1&gt;[0]', 'LABEL1.1', '@=DATA&lt;LABEL1&gt;[0] is correct', :todo);
eval_is('%=DATA&lt;LABEL1&gt;[2]', 'LABEL1.3', '@=DATA&lt;LABEL1&gt;[2] is correct', :todo);
eval_is('~ %=DATA&lt;LABEL1&gt;', 'LABEL1.1LABEL1.2LABEL1.3', '~ %=DATA&lt;LABEL1&gt; is correct', :todo);

eval_is('~ $=LABEL2', 'LABEL2.1LABEL2.2', '~ $=LABEL2 is correct', :todo);
eval_is('$=LABEL2[1]', 'LABEL2.2', '$=LABEL2[1] is correct', :todo);

# S02 says this "=begin comment" "=end comment" shouldn't need a "=cut"
# to indicate the end of the pod.

eval_is( '
=begin comment

This is a comment with a "=cut".

=end comment
=cut

return "foo";
', 'foo');

eval_is( '
=begin comment

This is a comment without a "=cut".

=end comment

return "foo";
', 'foo');


</pre>
</div>

<p>We have single paragraph comments with <code>=for comment</code> as well.
That lets <code>=for</code> keep its meaning as the equivalent of a <code>=begin</code>
and <code>=end</code> combined.  As with <code>=begin</code> and <code>=end</code>, a comment started
in code reverts to code afterwards.</p>
<p>Since there is a newline before the first <code>=</code>, the POD form of comment
counts as whitespace equivalent to a newline.</p>
<p></p>
<li></li>
Embedded comments are supported as a variant on quoting syntax, introduced
by <code>#</code> plus any user-selected bracket characters (as defined in
<a href="#lexical20conventions">Lexical Conventions</a> above):
<a name="msg_19"></a>
<a href="?hide_quotes=no#msg_19" onclick="return tog_quote(19);">
<div ID="header_shown_19" style="display: none;">
- Hide the snippet from t/syntax/comments.t (line 10 ~ line 48) -
</div>
<div ID="header_hidden_19" style="display: block;">
- Show the snippet from t/syntax/comments.t (line 10 ~ line 48, 39 lines) -
</div>
</a>
<div ID="hide_19" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
    # L&lt;S02/"Whitespace and Comments"/"Embedded comments"
    #  "#" plus any bracket&gt;

    ok #[
        Multiline
        comments
        is fine
    ] 1, 'multiline embedded comment with #[]';

    ok #(
        Parens works also
    ) 1, 'multiline embedded comment with #()';

    my $var = #{ foo bar } 32;
    is $var, 32, 'embedded comment with #{}';

    $var = 3 + #「 this is a comment 」 56;
    is $var, 59, 'embedded comment with LEFT/RIGHT CORNER BRACKET';

    $var = 2 #『 blah blah blah 』 * 3;
    is $var, 6, 'embedded comment with LEFT/RIGHT WHITE CORNER BRACKET';

    my @list = 'a'..'c';

    # FIXME: $var = @list[ #（注释）2 ];
    is $var, 'c', 'embedded comment with FULLWIDTH LEFT/RIGHT PARENTHESIS';

    $var = @list[ 0 #《注释》];
    is $var, 'a', 'embedded comment with LEFT/RIGHT DOUBLE ANGLE BRACKET';

    $var = @list[#〈注释〉1];
    is $var, 'b', 'embedded comment with LEFT/RIGHT ANGLE BRACKET';

    # Note that 'LEFT/RIGHT SINGLE QUOTATION MARK' (i.e. ‘’) and
    # LEFT/RIGHT DOUBLE QUOTATION MARK (i.e. “”) are not valid delimiter
    # characters.
}

{

</pre>
</div>

<pre>
    say #( embedded comment ) &quot;hello, world!&quot;;</pre>
<pre>
    $object\#{ embedded comments }.say;</pre>
<pre>
    $object\ #「
        embedded comments
    」.say;</pre>
<p>Brackets may be nested, following the same policy as ordinary quote brackets.</p>
<p>There must be no space between the <code>#</code> and the opening bracket character.
(There may be the <em>visual appearance</em> of space for some double-wide
characters, however, such as the corner quotes above.)</p>
<a name="msg_20"></a>
<a href="?hide_quotes=no#msg_20" onclick="return tog_quote(20);">
<div ID="header_shown_20" style="display: none;">
- Hide the snippet from t/syntax/comments.t (line 49 ~ line 57) -
</div>
<div ID="header_hidden_20" style="display: block;">
- Show the snippet from t/syntax/comments.t (line 49 ~ line 57, 9 lines) -
</div>
</a>
<div ID="hide_20" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
    # L&lt;S02/"Whitespace and Comments"/"no space" between "#" and bracket&gt;

    ok !eval("3 * # (invalid comment) 2"), "no space allowed between '#' and '('";
    ok !eval("3 * #\t[invalid comment] 2"), "no tab allowed between '#' and '['";
    ok !eval("3 * #  \{invalid comment\} 2"), "no spaces allowed between '#' and '\{'";
    ok !eval("3 * #\n&lt;invalid comment&gt; 2"), "no spaces allowed between '#' and '&lt;'";
}

{

</pre>
</div>

<p></p>
<li></li>
As a special case to facilitate commenting out sections of code with
<code>s/^/#/</code>, <code>#</code> on the beginning of line is always considered a line-end
comment rather than an embedded comment, even if followed by a bracketing
character.
<a name="msg_23"></a>
<a href="?hide_quotes=no#msg_23" onclick="return tog_quote(23);">
<div ID="header_shown_23" style="display: none;">
- Hide the snippet from t/syntax/comments.t (line 94 ~ line 105) -
</div>
<div ID="header_hidden_23" style="display: block;">
- Show the snippet from t/syntax/comments.t (line 94 ~ line 105, 12 lines) -
</div>
</a>
<div ID="hide_23" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
    # L&lt;S02/"Whitespace and Comments"/
    #   "#" on "beginning of line" always "line-end comment"&gt;

    is 31,
#&lt;this is special cased
    31, '#&lt; on the left margin is a line-end comment';

    ok !eval(" #&lt;this is invalid"),
        'embedded comment not on the left margin';
}

{

</pre>
</div>

<p></p>
<li></li>
For all quoting constructs that use user-selected brackets, you can open
with multiple identical bracket characters, which must by closed by the
same number of closing brackets.  Counting of nested brackets applies only
to pairs of brackets of the same length as the opening brackets:
<a name="msg_22"></a>
<a href="?hide_quotes=no#msg_22" onclick="return tog_quote(22);">
<div ID="header_shown_22" style="display: none;">
- Hide the snippet from t/syntax/comments.t (line 76 ~ line 93) -
</div>
<div ID="header_hidden_22" style="display: block;">
- Show the snippet from t/syntax/comments.t (line 76 ~ line 93, 18 lines) -
</div>
</a>
<div ID="hide_22" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
    # L&lt;S02/"Whitespace and Comments"/"Counting of nested brackets"
    #   "applies only to" "pairs of brackets of the same length"&gt;

    is 3, #(
        (Nested parens) works also
    ) 3, 'nested parens #(...(...)...)';

    is -1 #&lt;&lt;&lt;
        Even &lt;this&gt; &lt;&lt;&lt; also &gt;&gt;&gt; works...
    &gt;&gt;&gt;, -1, 'nested brackets in embedded comment';

    is 'cat', #{{
        This comment contains unmatched } and { { { {   (ignored)
        Plus a nested {{ ... }} pair                    (counted)
    }} 'cat', 'embedded comments with nested/unmatched bracket chars';
}

{

</pre>
</div>

<a name="msg_21"></a>
<a href="?hide_quotes=no#msg_21" onclick="return tog_quote(21);">
<div ID="header_shown_21" style="display: none;">
- Hide the snippet from t/syntax/comments.t (line 58 ~ line 75) -
</div>
<div ID="header_hidden_21" style="display: block;">
- Show the snippet from t/syntax/comments.t (line 58 ~ line 75, 18 lines) -
</div>
</a>
<div ID="hide_21" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
    # L&lt;S02/"Whitespace and Comments"/"closed by" "same number of"
    #   "closing brackets"&gt;

    ok #&lt;&lt;&lt;
        Or this &lt;also&gt; works...
    &gt;&gt;&gt; 1, '#&lt;&lt;&lt;...&gt;&gt;&gt;';

    my $var = \#((( comment ))) 12;
    is $var, 12, '#(((...)))';

    $var #&lt;&lt; &lt; &gt;&gt; = 25;
    is $var, 25, '#&lt;&lt; &lt; &gt;&gt;';

    $var = #&lt;&lt; &gt; &gt;&gt; 36;
    is $var, 36, '#&lt;&lt; &gt; &gt;&gt;';
}

{

</pre>
</div>

<pre>
    say #{{
        This comment contains unmatched } and { { { {   (ignored)
        Plus a nested {{ ... }} pair                    (counted)
    }} q&lt;&lt; &lt;&lt;woot&gt;&gt; &gt;&gt;   # says &quot; &lt;&lt;woot&gt;&gt; &quot;</pre>
<p>Note however that bare circumfix or postcircumfix <code>&lt;&lt;...&gt;&gt;</code> is
not a user-selected bracket, but the ASCII variant of the <code>«...»</code>
interpolating word list.  Only <code>#</code> and the <code>q</code>-style quoters (including
<code>m</code>, <code>s</code>, <code>tr</code>, and <code>rx</code>) enable subsequent user-selected brackets.</p>
<p></p>
<li></li>
In addition to the general comment forms above, there is a
whitespace-only comment form that begins with backslash and ends
with a single dot, separated by 0 or more characters of whitespace,
which is equivalent to a single dot:
<pre>
    %hash\  .{$key}
    @array\ .[$ix]
    $subref\.($arg)</pre>
<p>This is useful for lining up postfixes.  This is known as the ``long dot'',
partly because it substitutes for a dot without the need for an extra dot:</p>
<pre>
    $object\  .say();</pre>
<p>The whitespace in the middle may include any of the comment forms above.
Because comments always count as whitespace, the <code>\.</code> in</p>
<pre>
    $object\#{ foo }.say</pre>
<p>reduce to a ``long dot''.  Valid ways to
insert a line break into a sequence of method calls include:</p>
<pre>
    $object\ # comment
    .say</pre>
<pre>
    $object\#[ comment
    ].say</pre>
<pre>
    $object\
    .say</pre>
<p></p>
<li></li>
In fact, any whitespace (including comments) may be hidden by prefixing
it with <code>\</code>.  It does not have to end with a dot.  It's just that
the normal use of a you-don't-see-this-space is typically to put
a dotted postfix on the next line.  But it also lets you continue
the line in any situation where a newline might confuse the parser,
regardless of the currently installed parser.  (Unless, of course,
you override the unspace rule itself...)  Although we say that the
unspace hides the whitespace from the parser, line numbers are still
counted if the unspace contains one or more newlines.  A <code>#</code> following
such a newline is always an end-of-line comment, as described above.
Since Pod chunks count as whitespace to the language, they are also
swallowed up by unspace.  Heredoc boundaries are suppressed, however,
so you can split excessively long heredoc intro lines like this:
<pre>
    ok(q:to'CODE', q:to'OUTPUT', \
    &quot;Here is a long description&quot;, \ # --more--
    todo(:parrøt&lt;0.42&gt;, :dötnet&lt;1.2&gt;));
        ...
        CODE
        ...
        OUTPUT</pre>
<p>To the heredoc parser that just looks like:</p>
<pre>
    ok(q:to'CODE', q:to'OUTPUT', &quot;Here is a long description&quot;, todo(:parrøt&lt;0.42&gt;, :dötnet&lt;1.2&gt;));
        ...
        CODE
        ...
        OUTPUT</pre>
<p></p>
<li></li>
An unspace may contain a comment, but a comment may not contain an unspace.
In particular, end-of-line comments do not treat backslash as significant.
If you say:
<a name="msg_24"></a>
<a href="?hide_quotes=no#msg_24" onclick="return tog_quote(24);">
<div ID="header_shown_24" style="display: none;">
- Hide the snippet from t/syntax/comments.t (line 106 ~ line 110) -
</div>
<div ID="header_hidden_24" style="display: block;">
- Show the snippet from t/syntax/comments.t (line 106 ~ line 110, 5 lines) -
</div>
</a>
<div ID="hide_24" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
    # L&lt;S02/Whitespace and Comments/"comment may not contain an unspace"&gt;
    my $a;
    ok !eval '$a = #\  (comment) 32', "comments can't contain unspace";
    is $a, undef, '$a remains undef';
}

</pre>
</div>

<pre>
    #\ (...</pre>
<p>it is an end-of-line comment, not an embedded comment.  Write:</p>
<pre>
    \ #(
        ...
       )</pre>
<p>to mean the other thing.</p>
<p></p>
<li></li>
In general, whitespace is optional in Perl 6 except where it is needed
to separate constructs that would be misconstrued as a single token or
other syntactic unit.  (In other words, Perl 6 follows the standard
<em>longest-token</em> principle, or in the cases of large constructs, a
<em>prefer shifting to reducing</em> principle.  See <a href="#grammatical20categories">Grammatical Categories</a>
below for more on how a Perl program is analyzed into tokens.)
<p>This is an unchanging deep rule, but the surface ramifications of it
change as various operators and macros are added to or removed from
the language, which we expect to happen because Perl 6 is designed to
be a mutable language.  In particular, there is a natural conflict
between postfix operators and infix operators, either of which
may occur after a term.  If a given token may be interpreted as
either a postfix operator or an infix operator, the infix operator
requires space before it.  Postfix operators may never have intervening
space, though they may have an intervening dot.  If further separation
is desired, an embedded comment may be used as described above, as long
as no whitespace occurs outside the embedded comment.</p>
<p>For instance, if you were to add your own <code>infix:&lt;++&gt;</code> operator,
then it must have space before it. The normal autoincrementing
<code>postfix:&lt;++&gt;</code> operator may never have space before it, but may
be written in any of these forms:</p>
<pre>
    $x++</pre>
<pre>
    $x.++</pre>
<pre>
    $x\ .++</pre>
<pre>
    $x\#( comment ).++
    $x\#((( comment ))).++</pre>
<pre>
    $x\
    .++</pre>
<pre>
    $x\         # comment
                # inside long dot
    .++</pre>
<pre>
    $x\         # comment
                # inside &quot;unspace&quot;
    ++          # (but long dot may be preferred...)</pre>
<pre>
    $x\#『     comment
                more comment
    』.++</pre>
<pre>
    $x\#[   comment 1
    comment 2
    =begin podstuff
    whatever (pod comments ignore current parser state)
    =end podstuff
    comment 3
    ].++</pre>
<p>A consequence of the postfix rule is that (except when delimiting a
quote or terminating a ``long dot'') a dot with whitespace in front
of it is always considered a method call on <code>$_</code> where a term is
expected.  If a term is not expected at this point, it is a syntax
error.  (Unless, of course, there is an infix operator of that name
beginning with dot.  You could, for instance, define a Fortranly
<code>infix:&lt;.EQ.&gt;</code> if the fit took you.  But you'll have to be sure to
always put whitespace in front of it, or it would be interpreted as
a postfix method call instead.)</p>
<p>For example,</p>
<pre>
    foo .method</pre>
<p>and</p>
<pre>
    foo
    .method</pre>
<p>will always be interpreted as</p>
<pre>
    foo $_.method</pre>
<p>but never as</p>
<pre>
    foo.method</pre>
<p>Use some variant of</p>
<pre>
    foo\
    .method</pre>
<p>if you mean the postfix method call.</p>
<p>One consequence of all this is that you may no longer write a Num as
<code>42.</code> with just a trailing dot.  You must instead say either <code>42</code>
or <code>42.0</code>.  In other words, a dot following a number can only be a
decimal point if the following character is a digit.  Otherwise the
postfix dot will be taken to be the start of some kind of method call
syntax, whether long-dotty or not.  (The <code>.123</code> form with a leading
dot is still allowed however when a term is expected, and is equivalent
to <code>0.123</code> rather than <code>$_.123</code>.)</p>
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>

<h1><a name="Built2dIn20Data20Types">Built-In Data Types</a></h1>
<ul>
<li></li>
In support of OO encapsulation, there is a new fundamental datatype:
<strong>P6opaque</strong>.  External access to opaque objects is always through method
calls, even for attributes.
<p></p>
<li></li>
Perl 6 has an optional type system that helps you write safer
code that performs better.  The compiler is free to infer what type
information it can from the types you supply, but will not complain
about missing type information unless you ask it to.
<p></p>
<li></li>
Perl 6 supports the notion of <strong>properties</strong> on various kinds of
objects.  Properties are like object attributes, except that they're
managed by the individual object rather than by the object's class.
<p>According to S12, properties are actually implemented by a
kind of mixin mechanism, and such mixins are accomplished by the
generation of an individual anonymous class for the object (unless
an identical anonymous class already exists and can safely be shared).</p>
<p></p>
<li></li>
Properties applied to objects constructed at compile-time, such as
variables and classes, are also called <strong>traits</strong>.  Traits cannot be
changed at run-time.  Changes to run-time properties are done via
mixin instead, so that the compiler can optimize based on declared traits.
<p></p>
<li></li>
Perl 6 is an OO engine, but you're not generally required to think
in OO when that's inconvenient.  However, some built-in concepts such
as filehandles will be more object-oriented in a user-visible way
than in Perl 5.
<p></p>
<li></li>
A variable's type is a constraint indicating what sorts of values the
variable may contain.  More precisely, it's a promise that the object
or objects contained in the variable are capable of responding to the
methods of the indicated ``role''.  See S12 for more about roles.
<pre>
    # $x can contain only Int objects
    my Int $x;</pre>
<p>A variable may itself be bound to a container type that specifies how
the container works, without specifying what kinds of things it contains.</p>
<pre>
    # $x is implemented by the MyScalar class
    my $x is MyScalar;</pre>
<p>Constraints and container types can be used together:</p>
<pre>
    # $x can contain only Int objects,
    # and is implemented by the MyScalar class
    my Int $x is MyScalar;</pre>
<p>Note that <code>$x</code> is also initialized to <code>::Int</code>.  See below for more on this.</p>
<p></p>
<li></li>
<code>my Dog $spot</code> by itself does not automatically call a <code>Dog</code> constructor.
It merely assigns an undefined <code>Dog</code> prototype object to <code>$spot</code>:
<pre>
    my Dog $spot;           # $spot is initialized with ::Dog
    my Dog $spot = Dog;     # same thing</pre>
<pre>
    $spot.defined;          # False
    say $spot;              # &quot;Dog&quot;</pre>
<p>Any class name used as a value by itself is an undefined instance of that
class's prototype.  See S12 for more on that.</p>
<p>To get a real <code>Dog</code> object, call a constructor method such as <code>new</code>:</p>
<pre>
    my Dog $spot .= new;
    my Dog $spot = $spot.new;   # .= is rewritten into this</pre>
<p>You can pass in arguments to the constructor as well:</p>
<pre>
    my Dog $cerberus .= new(heads =&gt; 3);
    my Dog $cerberus = $cerberus.new(heads =&gt; 3);   # same thing</pre>
<p></p>
<li></li>
If you say
<pre>
    my int @array is MyArray;</pre>
<p>you are declaring that the elements of <code>@array</code> are native integers,
but that the array itself is implemented by the <code>MyArray</code> class.
Untyped arrays and hashes are still perfectly acceptable, but have
the same performance issues they have in Perl 5.</p>
<p></p>
<li></li>
To get the number of elements in an array, use the <code>.elems</code> method.  You can
also ask for the total string length of an array's elements, in bytes,
codepoints or graphemes, using these methods <code>.bytes</code>, <code>.codes</code> or <code>.graphs</code>
respectively on the array.  The same methods apply to strings as well.
<p>There is no <code>.length</code> method for either arrays or strings, because <code>length</code>
does not specify a unit.</p>
<p></p>
<li></li>
Built-in object types start with an uppercase letter. This includes
immutable types (e.g. <code>Int</code>, <code>Num</code>, <code>Complex</code>, <code>Rational</code>, <code>Str</code>,
<code>Bit</code>, <code>Regex</code>, <code>Set</code>, <code>Junction</code>, <code>Code</code>, <code>Block</code>, <code>List</code>,
<code>Seq</code>), as well as mutable (container) types, such as <code>Scalar</code>,
<code>Array</code>, <code>Hash</code>, <code>Buf</code>, <code>Routine</code>, <code>Module</code>, etc.
<p>Non-object (native) types are lowercase: <code>int</code>, <code>num</code>, <code>complex</code>,
<code>rational</code>, <code>buf</code>, <code>bit</code>.  Native types are primarily intended for
declaring compact array storage.  However, Perl will try to make those
look like their corresponding uppercase types if you treat them that way.
(In other words, it does autoboxing.  Note, however, that sometimes
repeated autoboxing can slow your program more than the native type
can speed it up.)</p>
<p>Some object types can behave as value types.  Every object can produce
a ``safe key identifier'' (<code>SKID</code> for short) that uniquely identifies the
object for hashing and other value-based comparisons.  Normal objects
just use their address in memory, but if a class wishes to behave as a
value type, it can define a <code>.SKID</code> method that makes different objects
look like the same object if they happen to have the same contents.
SKID may also stand for ``static key id'', or ``silly key id'', or
``secret key id'', or ``supercalifragilisticexpialidocious key id''.</p>
<p></p>
<li></li>
Variables with non-native types can always contain <em>undefined</em> values,
such as <code>Undef</code>, <code>Whatever</code> and <code>Failure</code> objects.  See S04 for more
about failures (i.e. unthrown exceptions):
<pre>
    my Int $x = undef;    # works</pre>
<p>Variables with native types do not support undefinedness: it is an error
to assign an undefined value to them:</p>
<pre>
    my int $y = undef;    # dies</pre>
<p>Conjecture: num might support the autoconversion of undef to NaN, since
the floating-point form can represent this concept.  Might be better
to make that conversion optional though, so that the rocket designer
can decide whether to self-destruct immediately or shortly thereafter.</p>
<p></p>
<li></li>
Every object supports a <code>META</code> function/method that returns the
metaclass instance managing it, regardless of whether the object
is defined:
<pre>
    'x'.META.get_method_list;   # get available methods for strings
    Str.META.get_method_list;   # same thing with the prototype object Str
    META(Str).get_method_list;  # same thing as function call</pre>
<pre>
    'x'.get_method_list;        # this is an error - not a meta object
    Str.get_method_list;        # same thing</pre>
<p>(For a prototype system (a non-class-based object system), all objects are merely managed by the same meta object.)</p>
<p></p>
<li></li>
Perl 6 intrinsically supports big integers and rationals through its
system of type declarations.  <code>Int</code> automatically supports promotion
to arbitrary precision, as well as holding <code>Inf</code> and <code>NaN</code> values.
<p>(<code>Num</code> may support arbitrary-precision floating-point arithmetic, but
is not required to unless we can do so portably and efficiently.  Num
must support the largest native floating point format that runs at full speed.)</p>
<p><code>Rational</code> supports arbitrary precision rational arithmetic.  However,
dividing two <code>Int</code> objects produces fractionals as <code>Num</code> objects by
default, not <code>Rational</code> objects.  You can override this behavior with
a pragma.</p>
<p>Lower-case types like <code>int</code> and <code>num</code> imply the native
machine representation for integers and floating-point numbers,
respectively, and do not promote to arbitrary precision, though
larger representations are always allowed for temporary values.
Unless qualified with a number of bits, <code>int</code> and <code>num</code> types default
to the largest native types that run at full speed.</p>
<p>Numeric values in untyped variables use <code>Int</code> and <code>Num</code> semantics
rather than <code>int</code> and <code>num</code>.</p>
<p></p>
<li></li>
Perl 6 should by default make standard IEEE floating point concepts
visible, such as <code>Inf</code> (infinity) and <code>NaN</code> (not a number).  Within a
lexical scope, pragmas may specify the nature of temporary values,
and how floating point is to behave under various circumstances.
All IEEE modes must be lexically available via pragma except in cases
where that would entail heroic efforts to bypass a braindead platform.
<a name="msg_18"></a>
<a href="?hide_quotes=no#msg_18" onclick="return tog_quote(18);">
<div ID="header_shown_18" style="display: none;">
- Hide the snippet from t/builtins/math/NaN.t (line 9 ~ line 18) -
</div>
<div ID="header_hidden_18" style="display: block;">
- Show the snippet from t/builtins/math/NaN.t (line 9 ~ line 18, 10 lines) -
</div>
</a>
<div ID="hide_18" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
# L&lt;S02/"Built-In Data Types" /Perl 6 should by default make standard IEEE floating point concepts visible/&gt;

is 0 * Inf  , NaN, "0 * Inf";
is Inf / Inf, NaN, "Inf / Inf";
is Inf - Inf, NaN, "Inf - Inf";
is NaN ** 0,  NaN, "NaN ** 0";

# XXX - the semantics below are unspecified.
is 0**0     , 1, "0**0 is 1, _not_ NaN";
is Inf**0   , 1, "Inf**0 is 1, _not_ NaN";

</pre>
</div>

<p>The default floating-point modes do not throw exceptions but rather
propagate Inf and NaN.  The boxed object types may carry more detailed
information on where overflow or underflow occurred.  Numerics in Perl
are not designed to give the identical answer everywhere.  They are
designed to give the typical programmer the tools to achieve a good
enough answer most of the time.  (Really good programmers may occasionally
do even better.)  Mostly this just involves using enough bits that the
stupidities of the algorithm don't matter much.</p>
<p></p>
<li></li>
A <code>Str</code> is a Unicode string object.  There is no corresponding native
<code>str</code> type.  However, since a <code>Str</code> object may fill multiple roles,
we say that a <code>Str</code> keeps track of its minimum and maximum Unicode
abstraction levels, and plays along nicely with the current lexical
scope's idea of the ideal character, whether that is bytes, codepoints,
graphemes, or characters in some language.  For all builtin operations,
all <code>Str</code> positions are reported as position objects, not integers.
These <code>StrPos</code> objects point into a particular string at a particular
location independent of abstraction level.  The subtraction of two
<code>StrPos</code> objects gives a <code>StrLen</code> object, which is still not an
integer, because the string between two positions also has multiple
integer interpretations depending on the units.  A given <code>StrLen</code>
may know that it represents 18 bytes, 7 codepoints, and 3 graphemes,
but it knows this lazily because it actually just hangs onto the two
<code>StrPos</code> objects.  (It's much like a <code>Range</code> object in that respect.)
<p>If you use integers as arguments where position objects are expected,
it will be assumed that you mean the units of the current lexically
scoped Unicode abstraction level.  (Which defaults to graphemes.)
Otherwise you'll need to coerce to the proper units:</p>
<pre>
    substr($string, 42.as(Bytes), 1.as(ArabicChars))</pre>
<p>Of course, such a dimensional number will fail if used on a string
that doesn't provide the appropriate abstraction level.</p>
<p></p>
<li></li>
A <code>Buf</code> is a stringish view of an array of
integers, and has no Unicode or character properties without explicit
conversion to some kind of <code>Str</code>.  (A <code>buf</code> is the native counterpart.)
Typically it's an array of bytes serving as a buffer.  Bitwise
operations on a <code>Buf</code> treat the entire buffer as a single large
integer.  Bitwise operations on a <code>Str</code> generally fail unless the
<code>Str</code> in question can provide an abstract <code>Buf</code> interface somehow.
Coercion to <code>Buf</code> should generally invalidate the <code>Str</code> interface.
As a generic type <code>Buf</code> may be instantiated as (or bound to) any
of <code>buf8</code>, <code>buf16</code>, or <code>buf32</code> (or to any type that provides the
appropriate <code>Buf</code> interface), but when used to create a buffer <code>Buf</code>
defaults to <code>buf8</code>.
<p>Unlike <code>Str</code> types, <code>Buf</code> types prefer to deal with integer string
positions, and map these directly to the underlying compact array
as indices.  That is, these are not necessarily byte positions--an
integer position just counts over the number of underlying positions,
where one position means one cell of the underlying integer type.
Builtin string operations on <code>Buf</code> types return integers and expect
integers when dealing with positions.  As a limiting case, <code>buf8</code> is
just an old-school byte string, and the positions are byte positions.
Note, though, that if you remap a section of <code>buf32</code> memory to be
<code>buf8</code>, you'll have to multiply all your positions by 4.</p>
<p></p>
<li></li>
Ordinarily a term beginning with <code>*</code> indicates a global function
or type name, but by itself, the <code>*</code> term captures the notion of
``Whatever'', which is applied lazily by whatever operator it is an
argument to.  Generally it can just be thought of as a ``glob'' that
gives you everything it can in that argument position.  For instance:
<pre>
    if $x ~~ 1..* {...}                 # if 1 &lt;= $x &lt;= +Inf
    my ($a,$b,$c) = &quot;foo&quot; xx *;         # an arbitrary long list of &quot;foo&quot;
    if /foo/ ff * {...}                 # a latching flipflop
    @slice = @x[*;0;*];                 # any Int
    @slice = %x{*;'foo'};               # any keys in domain of 1st dimension
    @array[*]                           # flattens, unlike @array[]
    (*, *, $x) = (1, 2, 3);             # skip first two elements
                                        # (same as lvalue &quot;undef&quot; in Perl 5)</pre>
<p><code>Whatever</code> is an undefined prototype object derived from <code>Any</code>.  As a
type it is abstract, and may not be instantiated as a defined object.
If for a particular MMD dispatch, nothing in the MMD system claims it,
it dispatches to as an <code>Any</code> with an undefined value, and usually
blows up constructively.  If you say</p>
<pre>
    say 1 + *;</pre>
<p>you should probably not expect it to yield a reasonable answer, unless
you think an exception is reasonable.  Since the <code>Whatever</code> object
is effectively immutable, the optimizer is free to recognize <code>*</code>
and optimize in the context of what operator it is being passed to.</p>
<p>A variant of <code>*</code> is the <code>**</code> term.  It is generally understood to
be a multidimension form of <code>*</code> when that makes sense.</p>
<p>The <code>***</code> variant serves as the insertion point of a list of feeds.
That insertion point may be targeted by feeding into <code>*</code>.  See S06.</p>
<p>Other uses for <code>*</code> will doubtless suggest themselves over time.  These
can be given meaning via the MMD system, if not the compiler.  In general
a <code>Whatever</code> should be interpreted as maximizing the degrees of freedom
in a dwimmey way, not as a nihilistic ``don't care anymore--just shoot me''.</p>
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>

<h1><a name="Names20and20Variables">Names and Variables</a></h1>
<ul>
<li></li>
The <code>$Package'var</code> syntax is gone.  Use <code>$Package::var</code> instead.
<p></p>
<li></li>
Perl 6 includes a system of <strong>sigils</strong> to mark the fundamental
structural type of a variable:
<pre>
    $   scalar
    @   ordered array
    %   unordered hash (associative array)
    &amp;   code/rule/token/regex
    ::  package/module/class/role/subset/enum/type/grammar
    @@  multislice view of @</pre>
<p>Within a declaration, the <code>&amp;</code> sigil also declares the visibility of the
subroutine name without the sigil within the scope of the declaration:</p>
<pre>
    my &amp;func := sub { say &quot;Hi&quot; };
    func;   # calls &amp;func</pre>
<p>Within a signature or other declaration, the <code>::</code> sigil followed by an
identifier marks a type variable that also declares the visibility
of a package/type name without the sigil within the scope of the
declaration.  The first such declaration within a scope is assumed
to be an unbound type, and takes the actual type of its associated
argument.  With subsequent declarations in the same scope the use of
the sigil is optional, since the bare type name is also declared.</p>
<p>A declaration nested within must not use the sigil if it wishes to
refer to the same type, since the inner declaration would rebind
the type.  (Note that the signature of a pointy block counts as part
of the inner block, not the outer block.)</p>
<p></p>
<li></li>
Unlike in Perl 5, you may no longer put whitespace between a sigil
and its following name or construct.
<p></p>
<li></li>
Ordinary sigils indicate normally scoped variables, either lexical
or package scoped.  Oddly scoped variables include a secondary sigil
(a <strong>twigil</strong>) that indicates what kind of strange scoping the variable
is subject to:
<pre>
    $foo        ordinary scoping
    $.foo       object attribute accessor
    $^foo       self-declared formal parameter
    $*foo       global variable
    $+foo       contextual variable
    $?foo       compiler hint variable
    $=foo       pod variable
    $&lt;foo&gt;      match variable, short for $/{'foo'}
    $!foo       explicitly private attribute (mapped to $foo though)</pre>
<p>Most variables with twigils are implicitly declared or assumed to
be declared in some other scope, and don't need a ``my'' or ``our''.
Attribute variables are declared with <code>has</code>, though.</p>
<p></p>
<li></li>
Sigils are now invariant.  <code>$</code> always means a scalar variable, <code>@</code>
an array variable, and <code>%</code> a hash variable, even when subscripting.
Variables such as <code>@array</code> and <code>%hash</code> in scalar context simply
return themselves as <code>Array</code> and <code>Hash</code> objects.
<p></p>
<li></li>
In string contexts, container objects automatically stringify to
appropriate (white-space separated) string values.  In numeric
contexts, the number of elements in the container is returned.
In boolean contexts, a true value is returned if and only if there
are any elements in the container.
<p></p>
<li></li>
To get a Perlish representation of any object, use the <code>.perl</code> method.
Like the <code>Data::Dumper</code> module in Perl 5, the <code>.perl</code> method will put
quotes around strings, square brackets around list values, curlies around
hash values, constructors around objects, etc., so that Perl can evaluate
the result back to the same object.
<p></p>
<li></li>
To get a formatted representation of any scalar value, use the
<code>.fmt('%03d')</code> method to do an implicit <code>sprintf</code> on the value.
<p>To format an array value separated by commas, supply a second argument:
<code>.fmt('%03d', ', ')</code>.  To format a hash value or list of pairs, include
formats for both key and value in the first string: <code>.fmt('%s: %s', &quot;\n&quot;)</code>.</p>
<a name="msg_3"></a>
<a href="?hide_quotes=no#msg_3" onclick="return tog_quote(3);">
<div ID="header_shown_3" style="display: none;">
- Hide the snippet from t/builtins/sprintf_and_as.t (line 25 ~ line 26) -
</div>
<div ID="header_hidden_3" style="display: block;">
- Show the snippet from t/builtins/sprintf_and_as.t (line 25 ~ line 26, 2 lines) -
</div>
</a>
<div ID="hide_3" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
# L&lt;S02/"Names and Variables" /or list of pairs/&gt;
is (a =&gt; 1.3, b =&gt; 2.4).as("%s:%d", "_"), "a:1_b:2", "as() works with lists of pairs";

</pre>
</div>

<a name="msg_2"></a>
<a href="?hide_quotes=no#msg_2" onclick="return tog_quote(2);">
<div ID="header_shown_2" style="display: none;">
- Hide the snippet from t/builtins/sprintf_and_as.t (line 22 ~ line 24) -
</div>
<div ID="header_hidden_2" style="display: block;">
- Show the snippet from t/builtins/sprintf_and_as.t (line 22 ~ line 24, 3 lines) -
</div>
</a>
<div ID="hide_2" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
# L&lt;S02/"Names and Variables" /To format a hash value/&gt;
is hash((a =&gt; 1.3), (b =&gt; 2.4)).as("%s:%d", "_"), "a:1_b:2", "as() works with hashes";


</pre>
</div>

<a name="msg_1"></a>
<a href="?hide_quotes=no#msg_1" onclick="return tog_quote(1);">
<div ID="header_shown_1" style="display: none;">
- Hide the snippet from t/builtins/sprintf_and_as.t (line 19 ~ line 21) -
</div>
<div ID="header_hidden_1" style="display: block;">
- Show the snippet from t/builtins/sprintf_and_as.t (line 19 ~ line 21, 3 lines) -
</div>
</a>
<div ID="hide_1" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
# L&lt;S02/"Names and Variables" /To format an array value/&gt;
is (1.3,2.4,3).as("%d", "_"), "1_2_3", "as() works with lists";


</pre>
</div>

<p></p>
<li></li>
Subscripts now consistently dereference the container produced by
whatever was to their left.  Whitespace is not allowed between a
variable name and its subscript.  However, there is a corresponding
<strong>dot</strong> form of each subscript (<code>@foo.[1]</code> and <code>%bar.{'a'}</code>).  Constant
string subscripts may be placed in angles, so <code>%bar.{'a'}</code> may also
be written as <code>%bar&lt;a&gt;</code> or <code>%bar.&lt;a&gt;</code>.
<p></p>
<li></li>
Slicing is specified by the nature of the subscript, not by
the sigil.
<p></p>
<li></li>
The context in which a subscript is evaluated is no longer controlled
by the sigil either.  Subscripts are always evaluated in list context.
<p>If you need to force inner context to scalar, we now have convenient
single-character context specifiers such as + for numbers and ~ for strings:</p>
<pre>
    @x[f()]   =  g();       # list context for f() and g()
    @x[f()]   = +g();       # list context for f(), scalar context for g()
    @x[+f()]  =  g();       # scalar context for f() and g()
                            # -- see S03 for &quot;SIMPLE&quot; lvalues</pre>
<pre>
    @x[f()]   =  @y[g()];   # list context for f() and g()
    @x[f()]   = +@y[g()];   # list context for f() and g()
    @x[+f()]  =  @y[g()];   # scalar context for f(), list context for g()
    @x[f()]   =  @y[+g()];  # list context for f(), scalar context for g()</pre>
<p></p>
<li></li>
There is a need to distinguish list assignment from list binding.
List assignment works exactly as it does in Perl 5, copying the
values.  There's a new <code>:=</code> binding operator that lets you bind
names to Array and Hash objects without copying, in the same way
as subroutine arguments are bound to formal parameters.  See S06
for more about binding.
<p></p>
<li></li>
An argument list may be captured into an object with backslashed parens:
<pre>
    $args = \(1,2,3,:mice&lt;blind&gt;)</pre>
<p>Values in a <code>Capture</code> object are parsed as ordinary expressions, marked as
invocant, positional, named, and so on.</p>
<p>Like <code>List</code> objects, <code>Capture</code> objects are immutable in the abstract, but
evaluate their arguments lazily.  Before everything inside a <code>Capture</code> is
fully evaluated (which happens at compile time when all the arguments are
constants), the eventual value may well be unknown.  All we know is
that we have the promise to make the bits of it immutable as they become known.</p>
<p><code>Capture</code> objects may contain multiple unresolved iterators such as feeds
or slices.  How these are resolved depends on what they are eventually
bound to.  Some bindings are sensitive to multiple dimensions while
others are not.</p>
<p>You may retrieve parts from a <code>Capture</code> object with a prefix sigil operator:</p>
<pre>
    $args = \3;     # same as &quot;$args = \(3)&quot;
    $$args;         # same as &quot;$args as Scalar&quot; or &quot;Scalar($args)&quot;
    @$args;         # same as &quot;$args as Array&quot;  or &quot;Array($args)&quot;
    %$args;         # same as &quot;$args as Hash&quot;   or &quot;Hash($args)&quot;</pre>
<p>When cast into an array, you can access all the positional arguments; into a
hash, all named arguments; into a scalar, its invocant.</p>
<p>All prefix sigil operators accept one positional argument, evaluated in
scalar context as a rvalue.  They can interpolate in strings if called with
parentheses.  The special syntax form <code>$()</code> translates into <code>$( $/ )</code> 
to operate on the current match object; the same applies to <code>@()</code>, <code>%()</code> and
<code>*()</code> forms.</p>
<p><code>Capture</code> objects fill the ecological niche of references in Perl 6.
You can think of them as ``fat'' references, that is, references that
can capture not only the current identity of a single object, but
also the relative identities of several related objects.  Conversely,
you can think of Perl 5 references as a degenerate form of <code>Capture</code>
when you want to refer only to a single item.</p>
<p></p>
<li></li>
A signature object (<code>Signature</code>) may be created with colon-prefixed parens:
<pre>
    my ::MySig ::= :(Int, Num, Complex, Status :mice)</pre>
<p>Expressions inside the signature are parsed as parameter declarations
rather than ordinary expressions.  See S06 for more details on the syntax
for parameters.</p>
<p>Signature objects bound to <code>::t</code> variables may be used within another
signature to apply additional type constraints.  When applied to a
<code>Capture</code> argument of form <code>\$x</code>, the signature allows you to specify
the types of parameters that would otherwise be untyped:</p>
<pre>
    :(Num Dog|Cat $numdog, MySig \$a ($i,$j,$k,$mousestatus))</pre>
<p></p>
<li></li>
Unlike in Perl 5, the notation <code>&amp;foo</code> merely stands for the <code>foo</code>
function as a Code object without calling it.  You may call any Code
object with parens after it (which may, of course, contain arguments):
<pre>
    &amp;foo($arg1, $arg2);</pre>
<p>Whitespace is not allowed before the parens, but there is a
corresponding <code>.()</code> operator, plus the ``long dot'' forms that allow
you to insert optional whitespace and comments between the backslash
and the dot:</p>
<pre>
    &amp;foo\   .($arg1, $arg2);
    &amp;foo\#[
        embedded comment
    ].($arg1, $arg2);</pre>
<p></p>
<li></li>
With multiple dispatch, <code>&amp;foo</code> may not be sufficient to uniquely name a
specific function.  In that case, the type may be refined by using a
signature literal as a postfix operator:
<pre>
    &amp;foo:(Int,Num)</pre>
<p>It still just returns a <code>Code</code> object.  A call may also be partially
applied by using an argument list literal as a postfix operator:</p>
<pre>
    &amp;foo\(1,2,3,:mice&lt;blind&gt;)</pre>
<p>This is really just a shorthand for</p>
<pre>
    &amp;foo.assuming(1,2,3,:mice&lt;blind&gt;)</pre>
<p></p>
<li></li>
Slicing syntax is covered in S09.  Multidimensional
slices will be done with semicolons between individual slice subscripts.
Each such slice is evaluated lazily.
<p></p>
<li></li>
To make a slice subscript return something other than values, append an
appropriate adverb to the subscript.
<a name="msg_4"></a>
<a href="?hide_quotes=no#msg_4" onclick="return tog_quote(4);">
<div ID="header_shown_4" style="display: none;">
- Hide the snippet from t/operators/subscript_adverbs.t (line 7 ~ line 197) -
</div>
<div ID="header_hidden_4" style="display: block;">
- Show the snippet from t/operators/subscript_adverbs.t (line 7 ~ line 197, 191 lines) -
</div>
</a>
<div ID="hide_4" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
# L&lt;S02/"Names and Variables" /appropriate adverb to the subscript/&gt;

# Adverbs on array subscripts
# :p
{
    my @array = &lt;A B&gt;;

    isa_ok eval('@array[0]:p'), Pair,
        ":p on an array returned a Pair", :todo&lt;feature&gt;;
    is ~eval('@array[0]:p'), "0\tA",
        ":p on an array returned the correct pair", :todo&lt;feature&gt;;

    eval('@array[0]:p.value = "a"');
    is @array[0], "a",
        ":p on an array returns lvalues (like normal subscripts do as well)", :todo&lt;feature&gt;;

    is +eval('@array[0,1]:p'), 2,
        ":p on an array returned a two-elem array", :todo&lt;feature&gt;;
    is ~eval('@array[0,1]:p'), "0\ta 1\tB",
        ":p on an array returned a two-elem array consisting of the correct pairs", :todo&lt;feature&gt;;

    is +eval('@array[42,23]:p'),  0, ":p on an array weeded out non-existing entries (1)";
    is ~eval('@array[42,23]:p'), "", ":p on an array weeded out non-existing entries (2)";
}

# :kv
{
    my @array = &lt;A B&gt;;

    is +eval('@array[0]:kv'), 2,
        ":kv on an array returned a two-elem array", :todo&lt;feature&gt;;
    is ~eval('@array[0]:kv'), "0 A",
        ":kv on an array returned the correct two-elem array", :todo&lt;feature&gt;;

    eval('(@array[0]:kv)[1] = "a"');
    is @array[0], "a",
        ":kv on an array returns lvalues (like normal subscripts do as well)", :todo&lt;feature&gt;;

    is +eval('@array[0,1]:kv'), 4,
        ":kv on an array returned a four-elem array", :todo&lt;feature&gt;;
    is ~eval('@array[0,1]:kv'), "0 a 1 B",
        ":kv on an array returned the correct four-elem array", :todo&lt;feature&gt;;

    is +eval('@array[42,23]:kv'),  0, ":kv on an array weeded out non-existing entries (1)";
    is ~eval('@array[42,23]:kv'), "", ":kv on an array weeded out non-existing entries (2)";
}

# :k
{
    my @array = &lt;A B&gt;;

    is +eval('@array[0]:k'), 1,
        ":k on an array returned an one-elem array", :todo&lt;feature&gt;;
    is ~eval('@array[0]:k'), "0",
        ":k on an array returned the correct one-elem array", :todo&lt;feature&gt;;

    is +eval('@array[0,1]:k'), 2,
        ":k on an array returned a tow-elem array", :todo&lt;feature&gt;;
    is ~eval('@array[0,1]:k'), "0 1",
        ":k on an array returned the correct two-elem array", :todo&lt;feature&gt;;

    is +eval('@array[42,23]:k'),  0, ":k on an array weeded out non-existing entries (1)";
    is ~eval('@array[42,23]:k'), "", ":k on an array weeded out non-existing entries (2)";
}

# :v
{
    my @array = &lt;A B&gt;;

    is +eval('@array[0]:v'), 1,
        ":v on an array returned an one-elem array", :todo&lt;feature&gt;;
    is ~eval('@array[0]:v'), "A",
        ":v on an array returned the correct one-elem array", :todo&lt;feature&gt;;

    eval('@array[0]:v = "a"');
    is @array[0], "a",
        ":v on an array returns lvalues (like normal subscripts do as well)", :todo&lt;feature&gt;;

    is +eval('@array[0,1]:v'), 2,
        ":v on an array returned a tow-elem array", :todo&lt;feature&gt;;
    is ~eval('@array[0,1]:v'), "a B",
        ":v on an array returned the correct two-elem array", :todo&lt;feature&gt;;

    is +eval('@array[42,23]:v'),  0, ":v on an array weeded out non-existing entries (1)";
    is ~eval('@array[42,23]:v'), "", ":v on an array weeded out non-existing entries (2)";
}

# Adverbs on hash subscripts
# :p
{
    my %hash = (0 =&gt; "A", 1 =&gt; "B");

    isa_ok eval('%hash&lt;0&gt;:p'), Pair,
        ":p on a hash returned a Pair", :todo&lt;feature&gt;;
    is ~eval('%hash&lt;0&gt;:p'), "0\tA",
        ":p on a hash returned the correct pair", :todo&lt;feature&gt;;

    eval('%hash&lt;0&gt;:p.value = "a"');
    is %hash&lt;0&gt;, "a",
        ":p on a hash returns lvalues (like normal subscripts do as well)", :todo&lt;feature&gt;;

    is +eval('%hash&lt;0 1&gt;:p'), 2,
        ":p on a hash returned a two-elem array", :todo&lt;feature&gt;;
    is ~eval('%hash&lt;0 1&gt;:p'), "0\ta 1\tB",
        ":p on a hash returned a two-elem array consisting of the correct pairs", :todo&lt;feature&gt;;

    is +eval('%hash&lt;42 23&gt;:p'),  0, ":p on a hash weeded out non-existing entries (1)";
    is ~eval('%hash&lt;42 23&gt;:p'), "", ":p on a hash weeded out non-existing entries (2)";
}

# :kv
{
    my %hash = (0 =&gt; "A", 1 =&gt; "B");

    is +eval('%hash&lt;0&gt;:kv'), 2,
        ":kv on a hash returned a two-elem array", :todo&lt;feature&gt;;
    is ~eval('%hash&lt;0&gt;:kv'), "0 A",
        ":kv on a hash returned the correct two-elem array", :todo&lt;feature&gt;;

    eval('(%hash&lt;0&gt;:kv)[1] = "a"');
    is %hash&lt;0&gt;, "a",
        ":kv on a hash returns lvalues (like normal subscripts do as well)", :todo&lt;feature&gt;;

    is +eval('%hash&lt;0 1&gt;:kv'), 4,
        ":kv on a hash returned a four-elem array", :todo&lt;feature&gt;;
    is ~eval('%hash&lt;0 1&gt;:kv'), "0 a 1 B",
        ":kv on a hash returned the correct four-elem array", :todo&lt;feature&gt;;

    is +eval('%hash&lt;42 23&gt;:kv'),  0, ":kv on a hash weeded out non-existing entries (1)";
    is ~eval('%hash&lt;42 23&gt;:kv'), "", ":kv on a hash weeded out non-existing entries (2)";
}

# :k
{
    my %hash = (0 =&gt; "A", 1 =&gt; "B");

    is +eval('%hash&lt;0&gt;:k'), 1,
        ":k on a hash returned an one-elem array", :todo&lt;feature&gt;;
    is ~eval('%hash&lt;0&gt;:k'), "0",
        ":k on a hash returned the correct one-elem array", :todo&lt;feature&gt;;

    is +eval('%hash&lt;0 1&gt;:k'), 2,
        ":k on a hash returned a tow-elem array", :todo&lt;feature&gt;;
    is ~eval('%hash&lt;0 1&gt;:k'), "0 1",
        ":k on a hash returned the correct two-elem array", :todo&lt;feature&gt;;

    is +eval('%hash&lt;42 23&gt;:k'),  0, ":k on a hash weeded out non-existing entries (1)";
    is ~eval('%hash&lt;42 23&gt;:k'), "", ":k on a hash weeded out non-existing entries (2)";
}

# :v
{
    my %hash = (0 =&gt; "A", 1 =&gt; "B");

    is +eval('%hash&lt;0&gt;:v'), 1,
        ":v on a hash returned an one-elem array", :todo&lt;feature&gt;;
    is ~eval('%hash&lt;0&gt;:v'), "A",
        ":v on a hash returned the correct one-elem array", :todo&lt;feature&gt;;

    eval('%hash&lt;0&gt;:v = "a"');
    is %hash&lt;0&gt;, "a",
        ":v on a hash returns lvalues (like normal subscripts do as well)", :todo&lt;feature&gt;;

    is +eval('%hash&lt;0 1&gt;:v'), 2,
        ":v on a hash returned a tow-elem array", :todo&lt;feature&gt;;
    is ~eval('%hash&lt;0 1&gt;:v'), "a B",
        ":v on a hash returned the correct two-elem array", :todo&lt;feature&gt;;

    is +eval('%hash&lt;42 23&gt;:v'),  0, ":v on a hash weeded out non-existing entries (1)";
    is ~eval('%hash&lt;42 23&gt;:v'), "", ":v on a hash weeded out non-existing entries (2)";
}

# The adverbial forms weed out non-existing entries, but undefined (but
# existing) entries should be unaffected by this rule.
{
    my @array = (42, undef, 23);

    is +eval('@array[0,1,2]:kv'), 6,
        "undefined but existing entries should not be weeded out (1)", :todo&lt;feature&gt;;
    is ~eval('@array[0,1,2]:kv'), "0 42 1  2 23",
        "undefined but existing entries should not be weeded out (2)", :todo&lt;feature&gt;;
}

{
    my %hash = (0 =&gt; 42, 1 =&gt; undef, 2 =&gt; 23);

    is +eval('%hash&lt;0 1 2&gt;:kv'), 6,
        "undefined but existing entries should not be weeded out (3)", :todo&lt;feature&gt;;
    is ~eval('%hash&lt;0 1 2&gt;:kv'), "0 42 1  2 23",
        "undefined but existing entries should not be weeded out (4)", :todo&lt;feature&gt;;
}

</pre>
</div>

<pre>
    @array = &lt;A B&gt;;
    @array[0,1,2];      # returns 'A', 'B', undef
    @array[0,1,2]:p;    # returns 0 =&gt; 'A', 1 =&gt; 'B'
    @array[0,1,2]:kv;   # returns 0, 'A', 1, 'B'
    @array[0,1,2]:k;    # returns 0, 1
    @array[0,1,2]:v;    # returns 'A', 'B'</pre>
<pre>
    %hash = (:a&lt;A&gt;, :b&lt;B&gt;);
    %hash&lt;a b c&gt;;       # returns 'A', 'B', undef
    %hash&lt;a b c&gt;:p;     # returns a =&gt; 'A', b =&gt; 'B'
    %hash&lt;a b c&gt;:kv;    # returns 'a', 'A', 'b', 'B'
    %hash&lt;a b c&gt;:k;     # returns 'a', 'b'
    %hash&lt;a b c&gt;:v;     # returns 'A', 'B'</pre>
<p>The adverbial forms all weed out non-existing entries.</p>
<p></p>
<li></li>
In numeric context (i.e. when cast into <code>Int</code> or <code>Num</code>), a Hash object
becomes the number of pairs contained in the hash.  In a boolean context, a
Hash object is true if there are any pairs in the hash.  In either case,
any intrinsic iterator would be reset.  (If hashes do carry an intrinsic
iterator (as they do in Perl 5), there will be a <code>.reset</code> method on the
hash object to reset the iterator explicitly.)
<p></p>
<li></li>
Sorting a list of pairs should sort on their keys by default, then
on their values.  Sorting a list of lists should sort on the first
elements, then the second elements, etc.  For more on <code>sort</code> see S29.
<p></p>
<li></li>
Many of the special variables of Perl 5 are going away.  Those that
apply to some object such as a filehandle will instead be attributes
of the appropriate object.  Those that are truly global will have
global alphabetic names, such as <code>$*PID</code> or <code>@*ARGS</code>.
<p></p>
<li></li>
Any remaining special variables will be lexically scoped.
This includes <code>$_</code> and <code>@_</code>, as well as the new <code>$/</code>, which
is the return value of the last regex match.  <code>$0</code>, <code>$1</code>, <code>$2</code>, etc.,
are aliases into the <code>$/</code> object.
<p></p>
<li></li>
The <code>$#foo</code> notation is dead.  Use <code>@foo.end</code> or <code>@foo[-1]</code> instead.
(Or <code>@foo.shape[$dimension]</code> for multidimensional arrays.)
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>

<h1><a name="Names">Names</a></h1>
<ul>
<li></li>
Ordinary package-qualified names look like in Perl 5:
<pre>
    $Foo::Bar::baz      # the $baz variable in package Foo::Bar</pre>
<p>Sometimes it's clearer to keep the sigil with the variable name, so an
alternate way to write this is:</p>
<pre>
    Foo::Bar::&lt;$baz&gt;</pre>
<p>This is resolved at compile time because the variable name is a constant.</p>
<p></p>
<li></li>
The following pseudo-package names are reserved in the first position:
<a name="msg_9"></a>
<a href="?hide_quotes=no#msg_9" onclick="return tog_quote(9);">
<div ID="header_shown_9" style="display: none;">
- Hide the snippet from t/var/var.t (line 7 ~ line 12) -
</div>
<div ID="header_hidden_9" style="display: block;">
- Show the snippet from t/var/var.t (line 7 ~ line 12, 6 lines) -
</div>
</a>
<div ID="hide_9" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
# L&lt;S02/"Names" /names are reserved in the first position/&gt;
ok !eval('module MY;     1'), "MY is an out of scope name";
ok !eval('module OUTER;  1'), "OUTER is an out of scope name";
ok !eval('module CALLER; 1'), "CALLER is an out of scope name";



</pre>
</div>

<pre>
    MY          # Lexical variables declared in the current scope
    OUR         # Package variables declared in the current package
    GLOBAL      # Builtin variables and functions
    OUTER       # Lexical variables declared in the outer scope
    CALLER      # Contextual variables in the caller's scope
    CONTEXT     # Contextual variables in any caller's scope
    SUPER       # Package variables declared in inherited classes
    COMPILING   # Lexical variables in the scope being compiled</pre>
<p>Other all-caps names are semi-reserved.  We may add more of them in
the future, so you can protect yourself from future collisions by using
mixed case on your top-level packages.  (We promise not to break
any existing top-level CPAN package, of course.  Except maybe ACME,
and then only for coyotes.)</p>
<p></p>
<li></li>
You may interpolate a string into a package or variable name using
<code>::($expr)</code> where you'd ordinarily put a package or variable name.
The string is allowed to contain additional instances of <code>::</code>, which
will be interpreted as package nesting.  You may only interpolate
entire names, since the construct starts with <code>::</code>, and either ends
immediately or is continued with another <code>::</code> outside the parens.
Most symbolic references are done with this notation:
<pre>
    $foo = &quot;Bar&quot;;
    $foobar = &quot;Foo::Bar&quot;;
    $::($foo)           # package-scoped $Bar
    $::(&quot;MY::$foo&quot;)     # lexically-scoped $Bar
    $::(&quot;*::$foo&quot;)      # global $Bar
    $::($foobar)        # $Foo::Bar
    $::($foobar)::baz   # $Foo::Bar::baz
    $::($foo)::Bar::baz # $Bar::Bar::baz
    $::($foobar)baz     # ILLEGAL at compile time (no operator baz)</pre>
<p>Note that unlike in Perl 5, initial <code>::</code> doesn't imply global.
Package names are searched for from inner lexical scopes to outer,
then from inner packages to outer.  Variable names are searched
for from inner lexical scopes to outer, but unlike package names
are looked for in only the current package and the global package.</p>
<p>The global namespace is the last place it looks in either case.
You must use the <code>*</code> (or <code>GLOBAL</code>) package on the front of the
string argument to force the search to start in the global namespace.</p>
<p>Use the <code>MY</code> pseudopackage to limit the lookup to the current lexical
scope, and <code>OUR</code> to limit the scopes to the current package scope.</p>
<p></p>
<li></li>
When ``strict'' is in effect (which is the default except for one-liners),
non-qualified variables (such as <code>$x</code> and <code>@y</code>) are only looked up from
lexical scopes, but never from package scopes.
<p>To bind package variables into a lexical scope, simply say <code>our ($x, @y)</code>.
To bind global variables into a lexical scope, predeclare them with <code>use</code>:</p>
<pre>
    use GLOBAL &lt;$IN $OUT&gt;;</pre>
<p>Or just refer to them as <code>$*IN</code> and <code>$*OUT</code>.</p>
<p></p>
<li></li>
To do direct lookup in a package's symbol table without scanning, treat
the package name as a hash:
<pre>
    Foo::Bar::{'&amp;baz'}  # same as &amp;Foo::Bar::baz
    GLOBAL::&lt;$IN&gt;       # Same as $*IN
    Foo::&lt;::Bar&gt;&lt;::Baz&gt; # same as Foo::Bar::Baz</pre>
<p>Unlike <code>::()</code> symbolic references, this does not parse the argument
for <code>::</code>, nor does it initiate a namespace scan from that initial
point.  In addition, for constant subscripts, it is guaranteed to
resolve the symbol at compile time.</p>
<p>The null pseudo-package is reserved to mean the same search list as an ordinary
name search.  That is, the following are all identical in meaning:</p>
<pre>
    $foo
    $::{'foo'}
    ::{'$foo'}
    $::&lt;foo&gt;
    ::&lt;$foo&gt;</pre>
<p>That is, each of them scans lexical scopes outward, and then the current package scope
(though the package scope is then disallowed when ``strict'' is in effect).</p>
<p>As a result of these rules, you can write any arbitrary variable name as either of:</p>
<pre>
    $::{'!@#$#@'}
    ::{'$!@#$#@'}</pre>
<p>You can also use the <code>::&lt;&gt;</code> form as long as there are no spaces in the name.</p>
<p></p>
<li></li>
The current lexical symbol table is now accessible through the
pseudo-package <code>MY</code>.  The current package symbol table is visible as
pseudo-package <code>OUR</code>.  The <code>OUTER</code> name refers to the <code>MY</code> symbol table
immediately surrounding the current <code>MY</code>, and <code>OUTER::OUTER</code> is the one
surrounding that one.
<pre>
    our $foo = 41;
    say $::foo;         # prints 41, :: is no-op
    {
        my $foo = 42;
        say MY::&lt;$foo&gt;;         # prints &quot;42&quot;
        say $MY::foo;           # same thing
        say $::foo;             # same thing, :: is no-op here</pre>
<pre>
        say OUR::&lt;$foo&gt;;        # prints &quot;41&quot;
        say $OUR::foo;          # same thing</pre>
<pre>
        say OUTER::&lt;$foo&gt;;      # prints &quot;41&quot; (our $foo is also lexical)
        say $OUTER::foo;        # same thing
    }</pre>
<p>You may not use any lexically scoped symbol table, either by name or
by reference, to add symbols to a lexical scope that is done compiling.
(We reserve the right to relax this if it turns out to be useful though.)</p>
<p></p>
<li></li>
The <code>CALLER</code> package refers to the lexical scope of the (dynamically
scoped) caller.  The caller's lexical scope is allowed to hide any
variable except <code>$_</code> from you.  In fact, that's the default, and a
lexical variable must have the trait ``<code>is context</code>'' to be
visible via <code>CALLER</code>.  (<code>$_</code>, <code>$!</code> and <code>$/</code> are always
contextual.) If the variable is not visible in the caller, it returns
failure.
<a name="msg_8"></a>
<a href="?hide_quotes=no#msg_8" onclick="return tog_quote(8);">
<div ID="header_shown_8" style="display: none;">
- Hide the snippet from t/var/caller.t (line 51 ~ line 173) -
</div>
<div ID="header_hidden_8" style="display: block;">
- Show the snippet from t/var/caller.t (line 51 ~ line 173, 123 lines) -
</div>
</a>
<div ID="hide_8" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
# L&lt;S02/"Names" /The CALLER package refers to the lexical scope/&gt;
{
  # $_ is always implicitly declared "env".
  my sub foo () { $CALLER::_ }
  my sub bar () {
    $_ = 42;
    foo();
  }

  $_ = 23;
  is bar(), 42, '$_ is implicitly declared "env" (1)';
}

{
  # $_ is always implicitly declared "env".
  # (And, BTW, $_ is lexical.)
  my sub foo () { $_ = 17; $CALLER::_ }
  my sub bar () {
    $_ = 42;
    foo();
  }

  $_ = 23;
  is bar(), 42, '$_ is implicitly declared "env" (2)', :todo&lt;bug&gt;;
}

{
  # ...but other vars are not
  my sub foo { my $abc = 17; $CALLER::abc }
  my sub bar {
    my $abc = 42;
    foo();
  }

  my $abs = 23;
  dies_ok { bar() },
    'vars not declared "env" are not accessible via $CALLER::';
}

# Vars declared with env() default to being rw in the creating scope and
# readonly when accessed with $CALLER::.
{
  env $foo = 42;
  $foo++;
  is $foo, 43, "env() vars are rw in the creating scope (1)";
}

{
  env $foo = 42;
  { $foo++ }
  is $foo, 43, "env() vars are rw in the creating scope (2)";
}

{
  my sub modify { $CALLER::foo++ }
  env $foo = 42;
  dies_ok { modify() }, 'env() vars are ro when accessed with $CALLER::';
}

{
  my sub modify { $CALLER::_++ }
  $_ = 42;
  lives_ok { modify() }, '$_ is implicitly rw (1)';
  is $_, 43,             '$_ is implicitly rw (2)';
}

{
  my sub modify { $CALLER::foo++ }
  env $foo is rw = 42;
  lives_ok { modify() },
      'env() vars declared "is rw" are rw when accessed with $CALLER:: (1)', :todo&lt;bug&gt;;
  is $foo, 43,
      'env() vars declared "is rw" are rw when accessed with $CALLER:: (2)', :todo&lt;bug&gt;;
}

{
  my sub get_foo { try { $+foo } }
  env $foo = 42;

  is get_foo(), 42, '$+ is short for $CALLER::';
}

# Rebinding caller's variables -- legal?
{
  my $other_var = 23;
  my sub rebind_foo { $CALLER::foo := $other_var }
  env $foo = 42;

  lives_ok { rebind_foo() }, 'rebinding $CALLER:: variables works (1)', :todo&lt;bug&gt;;
  is $foo, 23,               'rebinding $CALLER:: variables works (2)', :todo&lt;bug&gt;;
  $other_var++;
  is $foo, 24,               'rebinding $CALLER:: variables works (3)', :todo&lt;bug&gt;;
}

=pod

Larry ruled that as erroneous.

15:13 &lt; iblech&gt; autrijus: :) BTW, WRT lex hoisting: sub foo { $CALLER::a }; { foo(); my $a
= 3; foo() }
15:13 &lt; autrijus&gt; iblech: larry ruled it as erroneous.
15:13 &lt; autrijus&gt; i.e. foo()'s behaviour is undefined.
15:14 &lt; iblech&gt; ok then :)
15:14 &lt; autrijus&gt; it's essential we do that because
15:14 &lt; autrijus&gt; foo($a, my $a)
15:14 &lt; autrijus&gt; is legal
15:14 &lt; autrijus&gt; and will be simply hazadrous to implement either way.
15:14 &lt; autrijus&gt; s/implement/mandate/

{
  if $*OS eq "browser" {  # test works under PIL2JS :)
    my $sub = sub { $CALLER::a };

    # No declaration of $a yet.
    dies_ok { $sub() }, '$CALLER:: dies when accessing not yet declared vars';

    my $a = 3;
    is $sub(), 3, '$CALLER:: works now (accessing a declared var)';
  } else {
    flunk "Test loops infinitely";
    flunk "Test loops infinitely";
  }
}

</pre>
</div>

<p>Any lexical declared with the <code>is context</code> trait is by default
considered readonly outside the current lexical scope.  You may add
<code>is rw</code> to allow called routines to modify your value.  <code>$_</code>,
<code>$!</code>, and <code>$/</code> are <code>rw</code> by default.  In any event, your lexical
scope can always access the variable as if it were an ordinary <code>my</code>;
the restriction on writing applies only to called subroutines.</p>
<p></p>
<li></li>
The <code>CONTEXT</code> pseudo-package is just like <code>CALLER</code> except that
it scans outward through all dynamic scopes until it finds a
contextual variable of that name in that caller's lexical scope.
(Use of <code>$+FOO</code> is equivalent to CONTEXT::&lt;$FOO&gt; or $CONTEXT::FOO.)
If after scanning all the lexical scopes of each dynamic scope,
there is no variable of that name, it looks in the <code>*</code> package.
If there is no variable in the <code>*</code> package and the variable is
a scalar, it then looks in <code>%*ENV</code> for the identifier of the variable,
that is, in the environment variables passed to program.  If the
value is not found there, it returns failure.  Note that <code>$+_</code> is
always the same as CALLER::&lt;$_&gt; since all callers have a <code>$_</code> that
is automatically considered environmental.  Note also that <code>CONTEXT</code>
and <code>$+</code> always skip the current scope, since you can always name
the variable directly without the <code>CONTEXT</code> or <code>+</code> if it's been
declared in the current lexical scope.
<a name="msg_5"></a>
<a href="?hide_quotes=no#msg_5" onclick="return tog_quote(5);">
<div ID="header_shown_5" style="display: none;">
- Hide the snippet from t/magicals/env.t (line 6 ~ line 134) -
</div>
<div ID="header_hidden_5" style="display: block;">
- Show the snippet from t/magicals/env.t (line 6 ~ line 134, 129 lines) -
</div>
</a>
<div ID="hide_5" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
# L&lt;S02/"Names" /environment variables passed to program/&gt;
plan 14;

if $*OS eq "browser" {
  skip_rest "Programs running in browsers don't have access to regular IO.";
  exit;
}

=kwid

= DESCRIPTION

Tests for %*ENV

Tests that C&lt;%*ENV&gt; can be read and written to and that
child processes see the modified C&lt;%*ENV&gt;.

=cut

# It must not be empty at startup.
ok +%*ENV.keys, '%*ENV has keys';

# %*ENV should be able to get copied into another variable.
my %vars = %*ENV;
is +%vars.keys, +%*ENV.keys, '%*ENV was successfully copied into another variable';

# XXX: Should modifying %vars affect the environment? I don't think so, but, of
# course, feel free to change the following test if I'm wrong.
%vars&lt;PATH&gt; = "42";
ok %*ENV&lt;PATH&gt; ne "42",
  'modifying a copy of %*ENV didn\'t affect the environment';

# Similarily, I don't think creating a new entry in %vars should affect the
# environment:
diag '%*ENV&lt;PUGS_ROCKS&gt;=' ~ %*ENV&lt;PUGS_ROCKS&gt;;
ok !defined(%*ENV&lt;PUGS_ROCKS&gt;), "there's no env variable 'PUGS_ROCKS'";
%vars&lt;PUGS_ROCKS&gt; = "42";
diag '%*ENV&lt;PUGS_ROCKS&gt;=' ~ %*ENV&lt;PUGS_ROCKS&gt;;
ok !defined(%*ENV&lt;PUGS_ROCKS&gt;), "there's still no env variable 'PUGS_ROCKS'";

my ($pugs,$redir,$squo) = ("./pugs", "&gt;", "'");

if $*OS eq any &lt;MSWin32 mingw msys cygwin&gt; {
    $pugs = 'pugs.exe';
};

my $expected = 'Hello from subprocess';
%*ENV&lt;PUGS_ROCKS&gt; = $expected;
# Note that the "?" preceeding the "(" is necessary, because we need a Bool,
# not a junction of Bools.
is %*ENV&lt;PUGS_ROCKS&gt;, $expected,'%*ENV is rw';

my $tempfile = "temp-ex-output." ~ $*PID ~ "." ~ rand 1000;

my $command = qq!$pugs -e "\%*ENV.perl.say" $redir $tempfile!;
diag $command;
system $command;

my $child_env = slurp $tempfile;
my %child_env = eval $child_env;
unlink $tempfile;

my $err = 0;
for %*ENV.kv -&gt; $k,$v {
  # Ignore env vars which bash and maybe other shells set automatically.
  next if $k eq any &lt;SHLVL _ OLDPWD PS1&gt;;
  if (%child_env{$k} !~~ $v) {
    if (! $err) {
      flunk("Environment gets propagated to child.");
      $err++;
    };
    diag "Expected: $k=$v";
    diag "Got:      $k=%child_env{$k}";
  } else {
    # diag "$k=$v";
  };
};
if (! $err) {
  ok(1,"Environment gets propagated to child.");
};

%*ENV.delete('PUGS_ROCKS');
is(%*ENV&lt;PUGS_ROCKS&gt;,undef,'We can remove keys from %*ENV');

my $command = qq!$pugs -e "\%*ENV.perl.say" $redir $tempfile!;
diag $command;
system $command;

my $child_env = slurp $tempfile;
my %child_env = eval $child_env;
unlink $tempfile;

is(%child_env&lt;PUGS_ROCKS&gt;,undef,'The child did not see %*ENV&lt;PUGS_ROCKS&gt;');

my $err = 0;
for %*ENV.kv -&gt; $k,$v {
  # Ignore env vars which bash and maybe other shells set automatically.
  next if $k eq any &lt;SHLVL _ OLDPWD PS1&gt;;
  if (%child_env{$k} !~~ $v) {
    if (! $err) {
      flunk("Environment gets propagated to child.");
      $err++;
    };
    diag "Expected: $k=$v";
    diag "Got:      $k=%child_env{$k}";
  } else {
    # diag "$k=$v";
  };
};
if (! $err) {
  ok(1,"Environment gets propagated to child.");
};

ok !%*ENV.exists("does_not_exist"), "exists() returns false on a not defined env var";

# %ENV must not be imported by default
my $x = eval "%ENV";
ok $! ~~ m:P5/Undeclared/, '%ENV not visible by default', :todo&lt;bug&gt;;

# following doesn't parse yet
{
    # It must be importable
    use GLOBAL &lt;%ENV&gt;;
    ok +%ENV.keys, 'imported %ENV has keys';
}
# Importation must be lexical
$x = eval "%ENV";
ok $! ~~ m:P5/Undeclared/, '%ENV not visible by after lexical import scope', :todo&lt;bug&gt;;
1;

</pre>
</div>

<p>The <code>CONTEXT</code> package is only for internal overriding of contextual
information, modelled on how environmental variables work among
processes.  Despite the fact that the <code>CONTEXT</code> package reflects the
current process's environment variables, at least where those are not
hidden by lower-level declarations, the <code>CONTEXT</code> package should not
be considered isomorphic to the current set of environment variables.
Subprocesses are passed only the global <code>%*ENV</code> values.  They do
not see any lexical variables or their values, unless you copy those
values into <code>%*ENV</code> to change what subprocesses see:</p>
<pre>
    temp %*ENV{LANG} = $+LANG;          # may be modified by parent
    system &quot;greet&quot;;</pre>
<p></p>
<li></li>
There is no longer any special package hash such as <code>%Foo::</code>.  Just
subscript the package object itself as a hash object, the key of which
is the variable name, including any sigil.  The package object can
be derived from a type name by use of the <code>::</code> postfix operator:
<pre>
    MyType::&lt;$foo&gt;
    MyType.::.{'$foo'}          # same thing with dots
    MyType\ .::\ .{'$foo'}      # same thing with long dots</pre>
<p>(Directly subscripting the type with either square brackets or curlies
is reserved for various generic type-theoretic operations.  In most other
matters type names and package names are interchangeable.)</p>
<p>Typeglobs are gone.  Use binding (<code>:=</code> or <code>::=</code>) to do aliasing.
Individual variable objects are still accessible through the
hash representing each symbol table, but you have to include the
sigil in the variable name now: <code>MyPackage::{'$foo'}</code> or the
equivalent <code>MyPackage::&lt;$foo&gt;</code>.</p>
<p></p>
<li></li>
Truly global variables live in the <code>*</code> package: <code>$*UID</code>, <code>%*ENV</code>.
(The <code>*</code> may be omitted if you import the name from the <code>GLOBAL</code>
package.)  <code>$*foo</code> is short for <code>$*::foo</code>, suggesting that the
variable is ``wild carded'' into every package.
<p></p>
<li></li>
Standard input is <code>$*IN</code>, standard output is <code>$*OUT</code>, and standard error
is <code>$*ERR</code>.  The magic command-line input handle is <code>$*ARGS</code>.
<p></p>
<li></li>
Magical file-scoped values live in variables with a <code>=</code> secondary
sigil.  <code>$=DATA</code> is the name of your <code>DATA</code> filehandle, for instance.
All pod structures are available through <code>%=POD</code> (or some such).
As with <code>*</code>, the <code>=</code> may also be used as a package name: <code>$=::DATA</code>.
<p></p>
<li></li>
Magical lexically scoped values live in variables with a <code>?</code> secondary
sigil.  These are all values that are known to the compiler, and may
in fact be dynamically scoped within the compiler itself, and only
appear to be lexically scoped because dynamic scopes of the compiler
resolve to lexical scopes of the program.  All <code>$?</code> variables are considered
constants, and may not be modified after being compiled in.
<p><code>$?FILE</code> and <code>$?LINE</code> are your current file and line number, for
instance.  <code>?</code> is not a shortcut for a package name like <code>*</code> is.
Instead of <code>$?OUTER::SUB</code> you probably want to write <code></code>OUTER::&lt;$?SUB&gt;
&gt;&gt;.</p>
<p>Here are some possibilities:</p>
<pre>
    $?OS        Which operating system am I compiled for?
    $?OSVER     Which operating system version am I compiled for?
    $?PERLVER   Which Perl version am I compiled for?
    $?FILE      Which file am I in?</pre>
<a name="msg_6"></a>
<a href="?hide_quotes=no#msg_6" onclick="return tog_quote(6);">
<div ID="header_shown_6" style="display: none;">
- Hide the snippet from t/magicals/file_line.t (line 11 ~ line 16) -
</div>
<div ID="header_hidden_6" style="display: block;">
- Show the snippet from t/magicals/file_line.t (line 11 ~ line 16, 6 lines) -
</div>
</a>
<div ID="hide_6" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
# L&lt;S02/"Names" /Which file am I in/&gt;
ok($?FILE eq ('t/magicals/file_line.t' | 't\\magicals\\file_line.t'), '$?FILE works');

# NOTE:
# above is a junction hack for Unix and Win32 file 
# paths until the FileSpec hack is working - Stevan

</pre>
</div>

<pre>
    $?LINE      Which line am I at?
    $?PACKAGE   Which package am I in?
    @?PACKAGE   Which nested packages am I in?
    $?MODULE    Which module am I in?
    @?MODULE    Which nested modules am I in?
    $?CLASS     Which class am I in? (as variable)
    @?CLASS     Which nested classes am I in?
    $?ROLE      Which role am I in? (as variable)
    @?ROLE      Which nested roles am I in?
    $?GRAMMAR   Which grammar am I in?
    @?GRAMMAR   Which nested grammars am I in?
    $?PARSER    Which Perl grammar was used to parse this statement?
    &amp;?ROUTINE   Which routine am I in?</pre>
<a name="msg_7"></a>
<a href="?hide_quotes=no#msg_7" onclick="return tog_quote(7);">
<div ID="header_shown_7" style="display: none;">
- Hide the snippet from t/magicals/subname.t (line 9 ~ line 17) -
</div>
<div ID="header_hidden_7" style="display: block;">
- Show the snippet from t/magicals/subname.t (line 9 ~ line 17, 9 lines) -
</div>
</a>
<div ID="hide_7" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
# L&lt;S02/"Names" /Which routine am I in/&gt;
sub foo { return &amp;?ROUTINE.name }
is(foo(), '&amp;main::foo', 'got the right routine name');

my $bar = sub { return &amp;?ROUTINE.name };
is($bar(), '&lt;anon&gt;', 'got the right routine name (anon-block)');

my $baz = try { &amp;?ROUTINE.name };
ok(not(defined $baz), '&amp;?ROUTINE.name not defined outside of a routine');

</pre>
</div>

<pre>
    @?ROUTINE   Which nested routines am I in?
    &amp;?BLOCK     Which block am I in?
    @?BLOCK     Which nested blocks am I in?
    $?LABEL     Which block label am I in?
    @?LABEL     Which nested block labels am I in?</pre>
<p>All the nested <code>@?</code> variables are ordered from the innermost to the
outermost, so <code>@?BLOCK[0]</code> is always the same as <code>$?BLOCK</code>.</p>
<p>Note that some of these things have parallels in the <code>*</code> space at run time:</p>
<pre>
    $*OS        Which OS I'm running under
    $*OSVER     Which OS version I'm running under
    $*PERLVER   Which Perl version I'm running under</pre>
<p>You should not assume that these will have the same value as their
compile-time cousins.</p>
<p></p>
<li></li>
While <code>$?</code> variables are constant to the run time, the compiler
has to have a way of changing these values at compile time without
getting confused about its own <code>$?</code> variables (which were frozen in
when the compile-time code was itself compiled).  The compiler can
talk about these compiler-dynamic values using the <code>COMPILING</code> pseudopackage.
<p>References to <code>COMPILING</code> variables are automatically hoisted into the
context currently being compiled.  Setting or temporizing a <code>COMPILING</code>
variable sets or temporizes the incipient <code>$?</code> variable in the
surrounding lexical context that is being compiled.  If nothing in
the context is being compiled, an exception is thrown.</p>
<pre>
    $?FOO // say &quot;undefined&quot;;   # probably says undefined
    BEGIN { COMPILING::&lt;$?FOO&gt; = 42 }
    say $?FOO;                  # prints 42
    {
        say $?FOO;              # prints 42
        BEGIN { temp COMPILING::&lt;$?FOO&gt; = 43 } # temporizes to *compiling* block
        say $?FOO;              # prints 43
        BEGIN { COMPILING::&lt;$?FOO&gt; = 44 }
        say $?FOO;              # prints 44
        BEGIN { say COMPILING::&lt;$?FOO&gt; }        # prints 44, but $?FOO probably undefined
    }
    say $?FOO;                  # prints 42 (left scope of temp above)
    $?FOO = 45;                 # always an error
    COMPILING::&lt;$?FOO&gt; = 45;    # an error unless we are compiling something</pre>
<p>Note that <code>CALLER::&lt;$?FOO&gt;</code> might discover the same variable
as <code>COMPILING::&lt;$?FOO</code>&gt;, but only if the compiling context is the
immediate caller.  Likewise <code>OUTER::&lt;$?FOO&gt;</code> might or might not
get you to the right place.  In the abstract, <code>COMPILING::&lt;$?FOO</code>&gt;
goes outwards dynamically until it finds a compiling scope, and so is
guaranteed to find the ``right'' <code>$?FOO</code>.  (In practice, the compiler
hopefully keeps track of its current compiling scope anyway, so no
scan is needed.)</p>
<p>Perceptive readers will note that this subsumes various ``compiler hints''
proposals.  Crazy readers will wonder whether this means you could
set an initial value for other lexicals in the compiling scope.  The
answer is yes.  In fact, this mechanism is probably used by the
exporter to bind names into the importer's namespace.</p>
<p></p>
<li></li>
The currently compiling Perl parser is switched by modifying
<code>COMPILING::&lt;$?PARSER&gt;</code>.  Lexically scoped parser changes
should temporize the modification.  Changes from here to
end-of-compilation unit can just assign or bind it.  In general,
most parser changes involve deriving a new grammar and then pointing
<code>COMPILING::&lt;$?PARSER&gt;</code> at that new grammar.  Alternately, the
tables driving the current parser can be modified without derivation,
but at least one level of anonymous derivation must intervene from
the standard Perl grammar, or you might be messing up someone else's
grammar.  Basically, the current grammar has to belong only to the
current compiling scope.  It may not be shared, at least not without
explicit consent of all parties.  No magical syntax at a distance.
Consent of the governed, and all that.
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>

<h1><a name="Literals">Literals</a></h1>
<a name="msg_10"></a>
<a href="?hide_quotes=no#msg_10" onclick="return tog_quote(10);">
<div ID="header_shown_10" style="display: none;">
- Hide the snippet from t/operators/listquote.t (line 37 ~ line 76) -
</div>
<div ID="header_hidden_10" style="display: block;">
- Show the snippet from t/operators/listquote.t (line 37 ~ line 76, 40 lines) -
</div>
</a>
<div ID="hide_10" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
# L&lt;S02/"Literals"&gt;
# L&lt;S03/"Chained comparisons"&gt;

my $s = join 'a', &lt;x y z&gt;;
is($s, "xayaz", 'list context &lt;list&gt;');

my $s = join [,] &lt;a x y z&gt;;
is($s, "xayaz", 'listop &lt;list&gt;');

my $x = try { [1,2,3].join&lt;a b c&gt; };
ok($!, '.join&lt;abc&gt; parses but semantic error');
is($x, [1,2,3].join()&lt;a b c&gt;, '.join&lt;a b c&gt; not treated as argument');

my @y = try { {:a&lt;1&gt;, :b(2)}&lt;a b c&gt; };
is(@y, [1,2,undef], '{...}&lt;a b c&gt; is hash subscript');

eval '{:a&lt;1&gt;, :b(2)} &lt;a b c&gt;';
ok($!, '{...} &lt;...&gt; parsefail');

ok((1 | 3) &lt; 3, '(...) &lt; 3 no parsefail');

eval '(1 | 3)&lt;3';
ok($!, '()&lt;3 parsefail');

eval 'print &lt; 3';
ok($!, 'print &lt; 3 parsefail');

my $z = eval 'reverse&lt;1 2 3&gt;';
ok($!, 'reverse&lt;1 2 3&gt; parsefail');

eval ':foo &lt;1 2 3&gt;';
ok($!, ':foo &lt;1 2 3&gt; parsefail');

my $r = eval ':foo &lt;3';
is($r, Bool::True, ':foo &lt;3 is comparison');

my $p = eval ':foo&lt;1 2 3&gt;';
is($p, 'foo' =&gt; (1,2,3), ':foo&lt;1 2 3&gt; is pair of list');

=cut

</pre>
</div>

<ul>
<li></li>
A single underscore is allowed only between any two digits in a
literal number, where the definition of digit depends on the radix.
Underscores are not allowed anywhere else in any numeric literal,
including next to the radix point or exponentiator, or at the beginning
or end.
<p></p>
<li></li>
Initial <code>0</code> no longer indicates octal numbers by itself.  You must use
an explicit radix marker for that.  Pre-defined radix prefixes include:
<pre>
    0b          base 2, digits 0..1
    0o          base 8, digits 0..7
    0d          base 10, digits 0..9
    0x          base 16, digits 0..9,a..f (case insensitive)</pre>
<p></p>
<li></li>
The general radix form of a number involves prefixing with the radix
in adverbial form:
<pre>
    :10&lt;42&gt;             same as 0d42 or 42
    :16&lt;DEAD_BEEF&gt;      same as 0xDEADBEEF
    :8&lt;177777&gt;          same as 0o177777 (65535)
    :2&lt;1.1&gt;             same as 0b1.1 (0d1.5)</pre>
<p>Extra digits are assumed to be represented by <code>a</code>..<code>z</code> and <code>A</code>..<code>Z</code>, so you
can go up to base 36.  (Use <code>A</code> and <code>B</code> for base twelve, not <code>T</code> and <code>E</code>.)
Alternately you can use a list of digits in decimal:</p>
<pre>
    :60[12,34,56]       # 12 * 3600 + 34 * 60 + 56
    :100[3,'.',14,16]   # pi</pre>
<p>Any radix may include a fractional part.  A dot is never ambiguous
because you have to tell it where the number ends:</p>
<pre>
    :16&lt;dead_beef.face&gt; # fraction
    :16&lt;dead_beef&gt;.face # method call</pre>
<p></p>
<li></li>
Only base 10 (in any form) allows an additional exponentiator starting
with 'e' or 'E'.  All other radixes must either rely on the constant folding
properties of ordinary multiplication and exponentiation, or supply the
equivalent two numbers as part of the string, which will be interpreted
as they would outside the string, that is, as decimal numbers by default:
<pre>
    :16&lt;dead_beef&gt; * 16**8
    :16&lt;dead_beef*16**8&gt;</pre>
<p>It's true that only radixes that define <code>e</code> as a digit are ambiguous that
way, but with any radix it's not clear whether the exponentiator should
be 10 or the radix, and this makes it explicit:</p>
<pre>
    0b1.1e10                    ILLEGAL, could be read as any of:</pre>
<pre>
    :2&lt;1.1&gt; * 2 ** 10           1536
    :2&lt;1.1&gt; * 10 ** 10          15,000,000,000
    :2&lt;1.1&gt; * :2&lt;10&gt; ** :2&lt;10&gt;  6</pre>
<p>So we write those as</p>
<pre>
    :2&lt;1.1*2**10&gt;               1536
    :2&lt;1.1*10**10&gt;              15,000,000,000
    :2«1.1*:2&lt;10&gt;**:2&lt;10&gt;»      6</pre>
<p>The generic string-to-number converter will recognize all of these
forms (including the * form, since constant folding is not available
to the run time).  Also allowed in strings are leading plus or minus,
and maybe a trailing Units type for an implied scaling.  Leading and
trailing whitespace is ignored.  Note also that leading <code>0</code> by itself
<em>never</em> implies octal in Perl 6.</p>
<p>Any of the adverbial forms may be used as a function:</p>
<pre>
    :2($x)      # &quot;bin2num&quot;
    :8($x)      # &quot;oct2num&quot;
    :10($x)     # &quot;dec2num&quot;
    :16($x)     # &quot;hex2num&quot;</pre>
<p>Think of these as setting the default radix, not forcing it.  Like Perl
5's old <code>oct()</code> function, any of these will recognize a number starting
with a different radix marker and switch to the other radix.  However,
note that the <code>:16()</code> converter function will interpret leading <code>0b</code>
or <code>0d</code> as hex digits, not radix switchers.</p>
<p></p>
<li></li>
Characters indexed by hex numbers can be interpolated into strings
by introducing with <code>&quot;\x&quot;</code>, followed by either a bare hex number
(<code>&quot;\x263a&quot;</code>) or a hex number in square brackets (<code>&quot;\x[263a]&quot;</code>).
Similarly, <code>&quot;\o12&quot;</code> and <code>&quot;\o[12]&quot;</code> interpolate octals, while
<code>&quot;\d1234&quot;</code> and <code>&quot;\d[1234]&quot;</code> interpolate decimals--but generally
you should be using hex in the world of Unicode.  Multiple characters
may be specified within any of the bracketed forms by separating the
numbers with comma: <code>&quot;\x[41,42,43]&quot;</code>.  You must use the bracketed
form to disambiguate if the unbracketed form would ``eat'' too many
characters, because all of the unbracketed forms eat as many characters
as they think look like digits in the radix specified.  None of these
notations work in normal Perl code.  They work only in interpolations
and regexes and the like.
<p>The old <code>\123</code> form is now illegal, as is the <code>\0123</code> form.
Only <code>\0</code> remains, and then only if the next character is not in
the range <code>'0'..'7'</code>.  Octal characters must use <code>\o</code> notation.
Note also that backreferences are no longer represented by <code>\1</code>
and the like--see S05.</p>
<p></p>
<li></li>
The <code>qw/foo bar/</code> quote operator now has a bracketed form: <code>&lt;foo bar&gt;</code>.
When used as a subscript it performs a slice equivalent to <code>{'foo','bar'}</code>.
Much like the relationship between single quotes and double quotes, single
angles do not interpolate while double angles do.  The double angles may
be written either with French quotes, <code>«$foo @bar[]»</code>, or
with ``Texas'' quotes, <code>&lt;&lt;$foo @bar[]&gt;&gt;</code>, as the ASCII workaround.
The implicit split is done after interpolation, but respects quotes
in a shell-like fashion, so that <code>«'$foo' &quot;@bar[]&quot;»</code> is guaranteed to
produce a list of two ``words'' equivalent to <code>('$foo', &quot;@bar[]&quot;)</code>.
<code>Pair</code> notation is also recognized inside <code>«...»</code> and such ``words'' are
returned as <code>Pair</code> objects.
<p></p>
<li></li>
There is now a generalized adverbial form of Pair notation.  The
following table shows the correspondence to the ``fatarrow'' notation:
<pre>
    Fat arrow           Adverbial pair
    =========           ==============
    a =&gt; 1              :a
    a =&gt; 0              :!a
    a =&gt; 0              :a(0)
    a =&gt; $x             :a($x)
    a =&gt; 'foo'          :a&lt;foo&gt;
    a =&gt; &lt;foo bar&gt;      :a&lt;foo bar&gt;
    a =&gt; «$foo @bar»  :a«$foo @bar»
    a =&gt; {...}          :a{...}
    a =&gt; [...]          :a[...]
    a =&gt; $a             :$a
    a =&gt; @a             :@a
    a =&gt; %a             :%a
    a =&gt; %foo&lt;a&gt;        %foo:&lt;a&gt;</pre>
<p>Note that as usual the <code>{...}</code> form can indicate either a closure or a hash
depending on the contents.  It does <em>not</em> indicate a subscript.</p>
<p>Note also that the <code>&lt;a b&gt;</code> form is not a subscript and is therefore
equivalent not to <code>.{'a','b'}</code> but rather to <code>('a','b')</code>.  Bare <code>&lt;a&gt;</code>
turns into <code>('a')</code> rather than <code>('a',)</code>.</p>
<p>Two or more adverbs can always be strung together without intervening
punctuation anywhere a single adverb is acceptable.  When used as
named arguments in an argument list, you may put comma between,
because they're just ordinary named arguments to the function, and
a fatarrow pair would work the same.   When modifying an operator
(that is, when one occurs where an operator is expected), you may
not put commas between, and the fatarrow form is not allowd.  See S06.</p>
<p>The negated form (<code>:!a</code>) and the sigiled forms (<code>:$a</code>, <code>:@a</code>,
<code>:%a</code>) never take an argument and don't care what the next character is.
They are considered complete.</p>
<p>The other forms of adverb (including the bare <code>:a</code> form) <em>always</em>
look for an immediate bracketed argument, and will slurp it up.
If that's not intended, you must use whitespace between the adverb and
the opening bracket.  The syntax of individual adverbs is the same
everywhere in Perl 6.  There are no exceptions based on whether an
argument is wanted or not.  Except as noted above, the parser always
looks for the brackets.  Despite not indicating a true subscript,
the brackets are similarly parsed as postfix operators.  As postfixes
the brackets may be separated from their initial <code>:foo</code> with either
dot or ``long dot'', but nothing else.</p>
<p>Regardless of syntax, adverbs used as named arguments generally show
up as optional named parameters to the function in question--even
if the function is an operator or macro.  The function in question
neither knows nor cares how weird the original syntax was.</p>
<p></p>
<li></li>
Generalized quotes may now take adverbs:
<pre>
    Short       Long            Meaning
    =====       ====            =======
    :x          :exec           Execute as command and return results
    :w          :words          Split result on words (no quote protection)
    :ww         :quotewords     Split result on words (with quote protection)
    :t          :to             Interpret result as heredoc terminator
    :n          :none           No escapes at all (unless otherwise adverbed)
    :q          :single         Interpolate \\, \q and \' (or whatever)
    :qq         :double         Interpolate with :s, :a, :h, :f, :c, :b
    :s          :scalar         Interpolate $ vars
    :a          :array          Interpolate @ vars
    :h          :hash           Interpolate % vars
    :f          :function       Interpolate &amp; calls
    :c          :closure        Interpolate {...} expressions
    :b          :backslash      Interpolate \n, \t, etc. (implies :q at least)
                :code           Quasiquoting</pre>
<p>Ordinarily the colon is required on adverbs, but the <code>quote</code> declarator
allows you to combine any of the existing adverbial forms above
without an intervening colon:</p>
<pre>
    quote qw;                   # declare a P5-esque qw// meaning q:w
    quote qn;                   # completely raw quote qn//
    quote qnc;                  # q:n:c//, interpolate only closures</pre>
<p>Actually, the first two are already assumed, because you get all of the
forms that use as single character predeclared for free.</p>
<p>If you want to abbreviate further, you may also give an explicit
definition as either a string or quasiquote:</p>
<pre>
    quote qx = 'qq:x';          # equivalent to P5's qx//
    quote qTO = 'qq:x:w:to';    # qq:x:w:to//
    quote circumfix:&lt;❰ ❱&gt; = q:code { .quoteharder };  # or some such...</pre>
<p>In particular, all these forms disable the lookahead for an adverbial argument,
as if there were a space after the keyword.  So although</p>
<pre>
    q:n($foo)</pre>
<p>will misinterpret <code>$foo</code> as the <code>:n</code> argument,</p>
<pre>
    qn(stuff)</pre>
<p>has the advantage of misinterpreting it as the argument to the <code>qn()</code>
function instead.  <code>:)</code></p>
<p>But parens are special that way.  (Even <code>q()</code> is assumed to be a
function call rather than a quote.)  Other bracketing characters are
special only if they can be mistaken for adverbial arguments, so</p>
<pre>
    qn[stuff]</pre>
<p>is fine, and means</p>
<pre>
    q:n /stuff/</pre>
<p>while</p>
<pre>
    q:n[stuff]</pre>
<p>is not so fine, if the user intended ``stuff'' to be the string rather
than an argument to <code>:n</code>.  Basically, you'll be fine if you just
never use parens for quote delimiters, and always put a space after
your adverbs.</p>
<p>If this is all too much of a hardship, you can define your own quote
adverbs and operators as standard macros.  The main difference is that,
unlike</p>
<pre>
    quote qn = 'q:n';</pre>
<p>declaring something like</p>
<pre>
    macro qn { 'q:n' }</pre>
<p>does <em>not</em> disable the subsequent search for an argument to <code>:n</code>.  To
get the equivalent, you need to add a space:</p>
<pre>
    macro qn { 'q:n ' }</pre>
<p>All the uppercase adverbs are reserved for user-defined quotes.
All Unicode delimiters above Latin-1 are reserved for user-defined quotes.</p>
<p></p>
<li></li>
A consequence of the previous item is that we can now say:
<pre>
    %hash = qw:c/a b c d {@array} {%hash}/;</pre>
<p>or</p>
<pre>
    %hash = qq:w/a b c d {@array} {%hash}/;</pre>
<p>to interpolate items into a <code>qw</code>.  Conveniently, arrays and hashes
interpolate with only whitespace separators by default, so the subsequent
split on whitespace still works out.  (But the built-in <code>«...»</code> quoter
automatically does interpolation equivalent to <code>qq:ww/.../</code>.  The
built-in <code>&lt;...&gt;</code> is equivalent to <code>q:w/.../</code>.)</p>
<p></p>
<li></li>
Whitespace is allowed between the ``q'' and its adverb: <code>q :w /.../</code>.
<a name="msg_11"></a>
<a href="?hide_quotes=no#msg_11" onclick="return tog_quote(11);">
<div ID="header_shown_11" style="display: none;">
- Hide the snippet from t/operators/quoting.t (line 164 ~ line 173) -
</div>
<div ID="header_hidden_11" style="display: block;">
- Show the snippet from t/operators/quoting.t (line 164 ~ line 173, 10 lines) -
</div>
</a>
<div ID="hide_11" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
  # L&lt;S02/Literals /Whitespace is allowed between the "q" and its adverb: q :w /..././&gt;
    my @q = ();
    try { eval '@q = (q :w /$foo $bar/)' };
    is(+@q, 2, "q :w // is the same as q:w//",:todo&lt;bug&gt;);
    is(@q[0], '$foo', "...",:todo&lt;bug&gt;);
    is(@q[1], '$bar', "...",:todo&lt;bug&gt;);
};


{ # qq:w,Interpolating quote constructor with words adverb 

</pre>
</div>

<p></p>
<li></li>
For these ``q'' forms the choice of delimiters has no influence on the
semantics.  That is, <code>''</code>, <code>&quot;&quot;</code>, <code>&lt;&gt;</code>, <code>«»</code>, <code>``</code>, <code>()</code>,
<code>[]</code>, and <code>{}</code> have no special significance when used in place of
<code>//</code> as delimiters.  There may be whitespace before the
opening delimiter. (Which is mandatory for parens because <code>q()</code> is
a subroutine call and <code>q:w(0)</code> is an adverb with arguments).  Other
brackets may also require whitespace when they would be understood as
an argument to an adverb in something like <code>q:z&lt;foo&gt;//</code>.
A colon may never be used as the delimiter since it will always be
taken to mean another adverb regardless of what's in front of it.
Nor may a <code>#</code> character be used as the delimiter since it is always
taken as whitespace (specifically, as a comment).
<p></p>
<li></li>
New quoting constructs may be declared as macros:
<pre>
    macro quote:&lt;qX&gt; (*%adverbs) {...}</pre>
<p>Note: macro adverbs are automatically evaluated at macro call time if
the adverbs are included in the parse.  If an adverb needs to affect
the parsing of the quoted text of the macro, then an explicit named
parameter may be passed on as a parameter to the <code>is parsed</code> subrule,
or used to select which subrule to invoke.</p>
<p></p>
<li></li>
You may interpolate double-quotish text into a single-quoted string
using the <code>\qq[...]</code> construct.  Other ``q'' forms also work, including
user-defined ones, as long as they start with ``q''.  Otherwise you'll
just have to embed your construct inside a <code>\qq[...]</code>.
<p></p>
<li></li>
Bare scalar variables always interpolate in double-quotish
strings.  Bare array, hash, and subroutine variables may <em>never</em> be
interpolated.  However, any scalar, array, hash or subroutine variable may
start an interpolation if it is followed by a sequence of one or more bracketed
dereferencers: that is, any of:
<ol>
<li><strong><a name="item_An_array_subscript">An array subscript</a></strong><br />
</li>
<li><strong><a name="item_A_hash_subscript">A hash subscript</a></strong><br />
</li>
<li><strong><a name="item_A_set_of_parentheses_indicating_a_function_call">A set of parentheses indicating a function call</a></strong><br />
</li>
<li><strong><a name="item_Any_of_1_through_3_in_their_dot_form">Any of 1 through 3 in their <strong>dot</strong> form</a></strong><br />
</li>
<li><strong><a name="item_A_method_call_that_includes_argument_parentheses">A method call that includes argument parentheses</a></strong><br />
</li>
<li><strong><a name="item_A_sequence_of_one_or_more_unparenthesized_method_c">A sequence of one or more unparenthesized method call, followed by any of 1 through 5</a></strong><br />
</li>
</ol>
<p>In other words, this is legal:</p>
<pre>
    &quot;Val = $a.ord.fmt('%x')\n&quot;</pre>
<p>and is equivalent to</p>
<pre>
    &quot;Val = { $a.ord.fmt('%x') }\n&quot;</pre>
<li></li>
In order to interpolate an entire array, it's necessary now to subscript
with empty brackets:
<pre>
    print &quot;The answers are @foo[]\n&quot;</pre>
<p>Note that this fixes the spurious ``<code>@</code>'' problem in double-quoted email addresses.</p>
<p>As with Perl 5 array interpolation, the elements are separated by a space.
(Except that a space is not added if the element already ends in some kind
of whitespace.  In particular, a list of pairs will interpolate with a
tab between the key and value, and a newline after the pair.)</p>
<a name="msg_12"></a>
<a href="?hide_quotes=no#msg_12" onclick="return tog_quote(12);">
<div ID="header_shown_12" style="display: none;">
- Hide the snippet from t/syntax/interpolation/arrays.t (line 5 ~ line 58) -
</div>
<div ID="header_hidden_12" style="display: block;">
- Show the snippet from t/syntax/interpolation/arrays.t (line 5 ~ line 58, 54 lines) -
</div>
</a>
<div ID="hide_12" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
# L&lt;S02/Literals /As with Perl 5 array interpolation/&gt;
# See L&lt;"http://www.nntp.perl.org/group/perl.perl6.language/23224"&gt;:
#   In a private conversation with Larry this afternoon, he said that by 
#   default "$foo" and ~$foo and $foo.as(Str) all give the same result 
#   (assuming scalar context, etc.).  And that "@foo[]" and ~[at]foo and 
#   @foo.as(Str) are the same as join(' ', @foo) where join is effectively:

plan 10;

{
  my @array = &lt;a b c d&gt;;

  is ~@array, "a b c d",
    "arrays whose elements don't contain whitespace stringify correctly (1)";
  is "@array[]", "a b c d",
    "arrays whose elements don't contain whitespace stringify correctly (2)";
}

{
  my @array = &lt;a b c d&gt;;
  push @array, [&lt;e f g h&gt;];

  is ~@array, "a b c d e f g h",
    "arrays with embedded array references stringify correctly (1)";
  is "@array[]", "a b c d e f g h",
    "arrays with embedded array references stringify correctly (2)";
}

{
  my @array = ("a", "b ", "c");

  is ~@array, "a b  c",
    "array whose elements do contain whitespace stringify correctly (1-1)";
  is "@array[]", "a b  c",
    "array whose elements do contain whitespace stringify correctly (1-2)";
}

{
  my @array = ("a\t", "b ", "c");

  is ~@array, "a\t b  c",
    "array whose elements do contain whitespace stringify correctly (2-1)";
  is "@array[]", "a\t b  c",
    "array whose elements do contain whitespace stringify correctly (2-2)";
}

{
  my @array = ("a\t", " b ", "c");

  is ~@array, "a\t  b  c",
    "array whose elements do contain whitespace stringify correctly (3-1)";
  is "@array[]", "a\t  b  c",
    "array whose elements do contain whitespace stringify correctly (3-2)";
}

</pre>
</div>

<p></p>
<li></li>
In order to interpolate an entire hash, it's necessary to subscript
with empty braces or angles:
<pre>
    print &quot;The associations are:\n%bar{}&quot;
    print &quot;The associations are:\n%bar&lt;&gt;&quot;</pre>
<p>Note that this avoids the spurious ``<code>%</code>'' problem in double-quoted printf formats.</p>
<p>By default, keys and values are separated by tab characters, and pairs
are terminated by newlines.  (This is almost never what you want, but
if you want something polished, you can be more specific.)</p>
<p></p>
<li></li>
In order to interpolate the result of a sub call, it's necessary to include
both the sigil and parentheses:
<pre>
    print &quot;The results are &amp;baz().\n&quot;</pre>
<p>The function is called in scalar context.  (If it returns a list anyway,
that list is interpolated as if it were an array in string context.)</p>
<p></p>
<li></li>
In order to interpolate the result of a method call without arguments,
it's necessary to include parentheses or extend the call with something
ending in brackets:
<a name="msg_13"></a>
<a href="?hide_quotes=no#msg_13" onclick="return tog_quote(13);">
<div ID="header_shown_13" style="display: none;">
- Hide the snippet from t/syntax/interpolation/strings.t (line 34 ~ line 63) -
</div>
<div ID="header_hidden_13" style="display: block;">
- Show the snippet from t/syntax/interpolation/strings.t (line 34 ~ line 63, 30 lines) -
</div>
</a>
<div ID="hide_13" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
# L&lt;S02/"Literals" /"In order to interpolate the result of a method call"&gt;
is("$world.chars()", '5', 'method calls with parens should interpolate');
is("$world.chars", 'World.chars', 'method calls without parens should not interpolate');
is("$world.reverse.chars()", '5', 'cascade of argumentless methods, last ending in paren');
is("$world.substr(0,1)", 'W', 'method calls with parens and args should interpolate');

# Single quotes
# XXX the next tests will always succeed even if '' interpolation is buggy
is('Hello $world', 'Hello $world', 'single quoted string interpolation does not work (which is correct)');
is('2 + 2 = { 2+2 }', '2 + 2 = { 2+2 }', 'single quoted closure interpolation does not work (which is correct)');
is('$world @list[] %hash{} &amp;func()', '$world @list[] %hash{} &amp;func()', 'single quoted string interpolation does not work (which is correct)');

# Corner-cases
is("Hello $world!", "Hello World!", "! is not a part of var names");
sub list_count (*@args) { +@args }
is(list_count("@list[]"), 1, 'quoted interpolation gets string context');
is(qq{a{chr 98}c}, 'abc', "curly brace delimiters don't interfere with closure interpolation");

# Quoting constructs
# The next test will always succeed, but if there's a bug it probably
# won't compile.
is(qn"abc\\d\\'\/", qn"abc\\d\\'\/", "raw quotation works");
is(q"abc\\d\"\'\/", qn|abc\d"\'\/|, "single quotation works"); #"
is(qq"abc\\d\"\'\/", qn|abc\d"'/|, "double quotation works"); #"
is(qa"$world @list[] %hash{}", qn"$world 1 2 %hash{}", "only interpolate array");
is(qb"$world \\\"\n\t", "\$world \\\"\n\t", "only interpolate backslash");
is('$world \qq[@list[]] %hash{}', '$world 1 2 %hash{}', "interpolate quoting constructs in ''");

is(" \d[111] \d[107] ", ' o k ', "\\d[] respects whitespaces around it")


</pre>
</div>

<pre>
    print &quot;The attribute is $obj.attr().\n&quot;
    print &quot;The attribute is $obj.attr&lt;Jan&gt;.\n&quot;</pre>
<p>The method is called in scalar context.  (If it returns a list,
that list is interpolated as if it were an array.)</p>
<p>It is allowed to have a cascade of argumentless methods as long as
the last one ends with parens:</p>
<pre>
    print &quot;The attribute is %obj.keys.sort.reverse().\n&quot;</pre>
<p>(The cascade is basically counted as a single method call for the
end-bracket rule.)</p>
<p></p>
<li></li>
Multiple dereferencers may be stacked as long as each one ends in
some kind of bracket:
<pre>
    print &quot;The attribute is @baz[3](1,2,3){$xyz}&lt;blurfl&gt;.attr().\n&quot;</pre>
<p>Note that the final period above is not taken as part of the expression since
it doesn't introduce a bracketed dereferencer.  Spaces are not allowed
between the dereferencers even when you use the dotted forms.</p>
<p></p>
<li></li>
A bare closure also interpolates in double-quotish context.  It may
not be followed by any dereferencers, since you can always put them
inside the closure.  The expression inside is evaluated in scalar
(string) context.  You can force list context on the expression using
the <code>list</code> operator if necessary.
<p>The following means the same as the previous example.</p>
<pre>
    print &quot;The attribute is { @baz[3](1,2,3){$xyz}&lt;blurfl&gt;.attr }.\n&quot;</pre>
<p>The final parens are unnecessary since we're providing ``real'' code in
the curlies.  If you need to have double quotes that don't interpolate
curlies, you can explicitly remove the capability:</p>
<pre>
    qq:c(0) &quot;Here are { $two uninterpolated } curlies&quot;;</pre>
<p>or equivalently:</p>
<pre>
    qq:!c &quot;Here are { $two uninterpolated } curlies&quot;;</pre>
<p>Alternately, you can build up capabilities from single quote to tell
it exactly what you <em>do</em> want to interpolate:</p>
<pre>
    q:s 'Here are { $two uninterpolated } curlies';</pre>
<p></p>
<li></li>
Secondary sigils (twigils) have no influence over whether the primary sigil
interpolates.  That is, if <code>$a</code> interpolates, so do <code>$^a</code>, <code>$*a</code>,
<code>$=a</code>, <code>$?a</code>, <code>$.a</code>, etc.  It only depends on the <code>$</code>.
<p></p>
<li></li>
No other expressions interpolate.  Use curlies.
<p></p>
<li></li>
A class method may not be directly interpolated.  Use curlies:
<pre>
    print &quot;The dog bark is {Dog.bark}.\n&quot;</pre>
<p></p>
<li></li>
The old disambiguation syntax:
<pre>
    ${foo[$bar]}
    ${foo}[$bar]</pre>
<p>is dead.  Use closure curlies instead:</p>
<pre>
    {$foo[$bar]}
    {$foo}[$bar]</pre>
<p>(You may be detecting a trend here...)</p>
<p></p>
<li></li>
To interpolate a topical method, use curlies: <code>&quot;{.bark}&quot;</code>.
<p></p>
<li></li>
To interpolate a function call without a sigil, use curlies: <code>&quot;{abs $var}&quot;</code>.
<p></p>
<li></li>
And so on.
<p></p>
<li></li>
Backslash sequences still interpolate, but there's no longer any <code>\v</code>
to mean <em>vertical tab</em>, whatever that is...  (<code>\v</code> now match vertical
whitespace in a regex.)
<p></p>
<li></li>
There's also no longer any <code>\L</code>, <code>\U</code>, <code>\l</code>, <code>\u</code>, or <code>\Q</code>.
Use curlies with the appropriate function instead: <code>&quot;{ucfirst $word}&quot;</code>.
<p></p>
<li></li>
You may interpolate any Unicode codepoint by name using <code>\c</code> and
square brackets:
<pre>
    &quot;\c[NEGATED DOUBLE VERTICAL BAR DOUBLE RIGHT TURNSTILE]&quot;</pre>
<p>Multiple codepoints constituting a single character may be interpolated
with a single <code>\c</code> by separating the names with comma:</p>
<pre>
    &quot;\c[LATIN CAPITAL LETTER A, COMBINING RING ABOVE]&quot;</pre>
<p>Whether that is regarded as one character or two depends on the
Unicode support level of the current lexical scope.  It is also
possible to interpolate multiple codepoints that do not resolve to
a single character:</p>
<pre>
    &quot;\c[LATIN CAPITAL LETTER A, LATIN CAPITAL LETTER B]&quot;</pre>
<p>[Note: none of the official Unicode character names contains comma.]</p>
<p></p>
<li></li>
There are no barewords in Perl 6.  An undeclared bare identifier will
always be taken to mean a subroutine or method name.  (Class names
(and other type names) are predeclared, or prefixed with the <code>::</code>
type sigil when you're declaring a new one.)  A consequence of this
is that there's no longer any ``<code>use strict 'subs'</code>''.  Since the syntax
for method calls is distinguished from sub calls, it is only unrecognized
sub calls that must be treated specially.
<p>You still must declare your subroutines, but a bareword with an unrecognized
name is provisionally compiled as a subroutine call, on that assumption that
such a declaration will occur by the end of the current compilation unit:</p>
<pre>
    foo;         # provisional call if neither &amp;foo nor ::foo is defined so far
    foo();       # provisional call if &amp;foo is not defined so far
    foo($x, $y); # provisional call if &amp;foo is not defined so far
    $x.foo;      # not a provisional call; it's a method call on $x
    foo($x);     # not a provisional call; it's a method call on $x</pre>
<p>If a postdeclaration is not seen, the compile fails at <code>CHECK</code> time.
(You are still free to predeclare subroutines explicitly, of course.)
The postdeclaration may be in any lexical or package scope that
could have made the declaration visible to the provisional call had the
declaration occurred before rather than after the provisional
call.</p>
<p>This fixup is done only for provisional calls.  If there
is <em>any</em> real predeclaration visible, it always takes precedence.
In case of multiple ambiguous postdeclarations, either they must all
be multis, or a compile-time error is declared and you must predeclare,
even if one postdeclaration is obviously ``closer''.  A single
<code>proto</code> predeclaration may make all postdeclared <code>multi</code> work fine,
since that's a run-time dispatch, and all multis are effectively
visible at the point of the controlling <code>proto</code> declaration.</p>
<p>Parsing of a bareword function as a provisional call is always done
the same way list operators are treated.  If a postdeclaration
bends the syntax to be inconsistent with that, it is an error of
the inconsistent signature variety.</p>
<p>If the unrecognized subroutine name is followed by <code>postcircumfix:&lt;( )&gt;</code>,
it is compiled as a provisional function call of the parenthesized form.
If it is not, it is compiled as a provisional function call of
the list operator form, which may or may not have an argument list.
When in doubt, the attempt is made to parse an argument list.  As with
any list operator, an immediate postfix operator is illegal unless it is a
form of parentheses, whereas anything following whitespace will be interpreted
as an argument list if possible.</p>
<p>Based on the signature of the subroutine declaration, there are only
four ways that an argument list can be parsed:</p>
<pre>
    Signature           # of expected args
    ()                  0
    ($x)                1
    ($x?)               0..1
    (anything else)     0..Inf</pre>
<p>That is, a standard subroutine call may be parsed only as a 0-arg term
(or function call), a 1-mandatory-arg prefix operator (or function
call), a 1-optional-arg term or prefix operator (or function call), or
an ``infinite-arg'' list operator (or function call).  A given signature
might only accept 2 arguments, but the only number distinctions the
parser is allowed to make is between void, singular and plural;
checking that number of arguments supplied matches some number
larger than one must be done as a separate semantic constraint, not
as a syntactic constraint.  Perl functions never take N arguments
off of a list and leave the rest for someone else, except for small
values of N, where small is defined as not more than 1.  You can get
fancier using macros, but macros <em>always</em> require predeclaration.
Since the non-infinite-list forms are essentially behaving as macros,
those forms also require predeclaration.  Only the infinite-list form
may be postdeclared (and hence used provisionally).</p>
<p>It is illegal for a provisional subroutine call to be followed by a
colon postfix, since such a colon is allowed only on an indirect object,
or a method call in dot form.  (It is also allowed on a label when a
statement is expected.) So for any undeclared identifier ``<code>foo</code>'':</p>
<pre>
    foo.bar             # ILLEGAL       -- postfix must use foo().bar
    foo .bar            # foo($_.bar)   -- no postfix starts with whitespace
    foo\ .bar           # ILLEGAL       -- long dot must use foo()\ .bar
    foo++               # ILLEGAL       -- postfix must use foo()++
    foo 1,2,3           # foo(1,2,3)    -- args always expected after listop
    foo + 1             # foo(+1)       -- term always expected after listop
    foo;                # foo();        -- no postfix, but no args either
    foo:                #   label       -- must be label at statement boundary.
                                        -- ILLEGAL otherwise
    foo: bar:           #   two labels in a row, okay
    .foo:               # $_.foo: 1     -- must be &quot;dot&quot; method with : args
    .foo(1)             # $_.foo(1)     -- must be &quot;dot&quot; method with () args
    .foo                # $_.foo()      -- must be &quot;dot&quot; method with no args
    .$foo:              # $_.$foo: 1    -- indirect &quot;dot&quot; method with : args
    foo bar: 1          # bar.foo(1)    -- bar must be predecl as class
                                        -- sub bar allowed here only if 0-ary
                                        -- otherwise you must say (bar):
    foo bar 1           # foo(bar(1))   -- both subject to postdeclaration
                                        -- never taken as indirect object
    foo $bar: 1         # $bar.foo(1)   -- indirect object even if declared sub
                                        -- $bar considered one token
    foo (bar()):        # bar().foo(1)  -- even if foo declared sub
    foo bar():          # ILLEGAL       -- bar() is two tokens.
    foo .bar:           # foo(.bar:)    -- colon chooses .bar to listopify
    foo bar baz: 1      # foo(baz.bar(1)) -- colon controls &quot;bar&quot;, not foo.
    foo (bar baz): 1    # bar(baz()).foo(1) -- colon controls &quot;foo&quot;
    $foo $bar           # ILLEGAL       -- two terms in a row
    $foo $bar:          # ILLEGAL       -- use $bar.$foo for indirection
    (foo bar) baz: 1    # ILLEGAL       -- use $baz.$(foo bar) for indirection</pre>
<p>The indirect object colon only ever dominates a simple term, where
``simple'' includes classes and variables and parenthesized expressions,
but explicitly not method calls, because the colon will bind to a
trailing method call in preference.  An indirect object that parses as
more than one token must be placed in parentheses, followed by the colon.</p>
<p>In short, only an identifier followed by a simple term followed by a
postfix colon is <code>ever</code> parsed as an indirect object, but that form
will <code>always</code> be parsed as an indirect object regardless of whether
the identifier is otherwise declared.</p>
<p></p>
<li></li>
There's also no ``<code>use strict 'refs'</code>'' because symbolic dereferences
are now syntactically distinguished from hard dereferences.
<code>@($arrayref)</code> must now provide an actual array object, while
<code>@::($string)</code> is explicitly a symbolic reference.  (Yes, this may
give fits to the P5-to-P6 translator, but I think it's worth it to
separate the concepts.  Perhaps the symbolic ref form will admit real
objects in a pinch.)
<p></p>
<li></li>
There is no hash subscript autoquoting in Perl 6.  Use <code>%x&lt;foo&gt;</code>
for constant hash subscripts, or the old standby <code>%x{'foo'}</code>.  (It
also works to say <code>%x«foo»</code> as long as you realized it's subject to
interpolation.)
<p>But <code>=&gt;</code> still autoquotes any bare identifier to its immediate
left (horizontal whitespace allowed but not comments).  The identifier is not
subject to keyword or even macro interpretation.  If you say</p>
<pre>
    $x = do {
        call_something();
        if =&gt; 1;
    }</pre>
<p>then <code>$x</code> ends up containing the pair <code>(&quot;if&quot; =&gt; 1)</code>.  Always.
(Unlike in Perl 5, where version numbers didn't autoquote.)</p>
<p>You can also use the :key($value) form to quote the keys of option
pairs.  To align values of option pairs, you may use the
``long dot'' postfix forms:</p>
<pre>
    :longkey\  .($value)
    :shortkey\ .&lt;string&gt;
    :fookey\   .{ $^a &lt;=&gt; $^b }</pre>
<p>These will be interpreted as</p>
<pre>
    :longkey($value)
    :shortkey&lt;string&gt;
    :fookey{ $^a &lt;=&gt; $^b }</pre>
<p></p>
<li></li>
The double-underscore forms are going away:
<pre>
    Old                 New
    ---                 ---
    __LINE__            $?LINE
    __FILE__            $?FILE
    __PACKAGE__         $?PACKAGE
    __END__             =begin END
    __DATA__            =begin DATA</pre>
<p>The <code>=begin END</code> pod stream is special in that it assumes there's
no corresponding <code>=end END</code> before end of file.  The <code>DATA</code>
stream is no longer special--any POD stream in the current file
can be accessed via a filehandle, named as <code>%=POD{'DATA'}</code> and such.
Alternately, you can treat a pod stream as a scalar via <code>$=DATA</code>
or as an array via <code>@=DATA</code>.  Presumably a module could read all
its COMMENT blocks from <code>@=COMMENT</code>, for instance.  Each chunk of
pod comes as a separate array element.  You have to split it into lines
yourself.  Each chunk has a <code>.linenum</code> property that indicates its
starting line within the source file.</p>
<p>The lexical routine itself is <code>&amp;?ROUTINE</code>; you can get its name with
<code>&amp;ROUTINE.name</code>.  The current block is <code>&amp;?BLOCK</code>.  If the block has a label,
that shows up in <code>&amp;?BLOCK.label</code>.</p>
<p></p>
<li></li>
Heredocs are no longer written with <code>&lt;&lt;</code>, but with an adverb on
any other quote construct:
<pre>
    print qq:to/END/;
        Give $amount to the man behind curtain number $curtain.
        END</pre>
<p>Other adverbs are also allowed, as are multiple heredocs within the same
expression:</p>
<pre>
    print q:c:to/END/, q:to/END/;
        Give $100 to the man behind curtain number {$curtain}.
        END
        Here is a $non-interpolated string
        END</pre>
<p></p>
<li></li>
Here docs allow optional whitespace both before and after terminating
delimiter.  Leading whitespace equivalent to the indentation of the
delimiter will be removed from all preceding lines.  If a line is
deemed to have less whitespace than the terminator, only whitespace
is removed, and a warning may be issued.  (Hard tabs will be assumed
to be 8 spaces, but as long as tabs and spaces are used consistently
that doesn't matter.)  A null terminating delimiter terminates on
the next line consisting only of whitespace, but such a terminator
will be assumed to have no indentation.  (That is, it's assumed to
match at the beginning of any whitespace.)
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>

<h1><a name="Context">Context</a></h1>
<ul>
<li></li>
Perl still has the three main contexts: void, scalar, and list.
<p></p>
<li></li>
In addition to undifferentiated scalars, we also have these scalar contexts:
<pre>
    Context     Type    OOtype  Operator
    -------     ----    ------  --------
    boolean     bit     Bit     ?</pre>
<a name="msg_17"></a>
<a href="?hide_quotes=no#msg_17" onclick="return tog_quote(17);">
<div ID="header_shown_17" style="display: none;">
- Hide the snippet from t/syntax/force_context.t (line 54 ~ line 74) -
</div>
<div ID="header_hidden_17" style="display: block;">
- Show the snippet from t/syntax/force_context.t (line 54 ~ line 74, 21 lines) -
</div>
</a>
<div ID="hide_17" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
# L&lt;S02/Context/boolean "?"&gt;
# L&lt;S03/Changes to Perl 5 operators/"?" imposes boolean context&gt;
# boolean context
{
    my $a = '';
    is(ref(?$a), 'Bool', 'it is forced into a Bool');
    ok(!(?$a), 'it is forced into boolean context');

    my $b = 'This will be true';
    is(ref(?$b), 'Bool', 'it is forced into a Bool');
    ok(?$b, 'it is forced into boolean context');

    my $c = 0;
    is(ref(?$c), 'Bool', 'it is forced into a Bool');
    ok(!(?$c), 'it is forced into boolean context');

    my $d = 1;
    is(ref(?$d), 'Bool', 'it is forced into a Bool');
    ok(?$d, 'it is forced into boolean context');
}


</pre>
</div>

<pre>
    integer     int     Int     int
    numeric     num     Num     +</pre>
<a name="msg_15"></a>
<a href="?hide_quotes=no#msg_15" onclick="return tog_quote(15);">
<div ID="header_shown_15" style="display: none;">
- Hide the snippet from t/syntax/force_context.t (line 13 ~ line 24) -
</div>
<div ID="header_hidden_15" style="display: block;">
- Show the snippet from t/syntax/force_context.t (line 13 ~ line 24, 12 lines) -
</div>
</a>
<div ID="hide_15" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
# L&lt;S02/Context/numeric "+"&gt;
# numeric (+) context
{
    my $a = '2 is my favorite number';
    is(ref(+$a), 'Num', 'it is forced into a Num');
    is(+$a, 2, 'forced into numeric context');

    my $b = 'Did you know that, 2 is my favorite number';
    is(ref(+$b), 'Num', 'it is forced into a Num');
    is(+$b, 0, 'non numbers forced into numeric context are 0');
}


</pre>
</div>

<pre>
    string      buf     Str     ~</pre>
<a name="msg_16"></a>
<a href="?hide_quotes=no#msg_16" onclick="return tog_quote(16);">
<div ID="header_shown_16" style="display: none;">
- Hide the snippet from t/syntax/force_context.t (line 37 ~ line 53) -
</div>
<div ID="header_hidden_16" style="display: block;">
- Show the snippet from t/syntax/force_context.t (line 37 ~ line 53, 17 lines) -
</div>
</a>
<div ID="hide_16" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
# L&lt;S02/Context/string "~"&gt;
# L&lt;S03/Changes to Perl 5 operators/Unary ~ string context&gt;
# string context
{
    my $a = 10.500000;
    is(ref(~$a), 'Str', 'it is forced into a Str');
    is(~$a, '10.5', 'forced into string context');

    my $b = -100;
    is(ref(~$b), 'Str', 'it is forced into a Str');
    is(~$b, '-100', 'forced into string context');

    my $c = -100.1010;
    is(ref(~$c), 'Str', 'it is forced into a Str');
    is(~$c, '-100.101', 'forced into string context');
}


</pre>
</div>

<p>There are also various container contexts that require particular kinds of
containers.</p>
<p></p>
<li></li>
Unlike in Perl 5, objects are no longer always considered true.
It depends on the state of their <code>.bit</code> property.  Classes get to decide
which of their values are true and which are false.  Individual objects
can override the class definition:
<a name="msg_14"></a>
<a href="?hide_quotes=no#msg_14" onclick="return tog_quote(14);">
<div ID="header_shown_14" style="display: none;">
- Hide the snippet from t/oo/syntax-but.t (line 62 ~ line 71) -
</div>
<div ID="header_hidden_14" style="display: block;">
- Show the snippet from t/oo/syntax-but.t (line 62 ~ line 71, 10 lines) -
</div>
</a>
<div ID="hide_14" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
# L&lt;S02/Context/"can override the class definition:"&gt;
my $true_zero;
ok((eval '$true_zero = 0 but True; 1'), "0 but True syntax evaluates");
ok ($true_zero == 0), "0 but True is numerically equal to 0";
ok ?($true_zero), "0 but True is true";
# TimToady++ says I can test False as well
my $false_positive;
ok(eval('$false_positive = 3 but False; 1'), "3 but False syntax evaluates");
ok ($false_positive == 3), "3 but False is numerically equal to 3";
ok !($false_positive), "3 but False is false";

</pre>
</div>

<pre>
    return 0 but True;</pre>
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>

<h1><a name="Lists">Lists</a></h1>
<ul>
<li></li>
List context in Perl 6 is by default lazy.  This means a list can
contain infinite generators without blowing up.  No flattening happens
to a lazy list until it is bound to the signature of a function or
method at call time (and maybe not even then).  We say that such
an argument list is ``lazily flattened'', meaning that we promise to
flatten the list on demand, but not before.
<p></p>
<li></li>
There is a ``<code>list</code>'' operator which imposes a list context on
its arguments even if <code>list</code> itself occurs in a scalar context.
In list context, it flattens lazily.  In a scalar context, it returns
the resulting list as a single <code>List</code> object.  (So the <code>list</code> operator
really does exactly the same thing as putting a list in parentheses with
at least one comma.  But it's more readable in some situations.)
<p></p>
<li></li>
The <code>[,]</code> list operator may be used to force list context on its
argument and <em>also</em> defeat any scalar argument checking imposed by
subroutine signature declarations.  This list flattens lazily.
<p></p>
<li></li>
To force non-lazy list flattening, use the <code>eager</code> list operator.
Don't use it on an infinite generator unless you have a machine with
infinite memory, and are willing to wait a long time.  It may also
be applied to a scalar iterator to force immediate iteration to completion.
<p></p>
<li></li>
Signatures on non-multi subs can be checked at compile time, whereas
multi sub and method call signatures can only be checked at run time
(in the absence of special instructions to the optimizer).
<p>This is not a problem for arguments that are arrays or hashes,
since they don't have to care about their context, but just return
themselves in any event, which may or may not be lazily flattened.</p>
<p>However, function calls in the argument list can't know their eventual
context because the method hasn't been dispatched yet, so we don't
know which signature to check against.  As in Perl 5, list context
is assumed unless you explicitly qualify the argument with a scalar
context operator.</p>
<p></p>
<li></li>
The <code>=&gt;</code> operator now constructs <code>Pair</code> objects rather than merely
functioning as a comma.  Both sides are in scalar context.
<p></p>
<li></li>
The <code>..</code> operator now constructs <code>Range</code> objects rather than merely
functioning as an operator.  Both sides are in scalar context.
<p></p>
<li></li>
There is no such thing as a hash list context.  Assignment to a hash
produces an ordinary list context.  You may assign alternating keys
and values just as in Perl 5.  You may also assign lists of <code>Pair</code> objects, in
which case each pair provides a key and a value.  You may, in fact,
mix the two forms, as long as the pairs come when a key is expected.
If you wish to supply a <code>Pair</code> as a key, you must compose an outer <code>Pair</code>
in which the key is the inner <code>Pair</code>:
<pre>
    %hash = (($keykey =&gt; $keyval) =&gt; $value);</pre>
<p></p>
<li></li>
The anonymous <code>enum</code> function takes a list of keys or pairs, and adds
values to any keys that are not already part of a key.  The value added
is one more than the previous key or pair's value.  This works nicely with
the new <code>qq:ww</code> form:
<pre>
    %hash = enum &lt;&lt;:Mon(1) Tue Wed Thu Fri Sat Sun&gt;&gt;;
    %hash = enum « :Mon(1) Tue Wed Thu Fri Sat Sun »;</pre>
<p>are the same as:</p>
<pre>
    %hash = ();
    %hash&lt;Mon Tue Wed Thu Fri Sat Sun&gt; = 1..7;</pre>
<p></p>
<li></li>
In contrast to assignment, binding to a hash requires a <code>Hash</code> (or
<code>Pair</code>) object.  Binding to a ``splat'' hash requires a list of pairs
or hashes, and stops processing the argument list when it runs out
of pairs or hashes.  See S06 for much more about parameter binding.
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>

<h1><a name="Files">Files</a></h1>
<ul>
<li></li>
Filename globs are no longer done with angle brackets.  Use the <code>glob</code>
function.
<p></p>
<li></li>
Input from a filehandle is no longer done with angle brackets.  Instead
of
<pre>
    while (&lt;HANDLE&gt;) {...}</pre>
<p>you now write</p>
<a name="msg_26"></a>
<a href="?hide_quotes=no#msg_26" onclick="return tog_quote(26);">
<div ID="header_shown_26" style="display: none;">
- Hide the snippet from t/builtins/io/io.t (line 53 ~ line 157) -
</div>
<div ID="header_hidden_26" style="display: block;">
- Show the snippet from t/builtins/io/io.t (line 53 ~ line 157, 105 lines) -
</div>
</a>
<div ID="hide_26" style="display:none; border:1px solid">
<pre style="margin-left: 6px">
# L&lt;S02/Files /you now write/&gt;
my $in3 = open($filename);
isa_ok($in3, 'IO');
my $line3a = =$in3;
is($line3a, "Hello World", 'unary =$in worked');
my $line3b = =$in3;
is($line3b, "Foo Bar Baz", 'unary =$in worked');
my $line3c = =$in3;
is($line3c, "The End", 'unary =$in worked');
ok($in3.close, 'file closed okay (3)');

# append to the file

my $append = open($filename, :a);
isa_ok($append, 'IO');
$append.say("... Its not over yet!");
ok($append.close, 'file closed okay (append)');

# now read in in list context

my $in4 = open($filename);
isa_ok($in4, 'IO');
my @lines4 = readline($in4);
is(+@lines4, 4, 'we got four lines from the file');
is(@lines4[0], "Hello World", 'readline($in) worked in list context');
is(@lines4[1], "Foo Bar Baz", 'readline($in) worked in list context');
is(@lines4[2], "The End", 'readline($in) worked in list context');
is(@lines4[3], "... Its not over yet!", 'readline($in) worked in list context');
ok($in4.close, 'file closed okay (4)');

my $in5 = open($filename);
isa_ok($in5, 'IO');
my @lines5 = $in5.readline();
is(+@lines5, 4, 'we got four lines from the file');
is(@lines5[0], "Hello World", '$in.readline() worked in list context');
is(@lines5[1], "Foo Bar Baz", '$in.readline() worked in list context');
is(@lines5[2], "The End", '$in.readline() worked in list context');
is(@lines5[3], "... Its not over yet!", '$in.readline() worked in list context');
ok($in5.close, 'file closed okay (5)');

my $in6 = open($filename);
isa_ok($in6, 'IO');
my @lines6 = =$in6;
is(+@lines6, 4, 'we got four lines from the file');
is(@lines6[0], "Hello World", 'unary =$in worked in list context');
is(@lines6[1], "Foo Bar Baz", 'unary =$in worked in list context');
is(@lines6[2], "The End", 'unary =$in worked in list context');
is(@lines6[3], "... Its not over yet!", 'unary =$in worked in list context');
ok($in6.close, 'file closed okay (6)');

# test reading a file into an array and then closing before 
# doing anything with the array (in other words, is pugs too lazy)
my $in7 = open($filename);
isa_ok($in7, 'IO');
my @lines7 = readline($in7);
ok($in7.close, 'file closed okay (7)');
is(+@lines7, 4, 'we got four lines from the file (lazily)');
is(@lines7[0], "Hello World", 'readline($in) worked in list context');
is(@lines7[1], "Foo Bar Baz", 'readline($in) worked in list context');
is(@lines7[2], "The End", 'readline($in) worked in list context');
is(@lines7[3], "... Its not over yet!", 'readline($in) worked in list context');

#now be sure to delete the file as well

is(unlink($filename), 1, 'file has been removed');

# new file for testing other types of open() calls

my $out8 = open($filename, :w);
isa_ok($out8, 'IO');
$out8.say("Hello World");
ok($out8.close, 'file closed okay (out8)');

my $in8 = open($filename);
isa_ok($in8, 'IO');
my $line8_1 = readline($in8);
is($line8_1, "Hello World", 'readline($in) worked');
ok($in8.close, 'file closed okay (in8)');

my $fh9 = open($filename, :r, :w);  # was "&lt;+" ? 
isa_ok($fh9, 'IO');
#my $line9_1 = readline($fh9);
#is($line9_1, "Hello World");
#$fh9.say("Second line");
ok($fh9.close, 'file closed okay (9)');

#my $in9 = open($filename);
#isa_ok($in9, 'IO');
#my $line9_1 = readline($in9);
#my $line9_2 = readline($in9);
#is($line9_1, "Hello World", 'readline($in) worked');
#is($line9_2, "Second line", 'readline($in) worked');

my $fh10 = open($filename, :rw);  # was "&lt;+" ? 
isa_ok($fh10, 'IO');
#ok($fh10.close, 'file closed okay (10)');

# This test fails on win32; skip it for now.
if $*OS eq any &lt;MSWin32 mingw msys cygwin&gt; {
    unlink($filename);
    flunk('skip unlink() test - erratic behaviour on win32', :todo&lt;bug&gt;);
}
else {
    ok(unlink($filename), 'file has been removed');
}

</pre>
</div>

<pre>
    for =$handle {...}</pre>
<p>As a unary prefix operator, you may also apply adverbs to <code>=</code>:</p>
<pre>
    for =$handle :prompt('$ ') { say $_ + 1 }</pre>
<p>or</p>
<pre>
    for =($handle):prompt('$ ') { say $_ + 1 }</pre>
<p>or you may even write it in its functional form, passing the adverbs
as ordinary named arguments.</p>
<pre>
    for prefix:&lt;=&gt;($handle, :prompt('$ ')) { say $_ + 1 }</pre>
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>

<h1><a name="Properties">Properties</a></h1>
<ul>
<li></li>
Properties work as detailed in S12.  They're actually object
attributes provided by role mixins.  Compile-time properties applied
to containers and such still use the <code>is</code> keyword, but are now called
``traits''.  On the other hand, run-time properties are attached to
individual objects using the <code>but</code> keyword instead, but are still
called ``properties''.
<p></p>
<li></li>
Properties are accessed just like attributes because they are in fact
attributes of some class or other, even if it's an anonymous singleton
class generated on the fly for that purpose.  Since ``<code>rw</code>'' attributes
behave in all respects as variables, properties may therefore also
be temporized with <code>temp</code>, or hypotheticalized with <code>let</code>.
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>

<h1><a name="Grammatical20Categories">Grammatical Categories</a></h1>
<p>Lexing in Perl 6 is controlled by a system of grammatical categories.
At each point in the parse, the lexer knows which subset of the
grammatical categories are possible at that point, and follows the
longest-token rule across all the active grammatical categories.
(Ordering of grammatical categories matters only in case of a ``tie'',
in which case the grammatical category that is notionally ``first''
in the grammar wins.  For instance, a statement_control is always going to win out over a prefix operator of the same name.  More specifically, you can't
call a function named ``if'' directly because it would be hidden either
by the statement_control category or the statement_modifier category.)</p>
<p>Here are the current grammatical categories:</p>
<pre>
    term:&lt;...&gt;                                  $x = {...}
    quote:&lt;qX&gt;                                  qX/foo/
    prefix:&lt;!&gt;                                  !$x (and $x.! if no postfix:&lt;!&gt;)
    infix:&lt;+&gt;                                   $x + $y
    postfix:&lt;++&gt;                                $x++
    circumfix:&lt;[ ]&gt;                             [ @x ]
    postcircumfix:&lt;[ ]&gt;                         $x[$y] or $x.[$y]
    regex_metachar:&lt;,&gt;                          /,/
    regex_backslash:&lt;w&gt;                         /\w/ and /\W/
    regex_assertion:&lt;*&gt;                         /&lt;*stuff&gt;/
    regex_mod_internal:&lt;perl5&gt;                  m:/ ... :perl5 ... /
    regex_mod_external:&lt;nth&gt;                    m:nth(3)/ ... /
    trait_verb:&lt;handles&gt;                        has $.tail handles &lt;wag&gt;
    trait_auxiliary:&lt;shall&gt;                     my $x shall conform&lt;TR123&gt;
    scope_declarator:&lt;has&gt;                      has $.x;
    statement_control:&lt;if&gt;                      if $condition {...} else {...}
    statement_modifier:&lt;if&gt;                     ... if $condition
    infix_prefix_meta_operator:&lt;!&gt;              $x !~~ 2;
    infix_postfix_meta_operator:&lt;=&gt;             $x += 2;
    postfix_prefix_meta_operator:{'»'}          @array »++
    prefix_postfix_meta_operator:{'«'}          -« @magnitudes
    infix_circumfix_meta_operator:{'»','«'}     @a »+« @b
    prefix_circumfix_meta_operator:{'[',']'}    [*]</pre>
<p>Any category containing ``circumfix'' requires two token arguments, supplied
in slice notation.</p>
<p><a href="#__index__"><small>Back to Top</small></a></p>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" valign="middle">
<big><strong><span class="block">&nbsp;TITLE</span></strong></big>
</td></tr>
</table>

</body>

</html>
