<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
           "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>S02</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="http://dev.perl.org/css/perl.css">

<script type="text/javascript">
var agt = navigator.userAgent.toLowerCase();

var is_opera = (agt.indexOf("opera") != -1);
var is_ie = (agt.indexOf("msie") != -1) && document.all && !is_opera;
var is_ie5 = (agt.indexOf("msie 5") != -1) && document.all;

function tog() {
  // tog: toggle the visibility of html elements (arguments[1..]) from none to
  // arguments[0].  Return what should be returned in a javascript onevent().
  display = arguments[0];
  for( var i=1; i<arguments.length; i++ ) {
    var x = document.getElementById(arguments[i]);
    if (!x) continue;
    if (x.style.display == "none" || x.style.display == "") {
      x.style.display = display;
    } else {
      x.style.display = "none";
    }
  }

  var e = is_ie ? window.event : this;
  if (e) {
    if (is_ie) {
      e.cancelBubble = true;
      e.returnValue = false;
      return false;
    } else {
      return false;
    }
  }
}

function tog_quote( idnum ) {
  return tog( 'block', 'header_shown_' + idnum, 'header_hidden_' + idnum,
       'hide_' + idnum );
}

</script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.03,
  using Pod::Simple::PullParser v2.02,
  under Perl v5.008007 at Fri Aug 25 07:51:21 2006 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
            <I>This page was generated at 2006-08-25 07:51:22 GMT. (syn r11316)</I>
        
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Lexical_Conventions'>Lexical Conventions</a>
  <li class='indexItem indexItem1'><a href='#Whitespace_and_Comments'>Whitespace and Comments</a>
  <li class='indexItem indexItem1'><a href='#Built-In_Data_Types'>Built-In Data Types</a>
  <li class='indexItem indexItem1'><a href='#Names_and_Variables'>Names and Variables</a>
  <li class='indexItem indexItem1'><a href='#Names'>Names</a>
  <li class='indexItem indexItem1'><a href='#Literals'>Literals</a>
  <li class='indexItem indexItem1'><a href='#Context'>Context</a>
  <li class='indexItem indexItem1'><a href='#Lists'>Lists</a>
  <li class='indexItem indexItem1'><a href='#Files'>Files</a>
  <li class='indexItem indexItem1'><a href='#Properties'>Properties</a>
  <li class='indexItem indexItem1'><a href='#Grammatical_Categories'>Grammatical Categories</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 2: Bits and Pieces</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Larry Wall &#60;larry@wall.org&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre>  Maintainer: Larry Wall &#60;larry@wall.org&#62;
  Date: 10 Aug 2004
  Last Modified: 15 Aug 2006
  Number: 2
  Version: 65</pre>

<p>This document summarizes Apocalypse 2, which covers small-scale lexical items and typological issues. (These Synopses also contain updates to reflect the evolving design of Perl 6 over time, unlike the Apocalypses, which are frozen in time as &#34;historical documents&#34;. These updates are not marked--if a Synopsis disagrees with its Apocalypse, assume the Synopsis is correct.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Lexical_Conventions"
>Lexical Conventions</a></h1>

<ul>
<li>In the abstract, Perl is written in Unicode, and has consistent Unicode semantics regardless of the underlying text representations.
<a name="msg_27"></a>
<a href="?hide_quotes=no#msg_27" onclick="return tog_quote(27);">
<div ID="header_shown_27" style="display: none;">
- Hide the snippet from t/syntax/unicode.t (line 7 ~ line 80) -
</div>
<div ID="header_hidden_27" style="display: block;">
- Show the snippet from t/syntax/unicode.t (line 7 ~ line 80, 74 lines) -
</div>
</a>
<div ID="hide_27" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S02/&quot;Lexical Conventions&quot;/&quot;Perl is written in Unicode&quot;&gt;

# Unicode variables
# english ;-)
ok(try {my $foo; sub foo {}; 1}, &quot;ascii declaration&quot;);
is(try {my $bar = 2; sub id ($x) { $x }; id($bar)}, 2, &quot;evaluation&quot;); 

# umlauts
ok(try {my $übervar; sub fü {}; 1}, &quot;umlauts declaration&quot;);
is(try {my $schloß = 2; sub öok ($x) { $x }; öok($schloß)}, 2, &quot;evaluation&quot;);

# monty python
ok(try {my $møøse; sub bïte {}; 1}, &quot;a møøse once bit my sister&quot;);
is(try {my $møøse = 2; sub såck ($x) { $x }; såck($møøse)}, 2, &quot;møøse bites kan be preti nasti&quot;);

# french
ok(try {my $un_variable_français; sub blâ {}; 1}, &quot;french declaration&quot;);
is(try {my $frénch = 2; sub bléch ($x) { $x }; bléch($frénch)}, 2, &quot;evaluation&quot;);

# Some Chinese Characters
ok(try {my $一; 1}, &quot;chinese declaration&quot;);
is(try {my $二 = 2; sub 恆等($x) {$x}; 恆等($二)}, 2, &quot;evaluation&quot;);

# Tibetan Characters
ok(try {my $ཀ; 1}, &quot;tibetan declaration&quot;);
is(try {my $ཁ = 2; $ཁ}, 2, &quot;evaluation&quot;);

# Japanese
ok(try {my $い; 1}, &quot;japanese declaration&quot;);
is(try {my $に = 2; $に}, 2, &quot;evaluation&quot;);

# arabic
ok(try {my $الصفحة ; 1}, &quot;arabic declaration&quot;);
is(try {my $الصفحة = 2; $الصفحة}, 2, &quot;evaluation&quot;);

# hebrew
ok(try {my $פוו; sub לה {}; 1}, &quot;hebrew declaration&quot;);
is(try {my $באר = 2; sub זהות ($x) { $x }; זהות($באר)}, 2, &quot;evaluation&quot;);

# russian
ok(try {my $один; sub раз {}; 1}, &quot;russian declaration&quot;);
is(try {my $два = 2; sub идентичный ($x) { $x }; идентичный($два)}, 2, &quot;evaluation&quot;);

# Unicode subs
{
    my sub äöü () { 42 }
    is äöü, 42, &quot;Unicode subs with no parameters&quot;;
}
{
    my sub äöü ($x) { 1000 + $x }
    is äöü 17, 1017, &quot;Unicode subs with one parameter (parsed as prefix ops)&quot;;
}

# Unicode parameters
{
    my sub abc (:$äöü) { 1000 + $äöü }

    is abc(äöü =&gt; 42), 1042, &quot;Unicode named params (1)&quot;;
    is abc(:äöü(42)),  1042, &quot;Unicode named params (2)&quot;;
}

# Unicode placeholder variables
{
    is
        ~(&lt; foostraße barstraße fakestraße &gt;.map:{ ucfirst $^straßenname }),
        &quot;Foostraße Barstraße Fakestraße&quot;,
        &quot;Unicode placeholder variables&quot;;
}

# Unicode methods
{
    my method Str::äöü { ucfirst self }
    is &quot;pugs&quot;.äöü, &quot;Pugs&quot;, &quot;Unicode methods&quot;;
}</pre>
</div>

</li>

<li>Perl can count Unicode line and paragraph separators as line markers, but that behavior had better be configurable so that Perl&#39;s idea of line numbers matches what your editor thinks about Unicode lines.</li>

<li>Unicode horizontal whitespace is counted as whitespace, but it&#39;s better not to use thin spaces where they will make adjoining tokens look like a single token. On the other hand, Perl doesn&#39;t use indentation as syntax, so you are free to use any whitespace anywhere that whitespace makes sense. Comments always count as whitespace.</li>

<li>For some syntactic purposes, Perl distinguishes bracketing characters from non-bracketing. Bracketing characters are defined as any Unicode characters with either bidirectional mirrorings or Ps/Pe properties.
<p>In practice, though, you&#39;re safest using matching characters with Ps/Pe properties, though ASCII angle brackets are a notable exception, since they&#39;re bidirectional but not in the Ps/Pe set.</p>

<p>Characters with no corresponding closing character do not qualify as opening brackets. This includes the second section of the Unicode BidiMirroring data table, as well as <code>U+201A</code> and <code>U+201E</code>.</p>

<p>If a character is already used in Ps/Pe mappings, then its entry in BidiMirroring is ignored. Therefore <code>U+298D</code> maps to <code>U+298E</code>, not <code>U+2990</code>, and <code>U+298E</code> itself is not a valid bracket opener.</p>

<p>The <code>U+301D</code> has two closing alternatives, <code>U+301E</code> and <code>U+301F</code>; Perl 6 only recognizes the one with lower code point number, <code>U+301E</code>, as the closing brace. This policy also applies to new one-to-many mappings introduced in the future.</p>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Whitespace_and_Comments"
>Whitespace and Comments</a></h1>

<ul>
<li>Single-line comments work as in Perl 5, starting with a <code>#</code> character and ending at the subsequent newline. They count as whitespace equivalent to newline for purposes of separation. Unlike in Perl 5, <code>#</code> may not be used as the delimiter in quoting constructs.</li>

<li>Multiline comments are provided by extending the syntax of POD to nest <code>=begin comment</code>/<code>=end comment</code> correctly without the need for <code>=cut</code>. The format name does not have to be <code>comment</code> -- any unrecognized format name will do to make it a comment. (However, bare <code>=begin</code> and <code>=end</code> probably aren&#39;t good enough, because all comments in them will show up in the formatted output.)
<a name="msg_19"></a>
<a href="?hide_quotes=no#msg_19" onclick="return tog_quote(19);">
<div ID="header_shown_19" style="display: none;">
- Hide the snippet from t/syntax/POD.t (line 7 ~ line 53) -
</div>
<div ID="header_hidden_19" style="display: block;">
- Show the snippet from t/syntax/POD.t (line 7 ~ line 53, 47 lines) -
</div>
</a>
<div ID="hide_19" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S02/&quot;Whitespace and Comments&quot;/&quot;Multiline comments&quot; extending POD&gt;
# others will be added later, or you can do it.

eval_ok '
=begin DATA LABEL1
LABEL1.1
LABEL1.2
LABEL1.3
=end DATA

=begin DATA LABEL2
LABEL2.1
LABEL2.2
=end DATA
', &quot;=begin DATA works&quot;, :todo;

eval_is('%=DATA&lt;LABEL1&gt;[0]', 'LABEL1.1', '@=DATA&lt;LABEL1&gt;[0] is correct', :todo);
eval_is('%=DATA&lt;LABEL1&gt;[2]', 'LABEL1.3', '@=DATA&lt;LABEL1&gt;[2] is correct', :todo);
eval_is('~ %=DATA&lt;LABEL1&gt;', 'LABEL1.1LABEL1.2LABEL1.3', '~ %=DATA&lt;LABEL1&gt; is correct', :todo);

eval_is('~ $=LABEL2', 'LABEL2.1LABEL2.2', '~ $=LABEL2 is correct', :todo);
eval_is('$=LABEL2[1]', 'LABEL2.2', '$=LABEL2[1] is correct', :todo);

# S02 says this &quot;=begin comment&quot; &quot;=end comment&quot; shouldn't need a &quot;=cut&quot;
# to indicate the end of the pod.

eval_is( '
=begin comment

This is a comment with a &quot;=cut&quot;.

=end comment
=cut

return &quot;foo&quot;;
', 'foo');

eval_is( '
=begin comment

This is a comment without a &quot;=cut&quot;.

=end comment

return &quot;foo&quot;;
', 'foo');</pre>
</div>


<p>We have single paragraph comments with <code>=for comment</code> as well. That lets <code>=for</code> keep its meaning as the equivalent of a <code>=begin</code> and <code>=end</code> combined. As with <code>=begin</code> and <code>=end</code>, a comment started in code reverts to code afterwards.</p>

<p>Since there is a newline before the first <code>=</code>, the POD form of comment counts as whitespace equivalent to a newline.</p>
</li>

<li>Embedded comments are supported as a variant on quoting syntax, introduced by <code>#</code> plus any user-selected bracket characters (as defined in <a href="#Lexical_Conventions" class="podlinkpod"
>&#34;Lexical Conventions&#34;</a> above):
<a name="msg_25"></a>
<a href="?hide_quotes=no#msg_25" onclick="return tog_quote(25);">
<div ID="header_shown_25" style="display: none;">
- Hide the snippet from t/syntax/comments.t (line 10 ~ line 48) -
</div>
<div ID="header_hidden_25" style="display: block;">
- Show the snippet from t/syntax/comments.t (line 10 ~ line 48, 39 lines) -
</div>
</a>
<div ID="hide_25" style="display:none; border:1px solid">
<pre style="margin-left: 6px">    # L&lt;S02/&quot;Whitespace and Comments&quot;/&quot;Embedded comments&quot;
    #  &quot;#&quot; plus any bracket&gt;

    ok #[
        Multiline
        comments
        is fine
    ] 1, 'multiline embedded comment with #[]';

    ok #(
        Parens works also
    ) 1, 'multiline embedded comment with #()';

    my $var = #{ foo bar } 32;
    is $var, 32, 'embedded comment with #{}';

    $var = 3 + #「 this is a comment 」 56;
    is $var, 59, 'embedded comment with LEFT/RIGHT CORNER BRACKET';

    $var = 2 #『 blah blah blah 』 * 3;
    is $var, 6, 'embedded comment with LEFT/RIGHT WHITE CORNER BRACKET';

    my @list = 'a'..'c';

    # FIXME: $var = @list[ #（注释）2 ];
    is $var, 'c', 'embedded comment with FULLWIDTH LEFT/RIGHT PARENTHESIS';

    $var = @list[ 0 #《注释》];
    is $var, 'a', 'embedded comment with LEFT/RIGHT DOUBLE ANGLE BRACKET';

    $var = @list[#〈注释〉1];
    is $var, 'b', 'embedded comment with LEFT/RIGHT ANGLE BRACKET';

    # Note that 'LEFT/RIGHT SINGLE QUOTATION MARK' (i.e. ‘’) and
    # LEFT/RIGHT DOUBLE QUOTATION MARK (i.e. “”) are not valid delimiter
    # characters.
}

{</pre>
</div>


<pre>    say #( embedded comment ) &#34;hello, world!&#34;;

    $object\#{ embedded comments }.say;

    $object\ #&#12300;
        embedded comments
    &#12301;.say;</pre>

<p>Brackets may be nested, following the same policy as ordinary quote brackets.</p>

<p>There must be no space between the <code>#</code> and the opening bracket character. (There may be the <i>visual appearance</i> of space for some double-wide characters, however, such as the corner quotes above.)</p>

<a name="msg_24"></a>
<a href="?hide_quotes=no#msg_24" onclick="return tog_quote(24);">
<div ID="header_shown_24" style="display: none;">
- Hide the snippet from t/syntax/comments.t (line 49 ~ line 57) -
</div>
<div ID="header_hidden_24" style="display: block;">
- Show the snippet from t/syntax/comments.t (line 49 ~ line 57, 9 lines) -
</div>
</a>
<div ID="hide_24" style="display:none; border:1px solid">
<pre style="margin-left: 6px">    # L&lt;S02/&quot;Whitespace and Comments&quot;/&quot;no space&quot; between &quot;#&quot; and bracket&gt;

    ok !eval(&quot;3 * # (invalid comment) 2&quot;), &quot;no space allowed between '#' and '('&quot;;
    ok !eval(&quot;3 * #\t[invalid comment] 2&quot;), &quot;no tab allowed between '#' and '['&quot;;
    ok !eval(&quot;3 * #  \{invalid comment\} 2&quot;), &quot;no spaces allowed between '#' and '\{'&quot;;
    ok !eval(&quot;3 * #\n&lt;invalid comment&gt; 2&quot;), &quot;no spaces allowed between '#' and '&lt;'&quot;;
}

{</pre>
</div>

</li>

<li>As a special case to facilitate commenting out sections of code with <code>s/^/#/</code>, <code>#</code> on the beginning of line is always considered a line-end comment rather than an embedded comment, even if followed by a bracketing character.
<a name="msg_21"></a>
<a href="?hide_quotes=no#msg_21" onclick="return tog_quote(21);">
<div ID="header_shown_21" style="display: none;">
- Hide the snippet from t/syntax/comments.t (line 94 ~ line 105) -
</div>
<div ID="header_hidden_21" style="display: block;">
- Show the snippet from t/syntax/comments.t (line 94 ~ line 105, 12 lines) -
</div>
</a>
<div ID="hide_21" style="display:none; border:1px solid">
<pre style="margin-left: 6px">    # L&lt;S02/&quot;Whitespace and Comments&quot;/
    #   &quot;#&quot; on &quot;beginning of line&quot; always &quot;line-end comment&quot;&gt;

    is 31,
#&lt;this is special cased
    31, '#&lt; on the left margin is a line-end comment';

    ok !eval(&quot; #&lt;this is invalid&quot;),
        'embedded comment not on the left margin';
}

{</pre>
</div>

</li>

<li>For all quoting constructs that use user-selected brackets, you can open with multiple identical bracket characters, which must by closed by the same number of closing brackets. Counting of nested brackets applies only to pairs of brackets of the same length as the opening brackets:
<a name="msg_23"></a>
<a href="?hide_quotes=no#msg_23" onclick="return tog_quote(23);">
<div ID="header_shown_23" style="display: none;">
- Hide the snippet from t/syntax/comments.t (line 58 ~ line 75) -
</div>
<div ID="header_hidden_23" style="display: block;">
- Show the snippet from t/syntax/comments.t (line 58 ~ line 75, 18 lines) -
</div>
</a>
<div ID="hide_23" style="display:none; border:1px solid">
<pre style="margin-left: 6px">    # L&lt;S02/&quot;Whitespace and Comments&quot;/&quot;closed by&quot; &quot;same number of&quot;
    #   &quot;closing brackets&quot;&gt;

    ok #&lt;&lt;&lt;
        Or this &lt;also&gt; works...
    &gt;&gt;&gt; 1, '#&lt;&lt;&lt;...&gt;&gt;&gt;';

    my $var = \#((( comment ))) 12;
    is $var, 12, '#(((...)))';

    $var #&lt;&lt; &lt; &gt;&gt; = 25;
    is $var, 25, '#&lt;&lt; &lt; &gt;&gt;';

    $var = #&lt;&lt; &gt; &gt;&gt; 36;
    is $var, 36, '#&lt;&lt; &gt; &gt;&gt;';
}

{</pre>
</div>


<a name="msg_22"></a>
<a href="?hide_quotes=no#msg_22" onclick="return tog_quote(22);">
<div ID="header_shown_22" style="display: none;">
- Hide the snippet from t/syntax/comments.t (line 76 ~ line 93) -
</div>
<div ID="header_hidden_22" style="display: block;">
- Show the snippet from t/syntax/comments.t (line 76 ~ line 93, 18 lines) -
</div>
</a>
<div ID="hide_22" style="display:none; border:1px solid">
<pre style="margin-left: 6px">    # L&lt;S02/&quot;Whitespace and Comments&quot;/&quot;Counting of nested brackets&quot;
    #   &quot;applies only to&quot; &quot;pairs of brackets of the same length&quot;&gt;

    is 3, #(
        (Nested parens) works also
    ) 3, 'nested parens #(...(...)...)';

    is -1 #&lt;&lt;&lt;
        Even &lt;this&gt; &lt;&lt;&lt; also &gt;&gt;&gt; works...
    &gt;&gt;&gt;, -1, 'nested brackets in embedded comment';

    is 'cat', #{{
        This comment contains unmatched } and { { { {   (ignored)
        Plus a nested {{ ... }} pair                    (counted)
    }} 'cat', 'embedded comments with nested/unmatched bracket chars';
}

{</pre>
</div>


<pre>    say #{{
        This comment contains unmatched } and { { { {   (ignored)
        Plus a nested {{ ... }} pair                    (counted)
    }} q&#60;&#60; &#60;&#60;woot&#62;&#62; &#62;&#62;   # says &#34; &#60;&#60;woot&#62;&#62; &#34;</pre>

<p>Note however that bare circumfix or postcircumfix <code>&#60;&#60;...&#62;&#62;</code> is not a user-selected bracket, but the ASCII variant of the <code>&#171;...&#187;</code> interpolating word list. Only <code>#</code> and the <code>q</code>-style quoters (including <code>m</code>, <code>s</code>, <code>tr</code>, and <code>rx</code>) enable subsequent user-selected brackets.</p>
</li>

<li>In addition to the general comment forms above, there is a whitespace-only comment form that begins with backslash and ends with a single dot, separated by 0 or more characters of whitespace, which is equivalent to a single dot:
<pre>    %hash\  .{$key}
    @array\ .[$ix]
    $subref\.($arg)</pre>

<p>This is useful for lining up postfixes. This is known as the &#34;long dot&#34;, partly because it substitutes for a dot without the need for an extra dot:</p>

<pre>    $object\  .say();</pre>

<p>The whitespace in the middle may include any of the comment forms above. Because comments always count as whitespace, the <code>\.</code> in</p>

<pre>    $object\#{ foo }.say</pre>

<p>reduce to a &#34;long dot&#34;. Valid ways to insert a line break into a sequence of method calls include:</p>

<pre>    $object\ # comment
    .say

    $object\#[ comment
    ].say

    $object\
    .say</pre>
</li>

<li>In fact, any whitespace (including comments) may be hidden by prefixing it with <code>\</code>. It does not have to end with a dot. It&#39;s just that the normal use of a you-don&#39;t-see-this-space is typically to put a dotted postfix on the next line. But it also lets you continue the line in any situation where a newline might confuse the parser, regardless of the currently installed parser. (Unless, of course, you override the unspace rule itself...) Although we say that the unspace hides the whitespace from the parser, line numbers are still counted if the unspace contains one or more newlines. A <code>#</code> following such a newline is always an end-of-line comment, as described above. Since Pod chunks count as whitespace to the language, they are also swallowed up by unspace. Heredoc boundaries are suppressed, however, so you can split excessively long heredoc intro lines like this:
<pre>    ok(q:to&#39;CODE&#39;, q:to&#39;OUTPUT&#39;, \
    &#34;Here is a long description&#34;, \ # --more--
    todo(:parr&#248;t&#60;0.42&#62;, :d&#246;tnet&#60;1.2&#62;));
        ...
        CODE
        ...
        OUTPUT</pre>

<p>To the heredoc parser that just looks like:</p>

<pre>    ok(q:to&#39;CODE&#39;, q:to&#39;OUTPUT&#39;, &#34;Here is a long description&#34;, todo(:parr&#248;t&#60;0.42&#62;, :d&#246;tnet&#60;1.2&#62;));
        ...
        CODE
        ...
        OUTPUT</pre>
</li>

<li>An unspace may contain a comment, but a comment may not contain an unspace. In particular, end-of-line comments do not treat backslash as significant. If you say:
<a name="msg_20"></a>
<a href="?hide_quotes=no#msg_20" onclick="return tog_quote(20);">
<div ID="header_shown_20" style="display: none;">
- Hide the snippet from t/syntax/comments.t (line 106 ~ line 110) -
</div>
<div ID="header_hidden_20" style="display: block;">
- Show the snippet from t/syntax/comments.t (line 106 ~ line 110, 5 lines) -
</div>
</a>
<div ID="hide_20" style="display:none; border:1px solid">
<pre style="margin-left: 6px">    # L&lt;S02/Whitespace and Comments/&quot;comment may not contain an unspace&quot;&gt;
    my $a;
    ok !eval '$a = #\  (comment) 32', &quot;comments can't contain unspace&quot;;
    is $a, undef, '$a remains undef';
}</pre>
</div>


<pre>    #\ (...</pre>

<p>it is an end-of-line comment, not an embedded comment. Write:</p>

<pre>    \ #(
        ...
       )</pre>

<p>to mean the other thing.</p>
</li>

<li>In general, whitespace is optional in Perl 6 except where it is needed to separate constructs that would be misconstrued as a single token or other syntactic unit. (In other words, Perl 6 follows the standard <i>longest-token</i> principle, or in the cases of large constructs, a <i>prefer shifting to reducing</i> principle. See <a href="#Grammatical_Categories" class="podlinkpod"
>&#34;Grammatical Categories&#34;</a> below for more on how a Perl program is analyzed into tokens.)
<p>This is an unchanging deep rule, but the surface ramifications of it change as various operators and macros are added to or removed from the language, which we expect to happen because Perl 6 is designed to be a mutable language. In particular, there is a natural conflict between postfix operators and infix operators, either of which may occur after a term. If a given token may be interpreted as either a postfix operator or an infix operator, the infix operator requires space before it. Postfix operators may never have intervening space, though they may have an intervening dot. If further separation is desired, an embedded comment may be used as described above, as long as no whitespace occurs outside the embedded comment.</p>

<p>For instance, if you were to add your own <code>infix:&#60;++&#62;</code> operator, then it must have space before it. The normal autoincrementing <code>postfix:&#60;++&#62;</code> operator may never have space before it, but may be written in any of these forms:</p>

<pre>    $x++

    $x.++

    $x\ .++

    $x\#( comment ).++
    $x\#((( comment ))).++

    $x\
    .++

    $x\         # comment
                # inside long dot
    .++

    $x\         # comment
                # inside &#34;unspace&#34;
    ++          # (but long dot may be preferred...)

    $x\#&#12302;       comment
                more comment
    &#12303;.++

    $x\#[   comment 1
    comment 2
    =begin podstuff
    whatever (pod comments ignore current parser state)
    =end podstuff
    comment 3
    ].++</pre>

<p>A consequence of the postfix rule is that (except when delimiting a quote or terminating a &#34;long dot&#34;) a dot with whitespace in front of it is always considered a method call on <code>$_</code> where a term is expected. If a term is not expected at this point, it is a syntax error. (Unless, of course, there is an infix operator of that name beginning with dot. You could, for instance, define a Fortranly <code>infix:&#60;.EQ.&#62;</code> if the fit took you. But you&#39;ll have to be sure to always put whitespace in front of it, or it would be interpreted as a postfix method call instead.)</p>

<p>For example,</p>

<pre>    foo .method</pre>

<p>and</p>

<pre>    foo
    .method</pre>

<p>will always be interpreted as</p>

<pre>    foo $_.method</pre>

<p>but never as</p>

<pre>    foo.method  </pre>

<p>Use some variant of</p>

<pre>    foo\
    .method</pre>

<p>if you mean the postfix method call.</p>

<p>One consequence of all this is that you may no longer write a Num as <code>42.</code> with just a trailing dot. You must instead say either <code>42</code> or <code>42.0</code>. In other words, a dot following a number can only be a decimal point if the following character is a digit. Otherwise the postfix dot will be taken to be the start of some kind of method call syntax, whether long-dotty or not. (The <code>.123</code> form with a leading dot is still allowed however when a term is expected, and is equivalent to <code>0.123</code> rather than <code>$_.123</code>.)</p>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Built-In_Data_Types"
>Built-In Data Types</a></h1>

<ul>
<li>In support of OO encapsulation, there is a new fundamental datatype: <b>P6opaque</b>. External access to opaque objects is always through method calls, even for attributes.</li>

<li>Perl 6 has an optional type system that helps you write safer code that performs better. The compiler is free to infer what type information it can from the types you supply, but will not complain about missing type information unless you ask it to.</li>

<li>Perl 6 supports the notion of <b>properties</b> on various kinds of objects. Properties are like object attributes, except that they&#39;re managed by the individual object rather than by the object&#39;s class.
<p>According to S12, properties are actually implemented by a kind of mixin mechanism, and such mixins are accomplished by the generation of an individual anonymous class for the object (unless an identical anonymous class already exists and can safely be shared).</p>
</li>

<li>Properties applied to objects constructed at compile-time, such as variables and classes, are also called <b>traits</b>. Traits cannot be changed at run-time. Changes to run-time properties are done via mixin instead, so that the compiler can optimize based on declared traits.</li>

<li>Perl 6 is an OO engine, but you&#39;re not generally required to think in OO when that&#39;s inconvenient. However, some built-in concepts such as filehandles will be more object-oriented in a user-visible way than in Perl 5.</li>

<li>A variable&#39;s type is a constraint indicating what sorts of values the variable may contain. More precisely, it&#39;s a promise that the object or objects contained in the variable are capable of responding to the methods of the indicated &#34;role&#34;. See S12 for more about roles.
<pre>    # $x can contain only Int objects
    my Int $x;</pre>

<p>A variable may itself be bound to a container type that specifies how the container works, without specifying what kinds of things it contains.</p>

<pre>    # $x is implemented by the MyScalar class
    my $x is MyScalar;</pre>

<p>Constraints and container types can be used together:</p>

<pre>    # $x can contain only Int objects,
    # and is implemented by the MyScalar class
    my Int $x is MyScalar;</pre>

<p>Note that <code>$x</code> is also initialized to <code>::Int</code>. See below for more on this.</p>
</li>

<li><code>my Dog $spot</code> by itself does not automatically call a <code>Dog</code> constructor. It merely assigns an undefined <code>Dog</code> prototype object to <code>$spot</code>:
<pre>    my Dog $spot;           # $spot is initialized with ::Dog
    my Dog $spot = Dog;     # same thing

    $spot.defined;          # False
    say $spot;              # &#34;Dog&#34;</pre>

<p>Any class name used as a value by itself is an undefined instance of that class&#39;s prototype. See S12 for more on that.</p>

<p>To get a real <code>Dog</code> object, call a constructor method such as <code>new</code>:</p>

<pre>    my Dog $spot .= new;
    my Dog $spot = $spot.new;   # .= is rewritten into this</pre>

<p>You can pass in arguments to the constructor as well:</p>

<pre>    my Dog $cerberus .= new(heads =&#62; 3);
    my Dog $cerberus = $cerberus.new(heads =&#62; 3);   # same thing</pre>
</li>

<li>If you say
<pre>    my int @array is MyArray;</pre>

<p>you are declaring that the elements of <code>@array</code> are native integers, but that the array itself is implemented by the <code>MyArray</code> class. Untyped arrays and hashes are still perfectly acceptable, but have the same performance issues they have in Perl 5.</p>
</li>

<li>To get the number of elements in an array, use the <code>.elems</code> method. You can also ask for the total string length of an array&#39;s elements, in bytes, codepoints or graphemes, using these methods <code>.bytes</code>, <code>.codes</code> or <code>.graphs</code> respectively on the array. The same methods apply to strings as well.
<p>There is no <code>.length</code> method for either arrays or strings, because <code>length</code> does not specify a unit.</p>
</li>

<li>Built-in object types start with an uppercase letter. This includes immutable types (e.g. <code>Int</code>, <code>Num</code>, <code>Complex</code>, <code>Rational</code>, <code>Str</code>, <code>Bit</code>, <code>Regex</code>, <code>Set</code>, <code>Junction</code>, <code>Code</code>, <code>Block</code>, <code>List</code>, <code>Seq</code>), as well as mutable (container) types, such as <code>Scalar</code>, <code>Array</code>, <code>Hash</code>, <code>Buf</code>, <code>Routine</code>, <code>Module</code>, etc.
<p>Non-object (native) types are lowercase: <code>int</code>, <code>num</code>, <code>complex</code>, <code>rational</code>, <code>buf</code>, <code>bit</code>. Native types are primarily intended for declaring compact array storage. However, Perl will try to make those look like their corresponding uppercase types if you treat them that way. (In other words, it does autoboxing. Note, however, that sometimes repeated autoboxing can slow your program more than the native type can speed it up.)</p>

<p>Some object types can behave as value types. Every object can produce a &#34;safe key identifier&#34; (<code>SKID</code> for short) that uniquely identifies the object for hashing and other value-based comparisons. Normal objects just use their address in memory, but if a class wishes to behave as a value type, it can define a <code>.SKID</code> method that makes different objects look like the same object if they happen to have the same contents. SKID may also stand for &#34;static key id&#34;, or &#34;silly key id&#34;, or &#34;secret key id&#34;, or &#34;supercalifragilisticexpialidocious key id&#34;.</p>
</li>

<li>Variables with non-native types can always contain <i>undefined</i> values, such as <code>Undef</code>, <code>Whatever</code> and <code>Failure</code> objects. See S04 for more about failures (i.e. unthrown exceptions):
<pre>    my Int $x = undef;    # works</pre>

<p>Variables with native types do not support undefinedness: it is an error to assign an undefined value to them:</p>

<pre>    my int $y = undef;    # dies</pre>

<p>Conjecture: num might support the autoconversion of undef to NaN, since the floating-point form can represent this concept. Might be better to make that conversion optional though, so that the rocket designer can decide whether to self-destruct immediately or shortly thereafter.</p>
</li>

<li>Every object supports a <code>META</code> function/method that returns the metaclass instance managing it, regardless of whether the object is defined:
<pre>    &#39;x&#39;.META.get_method_list;   # get available methods for strings
    Str.META.get_method_list;   # same thing with the prototype object Str
    META(Str).get_method_list;  # same thing as function call

    &#39;x&#39;.get_method_list;        # this is an error - not a meta object
    Str.get_method_list;        # same thing</pre>

<p>(For a prototype system (a non-class-based object system), all objects are merely managed by the same meta object.)</p>
</li>

<li>Perl 6 intrinsically supports big integers and rationals through its system of type declarations. <code>Int</code> automatically supports promotion to arbitrary precision, as well as holding <code>Inf</code> and <code>NaN</code> values.
<p>(<code>Num</code> may support arbitrary-precision floating-point arithmetic, but is not required to unless we can do so portably and efficiently. Num must support the largest native floating point format that runs at full speed.)</p>

<p><code>Rational</code> supports arbitrary precision rational arithmetic. However, dividing two <code>Int</code> objects produces fractionals as <code>Num</code> objects by default, not <code>Rational</code> objects. You can override this behavior with a pragma.</p>

<p>Lower-case types like <code>int</code> and <code>num</code> imply the native machine representation for integers and floating-point numbers, respectively, and do not promote to arbitrary precision, though larger representations are always allowed for temporary values. Unless qualified with a number of bits, <code>int</code> and <code>num</code> types default to the largest native types that run at full speed.</p>

<p>Numeric values in untyped variables use <code>Int</code> and <code>Num</code> semantics rather than <code>int</code> and <code>num</code>.</p>
</li>

<li>Perl 6 should by default make standard IEEE floating point concepts visible, such as <code>Inf</code> (infinity) and <code>NaN</code> (not a number). Within a lexical scope, pragmas may specify the nature of temporary values, and how floating point is to behave under various circumstances. All IEEE modes must be lexically available via pragma except in cases where that would entail heroic efforts to bypass a braindead platform.
<a name="msg_18"></a>
<a href="?hide_quotes=no#msg_18" onclick="return tog_quote(18);">
<div ID="header_shown_18" style="display: none;">
- Hide the snippet from t/builtins/math/NaN.t (line 9 ~ line 18) -
</div>
<div ID="header_hidden_18" style="display: block;">
- Show the snippet from t/builtins/math/NaN.t (line 9 ~ line 18, 10 lines) -
</div>
</a>
<div ID="hide_18" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S02/&quot;Built-In Data Types&quot; /Perl 6 should by default make standard IEEE floating point concepts visible/&gt;

is 0 * Inf  , NaN, &quot;0 * Inf&quot;;
is Inf / Inf, NaN, &quot;Inf / Inf&quot;;
is Inf - Inf, NaN, &quot;Inf - Inf&quot;;
is NaN ** 0,  NaN, &quot;NaN ** 0&quot;;

# XXX - the semantics below are unspecified.
is 0**0     , 1, &quot;0**0 is 1, _not_ NaN&quot;;
is Inf**0   , 1, &quot;Inf**0 is 1, _not_ NaN&quot;;</pre>
</div>


<p>The default floating-point modes do not throw exceptions but rather propagate Inf and NaN. The boxed object types may carry more detailed information on where overflow or underflow occurred. Numerics in Perl are not designed to give the identical answer everywhere. They are designed to give the typical programmer the tools to achieve a good enough answer most of the time. (Really good programmers may occasionally do even better.) Mostly this just involves using enough bits that the stupidities of the algorithm don&#39;t matter much.</p>
</li>

<li>A <code>Str</code> is a Unicode string object. There is no corresponding native <code>str</code> type. However, since a <code>Str</code> object may fill multiple roles, we say that a <code>Str</code> keeps track of its minimum and maximum Unicode abstraction levels, and plays along nicely with the current lexical scope&#39;s idea of the ideal character, whether that is bytes, codepoints, graphemes, or characters in some language. For all builtin operations, all <code>Str</code> positions are reported as position objects, not integers. These <code>StrPos</code> objects point into a particular string at a particular location independent of abstraction level. The subtraction of two <code>StrPos</code> objects gives a <code>StrLen</code> object, which is still not an integer, because the string between two positions also has multiple integer interpretations depending on the units. A given <code>StrLen</code> may know that it represents 18 bytes, 7 codepoints, and 3 graphemes, but it knows this lazily because it actually just hangs onto the two <code>StrPos</code> objects. (It&#39;s much like a <code>Range</code> object in that respect.)
<p>If you use integers as arguments where position objects are expected, it will be assumed that you mean the units of the current lexically scoped Unicode abstraction level. (Which defaults to graphemes.) Otherwise you&#39;ll need to coerce to the proper units:</p>

<pre>    substr($string, 42.as(Bytes), 1.as(ArabicChars))</pre>

<p>Of course, such a dimensional number will fail if used on a string that doesn&#39;t provide the appropriate abstraction level.</p>
</li>

<li>A <code>Buf</code> is a stringish view of an array of integers, and has no Unicode or character properties without explicit conversion to some kind of <code>Str</code>. (A <code>buf</code> is the native counterpart.) Typically it&#39;s an array of bytes serving as a buffer. Bitwise operations on a <code>Buf</code> treat the entire buffer as a single large integer. Bitwise operations on a <code>Str</code> generally fail unless the <code>Str</code> in question can provide an abstract <code>Buf</code> interface somehow. Coercion to <code>Buf</code> should generally invalidate the <code>Str</code> interface. As a generic type <code>Buf</code> may be instantiated as (or bound to) any of <code>buf8</code>, <code>buf16</code>, or <code>buf32</code> (or to any type that provides the appropriate <code>Buf</code> interface), but when used to create a buffer <code>Buf</code> defaults to <code>buf8</code>.
<p>Unlike <code>Str</code> types, <code>Buf</code> types prefer to deal with integer string positions, and map these directly to the underlying compact array as indices. That is, these are not necessarily byte positions--an integer position just counts over the number of underlying positions, where one position means one cell of the underlying integer type. Builtin string operations on <code>Buf</code> types return integers and expect integers when dealing with positions. As a limiting case, <code>buf8</code> is just an old-school byte string, and the positions are byte positions. Note, though, that if you remap a section of <code>buf32</code> memory to be <code>buf8</code>, you&#39;ll have to multiply all your positions by 4.</p>
</li>

<li>Ordinarily a term beginning with <code>*</code> indicates a global function or type name, but by itself, the <code>*</code> term captures the notion of &#34;Whatever&#34;, which is applied lazily by whatever operator it is an argument to. Generally it can just be thought of as a &#34;glob&#34; that gives you everything it can in that argument position. For instance:
<pre>    if $x ~~ 1..* {...}                 # if 1 &#60;= $x &#60;= +Inf
    my ($a,$b,$c) = &#34;foo&#34; xx *;         # an arbitrary long list of &#34;foo&#34;
    if /foo/ ff * {...}                 # a latching flipflop
    @slice = @x[*;0;*];                 # any Int
    @slice = %x{*;&#39;foo&#39;};               # any keys in domain of 1st dimension
    @array[*]                           # flattens, unlike @array[]
    (*, *, $x) = (1, 2, 3);             # skip first two elements
                                        # (same as lvalue &#34;undef&#34; in Perl 5)</pre>

<p><code>Whatever</code> is an undefined prototype object derived from <code>Any</code>. As a type it is abstract, and may not be instantiated as a defined object. If for a particular MMD dispatch, nothing in the MMD system claims it, it dispatches to as an <code>Any</code> with an undefined value, and usually blows up constructively. If you say</p>

<pre>    say 1 + *;</pre>

<p>you should probably not expect it to yield a reasonable answer, unless you think an exception is reasonable. Since the <code>Whatever</code> object is effectively immutable, the optimizer is free to recognize <code>*</code> and optimize in the context of what operator it is being passed to.</p>

<p>A variant of <code>*</code> is the <code>**</code> term. It is generally understood to be a multidimension form of <code>*</code> when that makes sense.</p>

<p>The <code>***</code> variant serves as the insertion point of a list of feeds. That insertion point may be targeted by feeding into <code>*</code>. See S06.</p>

<p>Other uses for <code>*</code> will doubtless suggest themselves over time. These can be given meaning via the MMD system, if not the compiler. In general a <code>Whatever</code> should be interpreted as maximizing the degrees of freedom in a dwimmey way, not as a nihilistic &#34;don&#39;t care anymore--just shoot me&#34;.</p>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Names_and_Variables"
>Names and Variables</a></h1>

<ul>
<li>The <code>$Package&#39;var</code> syntax is gone. Use <code>$Package::var</code> instead.</li>

<li>Perl 6 includes a system of <b>sigils</b> to mark the fundamental structural type of a variable:
<pre>    $   scalar
    @   ordered array
    %   unordered hash (associative array)
    &#38;   code/rule/token/regex
    ::  package/module/class/role/subset/enum/type/grammar
    @@  multislice view of @</pre>

<p>Within a declaration, the <code>&#38;</code> sigil also declares the visibility of the subroutine name without the sigil within the scope of the declaration:</p>

<pre>    my &#38;func := sub { say &#34;Hi&#34; };
    func;   # calls &#38;func</pre>

<p>Within a signature or other declaration, the <code>::</code> sigil followed by an identifier marks a type variable that also declares the visibility of a package/type name without the sigil within the scope of the declaration. The first such declaration within a scope is assumed to be an unbound type, and takes the actual type of its associated argument. With subsequent declarations in the same scope the use of the sigil is optional, since the bare type name is also declared.</p>

<p>A declaration nested within must not use the sigil if it wishes to refer to the same type, since the inner declaration would rebind the type. (Note that the signature of a pointy block counts as part of the inner block, not the outer block.)</p>
</li>

<li>Unlike in Perl 5, you may no longer put whitespace between a sigil and its following name or construct.</li>

<li>Ordinary sigils indicate normally scoped variables, either lexical or package scoped. Oddly scoped variables include a secondary sigil (a <b>twigil</b>) that indicates what kind of strange scoping the variable is subject to:
<pre>    $foo        ordinary scoping
    $.foo       object attribute accessor
    $^foo       self-declared formal parameter
    $*foo       global variable
    $+foo       contextual variable
    $?foo       compiler hint variable
    $=foo       pod variable
    $&#60;foo&#62;      match variable, short for $/{&#39;foo&#39;}
    $!foo       explicitly private attribute (mapped to $foo though)</pre>

<p>Most variables with twigils are implicitly declared or assumed to be declared in some other scope, and don&#39;t need a &#34;my&#34; or &#34;our&#34;. Attribute variables are declared with <code>has</code>, though.</p>
</li>

<li>Sigils are now invariant. <code>$</code> always means a scalar variable, <code>@</code> an array variable, and <code>%</code> a hash variable, even when subscripting. Variables such as <code>@array</code> and <code>%hash</code> in scalar context simply return themselves as <code>Array</code> and <code>Hash</code> objects.</li>

<li>In string contexts, container objects automatically stringify to appropriate (white-space separated) string values. In numeric contexts, the number of elements in the container is returned. In boolean contexts, a true value is returned if and only if there are any elements in the container.</li>

<li>To get a Perlish representation of any object, use the <code>.perl</code> method. Like the <code>Data::Dumper</code> module in Perl 5, the <code>.perl</code> method will put quotes around strings, square brackets around list values, curlies around hash values, constructors around objects, etc., so that Perl can evaluate the result back to the same object.</li>

<li>To get a formatted representation of any scalar value, use the <code>.fmt(&#39;%03d&#39;)</code> method to do an implicit <code>sprintf</code> on the value.
<p>To format an array value separated by commas, supply a second argument: <code>.fmt(&#39;%03d&#39;, &#39;, &#39;)</code>. To format a hash value or list of pairs, include formats for both key and value in the first string: <code>.fmt(&#39;%s: %s&#39;, &#34;\n&#34;)</code>.</p>

<a name="msg_4"></a>
<a href="?hide_quotes=no#msg_4" onclick="return tog_quote(4);">
<div ID="header_shown_4" style="display: none;">
- Hide the snippet from t/builtins/sprintf_and_as.t (line 19 ~ line 21) -
</div>
<div ID="header_hidden_4" style="display: block;">
- Show the snippet from t/builtins/sprintf_and_as.t (line 19 ~ line 21, 3 lines) -
</div>
</a>
<div ID="hide_4" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S02/&quot;Names and Variables&quot; /To format an array value/&gt;
is (1.3,2.4,3).as(&quot;%d&quot;, &quot;_&quot;), &quot;1_2_3&quot;, &quot;as() works with lists&quot;;</pre>
</div>


<a name="msg_3"></a>
<a href="?hide_quotes=no#msg_3" onclick="return tog_quote(3);">
<div ID="header_shown_3" style="display: none;">
- Hide the snippet from t/builtins/sprintf_and_as.t (line 22 ~ line 24) -
</div>
<div ID="header_hidden_3" style="display: block;">
- Show the snippet from t/builtins/sprintf_and_as.t (line 22 ~ line 24, 3 lines) -
</div>
</a>
<div ID="hide_3" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S02/&quot;Names and Variables&quot; /To format a hash value/&gt;
is hash((a =&gt; 1.3), (b =&gt; 2.4)).as(&quot;%s:%d&quot;, &quot;_&quot;), &quot;a:1_b:2&quot;, &quot;as() works with hashes&quot;;</pre>
</div>


<a name="msg_2"></a>
<a href="?hide_quotes=no#msg_2" onclick="return tog_quote(2);">
<div ID="header_shown_2" style="display: none;">
- Hide the snippet from t/builtins/sprintf_and_as.t (line 25 ~ line 26) -
</div>
<div ID="header_hidden_2" style="display: block;">
- Show the snippet from t/builtins/sprintf_and_as.t (line 25 ~ line 26, 2 lines) -
</div>
</a>
<div ID="hide_2" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S02/&quot;Names and Variables&quot; /or list of pairs/&gt;
is (a =&gt; 1.3, b =&gt; 2.4).as(&quot;%s:%d&quot;, &quot;_&quot;), &quot;a:1_b:2&quot;, &quot;as() works with lists of pairs&quot;;</pre>
</div>

</li>

<li>Subscripts now consistently dereference the container produced by whatever was to their left. Whitespace is not allowed between a variable name and its subscript. However, there is a corresponding <b>dot</b> form of each subscript (<code>@foo.[1]</code> and <code>%bar.{&#39;a&#39;}</code>). Constant string subscripts may be placed in angles, so <code>%bar.{&#39;a&#39;}</code> may also be written as <code>%bar&#60;a&#62;</code> or <code>%bar.&#60;a&#62;</code>.</li>

<li>Slicing is specified by the nature of the subscript, not by the sigil.</li>

<li>The context in which a subscript is evaluated is no longer controlled by the sigil either. Subscripts are always evaluated in list context.
<p>If you need to force inner context to scalar, we now have convenient single-character context specifiers such as + for numbers and ~ for strings:</p>

<pre>    @x[f()]   =  g();       # list context for f() and g()
    @x[f()]   = +g();       # list context for f(), scalar context for g()
    @x[+f()]  =  g();       # scalar context for f() and g()
                            # -- see S03 for &#34;SIMPLE&#34; lvalues

    @x[f()]   =  @y[g()];   # list context for f() and g()
    @x[f()]   = +@y[g()];   # list context for f() and g()
    @x[+f()]  =  @y[g()];   # scalar context for f(), list context for g()
    @x[f()]   =  @y[+g()];  # list context for f(), scalar context for g()</pre>
</li>

<li>There is a need to distinguish list assignment from list binding. List assignment works exactly as it does in Perl 5, copying the values. There&#39;s a new <code>:=</code> binding operator that lets you bind names to Array and Hash objects without copying, in the same way as subroutine arguments are bound to formal parameters. See S06 for more about binding.</li>

<li>An argument list may be captured into an object with backslashed parens:
<pre>    $args = \(1,2,3,:mice&#60;blind&#62;)</pre>

<p>Values in a <code>Capture</code> object are parsed as ordinary expressions, marked as invocant, positional, named, and so on.</p>

<p>Like <code>List</code> objects, <code>Capture</code> objects are immutable in the abstract, but evaluate their arguments lazily. Before everything inside a <code>Capture</code> is fully evaluated (which happens at compile time when all the arguments are constants), the eventual value may well be unknown. All we know is that we have the promise to make the bits of it immutable as they become known.</p>

<p><code>Capture</code> objects may contain multiple unresolved iterators such as feeds or slices. How these are resolved depends on what they are eventually bound to. Some bindings are sensitive to multiple dimensions while others are not.</p>

<p>You may retrieve parts from a <code>Capture</code> object with a prefix sigil operator:</p>

<pre>    $args = \3;     # same as &#34;$args = \(3)&#34;
    $$args;         # same as &#34;$args as Scalar&#34; or &#34;Scalar($args)&#34;
    @$args;         # same as &#34;$args as Array&#34;  or &#34;Array($args)&#34;
    %$args;         # same as &#34;$args as Hash&#34;   or &#34;Hash($args)&#34;</pre>

<p>When cast into an array, you can access all the positional arguments; into a hash, all named arguments; into a scalar, its invocant.</p>

<p>All prefix sigil operators accept one positional argument, evaluated in scalar context as a rvalue. They can interpolate in strings if called with parentheses. The special syntax form <code>$()</code> translates into <code>$( $/ )</code> to operate on the current match object; the same applies to <code>@()</code>, <code>%()</code> and <code>*()</code> forms.</p>

<p><code>Capture</code> objects fill the ecological niche of references in Perl 6. You can think of them as &#34;fat&#34; references, that is, references that can capture not only the current identity of a single object, but also the relative identities of several related objects. Conversely, you can think of Perl 5 references as a degenerate form of <code>Capture</code> when you want to refer only to a single item.</p>
</li>

<li>A signature object (<code>Signature</code>) may be created with colon-prefixed parens:
<pre>    my ::MySig ::= :(Int, Num, Complex, Status :mice)</pre>

<p>Expressions inside the signature are parsed as parameter declarations rather than ordinary expressions. See S06 for more details on the syntax for parameters.</p>

<p>Signature objects bound to <code>::t</code> variables may be used within another signature to apply additional type constraints. When applied to a <code>Capture</code> argument of form <code>\$x</code>, the signature allows you to specify the types of parameters that would otherwise be untyped:</p>

<pre>    :(Num Dog|Cat $numdog, MySig \$a ($i,$j,$k,$mousestatus))</pre>
</li>

<li>Unlike in Perl 5, the notation <code>&#38;foo</code> merely stands for the <code>foo</code> function as a Code object without calling it. You may call any Code object with parens after it (which may, of course, contain arguments):
<pre>    &#38;foo($arg1, $arg2);</pre>

<p>Whitespace is not allowed before the parens, but there is a corresponding <code>.()</code> operator, plus the &#34;long dot&#34; forms that allow you to insert optional whitespace and comments between the backslash and the dot:</p>

<pre>    &#38;foo\   .($arg1, $arg2);
    &#38;foo\#[
        embedded comment
    ].($arg1, $arg2);</pre>
</li>

<li>With multiple dispatch, <code>&#38;foo</code> may not be sufficient to uniquely name a specific function. In that case, the type may be refined by using a signature literal as a postfix operator:
<pre>    &#38;foo:(Int,Num)</pre>

<p>It still just returns a <code>Code</code> object. A call may also be partially applied by using an argument list literal as a postfix operator:</p>

<pre>    &#38;foo\(1,2,3,:mice&#60;blind&#62;)</pre>

<p>This is really just a shorthand for</p>

<pre>    &#38;foo.assuming(1,2,3,:mice&#60;blind&#62;)</pre>
</li>

<li>Slicing syntax is covered in S09. Multidimensional slices will be done with semicolons between individual slice subscripts. Each such slice is evaluated lazily.</li>

<li>To make a slice subscript return something other than values, append an appropriate adverb to the subscript.
<a name="msg_1"></a>
<a href="?hide_quotes=no#msg_1" onclick="return tog_quote(1);">
<div ID="header_shown_1" style="display: none;">
- Hide the snippet from t/operators/subscript_adverbs.t (line 7 ~ line 197) -
</div>
<div ID="header_hidden_1" style="display: block;">
- Show the snippet from t/operators/subscript_adverbs.t (line 7 ~ line 197, 191 lines) -
</div>
</a>
<div ID="hide_1" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S02/&quot;Names and Variables&quot; /appropriate adverb to the subscript/&gt;

# Adverbs on array subscripts
# :p
{
    my @array = &lt;A B&gt;;

    isa_ok eval('@array[0]:p'), Pair,
        &quot;:p on an array returned a Pair&quot;, :todo&lt;feature&gt;;
    is ~eval('@array[0]:p'), &quot;0\tA&quot;,
        &quot;:p on an array returned the correct pair&quot;, :todo&lt;feature&gt;;

    eval('@array[0]:p.value = &quot;a&quot;');
    is @array[0], &quot;a&quot;,
        &quot;:p on an array returns lvalues (like normal subscripts do as well)&quot;, :todo&lt;feature&gt;;

    is +eval('@array[0,1]:p'), 2,
        &quot;:p on an array returned a two-elem array&quot;, :todo&lt;feature&gt;;
    is ~eval('@array[0,1]:p'), &quot;0\ta 1\tB&quot;,
        &quot;:p on an array returned a two-elem array consisting of the correct pairs&quot;, :todo&lt;feature&gt;;

    is +eval('@array[42,23]:p'),  0, &quot;:p on an array weeded out non-existing entries (1)&quot;;
    is ~eval('@array[42,23]:p'), &quot;&quot;, &quot;:p on an array weeded out non-existing entries (2)&quot;;
}

# :kv
{
    my @array = &lt;A B&gt;;

    is +eval('@array[0]:kv'), 2,
        &quot;:kv on an array returned a two-elem array&quot;, :todo&lt;feature&gt;;
    is ~eval('@array[0]:kv'), &quot;0 A&quot;,
        &quot;:kv on an array returned the correct two-elem array&quot;, :todo&lt;feature&gt;;

    eval('(@array[0]:kv)[1] = &quot;a&quot;');
    is @array[0], &quot;a&quot;,
        &quot;:kv on an array returns lvalues (like normal subscripts do as well)&quot;, :todo&lt;feature&gt;;

    is +eval('@array[0,1]:kv'), 4,
        &quot;:kv on an array returned a four-elem array&quot;, :todo&lt;feature&gt;;
    is ~eval('@array[0,1]:kv'), &quot;0 a 1 B&quot;,
        &quot;:kv on an array returned the correct four-elem array&quot;, :todo&lt;feature&gt;;

    is +eval('@array[42,23]:kv'),  0, &quot;:kv on an array weeded out non-existing entries (1)&quot;;
    is ~eval('@array[42,23]:kv'), &quot;&quot;, &quot;:kv on an array weeded out non-existing entries (2)&quot;;
}

# :k
{
    my @array = &lt;A B&gt;;

    is +eval('@array[0]:k'), 1,
        &quot;:k on an array returned an one-elem array&quot;, :todo&lt;feature&gt;;
    is ~eval('@array[0]:k'), &quot;0&quot;,
        &quot;:k on an array returned the correct one-elem array&quot;, :todo&lt;feature&gt;;

    is +eval('@array[0,1]:k'), 2,
        &quot;:k on an array returned a tow-elem array&quot;, :todo&lt;feature&gt;;
    is ~eval('@array[0,1]:k'), &quot;0 1&quot;,
        &quot;:k on an array returned the correct two-elem array&quot;, :todo&lt;feature&gt;;

    is +eval('@array[42,23]:k'),  0, &quot;:k on an array weeded out non-existing entries (1)&quot;;
    is ~eval('@array[42,23]:k'), &quot;&quot;, &quot;:k on an array weeded out non-existing entries (2)&quot;;
}

# :v
{
    my @array = &lt;A B&gt;;

    is +eval('@array[0]:v'), 1,
        &quot;:v on an array returned an one-elem array&quot;, :todo&lt;feature&gt;;
    is ~eval('@array[0]:v'), &quot;A&quot;,
        &quot;:v on an array returned the correct one-elem array&quot;, :todo&lt;feature&gt;;

    eval('@array[0]:v = &quot;a&quot;');
    is @array[0], &quot;a&quot;,
        &quot;:v on an array returns lvalues (like normal subscripts do as well)&quot;, :todo&lt;feature&gt;;

    is +eval('@array[0,1]:v'), 2,
        &quot;:v on an array returned a tow-elem array&quot;, :todo&lt;feature&gt;;
    is ~eval('@array[0,1]:v'), &quot;a B&quot;,
        &quot;:v on an array returned the correct two-elem array&quot;, :todo&lt;feature&gt;;

    is +eval('@array[42,23]:v'),  0, &quot;:v on an array weeded out non-existing entries (1)&quot;;
    is ~eval('@array[42,23]:v'), &quot;&quot;, &quot;:v on an array weeded out non-existing entries (2)&quot;;
}

# Adverbs on hash subscripts
# :p
{
    my %hash = (0 =&gt; &quot;A&quot;, 1 =&gt; &quot;B&quot;);

    isa_ok eval('%hash&lt;0&gt;:p'), Pair,
        &quot;:p on a hash returned a Pair&quot;, :todo&lt;feature&gt;;
    is ~eval('%hash&lt;0&gt;:p'), &quot;0\tA&quot;,
        &quot;:p on a hash returned the correct pair&quot;, :todo&lt;feature&gt;;

    eval('%hash&lt;0&gt;:p.value = &quot;a&quot;');
    is %hash&lt;0&gt;, &quot;a&quot;,
        &quot;:p on a hash returns lvalues (like normal subscripts do as well)&quot;, :todo&lt;feature&gt;;

    is +eval('%hash&lt;0 1&gt;:p'), 2,
        &quot;:p on a hash returned a two-elem array&quot;, :todo&lt;feature&gt;;
    is ~eval('%hash&lt;0 1&gt;:p'), &quot;0\ta 1\tB&quot;,
        &quot;:p on a hash returned a two-elem array consisting of the correct pairs&quot;, :todo&lt;feature&gt;;

    is +eval('%hash&lt;42 23&gt;:p'),  0, &quot;:p on a hash weeded out non-existing entries (1)&quot;;
    is ~eval('%hash&lt;42 23&gt;:p'), &quot;&quot;, &quot;:p on a hash weeded out non-existing entries (2)&quot;;
}

# :kv
{
    my %hash = (0 =&gt; &quot;A&quot;, 1 =&gt; &quot;B&quot;);

    is +eval('%hash&lt;0&gt;:kv'), 2,
        &quot;:kv on a hash returned a two-elem array&quot;, :todo&lt;feature&gt;;
    is ~eval('%hash&lt;0&gt;:kv'), &quot;0 A&quot;,
        &quot;:kv on a hash returned the correct two-elem array&quot;, :todo&lt;feature&gt;;

    eval('(%hash&lt;0&gt;:kv)[1] = &quot;a&quot;');
    is %hash&lt;0&gt;, &quot;a&quot;,
        &quot;:kv on a hash returns lvalues (like normal subscripts do as well)&quot;, :todo&lt;feature&gt;;

    is +eval('%hash&lt;0 1&gt;:kv'), 4,
        &quot;:kv on a hash returned a four-elem array&quot;, :todo&lt;feature&gt;;
    is ~eval('%hash&lt;0 1&gt;:kv'), &quot;0 a 1 B&quot;,
        &quot;:kv on a hash returned the correct four-elem array&quot;, :todo&lt;feature&gt;;

    is +eval('%hash&lt;42 23&gt;:kv'),  0, &quot;:kv on a hash weeded out non-existing entries (1)&quot;;
    is ~eval('%hash&lt;42 23&gt;:kv'), &quot;&quot;, &quot;:kv on a hash weeded out non-existing entries (2)&quot;;
}

# :k
{
    my %hash = (0 =&gt; &quot;A&quot;, 1 =&gt; &quot;B&quot;);

    is +eval('%hash&lt;0&gt;:k'), 1,
        &quot;:k on a hash returned an one-elem array&quot;, :todo&lt;feature&gt;;
    is ~eval('%hash&lt;0&gt;:k'), &quot;0&quot;,
        &quot;:k on a hash returned the correct one-elem array&quot;, :todo&lt;feature&gt;;

    is +eval('%hash&lt;0 1&gt;:k'), 2,
        &quot;:k on a hash returned a tow-elem array&quot;, :todo&lt;feature&gt;;
    is ~eval('%hash&lt;0 1&gt;:k'), &quot;0 1&quot;,
        &quot;:k on a hash returned the correct two-elem array&quot;, :todo&lt;feature&gt;;

    is +eval('%hash&lt;42 23&gt;:k'),  0, &quot;:k on a hash weeded out non-existing entries (1)&quot;;
    is ~eval('%hash&lt;42 23&gt;:k'), &quot;&quot;, &quot;:k on a hash weeded out non-existing entries (2)&quot;;
}

# :v
{
    my %hash = (0 =&gt; &quot;A&quot;, 1 =&gt; &quot;B&quot;);

    is +eval('%hash&lt;0&gt;:v'), 1,
        &quot;:v on a hash returned an one-elem array&quot;, :todo&lt;feature&gt;;
    is ~eval('%hash&lt;0&gt;:v'), &quot;A&quot;,
        &quot;:v on a hash returned the correct one-elem array&quot;, :todo&lt;feature&gt;;

    eval('%hash&lt;0&gt;:v = &quot;a&quot;');
    is %hash&lt;0&gt;, &quot;a&quot;,
        &quot;:v on a hash returns lvalues (like normal subscripts do as well)&quot;, :todo&lt;feature&gt;;

    is +eval('%hash&lt;0 1&gt;:v'), 2,
        &quot;:v on a hash returned a tow-elem array&quot;, :todo&lt;feature&gt;;
    is ~eval('%hash&lt;0 1&gt;:v'), &quot;a B&quot;,
        &quot;:v on a hash returned the correct two-elem array&quot;, :todo&lt;feature&gt;;

    is +eval('%hash&lt;42 23&gt;:v'),  0, &quot;:v on a hash weeded out non-existing entries (1)&quot;;
    is ~eval('%hash&lt;42 23&gt;:v'), &quot;&quot;, &quot;:v on a hash weeded out non-existing entries (2)&quot;;
}

# The adverbial forms weed out non-existing entries, but undefined (but
# existing) entries should be unaffected by this rule.
{
    my @array = (42, undef, 23);

    is +eval('@array[0,1,2]:kv'), 6,
        &quot;undefined but existing entries should not be weeded out (1)&quot;, :todo&lt;feature&gt;;
    is ~eval('@array[0,1,2]:kv'), &quot;0 42 1  2 23&quot;,
        &quot;undefined but existing entries should not be weeded out (2)&quot;, :todo&lt;feature&gt;;
}

{
    my %hash = (0 =&gt; 42, 1 =&gt; undef, 2 =&gt; 23);

    is +eval('%hash&lt;0 1 2&gt;:kv'), 6,
        &quot;undefined but existing entries should not be weeded out (3)&quot;, :todo&lt;feature&gt;;
    is ~eval('%hash&lt;0 1 2&gt;:kv'), &quot;0 42 1  2 23&quot;,
        &quot;undefined but existing entries should not be weeded out (4)&quot;, :todo&lt;feature&gt;;
}</pre>
</div>


<pre>    @array = &#60;A B&#62;;
    @array[0,1,2];      # returns &#39;A&#39;, &#39;B&#39;, undef
    @array[0,1,2]:p;    # returns 0 =&#62; &#39;A&#39;, 1 =&#62; &#39;B&#39;
    @array[0,1,2]:kv;   # returns 0, &#39;A&#39;, 1, &#39;B&#39;
    @array[0,1,2]:k;    # returns 0, 1
    @array[0,1,2]:v;    # returns &#39;A&#39;, &#39;B&#39;

    %hash = (:a&#60;A&#62;, :b&#60;B&#62;);
    %hash&#60;a b c&#62;;       # returns &#39;A&#39;, &#39;B&#39;, undef
    %hash&#60;a b c&#62;:p;     # returns a =&#62; &#39;A&#39;, b =&#62; &#39;B&#39;
    %hash&#60;a b c&#62;:kv;    # returns &#39;a&#39;, &#39;A&#39;, &#39;b&#39;, &#39;B&#39;
    %hash&#60;a b c&#62;:k;     # returns &#39;a&#39;, &#39;b&#39;
    %hash&#60;a b c&#62;:v;     # returns &#39;A&#39;, &#39;B&#39;</pre>

<p>The adverbial forms all weed out non-existing entries.</p>
</li>

<li>In numeric context (i.e. when cast into <code>Int</code> or <code>Num</code>), a Hash object becomes the number of pairs contained in the hash. In a boolean context, a Hash object is true if there are any pairs in the hash. In either case, any intrinsic iterator would be reset. (If hashes do carry an intrinsic iterator (as they do in Perl 5), there will be a <code>.reset</code> method on the hash object to reset the iterator explicitly.)</li>

<li>Sorting a list of pairs should sort on their keys by default, then on their values. Sorting a list of lists should sort on the first elements, then the second elements, etc. For more on <code>sort</code> see S29.</li>

<li>Many of the special variables of Perl 5 are going away. Those that apply to some object such as a filehandle will instead be attributes of the appropriate object. Those that are truly global will have global alphabetic names, such as <code>$*PID</code> or <code>@*ARGS</code>.</li>

<li>Any remaining special variables will be lexically scoped. This includes <code>$_</code> and <code>@_</code>, as well as the new <code>$/</code>, which is the return value of the last regex match. <code>$0</code>, <code>$1</code>, <code>$2</code>, etc., are aliases into the <code>$/</code> object.</li>

<li>The <code>$#foo</code> notation is dead. Use <code>@foo.end</code> or <code>@foo[-1]</code> instead. (Or <code>@foo.shape[$dimension]</code> for multidimensional arrays.)</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Names"
>Names</a></h1>

<ul>
<li>Ordinary package-qualified names look like in Perl 5:
<pre>    $Foo::Bar::baz      # the $baz variable in package Foo::Bar</pre>

<p>Sometimes it&#39;s clearer to keep the sigil with the variable name, so an alternate way to write this is:</p>

<pre>    Foo::Bar::&#60;$baz&#62;</pre>

<p>This is resolved at compile time because the variable name is a constant.</p>
</li>

<li>The following pseudo-package names are reserved in the first position:
<a name="msg_5"></a>
<a href="?hide_quotes=no#msg_5" onclick="return tog_quote(5);">
<div ID="header_shown_5" style="display: none;">
- Hide the snippet from t/var/var.t (line 7 ~ line 12) -
</div>
<div ID="header_hidden_5" style="display: block;">
- Show the snippet from t/var/var.t (line 7 ~ line 12, 6 lines) -
</div>
</a>
<div ID="hide_5" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S02/&quot;Names&quot; /names are reserved in the first position/&gt;
ok !eval('module MY;     1'), &quot;MY is an out of scope name&quot;;
ok !eval('module OUTER;  1'), &quot;OUTER is an out of scope name&quot;;
ok !eval('module CALLER; 1'), &quot;CALLER is an out of scope name&quot;;</pre>
</div>


<pre>    MY          # Lexical variables declared in the current scope
    OUR         # Package variables declared in the current package
    GLOBAL      # Builtin variables and functions
    OUTER       # Lexical variables declared in the outer scope
    CALLER      # Contextual variables in the caller&#39;s scope
    CONTEXT     # Contextual variables in any caller&#39;s scope
    SUPER       # Package variables declared in inherited classes
    COMPILING   # Lexical variables in the scope being compiled</pre>

<p>Other all-caps names are semi-reserved. We may add more of them in the future, so you can protect yourself from future collisions by using mixed case on your top-level packages. (We promise not to break any existing top-level CPAN package, of course. Except maybe ACME, and then only for coyotes.)</p>
</li>

<li>You may interpolate a string into a package or variable name using <code>::($expr)</code> where you&#39;d ordinarily put a package or variable name. The string is allowed to contain additional instances of <code>::</code>, which will be interpreted as package nesting. You may only interpolate entire names, since the construct starts with <code>::</code>, and either ends immediately or is continued with another <code>::</code> outside the parens. Most symbolic references are done with this notation:
<pre>    $foo = &#34;Bar&#34;;
    $foobar = &#34;Foo::Bar&#34;;
    $::($foo)           # package-scoped $Bar
    $::(&#34;MY::$foo&#34;)     # lexically-scoped $Bar
    $::(&#34;*::$foo&#34;)      # global $Bar
    $::($foobar)        # $Foo::Bar
    $::($foobar)::baz   # $Foo::Bar::baz
    $::($foo)::Bar::baz # $Bar::Bar::baz
    $::($foobar)baz     # ILLEGAL at compile time (no operator baz)</pre>

<p>Note that unlike in Perl 5, initial <code>::</code> doesn&#39;t imply global. Package names are searched for from inner lexical scopes to outer, then from inner packages to outer. Variable names are searched for from inner lexical scopes to outer, but unlike package names are looked for in only the current package and the global package.</p>

<p>The global namespace is the last place it looks in either case. You must use the <code>*</code> (or <code>GLOBAL</code>) package on the front of the string argument to force the search to start in the global namespace.</p>

<p>Use the <code>MY</code> pseudopackage to limit the lookup to the current lexical scope, and <code>OUR</code> to limit the scopes to the current package scope.</p>
</li>

<li>When &#34;strict&#34; is in effect (which is the default except for one-liners), non-qualified variables (such as <code>$x</code> and <code>@y</code>) are only looked up from lexical scopes, but never from package scopes.
<p>To bind package variables into a lexical scope, simply say <code>our ($x, @y)</code>. To bind global variables into a lexical scope, predeclare them with <code>use</code>:</p>

<pre>    use GLOBAL &#60;$IN $OUT&#62;;</pre>

<p>Or just refer to them as <code>$*IN</code> and <code>$*OUT</code>.</p>
</li>

<li>To do direct lookup in a package&#39;s symbol table without scanning, treat the package name as a hash:
<pre>    Foo::Bar::{&#39;&#38;baz&#39;}  # same as &#38;Foo::Bar::baz
    GLOBAL::&#60;$IN&#62;       # Same as $*IN
    Foo::&#60;::Bar&#62;&#60;::Baz&#62; # same as Foo::Bar::Baz</pre>

<p>Unlike <code>::()</code> symbolic references, this does not parse the argument for <code>::</code>, nor does it initiate a namespace scan from that initial point. In addition, for constant subscripts, it is guaranteed to resolve the symbol at compile time.</p>

<p>The null pseudo-package is reserved to mean the same search list as an ordinary name search. That is, the following are all identical in meaning:</p>

<pre>    $foo
    $::{&#39;foo&#39;}
    ::{&#39;$foo&#39;}
    $::&#60;foo&#62;
    ::&#60;$foo&#62;</pre>

<p>That is, each of them scans lexical scopes outward, and then the current package scope (though the package scope is then disallowed when &#34;strict&#34; is in effect).</p>

<p>As a result of these rules, you can write any arbitrary variable name as either of:</p>

<pre>    $::{&#39;!@#$#@&#39;}
    ::{&#39;$!@#$#@&#39;}</pre>

<p>You can also use the <code>::&#60;&#62;</code> form as long as there are no spaces in the name.</p>
</li>

<li>The current lexical symbol table is now accessible through the pseudo-package <code>MY</code>. The current package symbol table is visible as pseudo-package <code>OUR</code>. The <code>OUTER</code> name refers to the <code>MY</code> symbol table immediately surrounding the current <code>MY</code>, and <code>OUTER::OUTER</code> is the one surrounding that one.
<pre>    our $foo = 41;
    say $::foo;         # prints 41, :: is no-op
    {
        my $foo = 42;
        say MY::&#60;$foo&#62;;         # prints &#34;42&#34;
        say $MY::foo;           # same thing
        say $::foo;             # same thing, :: is no-op here

        say OUR::&#60;$foo&#62;;        # prints &#34;41&#34;
        say $OUR::foo;          # same thing

        say OUTER::&#60;$foo&#62;;      # prints &#34;41&#34; (our $foo is also lexical)
        say $OUTER::foo;        # same thing
    }</pre>

<p>You may not use any lexically scoped symbol table, either by name or by reference, to add symbols to a lexical scope that is done compiling. (We reserve the right to relax this if it turns out to be useful though.)</p>
</li>

<li>The <code>CALLER</code> package refers to the lexical scope of the (dynamically scoped) caller. The caller&#39;s lexical scope is allowed to hide any variable except <code>$_</code> from you. In fact, that&#39;s the default, and a lexical variable must have the trait &#34;<code>is context</code>&#34; to be visible via <code>CALLER</code>. (<code>$_</code>, <code>$!</code> and <code>$/</code> are always contextual.) If the variable is not visible in the caller, it returns failure.
<a name="msg_6"></a>
<a href="?hide_quotes=no#msg_6" onclick="return tog_quote(6);">
<div ID="header_shown_6" style="display: none;">
- Hide the snippet from t/var/caller.t (line 51 ~ line 173) -
</div>
<div ID="header_hidden_6" style="display: block;">
- Show the snippet from t/var/caller.t (line 51 ~ line 173, 123 lines) -
</div>
</a>
<div ID="hide_6" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S02/&quot;Names&quot; /The CALLER package refers to the lexical scope/&gt;
{
  # $_ is always implicitly declared &quot;env&quot;.
  my sub foo () { $CALLER::_ }
  my sub bar () {
    $_ = 42;
    foo();
  }

  $_ = 23;
  is bar(), 42, '$_ is implicitly declared &quot;env&quot; (1)';
}

{
  # $_ is always implicitly declared &quot;env&quot;.
  # (And, BTW, $_ is lexical.)
  my sub foo () { $_ = 17; $CALLER::_ }
  my sub bar () {
    $_ = 42;
    foo();
  }

  $_ = 23;
  is bar(), 42, '$_ is implicitly declared &quot;env&quot; (2)', :todo&lt;bug&gt;;
}

{
  # ...but other vars are not
  my sub foo { my $abc = 17; $CALLER::abc }
  my sub bar {
    my $abc = 42;
    foo();
  }

  my $abs = 23;
  dies_ok { bar() },
    'vars not declared &quot;env&quot; are not accessible via $CALLER::';
}

# Vars declared with env() default to being rw in the creating scope and
# readonly when accessed with $CALLER::.
{
  env $foo = 42;
  $foo++;
  is $foo, 43, &quot;env() vars are rw in the creating scope (1)&quot;;
}

{
  env $foo = 42;
  { $foo++ }
  is $foo, 43, &quot;env() vars are rw in the creating scope (2)&quot;;
}

{
  my sub modify { $CALLER::foo++ }
  env $foo = 42;
  dies_ok { modify() }, 'env() vars are ro when accessed with $CALLER::';
}

{
  my sub modify { $CALLER::_++ }
  $_ = 42;
  lives_ok { modify() }, '$_ is implicitly rw (1)';
  is $_, 43,             '$_ is implicitly rw (2)';
}

{
  my sub modify { $CALLER::foo++ }
  env $foo is rw = 42;
  lives_ok { modify() },
      'env() vars declared &quot;is rw&quot; are rw when accessed with $CALLER:: (1)', :todo&lt;bug&gt;;
  is $foo, 43,
      'env() vars declared &quot;is rw&quot; are rw when accessed with $CALLER:: (2)', :todo&lt;bug&gt;;
}

{
  my sub get_foo { try { $+foo } }
  env $foo = 42;

  is get_foo(), 42, '$+ is short for $CALLER::';
}

# Rebinding caller's variables -- legal?
{
  my $other_var = 23;
  my sub rebind_foo { $CALLER::foo := $other_var }
  env $foo = 42;

  lives_ok { rebind_foo() }, 'rebinding $CALLER:: variables works (1)', :todo&lt;bug&gt;;
  is $foo, 23,               'rebinding $CALLER:: variables works (2)', :todo&lt;bug&gt;;
  $other_var++;
  is $foo, 24,               'rebinding $CALLER:: variables works (3)', :todo&lt;bug&gt;;
}

=pod

Larry ruled that as erroneous.

15:13 &lt; iblech&gt; autrijus: :) BTW, WRT lex hoisting: sub foo { $CALLER::a }; { foo(); my $a
= 3; foo() }
15:13 &lt; autrijus&gt; iblech: larry ruled it as erroneous.
15:13 &lt; autrijus&gt; i.e. foo()'s behaviour is undefined.
15:14 &lt; iblech&gt; ok then :)
15:14 &lt; autrijus&gt; it's essential we do that because
15:14 &lt; autrijus&gt; foo($a, my $a)
15:14 &lt; autrijus&gt; is legal
15:14 &lt; autrijus&gt; and will be simply hazadrous to implement either way.
15:14 &lt; autrijus&gt; s/implement/mandate/

{
  if $*OS eq &quot;browser&quot; {  # test works under PIL2JS :)
    my $sub = sub { $CALLER::a };

    # No declaration of $a yet.
    dies_ok { $sub() }, '$CALLER:: dies when accessing not yet declared vars';

    my $a = 3;
    is $sub(), 3, '$CALLER:: works now (accessing a declared var)';
  } else {
    flunk &quot;Test loops infinitely&quot;;
    flunk &quot;Test loops infinitely&quot;;
  }
}</pre>
</div>


<p>Any lexical declared with the <code>is context</code> trait is by default considered readonly outside the current lexical scope. You may add <code>is rw</code> to allow called routines to modify your value. <code>$_</code>, <code>$!</code>, and <code>$/</code> are <code>rw</code> by default. In any event, your lexical scope can always access the variable as if it were an ordinary <code>my</code>; the restriction on writing applies only to called subroutines.</p>
</li>

<li>The <code>CONTEXT</code> pseudo-package is just like <code>CALLER</code> except that it scans outward through all dynamic scopes until it finds a contextual variable of that name in that caller&#39;s lexical scope. (Use of <code>$+FOO</code> is equivalent to CONTEXT::&#60;$FOO&#62; or $CONTEXT::FOO.) If after scanning all the lexical scopes of each dynamic scope, there is no variable of that name, it looks in the <code>*</code> package. If there is no variable in the <code>*</code> package and the variable is a scalar, it then looks in <code>%*ENV</code> for the identifier of the variable, that is, in the environment variables passed to program. If the value is not found there, it returns failure. Note that <code>$+_</code> is always the same as CALLER::&#60;$_&#62; since all callers have a <code>$_</code> that is automatically considered environmental. Note also that <code>CONTEXT</code> and <code>$+</code> always skip the current scope, since you can always name the variable directly without the <code>CONTEXT</code> or <code>+</code> if it&#39;s been declared in the current lexical scope.
<a name="msg_9"></a>
<a href="?hide_quotes=no#msg_9" onclick="return tog_quote(9);">
<div ID="header_shown_9" style="display: none;">
- Hide the snippet from t/magicals/env.t (line 6 ~ line 134) -
</div>
<div ID="header_hidden_9" style="display: block;">
- Show the snippet from t/magicals/env.t (line 6 ~ line 134, 129 lines) -
</div>
</a>
<div ID="hide_9" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S02/&quot;Names&quot; /environment variables passed to program/&gt;
plan 14;

if $*OS eq &quot;browser&quot; {
  skip_rest &quot;Programs running in browsers don't have access to regular IO.&quot;;
  exit;
}

=kwid

= DESCRIPTION

Tests for %*ENV

Tests that C&lt;%*ENV&gt; can be read and written to and that
child processes see the modified C&lt;%*ENV&gt;.

=cut

# It must not be empty at startup.
ok +%*ENV.keys, '%*ENV has keys';

# %*ENV should be able to get copied into another variable.
my %vars = %*ENV;
is +%vars.keys, +%*ENV.keys, '%*ENV was successfully copied into another variable';

# XXX: Should modifying %vars affect the environment? I don't think so, but, of
# course, feel free to change the following test if I'm wrong.
%vars&lt;PATH&gt; = &quot;42&quot;;
ok %*ENV&lt;PATH&gt; ne &quot;42&quot;,
  'modifying a copy of %*ENV didn\'t affect the environment';

# Similarily, I don't think creating a new entry in %vars should affect the
# environment:
diag '%*ENV&lt;PUGS_ROCKS&gt;=' ~ %*ENV&lt;PUGS_ROCKS&gt;;
ok !defined(%*ENV&lt;PUGS_ROCKS&gt;), &quot;there's no env variable 'PUGS_ROCKS'&quot;;
%vars&lt;PUGS_ROCKS&gt; = &quot;42&quot;;
diag '%*ENV&lt;PUGS_ROCKS&gt;=' ~ %*ENV&lt;PUGS_ROCKS&gt;;
ok !defined(%*ENV&lt;PUGS_ROCKS&gt;), &quot;there's still no env variable 'PUGS_ROCKS'&quot;;

my ($pugs,$redir,$squo) = (&quot;./pugs&quot;, &quot;&gt;&quot;, &quot;'&quot;);

if $*OS eq any &lt;MSWin32 mingw msys cygwin&gt; {
    $pugs = 'pugs.exe';
};

my $expected = 'Hello from subprocess';
%*ENV&lt;PUGS_ROCKS&gt; = $expected;
# Note that the &quot;?&quot; preceeding the &quot;(&quot; is necessary, because we need a Bool,
# not a junction of Bools.
is %*ENV&lt;PUGS_ROCKS&gt;, $expected,'%*ENV is rw';

my $tempfile = &quot;temp-ex-output.&quot; ~ $*PID ~ &quot;.&quot; ~ rand 1000;

my $command = qq!$pugs -e &quot;\%*ENV.perl.say&quot; $redir $tempfile!;
diag $command;
system $command;

my $child_env = slurp $tempfile;
my %child_env = eval $child_env;
unlink $tempfile;

my $err = 0;
for %*ENV.kv -&gt; $k,$v {
  # Ignore env vars which bash and maybe other shells set automatically.
  next if $k eq any &lt;SHLVL _ OLDPWD PS1&gt;;
  if (%child_env{$k} !~~ $v) {
    if (! $err) {
      flunk(&quot;Environment gets propagated to child.&quot;);
      $err++;
    };
    diag &quot;Expected: $k=$v&quot;;
    diag &quot;Got:      $k=%child_env{$k}&quot;;
  } else {
    # diag &quot;$k=$v&quot;;
  };
};
if (! $err) {
  ok(1,&quot;Environment gets propagated to child.&quot;);
};

%*ENV.delete('PUGS_ROCKS');
is(%*ENV&lt;PUGS_ROCKS&gt;,undef,'We can remove keys from %*ENV');

my $command = qq!$pugs -e &quot;\%*ENV.perl.say&quot; $redir $tempfile!;
diag $command;
system $command;

my $child_env = slurp $tempfile;
my %child_env = eval $child_env;
unlink $tempfile;

is(%child_env&lt;PUGS_ROCKS&gt;,undef,'The child did not see %*ENV&lt;PUGS_ROCKS&gt;');

my $err = 0;
for %*ENV.kv -&gt; $k,$v {
  # Ignore env vars which bash and maybe other shells set automatically.
  next if $k eq any &lt;SHLVL _ OLDPWD PS1&gt;;
  if (%child_env{$k} !~~ $v) {
    if (! $err) {
      flunk(&quot;Environment gets propagated to child.&quot;);
      $err++;
    };
    diag &quot;Expected: $k=$v&quot;;
    diag &quot;Got:      $k=%child_env{$k}&quot;;
  } else {
    # diag &quot;$k=$v&quot;;
  };
};
if (! $err) {
  ok(1,&quot;Environment gets propagated to child.&quot;);
};

ok !%*ENV.exists(&quot;does_not_exist&quot;), &quot;exists() returns false on a not defined env var&quot;;

# %ENV must not be imported by default
my $x = eval &quot;%ENV&quot;;
ok $! ~~ m:P5/Undeclared/, '%ENV not visible by default', :todo&lt;bug&gt;;

# following doesn't parse yet
{
    # It must be importable
    use GLOBAL &lt;%ENV&gt;;
    ok +%ENV.keys, 'imported %ENV has keys';
}
# Importation must be lexical
$x = eval &quot;%ENV&quot;;
ok $! ~~ m:P5/Undeclared/, '%ENV not visible by after lexical import scope', :todo&lt;bug&gt;;
1;</pre>
</div>


<p>The <code>CONTEXT</code> package is only for internal overriding of contextual information, modelled on how environmental variables work among processes. Despite the fact that the <code>CONTEXT</code> package reflects the current process&#39;s environment variables, at least where those are not hidden by lower-level declarations, the <code>CONTEXT</code> package should not be considered isomorphic to the current set of environment variables. Subprocesses are passed only the global <code>%*ENV</code> values. They do not see any lexical variables or their values, unless you copy those values into <code>%*ENV</code> to change what subprocesses see:</p>

<pre>    temp %*ENV{LANG} = $+LANG;          # may be modified by parent
    system &#34;greet&#34;;</pre>
</li>

<li>There is no longer any special package hash such as <code>%Foo::</code>. Just subscript the package object itself as a hash object, the key of which is the variable name, including any sigil. The package object can be derived from a type name by use of the <code>::</code> postfix operator:
<pre>    MyType::&#60;$foo&#62;
    MyType.::.{&#39;$foo&#39;}          # same thing with dots
    MyType\ .::\ .{&#39;$foo&#39;}      # same thing with long dots</pre>

<p>(Directly subscripting the type with either square brackets or curlies is reserved for various generic type-theoretic operations. In most other matters type names and package names are interchangeable.)</p>

<p>Typeglobs are gone. Use binding (<code>:=</code> or <code>::=</code>) to do aliasing. Individual variable objects are still accessible through the hash representing each symbol table, but you have to include the sigil in the variable name now: <code>MyPackage::{&#39;$foo&#39;}</code> or the equivalent <code>MyPackage::&#60;$foo&#62;</code>.</p>
</li>

<li>Truly global variables live in the <code>*</code> package: <code>$*UID</code>, <code>%*ENV</code>. (The <code>*</code> may be omitted if you import the name from the <code>GLOBAL</code> package.) <code>$*foo</code> is short for <code>$*::foo</code>, suggesting that the variable is &#34;wild carded&#34; into every package.</li>

<li>Standard input is <code>$*IN</code>, standard output is <code>$*OUT</code>, and standard error is <code>$*ERR</code>. The magic command-line input handle is <code>$*ARGS</code>.</li>

<li>Magical file-scoped values live in variables with a <code>=</code> secondary sigil. <code>$=DATA</code> is the name of your <code>DATA</code> filehandle, for instance. All pod structures are available through <code>%=POD</code> (or some such). As with <code>*</code>, the <code>=</code> may also be used as a package name: <code>$=::DATA</code>.</li>

<li>Magical lexically scoped values live in variables with a <code>?</code> secondary sigil. These are all values that are known to the compiler, and may in fact be dynamically scoped within the compiler itself, and only appear to be lexically scoped because dynamic scopes of the compiler resolve to lexical scopes of the program. All <code>$?</code> variables are considered constants, and may not be modified after being compiled in.
<p><code>$?FILE</code> and <code>$?LINE</code> are your current file and line number, for instance. <code>?</code> is not a shortcut for a package name like <code>*</code> is. Instead of <code>$?OUTER::SUB</code> you probably want to write <code>OUTER::&#60;$?SUB&#62;</code>.</p>

<p>Here are some possibilities:</p>

<pre>    $?OS        Which operating system am I compiled for?
    $?OSVER     Which operating system version am I compiled for?
    $?PERLVER   Which Perl version am I compiled for?
    $?FILE      Which file am I in?</pre>

<a name="msg_8"></a>
<a href="?hide_quotes=no#msg_8" onclick="return tog_quote(8);">
<div ID="header_shown_8" style="display: none;">
- Hide the snippet from t/magicals/file_line.t (line 11 ~ line 16) -
</div>
<div ID="header_hidden_8" style="display: block;">
- Show the snippet from t/magicals/file_line.t (line 11 ~ line 16, 6 lines) -
</div>
</a>
<div ID="hide_8" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S02/&quot;Names&quot; /Which file am I in/&gt;
ok($?FILE eq ('t/magicals/file_line.t' | 't\\magicals\\file_line.t'), '$?FILE works');

# NOTE:
# above is a junction hack for Unix and Win32 file 
# paths until the FileSpec hack is working - Stevan</pre>
</div>


<pre>    $?LINE      Which line am I at?
    $?PACKAGE   Which package am I in?
    @?PACKAGE   Which nested packages am I in?
    $?MODULE    Which module am I in?
    @?MODULE    Which nested modules am I in?
    $?CLASS     Which class am I in? (as variable)
    @?CLASS     Which nested classes am I in?
    $?ROLE      Which role am I in? (as variable)
    @?ROLE      Which nested roles am I in?
    $?GRAMMAR   Which grammar am I in?
    @?GRAMMAR   Which nested grammars am I in?
    $?PARSER    Which Perl grammar was used to parse this statement?
    &#38;?ROUTINE   Which routine am I in?</pre>

<a name="msg_7"></a>
<a href="?hide_quotes=no#msg_7" onclick="return tog_quote(7);">
<div ID="header_shown_7" style="display: none;">
- Hide the snippet from t/magicals/subname.t (line 9 ~ line 17) -
</div>
<div ID="header_hidden_7" style="display: block;">
- Show the snippet from t/magicals/subname.t (line 9 ~ line 17, 9 lines) -
</div>
</a>
<div ID="hide_7" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S02/&quot;Names&quot; /Which routine am I in/&gt;
sub foo { return &amp;?ROUTINE.name }
is(foo(), '&amp;main::foo', 'got the right routine name');

my $bar = sub { return &amp;?ROUTINE.name };
is($bar(), '&lt;anon&gt;', 'got the right routine name (anon-block)');

my $baz = try { &amp;?ROUTINE.name };
ok(not(defined $baz), '&amp;?ROUTINE.name not defined outside of a routine');</pre>
</div>


<pre>    @?ROUTINE   Which nested routines am I in?
    &#38;?BLOCK     Which block am I in?
    @?BLOCK     Which nested blocks am I in?
    $?LABEL     Which block label am I in?
    @?LABEL     Which nested block labels am I in?</pre>

<p>All the nested <code>@?</code> variables are ordered from the innermost to the outermost, so <code>@?BLOCK[0]</code> is always the same as <code>$?BLOCK</code>.</p>

<p>Note that some of these things have parallels in the <code>*</code> space at run time:</p>

<pre>    $*OS        Which OS I&#39;m running under
    $*OSVER     Which OS version I&#39;m running under
    $*PERLVER   Which Perl version I&#39;m running under</pre>

<p>You should not assume that these will have the same value as their compile-time cousins.</p>
</li>

<li>While <code>$?</code> variables are constant to the run time, the compiler has to have a way of changing these values at compile time without getting confused about its own <code>$?</code> variables (which were frozen in when the compile-time code was itself compiled). The compiler can talk about these compiler-dynamic values using the <code>COMPILING</code> pseudopackage.
<p>References to <code>COMPILING</code> variables are automatically hoisted into the context currently being compiled. Setting or temporizing a <code>COMPILING</code> variable sets or temporizes the incipient <code>$?</code> variable in the surrounding lexical context that is being compiled. If nothing in the context is being compiled, an exception is thrown.</p>

<pre>    $?FOO // say &#34;undefined&#34;;   # probably says undefined
    BEGIN { COMPILING::&#60;$?FOO&#62; = 42 }
    say $?FOO;                  # prints 42
    {
        say $?FOO;              # prints 42
        BEGIN { temp COMPILING::&#60;$?FOO&#62; = 43 } # temporizes to *compiling* block
        say $?FOO;              # prints 43
        BEGIN { COMPILING::&#60;$?FOO&#62; = 44 }
        say $?FOO;              # prints 44
        BEGIN { say COMPILING::&#60;$?FOO&#62; }        # prints 44, but $?FOO probably undefined
    }
    say $?FOO;                  # prints 42 (left scope of temp above)
    $?FOO = 45;                 # always an error
    COMPILING::&#60;$?FOO&#62; = 45;    # an error unless we are compiling something</pre>

<p>Note that <code>CALLER::&#60;$?FOO&#62;</code> might discover the same variable as <code>COMPILING::&#60;$?FOO</code>&#62;, but only if the compiling context is the immediate caller. Likewise <code>OUTER::&#60;$?FOO&#62;</code> might or might not get you to the right place. In the abstract, <code>COMPILING::&#60;$?FOO</code>&#62; goes outwards dynamically until it finds a compiling scope, and so is guaranteed to find the &#34;right&#34; <code>$?FOO</code>. (In practice, the compiler hopefully keeps track of its current compiling scope anyway, so no scan is needed.)</p>

<p>Perceptive readers will note that this subsumes various &#34;compiler hints&#34; proposals. Crazy readers will wonder whether this means you could set an initial value for other lexicals in the compiling scope. The answer is yes. In fact, this mechanism is probably used by the exporter to bind names into the importer&#39;s namespace.</p>
</li>

<li>The currently compiling Perl parser is switched by modifying <code>COMPILING::&#60;$?PARSER&#62;</code>. Lexically scoped parser changes should temporize the modification. Changes from here to end-of-compilation unit can just assign or bind it. In general, most parser changes involve deriving a new grammar and then pointing <code>COMPILING::&#60;$?PARSER&#62;</code> at that new grammar. Alternately, the tables driving the current parser can be modified without derivation, but at least one level of anonymous derivation must intervene from the standard Perl grammar, or you might be messing up someone else&#39;s grammar. Basically, the current grammar has to belong only to the current compiling scope. It may not be shared, at least not without explicit consent of all parties. No magical syntax at a distance. Consent of the governed, and all that.</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Literals"
>Literals</a></h1>

<a name="msg_13"></a>
<a href="?hide_quotes=no#msg_13" onclick="return tog_quote(13);">
<div ID="header_shown_13" style="display: none;">
- Hide the snippet from t/operators/listquote.t (line 37 ~ line 76) -
</div>
<div ID="header_hidden_13" style="display: block;">
- Show the snippet from t/operators/listquote.t (line 37 ~ line 76, 40 lines) -
</div>
</a>
<div ID="hide_13" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S02/&quot;Literals&quot;&gt;
# L&lt;S03/&quot;Chained comparisons&quot;&gt;

my $s = join 'a', &lt;x y z&gt;;
is($s, &quot;xayaz&quot;, 'list context &lt;list&gt;');

my $s = join [,] &lt;a x y z&gt;;
is($s, &quot;xayaz&quot;, 'listop &lt;list&gt;');

my $x = try { [1,2,3].join&lt;a b c&gt; };
ok($!, '.join&lt;abc&gt; parses but semantic error');
is($x, [1,2,3].join()&lt;a b c&gt;, '.join&lt;a b c&gt; not treated as argument');

my @y = try { {:a&lt;1&gt;, :b(2)}&lt;a b c&gt; };
is(@y, [1,2,undef], '{...}&lt;a b c&gt; is hash subscript');

eval '{:a&lt;1&gt;, :b(2)} &lt;a b c&gt;';
ok($!, '{...} &lt;...&gt; parsefail');

ok((1 | 3) &lt; 3, '(...) &lt; 3 no parsefail');

eval '(1 | 3)&lt;3';
ok($!, '()&lt;3 parsefail');

eval 'print &lt; 3';
ok($!, 'print &lt; 3 parsefail');

my $z = eval 'reverse&lt;1 2 3&gt;';
ok($!, 'reverse&lt;1 2 3&gt; parsefail');

eval ':foo &lt;1 2 3&gt;';
ok($!, ':foo &lt;1 2 3&gt; parsefail');

my $r = eval ':foo &lt;3';
is($r, Bool::True, ':foo &lt;3 is comparison');

my $p = eval ':foo&lt;1 2 3&gt;';
is($p, 'foo' =&gt; (1,2,3), ':foo&lt;1 2 3&gt; is pair of list');

=cut</pre>
</div>


<ul>
<li>A single underscore is allowed only between any two digits in a literal number, where the definition of digit depends on the radix. Underscores are not allowed anywhere else in any numeric literal, including next to the radix point or exponentiator, or at the beginning or end.</li>

<li>Initial <code>0</code> no longer indicates octal numbers by itself. You must use an explicit radix marker for that. Pre-defined radix prefixes include:
<pre>    0b          base 2, digits 0..1
    0o          base 8, digits 0..7
    0d          base 10, digits 0..9
    0x          base 16, digits 0..9,a..f (case insensitive)</pre>
</li>

<li>The general radix form of a number involves prefixing with the radix in adverbial form:
<pre>    :10&#60;42&#62;             same as 0d42 or 42
    :16&#60;DEAD_BEEF&#62;      same as 0xDEADBEEF
    :8&#60;177777&#62;          same as 0o177777 (65535)
    :2&#60;1.1&#62;             same as 0b1.1 (0d1.5)</pre>

<p>Extra digits are assumed to be represented by <code>a</code>..<code>z</code> and <code>A</code>..<code>Z</code>, so you can go up to base 36. (Use <code>A</code> and <code>B</code> for base twelve, not <code>T</code> and <code>E</code>.) Alternately you can use a list of digits in decimal:</p>

<pre>    :60[12,34,56]       # 12 * 3600 + 34 * 60 + 56
    :100[3,&#39;.&#39;,14,16]   # pi</pre>

<p>Any radix may include a fractional part. A dot is never ambiguous because you have to tell it where the number ends:</p>

<pre>    :16&#60;dead_beef.face&#62; # fraction
    :16&#60;dead_beef&#62;.face # method call</pre>
</li>

<li>Only base 10 (in any form) allows an additional exponentiator starting with &#39;e&#39; or &#39;E&#39;. All other radixes must either rely on the constant folding properties of ordinary multiplication and exponentiation, or supply the equivalent two numbers as part of the string, which will be interpreted as they would outside the string, that is, as decimal numbers by default:
<pre>    :16&#60;dead_beef&#62; * 16**8
    :16&#60;dead_beef*16**8&#62;</pre>

<p>It&#39;s true that only radixes that define <code>e</code> as a digit are ambiguous that way, but with any radix it&#39;s not clear whether the exponentiator should be 10 or the radix, and this makes it explicit:</p>

<pre>    0b1.1e10                    ILLEGAL, could be read as any of:

    :2&#60;1.1&#62; * 2 ** 10           1536
    :2&#60;1.1&#62; * 10 ** 10          15,000,000,000
    :2&#60;1.1&#62; * :2&#60;10&#62; ** :2&#60;10&#62;  6</pre>

<p>So we write those as</p>

<pre>    :2&#60;1.1*2**10&#62;               1536
    :2&#60;1.1*10**10&#62;              15,000,000,000
    :2&#171;1.1*:2&#60;10&#62;**:2&#60;10&#62;&#187;      6</pre>

<p>The generic string-to-number converter will recognize all of these forms (including the * form, since constant folding is not available to the run time). Also allowed in strings are leading plus or minus, and maybe a trailing Units type for an implied scaling. Leading and trailing whitespace is ignored. Note also that leading <code>0</code> by itself <i>never</i> implies octal in Perl 6.</p>

<p>Any of the adverbial forms may be used as a function:</p>

<pre>    :2($x)      # &#34;bin2num&#34;
    :8($x)      # &#34;oct2num&#34;
    :10($x)     # &#34;dec2num&#34;
    :16($x)     # &#34;hex2num&#34;</pre>

<p>Think of these as setting the default radix, not forcing it. Like Perl 5&#39;s old <code>oct()</code> function, any of these will recognize a number starting with a different radix marker and switch to the other radix. However, note that the <code>:16()</code> converter function will interpret leading <code>0b</code> or <code>0d</code> as hex digits, not radix switchers.</p>
</li>

<li>Characters indexed by hex numbers can be interpolated into strings by introducing with <code>&#34;\x&#34;</code>, followed by either a bare hex number (<code>&#34;\x263a&#34;</code>) or a hex number in square brackets (<code>&#34;\x[263a]&#34;</code>). Similarly, <code>&#34;\o12&#34;</code> and <code>&#34;\o[12]&#34;</code> interpolate octals, while <code>&#34;\d1234&#34;</code> and <code>&#34;\d[1234]&#34;</code> interpolate decimals--but generally you should be using hex in the world of Unicode. Multiple characters may be specified within any of the bracketed forms by separating the numbers with comma: <code>&#34;\x[41,42,43]&#34;</code>. You must use the bracketed form to disambiguate if the unbracketed form would &#34;eat&#34; too many characters, because all of the unbracketed forms eat as many characters as they think look like digits in the radix specified. None of these notations work in normal Perl code. They work only in interpolations and regexes and the like.
<p>The old <code>\123</code> form is now illegal, as is the <code>\0123</code> form. Only <code>\0</code> remains, and then only if the next character is not in the range <code>&#39;0&#39;..&#39;7&#39;</code>. Octal characters must use <code>\o</code> notation. Note also that backreferences are no longer represented by <code>\1</code> and the like--see S05.</p>
</li>

<li>The <code>qw/foo bar/</code> quote operator now has a bracketed form: <code>&#60;foo bar&#62;</code>. When used as a subscript it performs a slice equivalent to <code>{&#39;foo&#39;,&#39;bar&#39;}</code>. Much like the relationship between single quotes and double quotes, single angles do not interpolate while double angles do. The double angles may be written either with French quotes, <code>&#171;$foo @bar[]&#187;</code>, or with &#34;Texas&#34; quotes, <code>&#60;&#60;$foo @bar[]&#62;&#62;</code>, as the ASCII workaround. The implicit split is done after interpolation, but respects quotes in a shell-like fashion, so that <code>&#171;&#39;$foo&#39; &#34;@bar[]&#34;&#187;</code> is guaranteed to produce a list of two &#34;words&#34; equivalent to <code>(&#39;$foo&#39;, &#34;@bar[]&#34;)</code>. <code>Pair</code> notation is also recognized inside <code>&#171;...&#187;</code> and such &#34;words&#34; are returned as <code>Pair</code> objects.</li>

<li>There is now a generalized adverbial form of Pair notation. The following table shows the correspondence to the &#34;fatarrow&#34; notation:
<pre>    Fat arrow           Adverbial pair
    =========           ==============
    a =&#62; 1              :a
    a =&#62; 0              :!a
    a =&#62; 0              :a(0)
    a =&#62; $x             :a($x)
    a =&#62; &#39;foo&#39;          :a&#60;foo&#62;
    a =&#62; &#60;foo bar&#62;      :a&#60;foo bar&#62;
    a =&#62; &#171;$foo @bar&#187;    :a&#171;$foo @bar&#187;
    a =&#62; {...}          :a{...}
    a =&#62; [...]          :a[...]
    a =&#62; $a             :$a
    a =&#62; @a             :@a
    a =&#62; %a             :%a
    a =&#62; %foo&#60;a&#62;        %foo:&#60;a&#62;</pre>

<p>Note that as usual the <code>{...}</code> form can indicate either a closure or a hash depending on the contents. It does <i>not</i> indicate a subscript.</p>

<p>Note also that the <code>&#60;a b&#62;</code> form is not a subscript and is therefore equivalent not to <code>.{&#39;a&#39;,&#39;b&#39;}</code> but rather to <code>(&#39;a&#39;,&#39;b&#39;)</code>. Bare <code>&#60;a&#62;</code> turns into <code>(&#39;a&#39;)</code> rather than <code>(&#39;a&#39;,)</code>.</p>

<p>Two or more adverbs can always be strung together without intervening punctuation anywhere a single adverb is acceptable. When used as named arguments in an argument list, you may put comma between, because they&#39;re just ordinary named arguments to the function, and a fatarrow pair would work the same. When modifying an operator (that is, when one occurs where an operator is expected), you may not put commas between, and the fatarrow form is not allowd. See S06.</p>

<p>The negated form (<code>:!a</code>) and the sigiled forms (<code>:$a</code>, <code>:@a</code>, <code>:%a</code>) never take an argument and don&#39;t care what the next character is. They are considered complete.</p>

<p>The other forms of adverb (including the bare <code>:a</code> form) <i>always</i> look for an immediate bracketed argument, and will slurp it up. If that&#39;s not intended, you must use whitespace between the adverb and the opening bracket. The syntax of individual adverbs is the same everywhere in Perl 6. There are no exceptions based on whether an argument is wanted or not. Except as noted above, the parser always looks for the brackets. Despite not indicating a true subscript, the brackets are similarly parsed as postfix operators. As postfixes the brackets may be separated from their initial <code>:foo</code> with either dot or &#34;long dot&#34;, but nothing else.</p>

<p>Regardless of syntax, adverbs used as named arguments generally show up as optional named parameters to the function in question--even if the function is an operator or macro. The function in question neither knows nor cares how weird the original syntax was.</p>
</li>

<li>Generalized quotes may now take adverbs:
<pre>    Short       Long            Meaning
    =====       ====            =======
    :x          :exec           Execute as command and return results
    :w          :words          Split result on words (no quote protection)
    :ww         :quotewords     Split result on words (with quote protection)
    :t          :to             Interpret result as heredoc terminator
    :n          :none           No escapes at all (unless otherwise adverbed)
    :q          :single         Interpolate \\, \q and \&#39; (or whatever)
    :qq         :double         Interpolate with :s, :a, :h, :f, :c, :b
    :s          :scalar         Interpolate $ vars
    :a          :array          Interpolate @ vars
    :h          :hash           Interpolate % vars
    :f          :function       Interpolate &#38; calls
    :c          :closure        Interpolate {...} expressions
    :b          :backslash      Interpolate \n, \t, etc. (implies :q at least)
                :code           Quasiquoting</pre>

<p>Ordinarily the colon is required on adverbs, but the <code>quote</code> declarator allows you to combine any of the existing adverbial forms above without an intervening colon:</p>

<pre>    quote qw;                   # declare a P5-esque qw// meaning q:w
    quote qn;                   # completely raw quote qn//
    quote qnc;                  # q:n:c//, interpolate only closures</pre>

<p>Actually, the first two are already assumed, because you get all of the forms that use as single character predeclared for free.</p>

<p>If you want to abbreviate further, you may also give an explicit definition as either a string or quasiquote:</p>

<pre>    quote qx = &#39;qq:x&#39;;          # equivalent to P5&#39;s qx//
    quote qTO = &#39;qq:x:w:to&#39;;    # qq:x:w:to//
    quote circumfix:&#60;&#10096; &#10097;&#62; = q:code { .quoteharder };  # or some such...</pre>

<p>In particular, all these forms disable the lookahead for an adverbial argument, as if there were a space after the keyword. So although</p>

<pre>    q:n($foo)</pre>

<p>will misinterpret <code>$foo</code> as the <code>:n</code> argument,</p>

<pre>    qn(stuff)</pre>

<p>has the advantage of misinterpreting it as the argument to the <code>qn()</code> function instead. <code>:)</code></p>

<p>But parens are special that way. (Even <code>q()</code> is assumed to be a function call rather than a quote.) Other bracketing characters are special only if they can be mistaken for adverbial arguments, so</p>

<pre>    qn[stuff]</pre>

<p>is fine, and means</p>

<pre>    q:n /stuff/</pre>

<p>while</p>

<pre>    q:n[stuff]</pre>

<p>is not so fine, if the user intended &#34;stuff&#34; to be the string rather than an argument to <code>:n</code>. Basically, you&#39;ll be fine if you just never use parens for quote delimiters, and always put a space after your adverbs.</p>

<p>If this is all too much of a hardship, you can define your own quote adverbs and operators as standard macros. The main difference is that, unlike</p>

<pre>    quote qn = &#39;q:n&#39;;</pre>

<p>declaring something like</p>

<pre>    macro qn { &#39;q:n&#39; }</pre>

<p>does <i>not</i> disable the subsequent search for an argument to <code>:n</code>. To get the equivalent, you need to add a space:</p>

<pre>    macro qn { &#39;q:n &#39; }</pre>

<p>All the uppercase adverbs are reserved for user-defined quotes. All Unicode delimiters above Latin-1 are reserved for user-defined quotes.</p>
</li>

<li>A consequence of the previous item is that we can now say:
<pre>    %hash = qw:c/a b c d {@array} {%hash}/;</pre>

<p>or</p>

<pre>    %hash = qq:w/a b c d {@array} {%hash}/;</pre>

<p>to interpolate items into a <code>qw</code>. Conveniently, arrays and hashes interpolate with only whitespace separators by default, so the subsequent split on whitespace still works out. (But the built-in <code>&#171;...&#187;</code> quoter automatically does interpolation equivalent to <code>qq:ww/.../</code>. The built-in <code>&#60;...&#62;</code> is equivalent to <code>q:w/.../</code>.)</p>
</li>

<li>Whitespace is allowed between the &#34;q&#34; and its adverb: <code>q :w /.../</code>.
<a name="msg_12"></a>
<a href="?hide_quotes=no#msg_12" onclick="return tog_quote(12);">
<div ID="header_shown_12" style="display: none;">
- Hide the snippet from t/operators/quoting.t (line 164 ~ line 173) -
</div>
<div ID="header_hidden_12" style="display: block;">
- Show the snippet from t/operators/quoting.t (line 164 ~ line 173, 10 lines) -
</div>
</a>
<div ID="hide_12" style="display:none; border:1px solid">
<pre style="margin-left: 6px">  # L&lt;S02/Literals /Whitespace is allowed between the &quot;q&quot; and its adverb: q :w /..././&gt;
    my @q = ();
    try { eval '@q = (q :w /$foo $bar/)' };
    is(+@q, 2, &quot;q :w // is the same as q:w//&quot;,:todo&lt;bug&gt;);
    is(@q[0], '$foo', &quot;...&quot;,:todo&lt;bug&gt;);
    is(@q[1], '$bar', &quot;...&quot;,:todo&lt;bug&gt;);
};


{ # qq:w,Interpolating quote constructor with words adverb </pre>
</div>

</li>

<li>For these &#34;q&#34; forms the choice of delimiters has no influence on the semantics. That is, <code>&#39;&#39;</code>, <code>&#34;&#34;</code>, <code>&#60;&#62;</code>, <code>&#171;&#187;</code>, <code>``</code>, <code>()</code>, <code>[]</code>, and <code>{}</code> have no special significance when used in place of <code>//</code> as delimiters. There may be whitespace before the opening delimiter. (Which is mandatory for parens because <code>q()</code> is a subroutine call and <code>q:w(0)</code> is an adverb with arguments). Other brackets may also require whitespace when they would be understood as an argument to an adverb in something like <code>q:z&#60;foo&#62;//</code>. A colon may never be used as the delimiter since it will always be taken to mean another adverb regardless of what&#39;s in front of it. Nor may a <code>#</code> character be used as the delimiter since it is always taken as whitespace (specifically, as a comment).</li>

<li>New quoting constructs may be declared as macros:
<pre>    macro quote:&#60;qX&#62; (*%adverbs) {...}</pre>

<p>Note: macro adverbs are automatically evaluated at macro call time if the adverbs are included in the parse. If an adverb needs to affect the parsing of the quoted text of the macro, then an explicit named parameter may be passed on as a parameter to the <code>is parsed</code> subrule, or used to select which subrule to invoke.</p>
</li>

<li>You may interpolate double-quotish text into a single-quoted string using the <code>\qq[...]</code> construct. Other &#34;q&#34; forms also work, including user-defined ones, as long as they start with &#34;q&#34;. Otherwise you&#39;ll just have to embed your construct inside a <code>\qq[...]</code>.</li>

<li>Bare scalar variables always interpolate in double-quotish strings. Bare array, hash, and subroutine variables may <i>never</i> be interpolated. However, any scalar, array, hash or subroutine variable may start an interpolation if it is followed by a sequence of one or more bracketed dereferencers: that is, any of:
<dl>
<dt><a name="1._An_array_subscript"
>1. An array subscript
<dt><a name="2._A_hash_subscript"
>2. A hash subscript
<dt><a name="3._A_set_of_parentheses_indicating_a_function_call"
>3. A set of parentheses indicating a function call
<dt><a name="4._Any_of_1_through_3_in_their_dot_form"
>4. Any of 1 through 3 in their <b>dot</b> form
<dt><a name="5._A_method_call_that_includes_argument_parentheses"
>5. A method call that includes argument parentheses
<dt><a name="6._A_sequence_of_one_or_more_unparenthesized_method_call,_followed_by_any_of_1_through_5"
>6. A sequence of one or more unparenthesized method call, followed by any of 1 through 5</a></dt>
</dl>

<p>In other words, this is legal:</p>

<pre>    &#34;Val = $a.ord.fmt(&#39;%x&#39;)\n&#34;</pre>

<p>and is equivalent to</p>

<pre>    &#34;Val = { $a.ord.fmt(&#39;%x&#39;) }\n&#34;</pre>
</li>

<li>In order to interpolate an entire array, it&#39;s necessary now to subscript with empty brackets:
<pre>    print &#34;The answers are @foo[]\n&#34;</pre>

<p>Note that this fixes the spurious &#34;<code>@</code>&#34; problem in double-quoted email addresses.</p>

<p>As with Perl 5 array interpolation, the elements are separated by a space. (Except that a space is not added if the element already ends in some kind of whitespace. In particular, a list of pairs will interpolate with a tab between the key and value, and a newline after the pair.)</p>

<a name="msg_11"></a>
<a href="?hide_quotes=no#msg_11" onclick="return tog_quote(11);">
<div ID="header_shown_11" style="display: none;">
- Hide the snippet from t/syntax/interpolation/arrays.t (line 5 ~ line 58) -
</div>
<div ID="header_hidden_11" style="display: block;">
- Show the snippet from t/syntax/interpolation/arrays.t (line 5 ~ line 58, 54 lines) -
</div>
</a>
<div ID="hide_11" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S02/Literals /As with Perl 5 array interpolation/&gt;
# See L&lt;&quot;http://www.nntp.perl.org/group/perl.perl6.language/23224&quot;&gt;:
#   In a private conversation with Larry this afternoon, he said that by 
#   default &quot;$foo&quot; and ~$foo and $foo.as(Str) all give the same result 
#   (assuming scalar context, etc.).  And that &quot;@foo[]&quot; and ~[at]foo and 
#   @foo.as(Str) are the same as join(' ', @foo) where join is effectively:

plan 10;

{
  my @array = &lt;a b c d&gt;;

  is ~@array, &quot;a b c d&quot;,
    &quot;arrays whose elements don't contain whitespace stringify correctly (1)&quot;;
  is &quot;@array[]&quot;, &quot;a b c d&quot;,
    &quot;arrays whose elements don't contain whitespace stringify correctly (2)&quot;;
}

{
  my @array = &lt;a b c d&gt;;
  push @array, [&lt;e f g h&gt;];

  is ~@array, &quot;a b c d e f g h&quot;,
    &quot;arrays with embedded array references stringify correctly (1)&quot;;
  is &quot;@array[]&quot;, &quot;a b c d e f g h&quot;,
    &quot;arrays with embedded array references stringify correctly (2)&quot;;
}

{
  my @array = (&quot;a&quot;, &quot;b &quot;, &quot;c&quot;);

  is ~@array, &quot;a b  c&quot;,
    &quot;array whose elements do contain whitespace stringify correctly (1-1)&quot;;
  is &quot;@array[]&quot;, &quot;a b  c&quot;,
    &quot;array whose elements do contain whitespace stringify correctly (1-2)&quot;;
}

{
  my @array = (&quot;a\t&quot;, &quot;b &quot;, &quot;c&quot;);

  is ~@array, &quot;a\t b  c&quot;,
    &quot;array whose elements do contain whitespace stringify correctly (2-1)&quot;;
  is &quot;@array[]&quot;, &quot;a\t b  c&quot;,
    &quot;array whose elements do contain whitespace stringify correctly (2-2)&quot;;
}

{
  my @array = (&quot;a\t&quot;, &quot; b &quot;, &quot;c&quot;);

  is ~@array, &quot;a\t  b  c&quot;,
    &quot;array whose elements do contain whitespace stringify correctly (3-1)&quot;;
  is &quot;@array[]&quot;, &quot;a\t  b  c&quot;,
    &quot;array whose elements do contain whitespace stringify correctly (3-2)&quot;;
}</pre>
</div>

</li>

<li>In order to interpolate an entire hash, it&#39;s necessary to subscript with empty braces or angles:
<pre>    print &#34;The associations are:\n%bar{}&#34;
    print &#34;The associations are:\n%bar&#60;&#62;&#34;</pre>

<p>Note that this avoids the spurious &#34;<code>%</code>&#34; problem in double-quoted printf formats.</p>

<p>By default, keys and values are separated by tab characters, and pairs are terminated by newlines. (This is almost never what you want, but if you want something polished, you can be more specific.)</p>
</li>

<li>In order to interpolate the result of a sub call, it&#39;s necessary to include both the sigil and parentheses:
<pre>    print &#34;The results are &#38;baz().\n&#34;</pre>

<p>The function is called in scalar context. (If it returns a list anyway, that list is interpolated as if it were an array in string context.)</p>
</li>

<li>In order to interpolate the result of a method call without arguments, it&#39;s necessary to include parentheses or extend the call with something ending in brackets:
<a name="msg_10"></a>
<a href="?hide_quotes=no#msg_10" onclick="return tog_quote(10);">
<div ID="header_shown_10" style="display: none;">
- Hide the snippet from t/syntax/interpolation/strings.t (line 34 ~ line 63) -
</div>
<div ID="header_hidden_10" style="display: block;">
- Show the snippet from t/syntax/interpolation/strings.t (line 34 ~ line 63, 30 lines) -
</div>
</a>
<div ID="hide_10" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S02/&quot;Literals&quot; /&quot;In order to interpolate the result of a method call&quot;&gt;
is(&quot;$world.chars()&quot;, '5', 'method calls with parens should interpolate');
is(&quot;$world.chars&quot;, 'World.chars', 'method calls without parens should not interpolate');
is(&quot;$world.reverse.chars()&quot;, '5', 'cascade of argumentless methods, last ending in paren');
is(&quot;$world.substr(0,1)&quot;, 'W', 'method calls with parens and args should interpolate');

# Single quotes
# XXX the next tests will always succeed even if '' interpolation is buggy
is('Hello $world', 'Hello $world', 'single quoted string interpolation does not work (which is correct)');
is('2 + 2 = { 2+2 }', '2 + 2 = { 2+2 }', 'single quoted closure interpolation does not work (which is correct)');
is('$world @list[] %hash{} &amp;func()', '$world @list[] %hash{} &amp;func()', 'single quoted string interpolation does not work (which is correct)');

# Corner-cases
is(&quot;Hello $world!&quot;, &quot;Hello World!&quot;, &quot;! is not a part of var names&quot;);
sub list_count (*@args) { +@args }
is(list_count(&quot;@list[]&quot;), 1, 'quoted interpolation gets string context');
is(qq{a{chr 98}c}, 'abc', &quot;curly brace delimiters don't interfere with closure interpolation&quot;);

# Quoting constructs
# The next test will always succeed, but if there's a bug it probably
# won't compile.
is(qn&quot;abc\\d\\'\/&quot;, qn&quot;abc\\d\\'\/&quot;, &quot;raw quotation works&quot;);
is(q&quot;abc\\d\&quot;\'\/&quot;, qn|abc\d&quot;\'\/|, &quot;single quotation works&quot;); #&quot;
is(qq&quot;abc\\d\&quot;\'\/&quot;, qn|abc\d&quot;'/|, &quot;double quotation works&quot;); #&quot;
is(qa&quot;$world @list[] %hash{}&quot;, qn&quot;$world 1 2 %hash{}&quot;, &quot;only interpolate array&quot;);
is(qb&quot;$world \\\&quot;\n\t&quot;, &quot;\$world \\\&quot;\n\t&quot;, &quot;only interpolate backslash&quot;);
is('$world \qq[@list[]] %hash{}', '$world 1 2 %hash{}', &quot;interpolate quoting constructs in ''&quot;);

is(&quot; \d[111] \d[107] &quot;, ' o k ', &quot;\\d[] respects whitespaces around it&quot;)</pre>
</div>


<pre>    print &#34;The attribute is $obj.attr().\n&#34;
    print &#34;The attribute is $obj.attr&#60;Jan&#62;.\n&#34;</pre>

<p>The method is called in scalar context. (If it returns a list, that list is interpolated as if it were an array.)</p>

<p>It is allowed to have a cascade of argumentless methods as long as the last one ends with parens:</p>

<pre>    print &#34;The attribute is %obj.keys.sort.reverse().\n&#34;</pre>

<p>(The cascade is basically counted as a single method call for the end-bracket rule.)</p>
</li>

<li>Multiple dereferencers may be stacked as long as each one ends in some kind of bracket:
<pre>    print &#34;The attribute is @baz[3](1,2,3){$xyz}&#60;blurfl&#62;.attr().\n&#34;</pre>

<p>Note that the final period above is not taken as part of the expression since it doesn&#39;t introduce a bracketed dereferencer. Spaces are not allowed between the dereferencers even when you use the dotted forms.</p>
</li>

<li>A bare closure also interpolates in double-quotish context. It may not be followed by any dereferencers, since you can always put them inside the closure. The expression inside is evaluated in scalar (string) context. You can force list context on the expression using the <code>list</code> operator if necessary.
<p>The following means the same as the previous example.</p>

<pre>    print &#34;The attribute is { @baz[3](1,2,3){$xyz}&#60;blurfl&#62;.attr }.\n&#34;</pre>

<p>The final parens are unnecessary since we&#39;re providing &#34;real&#34; code in the curlies. If you need to have double quotes that don&#39;t interpolate curlies, you can explicitly remove the capability:</p>

<pre>    qq:c(0) &#34;Here are { $two uninterpolated } curlies&#34;;</pre>

<p>or equivalently:</p>

<pre>    qq:!c &#34;Here are { $two uninterpolated } curlies&#34;;</pre>

<p>Alternately, you can build up capabilities from single quote to tell it exactly what you <i>do</i> want to interpolate:</p>

<pre>    q:s &#39;Here are { $two uninterpolated } curlies&#39;;</pre>
</li>

<li>Secondary sigils (twigils) have no influence over whether the primary sigil interpolates. That is, if <code>$a</code> interpolates, so do <code>$^a</code>, <code>$*a</code>, <code>$=a</code>, <code>$?a</code>, <code>$.a</code>, etc. It only depends on the <code>$</code>.</li>

<li>No other expressions interpolate. Use curlies.</li>

<li>A class method may not be directly interpolated. Use curlies:
<pre>    print &#34;The dog bark is {Dog.bark}.\n&#34;</pre>
</li>

<li>The old disambiguation syntax:
<pre>    ${foo[$bar]}
    ${foo}[$bar]</pre>

<p>is dead. Use closure curlies instead:</p>

<pre>    {$foo[$bar]}
    {$foo}[$bar]</pre>

<p>(You may be detecting a trend here...)</p>
</li>

<li>To interpolate a topical method, use curlies: <code>&#34;{.bark}&#34;</code>.</li>

<li>To interpolate a function call without a sigil, use curlies: <code>&#34;{abs $var}&#34;</code>.</li>

<li>And so on.</li>

<li>Backslash sequences still interpolate, but there&#39;s no longer any <code>\v</code> to mean <i>vertical tab</i>, whatever that is... (<code>\v</code> now match vertical whitespace in a regex.)</li>

<li>There&#39;s also no longer any <code>\L</code>, <code>\U</code>, <code>\l</code>, <code>\u</code>, or <code>\Q</code>. Use curlies with the appropriate function instead: <code>&#34;{ucfirst $word}&#34;</code>.</li>

<li>You may interpolate any Unicode codepoint by name using <code>\c</code> and square brackets:
<pre>    &#34;\c[NEGATED DOUBLE VERTICAL BAR DOUBLE RIGHT TURNSTILE]&#34;</pre>

<p>Multiple codepoints constituting a single character may be interpolated with a single <code>\c</code> by separating the names with comma:</p>

<pre>    &#34;\c[LATIN CAPITAL LETTER A, COMBINING RING ABOVE]&#34;</pre>

<p>Whether that is regarded as one character or two depends on the Unicode support level of the current lexical scope. It is also possible to interpolate multiple codepoints that do not resolve to a single character:</p>

<pre>    &#34;\c[LATIN CAPITAL LETTER A, LATIN CAPITAL LETTER B]&#34;</pre>

<p>[Note: none of the official Unicode character names contains comma.]</p>
</li>

<li>There are no barewords in Perl 6. An undeclared bare identifier will always be taken to mean a subroutine or method name. (Class names (and other type names) are predeclared, or prefixed with the <code>::</code> type sigil when you&#39;re declaring a new one.) A consequence of this is that there&#39;s no longer any &#34;<code>use strict &#39;subs&#39;</code>&#34;. Since the syntax for method calls is distinguished from sub calls, it is only unrecognized sub calls that must be treated specially.
<p>You still must declare your subroutines, but a bareword with an unrecognized name is provisionally compiled as a subroutine call, on that assumption that such a declaration will occur by the end of the current compilation unit:</p>

<pre>    foo;         # provisional call if neither &#38;foo nor ::foo is defined so far
    foo();       # provisional call if &#38;foo is not defined so far
    foo($x, $y); # provisional call if &#38;foo is not defined so far
    $x.foo;      # not a provisional call; it&#39;s a method call on $x
    foo($x);     # not a provisional call; it&#39;s a method call on $x</pre>

<p>If a postdeclaration is not seen, the compile fails at <code>CHECK</code> time. (You are still free to predeclare subroutines explicitly, of course.) The postdeclaration may be in any lexical or package scope that could have made the declaration visible to the provisional call had the declaration occurred before rather than after the provisional call.</p>

<p>This fixup is done only for provisional calls. If there is <i>any</i> real predeclaration visible, it always takes precedence. In case of multiple ambiguous postdeclarations, either they must all be multis, or a compile-time error is declared and you must predeclare, even if one postdeclaration is obviously &#34;closer&#34;. A single <code>proto</code> predeclaration may make all postdeclared <code>multi</code> work fine, since that&#39;s a run-time dispatch, and all multis are effectively visible at the point of the controlling <code>proto</code> declaration.</p>

<p>Parsing of a bareword function as a provisional call is always done the same way list operators are treated. If a postdeclaration bends the syntax to be inconsistent with that, it is an error of the inconsistent signature variety.</p>

<p>If the unrecognized subroutine name is followed by <code>postcircumfix:&#60;( )&#62;</code>, it is compiled as a provisional function call of the parenthesized form. If it is not, it is compiled as a provisional function call of the list operator form, which may or may not have an argument list. When in doubt, the attempt is made to parse an argument list. As with any list operator, an immediate postfix operator is illegal unless it is a form of parentheses, whereas anything following whitespace will be interpreted as an argument list if possible.</p>

<p>Based on the signature of the subroutine declaration, there are only four ways that an argument list can be parsed:</p>

<pre>    Signature           # of expected args
    ()                  0
    ($x)                1
    ($x?)               0..1
    (anything else)     0..Inf</pre>

<p>That is, a standard subroutine call may be parsed only as a 0-arg term (or function call), a 1-mandatory-arg prefix operator (or function call), a 1-optional-arg term or prefix operator (or function call), or an &#34;infinite-arg&#34; list operator (or function call). A given signature might only accept 2 arguments, but the only number distinctions the parser is allowed to make is between void, singular and plural; checking that number of arguments supplied matches some number larger than one must be done as a separate semantic constraint, not as a syntactic constraint. Perl functions never take N arguments off of a list and leave the rest for someone else, except for small values of N, where small is defined as not more than 1. You can get fancier using macros, but macros <i>always</i> require predeclaration. Since the non-infinite-list forms are essentially behaving as macros, those forms also require predeclaration. Only the infinite-list form may be postdeclared (and hence used provisionally).</p>

<p>It is illegal for a provisional subroutine call to be followed by a colon postfix, since such a colon is allowed only on an indirect object, or a method call in dot form. (It is also allowed on a label when a statement is expected.) So for any undeclared identifier &#34;<code>foo</code>&#34;:</p>

<pre>    foo.bar             # ILLEGAL       -- postfix must use foo().bar
    foo .bar            # foo($_.bar)   -- no postfix starts with whitespace
    foo\ .bar           # ILLEGAL       -- long dot must use foo()\ .bar
    foo++               # ILLEGAL       -- postfix must use foo()++
    foo 1,2,3           # foo(1,2,3)    -- args always expected after listop
    foo + 1             # foo(+1)       -- term always expected after listop
    foo;                # foo();        -- no postfix, but no args either
    foo:                #   label       -- must be label at statement boundary.
                                        -- ILLEGAL otherwise
    foo: bar:           #   two labels in a row, okay
    .foo:               # $_.foo: 1     -- must be &#34;dot&#34; method with : args
    .foo(1)             # $_.foo(1)     -- must be &#34;dot&#34; method with () args
    .foo                # $_.foo()      -- must be &#34;dot&#34; method with no args
    .$foo:              # $_.$foo: 1    -- indirect &#34;dot&#34; method with : args
    foo bar: 1          # bar.foo(1)    -- bar must be predecl as class
                                        -- sub bar allowed here only if 0-ary
                                        -- otherwise you must say (bar):
    foo bar 1           # foo(bar(1))   -- both subject to postdeclaration
                                        -- never taken as indirect object
    foo $bar: 1         # $bar.foo(1)   -- indirect object even if declared sub
                                        -- $bar considered one token
    foo (bar()):        # bar().foo(1)  -- even if foo declared sub
    foo bar():          # ILLEGAL       -- bar() is two tokens.
    foo .bar:           # foo(.bar:)    -- colon chooses .bar to listopify
    foo bar baz: 1      # foo(baz.bar(1)) -- colon controls &#34;bar&#34;, not foo.
    foo (bar baz): 1    # bar(baz()).foo(1) -- colon controls &#34;foo&#34;
    $foo $bar           # ILLEGAL       -- two terms in a row
    $foo $bar:          # ILLEGAL       -- use $bar.$foo for indirection
    (foo bar) baz: 1    # ILLEGAL       -- use $baz.$(foo bar) for indirection</pre>

<p>The indirect object colon only ever dominates a simple term, where &#34;simple&#34; includes classes and variables and parenthesized expressions, but explicitly not method calls, because the colon will bind to a trailing method call in preference. An indirect object that parses as more than one token must be placed in parentheses, followed by the colon.</p>

<p>In short, only an identifier followed by a simple term followed by a postfix colon is <code>ever</code> parsed as an indirect object, but that form will <code>always</code> be parsed as an indirect object regardless of whether the identifier is otherwise declared.</p>
</li>

<li>There&#39;s also no &#34;<code>use strict &#39;refs&#39;</code>&#34; because symbolic dereferences are now syntactically distinguished from hard dereferences. <code>@($arrayref)</code> must now provide an actual array object, while <code>@::($string)</code> is explicitly a symbolic reference. (Yes, this may give fits to the P5-to-P6 translator, but I think it&#39;s worth it to separate the concepts. Perhaps the symbolic ref form will admit real objects in a pinch.)</li>

<li>There is no hash subscript autoquoting in Perl 6. Use <code>%x&#60;foo&#62;</code> for constant hash subscripts, or the old standby <code>%x{&#39;foo&#39;}</code>. (It also works to say <code>%x&#171;foo&#187;</code> as long as you realized it&#39;s subject to interpolation.)
<p>But <code>=&#62;</code> still autoquotes any bare identifier to its immediate left (horizontal whitespace allowed but not comments). The identifier is not subject to keyword or even macro interpretation. If you say</p>

<pre>    $x = do {
        call_something();
        if =&#62; 1;
    }</pre>

<p>then <code>$x</code> ends up containing the pair <code>(&#34;if&#34; =&#62; 1)</code>. Always. (Unlike in Perl 5, where version numbers didn&#39;t autoquote.)</p>

<p>You can also use the :key($value) form to quote the keys of option pairs. To align values of option pairs, you may use the &#34;long dot&#34; postfix forms:</p>

<pre>    :longkey\  .($value)
    :shortkey\ .&#60;string&#62;
    :fookey\   .{ $^a &#60;=&#62; $^b }</pre>

<p>These will be interpreted as</p>

<pre>    :longkey($value)
    :shortkey&#60;string&#62;
    :fookey{ $^a &#60;=&#62; $^b }</pre>
</li>

<li>The double-underscore forms are going away:
<pre>    Old                 New
    ---                 ---
    __LINE__            $?LINE
    __FILE__            $?FILE
    __PACKAGE__         $?PACKAGE
    __END__             =begin END
    __DATA__            =begin DATA</pre>

<p>The <code>=begin END</code> pod stream is special in that it assumes there&#39;s no corresponding <code>=end END</code> before end of file. The <code>DATA</code> stream is no longer special--any POD stream in the current file can be accessed via a filehandle, named as <code>%=POD{&#39;DATA&#39;}</code> and such. Alternately, you can treat a pod stream as a scalar via <code>$=DATA</code> or as an array via <code>@=DATA</code>. Presumably a module could read all its COMMENT blocks from <code>@=COMMENT</code>, for instance. Each chunk of pod comes as a separate array element. You have to split it into lines yourself. Each chunk has a <code>.linenum</code> property that indicates its starting line within the source file.</p>

<p>The lexical routine itself is <code>&#38;?ROUTINE</code>; you can get its name with <code>&#38;ROUTINE.name</code>. The current block is <code>&#38;?BLOCK</code>. If the block has a label, that shows up in <code>&#38;?BLOCK.label</code>.</p>
</li>

<li>Heredocs are no longer written with <code>&#60;&#60;</code>, but with an adverb on any other quote construct:
<pre>    print qq:to/END/;
        Give $amount to the man behind curtain number $curtain.
        END</pre>

<p>Other adverbs are also allowed, as are multiple heredocs within the same expression:</p>

<pre>    print q:c:to/END/, q:to/END/;
        Give $100 to the man behind curtain number {$curtain}.
        END
        Here is a $non-interpolated string
        END</pre>
</li>

<li>Here docs allow optional whitespace both before and after terminating delimiter. Leading whitespace equivalent to the indentation of the delimiter will be removed from all preceding lines. If a line is deemed to have less whitespace than the terminator, only whitespace is removed, and a warning may be issued. (Hard tabs will be assumed to be 8 spaces, but as long as tabs and spaces are used consistently that doesn&#39;t matter.) A null terminating delimiter terminates on the next line consisting only of whitespace, but such a terminator will be assumed to have no indentation. (That is, it&#39;s assumed to match at the beginning of any whitespace.)</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Context"
>Context</a></h1>

<ul>
<li>Perl still has the three main contexts: void, scalar, and list.</li>

<li>In addition to undifferentiated scalars, we also have these scalar contexts:
<pre>    Context     Type    OOtype  Operator
    -------     ----    ------  --------
    boolean     bit     Bit     ?</pre>

<a name="msg_14"></a>
<a href="?hide_quotes=no#msg_14" onclick="return tog_quote(14);">
<div ID="header_shown_14" style="display: none;">
- Hide the snippet from t/syntax/force_context.t (line 54 ~ line 74) -
</div>
<div ID="header_hidden_14" style="display: block;">
- Show the snippet from t/syntax/force_context.t (line 54 ~ line 74, 21 lines) -
</div>
</a>
<div ID="hide_14" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S02/Context/boolean &quot;?&quot;&gt;
# L&lt;S03/Changes to Perl 5 operators/&quot;?&quot; imposes boolean context&gt;
# boolean context
{
    my $a = '';
    is(ref(?$a), 'Bool', 'it is forced into a Bool');
    ok(!(?$a), 'it is forced into boolean context');

    my $b = 'This will be true';
    is(ref(?$b), 'Bool', 'it is forced into a Bool');
    ok(?$b, 'it is forced into boolean context');

    my $c = 0;
    is(ref(?$c), 'Bool', 'it is forced into a Bool');
    ok(!(?$c), 'it is forced into boolean context');

    my $d = 1;
    is(ref(?$d), 'Bool', 'it is forced into a Bool');
    ok(?$d, 'it is forced into boolean context');
}</pre>
</div>


<pre>    integer     int     Int     int
    numeric     num     Num     +</pre>

<a name="msg_16"></a>
<a href="?hide_quotes=no#msg_16" onclick="return tog_quote(16);">
<div ID="header_shown_16" style="display: none;">
- Hide the snippet from t/syntax/force_context.t (line 13 ~ line 24) -
</div>
<div ID="header_hidden_16" style="display: block;">
- Show the snippet from t/syntax/force_context.t (line 13 ~ line 24, 12 lines) -
</div>
</a>
<div ID="hide_16" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S02/Context/numeric &quot;+&quot;&gt;
# numeric (+) context
{
    my $a = '2 is my favorite number';
    is(ref(+$a), 'Num', 'it is forced into a Num');
    is(+$a, 2, 'forced into numeric context');

    my $b = 'Did you know that, 2 is my favorite number';
    is(ref(+$b), 'Num', 'it is forced into a Num');
    is(+$b, 0, 'non numbers forced into numeric context are 0');
}</pre>
</div>


<pre>    string      buf     Str     ~</pre>

<a name="msg_15"></a>
<a href="?hide_quotes=no#msg_15" onclick="return tog_quote(15);">
<div ID="header_shown_15" style="display: none;">
- Hide the snippet from t/syntax/force_context.t (line 37 ~ line 53) -
</div>
<div ID="header_hidden_15" style="display: block;">
- Show the snippet from t/syntax/force_context.t (line 37 ~ line 53, 17 lines) -
</div>
</a>
<div ID="hide_15" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S02/Context/string &quot;~&quot;&gt;
# L&lt;S03/Changes to Perl 5 operators/Unary ~ string context&gt;
# string context
{
    my $a = 10.500000;
    is(ref(~$a), 'Str', 'it is forced into a Str');
    is(~$a, '10.5', 'forced into string context');

    my $b = -100;
    is(ref(~$b), 'Str', 'it is forced into a Str');
    is(~$b, '-100', 'forced into string context');

    my $c = -100.1010;
    is(ref(~$c), 'Str', 'it is forced into a Str');
    is(~$c, '-100.101', 'forced into string context');
}</pre>
</div>


<p>There are also various container contexts that require particular kinds of containers.</p>
</li>

<li>Unlike in Perl 5, objects are no longer always considered true. It depends on the state of their <code>.bit</code> property. Classes get to decide which of their values are true and which are false. Individual objects can override the class definition:
<a name="msg_17"></a>
<a href="?hide_quotes=no#msg_17" onclick="return tog_quote(17);">
<div ID="header_shown_17" style="display: none;">
- Hide the snippet from t/oo/syntax-but.t (line 62 ~ line 71) -
</div>
<div ID="header_hidden_17" style="display: block;">
- Show the snippet from t/oo/syntax-but.t (line 62 ~ line 71, 10 lines) -
</div>
</a>
<div ID="hide_17" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S02/Context/&quot;can override the class definition:&quot;&gt;
my $true_zero;
ok((eval '$true_zero = 0 but True; 1'), &quot;0 but True syntax evaluates&quot;);
ok ($true_zero == 0), &quot;0 but True is numerically equal to 0&quot;;
ok ?($true_zero), &quot;0 but True is true&quot;;
# TimToady++ says I can test False as well
my $false_positive;
ok(eval('$false_positive = 3 but False; 1'), &quot;3 but False syntax evaluates&quot;);
ok ($false_positive == 3), &quot;3 but False is numerically equal to 3&quot;;
ok !($false_positive), &quot;3 but False is false&quot;;</pre>
</div>


<pre>    return 0 but True;</pre>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Lists"
>Lists</a></h1>

<ul>
<li>List context in Perl 6 is by default lazy. This means a list can contain infinite generators without blowing up. No flattening happens to a lazy list until it is bound to the signature of a function or method at call time (and maybe not even then). We say that such an argument list is &#34;lazily flattened&#34;, meaning that we promise to flatten the list on demand, but not before.</li>

<li>There is a &#34;<code>list</code>&#34; operator which imposes a list context on its arguments even if <code>list</code> itself occurs in a scalar context. In list context, it flattens lazily. In a scalar context, it returns the resulting list as a single <code>List</code> object. (So the <code>list</code> operator really does exactly the same thing as putting a list in parentheses with at least one comma. But it&#39;s more readable in some situations.)</li>

<li>The <code>[,]</code> list operator may be used to force list context on its argument and <i>also</i> defeat any scalar argument checking imposed by subroutine signature declarations. This list flattens lazily.</li>

<li>To force non-lazy list flattening, use the <code>eager</code> list operator. Don&#39;t use it on an infinite generator unless you have a machine with infinite memory, and are willing to wait a long time. It may also be applied to a scalar iterator to force immediate iteration to completion.</li>

<li>Signatures on non-multi subs can be checked at compile time, whereas multi sub and method call signatures can only be checked at run time (in the absence of special instructions to the optimizer).
<p>This is not a problem for arguments that are arrays or hashes, since they don&#39;t have to care about their context, but just return themselves in any event, which may or may not be lazily flattened.</p>

<p>However, function calls in the argument list can&#39;t know their eventual context because the method hasn&#39;t been dispatched yet, so we don&#39;t know which signature to check against. As in Perl 5, list context is assumed unless you explicitly qualify the argument with a scalar context operator.</p>
</li>

<li>The <code>=&#62;</code> operator now constructs <code>Pair</code> objects rather than merely functioning as a comma. Both sides are in scalar context.</li>

<li>The <code>..</code> operator now constructs <code>Range</code> objects rather than merely functioning as an operator. Both sides are in scalar context.</li>

<li>There is no such thing as a hash list context. Assignment to a hash produces an ordinary list context. You may assign alternating keys and values just as in Perl 5. You may also assign lists of <code>Pair</code> objects, in which case each pair provides a key and a value. You may, in fact, mix the two forms, as long as the pairs come when a key is expected. If you wish to supply a <code>Pair</code> as a key, you must compose an outer <code>Pair</code> in which the key is the inner <code>Pair</code>:
<pre>    %hash = (($keykey =&#62; $keyval) =&#62; $value);</pre>
</li>

<li>The anonymous <code>enum</code> function takes a list of keys or pairs, and adds values to any keys that are not already part of a key. The value added is one more than the previous key or pair&#39;s value. This works nicely with the new <code>qq:ww</code> form:
<pre>    %hash = enum &#60;&#60;:Mon(1) Tue Wed Thu Fri Sat Sun&#62;&#62;;
    %hash = enum &#171; :Mon(1) Tue Wed Thu Fri Sat Sun &#187;;</pre>

<p>are the same as:</p>

<pre>    %hash = ();
    %hash&#60;Mon Tue Wed Thu Fri Sat Sun&#62; = 1..7;</pre>
</li>

<li>In contrast to assignment, binding to a hash requires a <code>Hash</code> (or <code>Pair</code>) object. Binding to a &#34;splat&#34; hash requires a list of pairs or hashes, and stops processing the argument list when it runs out of pairs or hashes. See S06 for much more about parameter binding.</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Files"
>Files</a></h1>

<ul>
<li>Filename globs are no longer done with angle brackets. Use the <code>glob</code> function.</li>

<li>Input from a filehandle is no longer done with angle brackets. Instead of
<pre>    while (&#60;HANDLE&#62;) {...}</pre>

<p>you now write</p>

<a name="msg_26"></a>
<a href="?hide_quotes=no#msg_26" onclick="return tog_quote(26);">
<div ID="header_shown_26" style="display: none;">
- Hide the snippet from t/builtins/io/io.t (line 53 ~ line 157) -
</div>
<div ID="header_hidden_26" style="display: block;">
- Show the snippet from t/builtins/io/io.t (line 53 ~ line 157, 105 lines) -
</div>
</a>
<div ID="hide_26" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S02/Files /you now write/&gt;
my $in3 = open($filename);
isa_ok($in3, 'IO');
my $line3a = =$in3;
is($line3a, &quot;Hello World&quot;, 'unary =$in worked');
my $line3b = =$in3;
is($line3b, &quot;Foo Bar Baz&quot;, 'unary =$in worked');
my $line3c = =$in3;
is($line3c, &quot;The End&quot;, 'unary =$in worked');
ok($in3.close, 'file closed okay (3)');

# append to the file

my $append = open($filename, :a);
isa_ok($append, 'IO');
$append.say(&quot;... Its not over yet!&quot;);
ok($append.close, 'file closed okay (append)');

# now read in in list context

my $in4 = open($filename);
isa_ok($in4, 'IO');
my @lines4 = readline($in4);
is(+@lines4, 4, 'we got four lines from the file');
is(@lines4[0], &quot;Hello World&quot;, 'readline($in) worked in list context');
is(@lines4[1], &quot;Foo Bar Baz&quot;, 'readline($in) worked in list context');
is(@lines4[2], &quot;The End&quot;, 'readline($in) worked in list context');
is(@lines4[3], &quot;... Its not over yet!&quot;, 'readline($in) worked in list context');
ok($in4.close, 'file closed okay (4)');

my $in5 = open($filename);
isa_ok($in5, 'IO');
my @lines5 = $in5.readline();
is(+@lines5, 4, 'we got four lines from the file');
is(@lines5[0], &quot;Hello World&quot;, '$in.readline() worked in list context');
is(@lines5[1], &quot;Foo Bar Baz&quot;, '$in.readline() worked in list context');
is(@lines5[2], &quot;The End&quot;, '$in.readline() worked in list context');
is(@lines5[3], &quot;... Its not over yet!&quot;, '$in.readline() worked in list context');
ok($in5.close, 'file closed okay (5)');

my $in6 = open($filename);
isa_ok($in6, 'IO');
my @lines6 = =$in6;
is(+@lines6, 4, 'we got four lines from the file');
is(@lines6[0], &quot;Hello World&quot;, 'unary =$in worked in list context');
is(@lines6[1], &quot;Foo Bar Baz&quot;, 'unary =$in worked in list context');
is(@lines6[2], &quot;The End&quot;, 'unary =$in worked in list context');
is(@lines6[3], &quot;... Its not over yet!&quot;, 'unary =$in worked in list context');
ok($in6.close, 'file closed okay (6)');

# test reading a file into an array and then closing before 
# doing anything with the array (in other words, is pugs too lazy)
my $in7 = open($filename);
isa_ok($in7, 'IO');
my @lines7 = readline($in7);
ok($in7.close, 'file closed okay (7)');
is(+@lines7, 4, 'we got four lines from the file (lazily)');
is(@lines7[0], &quot;Hello World&quot;, 'readline($in) worked in list context');
is(@lines7[1], &quot;Foo Bar Baz&quot;, 'readline($in) worked in list context');
is(@lines7[2], &quot;The End&quot;, 'readline($in) worked in list context');
is(@lines7[3], &quot;... Its not over yet!&quot;, 'readline($in) worked in list context');

#now be sure to delete the file as well

is(unlink($filename), 1, 'file has been removed');

# new file for testing other types of open() calls

my $out8 = open($filename, :w);
isa_ok($out8, 'IO');
$out8.say(&quot;Hello World&quot;);
ok($out8.close, 'file closed okay (out8)');

my $in8 = open($filename);
isa_ok($in8, 'IO');
my $line8_1 = readline($in8);
is($line8_1, &quot;Hello World&quot;, 'readline($in) worked');
ok($in8.close, 'file closed okay (in8)');

my $fh9 = open($filename, :r, :w);  # was &quot;&lt;+&quot; ? 
isa_ok($fh9, 'IO');
#my $line9_1 = readline($fh9);
#is($line9_1, &quot;Hello World&quot;);
#$fh9.say(&quot;Second line&quot;);
ok($fh9.close, 'file closed okay (9)');

#my $in9 = open($filename);
#isa_ok($in9, 'IO');
#my $line9_1 = readline($in9);
#my $line9_2 = readline($in9);
#is($line9_1, &quot;Hello World&quot;, 'readline($in) worked');
#is($line9_2, &quot;Second line&quot;, 'readline($in) worked');

my $fh10 = open($filename, :rw);  # was &quot;&lt;+&quot; ? 
isa_ok($fh10, 'IO');
#ok($fh10.close, 'file closed okay (10)');

# This test fails on win32; skip it for now.
if $*OS eq any &lt;MSWin32 mingw msys cygwin&gt; {
    unlink($filename);
    flunk('skip unlink() test - erratic behaviour on win32', :todo&lt;bug&gt;);
}
else {
    ok(unlink($filename), 'file has been removed');
}</pre>
</div>


<pre>    for =$handle {...}</pre>

<p>As a unary prefix operator, you may also apply adverbs to <code>=</code>:</p>

<pre>    for =$handle :prompt(&#39;$ &#39;) { say $_ + 1 }</pre>

<p>or</p>

<pre>    for =($handle):prompt(&#39;$ &#39;) { say $_ + 1 }</pre>

<p>or you may even write it in its functional form, passing the adverbs as ordinary named arguments.</p>

<pre>    for prefix:&#60;=&#62;($handle, :prompt(&#39;$ &#39;)) { say $_ + 1 }</pre>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Properties"
>Properties</a></h1>

<ul>
<li>Properties work as detailed in S12. They&#39;re actually object attributes provided by role mixins. Compile-time properties applied to containers and such still use the <code>is</code> keyword, but are now called &#34;traits&#34;. On the other hand, run-time properties are attached to individual objects using the <code>but</code> keyword instead, but are still called &#34;properties&#34;.</li>

<li>Properties are accessed just like attributes because they are in fact attributes of some class or other, even if it&#39;s an anonymous singleton class generated on the fly for that purpose. Since &#34;<code>rw</code>&#34; attributes behave in all respects as variables, properties may therefore also be temporized with <code>temp</code>, or hypotheticalized with <code>let</code>.</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Grammatical_Categories"
>Grammatical Categories</a></h1>

<p>Lexing in Perl 6 is controlled by a system of grammatical categories. At each point in the parse, the lexer knows which subset of the grammatical categories are possible at that point, and follows the longest-token rule across all the active grammatical categories. (Ordering of grammatical categories matters only in case of a &#34;tie&#34;, in which case the grammatical category that is notionally &#34;first&#34; in the grammar wins. For instance, a statement_control is always going to win out over a prefix operator of the same name. More specifically, you can&#39;t call a function named &#34;if&#34; directly because it would be hidden either by the statement_control category or the statement_modifier ca