<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
           "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>S04</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="http://dev.perl.org/css/perl.css">

<script type="text/javascript">
var agt = navigator.userAgent.toLowerCase();

var is_opera = (agt.indexOf("opera") != -1);
var is_ie = (agt.indexOf("msie") != -1) && document.all && !is_opera;
var is_ie5 = (agt.indexOf("msie 5") != -1) && document.all;

function tog() {
  // tog: toggle the visibility of html elements (arguments[1..]) from none to
  // arguments[0].  Return what should be returned in a javascript onevent().
  display = arguments[0];
  for( var i=1; i<arguments.length; i++ ) {
    var x = document.getElementById(arguments[i]);
    if (!x) continue;
    if (x.style.display == "none" || x.style.display == "") {
      x.style.display = display;
    } else {
      x.style.display = "none";
    }
  }

  var e = is_ie ? window.event : this;
  if (e) {
    if (is_ie) {
      e.cancelBubble = true;
      e.returnValue = false;
      return false;
    } else {
      return false;
    }
  }
}

function tog_quote( idnum ) {
  return tog( 'block', 'header_shown_' + idnum, 'header_hidden_' + idnum,
       'hide_' + idnum );
}

</script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.03,
  using Pod::Simple::PullParser v2.02,
  under Perl v5.008007 at Fri Aug 25 08:27:01 2006 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
            <I>This page was generated at 2006-08-25 08:27:01 GMT.
            (syn <strong>r11316</strong>, pugs <strong>r12678</strong>)</I>
        
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#The_Relationship_of_Blocks_and_Declarations'>The Relationship of Blocks and Declarations</a>
  <li class='indexItem indexItem1'><a href='#Statement-ending_blocks'>Statement-ending blocks</a>
  <li class='indexItem indexItem1'><a href='#Conditional_statements'>Conditional statements</a>
  <li class='indexItem indexItem1'><a href='#Loop_statements'>Loop statements</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#The_while_and_until_statements'>The while and until statements</a>
    <li class='indexItem indexItem2'><a href='#The_repeat_statement'>The repeat statement</a>
    <li class='indexItem indexItem2'><a href='#The_general_loop_statement'>The general loop statement</a>
    <li class='indexItem indexItem2'><a href='#The_for_statement'>The for statement</a>
    <li class='indexItem indexItem2'><a href='#The_do-once_loop'>The do-once loop</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Switch_statements'>Switch statements</a>
  <li class='indexItem indexItem1'><a href='#Exception_handlers'>Exception handlers</a>
  <li class='indexItem indexItem1'><a href='#Control_Exceptions'>Control Exceptions</a>
  <li class='indexItem indexItem1'><a href='#The_goto_statement'>The goto statement</a>
  <li class='indexItem indexItem1'><a href='#Exceptions'>Exceptions</a>
  <li class='indexItem indexItem1'><a href='#Closure_traits'>Closure traits</a>
  <li class='indexItem indexItem1'><a href='#Statement_parsing'>Statement parsing</a>
  <li class='indexItem indexItem1'><a href='#Definition_of_Success'>Definition of Success</a>
  <li class='indexItem indexItem1'><a href='#When_is_a_closure_not_a_closure'>When is a closure not a closure</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 4: Blocks and Statements</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Larry Wall &#60;larry@wall.org&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre>  Maintainer: Larry Wall &#60;larry@wall.org&#62;
  Date: 19 Aug 2004
  Last Modified: 18 Aug 2006
  Number: 4
  Version: 37</pre>

<p>This document summarizes Apocalypse 4, which covers the block and statement syntax of Perl.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="The_Relationship_of_Blocks_and_Declarations"
>The Relationship of Blocks and Declarations</a></h1>

<a name="msg_6"></a>
<a href="?hide_quotes=no#msg_6" onclick="return tog_quote(6);">
<div ID="header_shown_6" style="display: none;">
- Hide the snippet from t/data_types/anon_block.t (line 13 ~ line 104) -
</div>
<div ID="header_hidden_6" style="display: block;">
- Show the snippet from t/data_types/anon_block.t (line 13 ~ line 104, 92 lines) -
</div>
</a>
<div ID="hide_6" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S04/&quot;The Relationship of Blocks and Declarations&quot;&gt;

=cut

plan 32;

# anon blocks L&lt;S06/&quot;Standard Subroutines&quot;&gt;
my $anon_sub = sub { 1 };
isa_ok($anon_sub, 'Sub');
is($anon_sub(), 1, 'sub { } works');

my $anon_sub_w_arg = sub ($arg) { 1 + $arg };
isa_ok($anon_sub_w_arg, 'Sub');
is($anon_sub_w_arg(3), 4, 'sub ($arg) {} works');

# anon blocks L&lt;S06/&quot;Blocks&quot;&gt;
my $anon_block = { 1 };
isa_ok($anon_block, 'Block');
is($anon_block(), 1, '{} &lt;anon block&gt; works');

# pointy subs L&lt;S06/&quot;Pointy subs&quot;&gt;
my $pointy_block = -&gt; { 1 };
isa_ok($pointy_block, 'Block');
is($pointy_block(), 1, '-&gt; {} &lt;&quot;pointy&quot; block&gt; works');

my $pointy_block_w_arg = -&gt; $arg { 1 + $arg };
isa_ok($pointy_block_w_arg, 'Block');
is($pointy_block_w_arg(3), 4, '-&gt; $arg {} &lt;&quot;pointy&quot; block w/args&gt; works');

my $pointy_block_w_multiple_args = -&gt; $arg1, $arg2 { $arg1 + $arg2 };
isa_ok($pointy_block_w_multiple_args, 'Block');
is($pointy_block_w_multiple_args(3, 4), 7, '-&gt; $arg1, $arg2 {} &lt;&quot;pointy&quot; block w/multiple args&gt; works');

my $pointy_block_nested = -&gt; $a { -&gt; $b { $a + $b }};
isa_ok($pointy_block_nested, Block);
isa_ok($pointy_block_nested(5), Block);
is $pointy_block_nested(5)(6), 11, '-&gt; $a { -&gt; $b { $a+$b }} nested &lt;&quot;pointy&quot; block&gt; works';

# bare blocks L&lt;S06/&quot;Blocks&quot;&gt;

my $foo;
{$foo = &quot;blah&quot;};
is($foo, &quot;blah&quot;, &quot;lone block actually executes it's content&quot;);

my $foo2;
{$foo2 = &quot;blah&quot;};
is($foo2, &quot;blah&quot;, &quot;lone block w/out a semicolon actually executes it's content&quot;);

my $foo3;
({$foo3 = &quot;blah&quot;});
ok(!defined($foo3), &quot;block enclosed by parentheses should not auto-execute (1)&quot;, :todo&lt;bug&gt;);

my $foo4;
({$foo4 = &quot;blah&quot;},);
ok(!defined($foo4), &quot;block enclosed by parentheses should not auto-execute (2)&quot;);

my ($one, $two);
# The try's here because it should die: $foo{...} should only work if $foo isa
# Hash (or sth. which provides appropriate tieing/&amp;postcircumfix:&lt;{
# }&gt;/whatever, but a Code should surely not support hash access).
# Additionally, a smart compiler will detect thus errors at compile-time, so I
# added an eval().  --iblech
try { eval '{$one = 1}{$two = 2}' };
is($one, undef, 'two blocks ({} {}) no semicolon after either,.. first block does not execute');
is($two, 2, '... but second block does (parsed as hash subscript)');

my ($one_a, $two_a);
{$one_a = 1}; {$two_a = 2}
is($one_a, 1, '... two blocks ({}; {}) semicolon after the first only,.. first block does execute');
is($two_a, 2, '... and second block does too');

my ($one_b, $two_b);
{
    $one_b = 1
}
{
    $two_b = 2
};
is($one_b, 1, '... two stand-alone blocks ({\n...\n}\n{\n...\n}),.. first block does execute');
is($two_b, 2, '... and second block does too');

my ($one_c, $two_c);
{$one_c = 1}; {$two_c = 2};
is($one_c, 1, '... two blocks ({}; {};) semicolon after both,.. first block does execute');
is($two_c, 2, '... and second block does too');

sub f { { 3 } }
is(f(), 3, 'bare blocks immediately runs even as the last statement');
is((sub { { 3 } }).(), 3, 'ditto for anonymous subs');
is((sub { { { 3 } } }).(), 3, 'ditto, even if nested');
dies_ok({(sub { { $^x } }).()}, 'implicit params become errors');
isnt((sub { -&gt; { 3 } }).(), 3, 'as are pointies');</pre>
</div>


<a name="msg_1"></a>
<a href="?hide_quotes=no#msg_1" onclick="return tog_quote(1);">
<div ID="header_shown_1" style="display: none;">
- Hide the snippet from t/var/var.t (line 13 ~ line 134) -
</div>
<div ID="header_hidden_1" style="display: block;">
- Show the snippet from t/var/var.t (line 13 ~ line 134, 122 lines) -
</div>
</a>
<div ID="hide_1" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/&quot;The Relationship of Blocks and Declarations&quot;&gt;
ok eval('my $x; my $x; 1'),       'it is legal to declare $x twice in the same scope.';
ok eval('state $x; state $x; 1'), 'it is legal to declare $x twice in the same scope.';

# XXX -- dunno why test test fails, but the next outer test works. --iblech
{ my $a = 1; {
   my $a=2; {
      my $a=3;
      is($a, 3,               'get regular a'); 
      is($OUTER::a, 2,        'get $OUTER::a'); 
      is($OUTER::OUTER::a, 1, 'get $OUTER::OUTER::a');
}}}

{
  my $a = 1;
  is $a, 1, 'get regular $a (1)';

  {
    is $a, 1, 'get regular $a (2)';
    my $a = 2;
    is $a, 2, 'get new regular $a (1)';

    {
      is $a, 2, 'get new regular $a (2)';
      my $a = 3;

      is $a,               3, 'get very new regular $a';
      is $OUTER::a,        2, 'get $OUTER::a';
      is $OUTER::OUTER::a, 1, 'get $OUTER::OUTER::a';
    }
  }
}

{
  my $a = 3;
  my $sub = { $a++ };

  {
    my $a = -10;
    is $a, -10,   'get regular $a';
    is $sub(), 3, 'get hidden $a (1)';
    is $sub(), 4, 'get hidden $a (2)';
    is $sub(), 5, 'get hidden $a (3)';
  }
}

{
  my $sub = -&gt; $stop {
    my $x = 3;
    if $stop {
      $x++;
    } else {
      $sub(1);
      $x;
    }
  };

  is $sub(0), 3,
    &quot;recursively called subref shouldn't stomp on the lexical vars of other instances&quot;;
}

{
  sub stomptest ($stop) {
    my $x = 3;
    if $stop {
      $x++;
    } else {
      stomptest 1;
      $x;
    }
  };

  is stomptest(0), 3,
    &quot;recursively called sub shouldn't stomp on the lexical vars of other instances&quot;;
}

{
  is foo(), 0, &quot;get variable not yet declared using a sub (1)&quot;;
  is foo(), 1, &quot;get variable not yet declared using a sub (2)&quot;;
  is foo(), 2, &quot;get variable not yet declared using a sub (3)&quot;;

  my $a;
  sub foo { $a++ }
}

{
  is bar(), 0, &quot;runtime part of my not yet executed (1)&quot;;
  is bar(), 1, &quot;runtime part of my not yet executed (2)&quot;;
  is bar(), 2, &quot;runtime part of my not yet executed (3)&quot;;

  my $a = 3;
  sub bar { $a++ }
}

{
  is baz(), 3, &quot;runtime part of my not yet executed (1)&quot;;
  is baz(), 4, &quot;runtime part of my not yet executed (2)&quot;;
  is baz(), 5, &quot;runtime part of my not yet executed (3)&quot;;

  my $a; BEGIN { $a = 3 };
  sub baz { $a++ }
}

{
  {
    my $a = 3;
    sub grtz { $a++ }
  }

  is grtz(), 3, &quot;get real hidden var using a sub (1)&quot;;
  is grtz(), 4, &quot;get real hidden var using a sub (1)&quot;;
  is grtz(), 5, &quot;get real hidden var using a sub (1)&quot;;
}

{
  my $a;
  sub rmbl { $a++ }

  is rmbl(), 0, &quot;var captured by sub is the right var (1)&quot;;
  $a++;
  is rmbl(), 2, &quot;var captured by sub is the right var (2)&quot;;
}</pre>
</div>


<p>Every block is a closure. (That is, in the abstract, they&#39;re all anonymous subroutines that take a snapshot of their lexical scope.) How a block is invoked and how its results are used are matters of context, but closures all work the same on the inside.</p>

<p>Blocks are delimited by curlies, or by the beginning and end of the current compilation unit (either the current file or the current <code>eval</code> string). Unlike in Perl 5, there are (by policy) no implicit blocks around standard control structures. (You could write a macro that violates this, but resist the urge.) Variables that mediate between an outer statement and an inner block (such as loop variables) should generally be declared as formal parameters to that block. There are three ways to declare formal parameters to a closure.</p>

<pre>    $func = sub ($a, $b) { print if $a eq $b };  # standard sub declaration
    $func = -&#62; $a, $b { print if $a eq $b };     # a &#34;pointy&#34; block
    $func = { print if $^a eq $^b }              # placeholder arguments</pre>

<p>A bare closure without placeholder arguments that uses <code>$_</code> (either explicitly or implicitly) is treated as though <code>$_</code> were a formal parameter:</p>

<pre>    $func = { print if $_ };   # Same as: $func = -&#62; $_ { print if $_ };
    $func(&#34;printme&#34;);</pre>

<p>In any case, all formal parameters are the equivalent of <code>my</code> variables within the block. See S06 for more on function parameters.</p>

<p>Except for such formal parameter declarations, all lexically scoped declarations are visible from the point of declaration to the end of the enclosing block. Period. Lexicals may not &#34;leak&#34; from a block to any other external scope (at least, not without some explicit aliasing action on the part of the block, such as exportation of a symbol from a module). The &#34;point of declaration&#34; is the moment the compiler sees &#34;<code>my $foo</code>&#34;, not the end of the statement as in Perl 5, so</p>

<pre>    my $x = $x;</pre>

<p>will no longer see the value of the outer <code>$x</code>; you&#39;ll need to say either</p>

<pre>    my $x = $OUTER::x;</pre>

<p>or</p>

<pre>    my $x = OUTER::&#60;$x&#62;;</pre>

<p>instead.</p>

<p>If you declare a lexical twice in the same scope, it is the same lexical:</p>

<pre>    my $x;
    my $x;</pre>

<p>If you&#39;ve referred to <code>$x</code> prior to the first declaration, and the compiler tentatively bound it to <code>$OUTER::x</code>, then it&#39;s an error to declare it, and the compiler is required to complain at that point. If such use can&#39;t be detected because it is hidden in an eval, then it is erroneous, since the <code>eval()</code> compiler might bind to either <code>$OUTER::x</code> or the subsequently declared &#34;<code>my $x</code>&#34;.</p>

<a name="msg_7"></a>
<a href="?hide_quotes=no#msg_7" onclick="return tog_quote(7);">
<div ID="header_shown_7" style="display: none;">
- Hide the snippet from t/builtins/my.t (line 29 ~ line 99) -
</div>
<div ID="header_hidden_7" style="display: block;">
- Show the snippet from t/builtins/my.t (line 29 ~ line 99, 71 lines) -
</div>
</a>
<div ID="hide_7" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/&quot;The Relationship of Blocks and Declarations&quot; /prior to the first declaration/&gt;
# &quot;If you've referred to $x prior to the first declaration, and the
#  compiler tentatively bound it to $OUTER::x, then it's an error to
#  declare it, and the compiler is allowed to complain at that point.&quot;
# A fully conformant compiler will fail this test.  At best,
#   is($d, 1, '$d is still the outer $d');
# passes &quot;tentatively&quot;, and the subsequent my is an uncomplained error.

# shadowing a lexical with a new lexical of the same name
# and that lexical does not leak out into the outer scope

my $d = 1;
if (1) { # create a new lexical scope
    is($d, 1, '$d is still the outer $d');
    my $d = 2;
    is($d, 2, '$d is now the lexical (inner) $d');    
}
is($d, 1, '$d is available, and the outer value has not changed');

# check closures with functions

my $func;
my $func2;
if (1) { # create a new lexical scope
    my $e = 0;
    $func = sub { $e++ }; # one to inc
    $func2 = sub { $e };  # one to access it
}

ok(!(eval '$e'), '$e is the not available in this scope');
is($func2(), 0, '$func2() just returns the $e lexical which is held by the closure');
$func();
is($func2(), 1, '$func() increments the $e lexical which is held by the closure');
$func();
is($func2(), 2, '... and one more time just to be sure');

# check my as simultaneous lvalue and rvalue

is(eval('my $e1 = my $e2 = 42'), 42, 'can parse squinting my value');
is(eval('my $e1 = my $e2 = 42; $e1'), 42, 'can capture squinting my value');
is(eval('my $e1 = my $e2 = 42; $e2'), 42, 'can set squinting my variable');

is(eval('my $x = 1, my $y = 2; $y'), 2, 'precedence of my wrt = and ,');

# check proper scoping of my in while condition

my $result;
my $x = 0;
is(eval('while my $x = 1 { $result = $x; last } $result'), 1, 'my in while cond seen from body');
is(eval('while my $x = 1 { last } $x'), 1, 'my in while cond seen after');

# check proper scoping of my in if condition

is(eval('if my $x = 1 { $x } else { 0 }'), 1, 'my in if cond seen from then');
is(eval('if not my $x = 1 { 0 } else { $x }'), 1, 'my in if cond seen from else');
is(eval('if my $x = 1 { 0 } else { 0 } $x'), 1, 'my in if cond seen after');

# check proper scoping of my in loop initializer

is(eval('loop (my $x = 1, my $y = 2; $x &gt; 0; $x--) { $result = $x; last } $result'), 1, '1st my in loop cond seen from body');
is(eval('loop (my $x = 1, my $y = 2; $x &gt; 0; $x--) { $result = $y; last } $result'), 2, '2nd my in loop cond seen from body');
is(eval('loop (my $x = 1, my $y = 2; $x &gt; 0; $x--) { last } $x'), 1, '1st my in loop cond seen after');
is(eval('loop (my $x = 1, my $y = 2; $x &gt; 0; $x--) { last } $y'), 2, '2nd my in loop cond seen after');

# check that can declaring lexical twice is noop
{
    my $f;
    $f = 5;
    my $f;
    is($f, 5, &quot;two lexicals declared in scope is noop&quot;);
}</pre>
</div>


<p>As in Perl 5, &#34;<code>our $foo</code>&#34; introduces a lexically scoped alias for a variable in the current package.</p>

<p>The new <code>constant</code> declarator introduces a lexically scoped name for a compile-time constant, either a variable or a 0-ary sub, which may be initialized with either a pseudo-assignment or a block:</p>

<pre>    constant Num $pi = 3;
    constant Num PI { 3 }
    constant Num &#960;  = atan(2,2) * 4;</pre>

<p>In any case the initializing value is evaluated at BEGIN time.</p>

<a name="msg_5"></a>
<a href="?hide_quotes=no#msg_5" onclick="return tog_quote(5);">
<div ID="header_shown_5" style="display: none;">
- Hide the snippet from t/var/constant.t (line 181 ~ line 193) -
</div>
<div ID="header_hidden_5" style="display: block;">
- Show the snippet from t/var/constant.t (line 181 ~ line 193, 13 lines) -
</div>
</a>
<div ID="hide_5" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/&quot;The Relationship of Blocks and Declarations&quot; /In any case the initializing value is evaluated at BEGIN time./&gt;
{
    my $ok;

    eval '
        my $foo = 42;
        BEGIN { $foo = 23 }
        my constant timecheck = $foo;
        $ok++ if timecheck == 23;
    ';

    ok $ok, &quot;the initializing values for constants are evaluated at compile-time&quot;, :todo&lt;feature&gt;;
}</pre>
</div>


<p>There is a new <code>state</code> declarator that introduces a lexically scoped variable like <code>my</code> does, but with a lifetime that persists for the life of the closure, so that it keeps its value from the end of one call to the beginning of the next. Separate clones of the closure get separate state variables.</p>

<a name="msg_3"></a>
<a href="?hide_quotes=no#msg_3" onclick="return tog_quote(3);">
<div ID="header_shown_3" style="display: none;">
- Hide the snippet from t/var/state.t (line 7 ~ line 158) -
</div>
<div ID="header_hidden_3" style="display: block;">
- Show the snippet from t/var/state.t (line 7 ~ line 158, 152 lines) -
</div>
</a>
<div ID="hide_3" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/&quot;The Relationship of Blocks and Declarations&quot; /There is a new state declarator that introduces/&gt;

# state() inside subs
{
    sub inc () {
        state $svar;
        $svar++;
        return $svar;
    };

    is(inc(), 1, &quot;state() works inside subs (#1)&quot;);
    is(inc(), 2, &quot;state() works inside subs (#2)&quot;);
    is(inc(), 3, &quot;state() works inside subs (#3)&quot;);
}

# state() inside coderefs
{
    my $gen = {
        # Note: The following line is only executed once, because it's equivalent
        # to
        #   state $svar will first { 42 };
        # See L&lt;S04/&quot;Closure traits&quot; /emantics to any initializer, so this also works/&gt;
        state $svar = 42;
        my $ret = { $svar++ };
    };

    my $a = $gen(); # $svar == 42
    $a(); $a();     # $svar == 44
    my $b = $gen(); # $svar == 44

    is $b(), 44, &quot;state() works inside coderefs&quot;;
}

# state() inside for-loops
{
    for 1,2,3 -&gt; $val {
        state $svar;
        $svar++;

        # Only check on last run
        if $val == 3 {
            is $svar, 3, &quot;state() works inside for-loops&quot;;
        }
    }
}

# state will first {...}
{
    my ($a, $b);
    eval '
        my $gen = {
            state $svar will first { 42 };
            -&gt; { $svar++ };
        }
        $a = $gen();    # $svar == 42
        $a(); $a();     # $svar == 44
        $b = $gen()();  # $svar == 44
    ';

    is $b, 44, 'state will first {...} works', :todo&lt;feature&gt;;
}

# Return of a reference to a state() var
{
    my $gen = {
        state $svar = 42;
        \$svar;
    };

    my $svar_ref = $gen();
    $$svar_ref++; $$svar_ref++;

    my $svar_ref = $gen();
    is $$svar_ref, 44, &quot;reference to a state() var&quot;, :todo&lt;bug&gt;;
}

# Anonymous state vars
# L&lt;&quot;http://groups.google.de/group/perl.perl6.language/msg/07aefb88f5fc8429&quot;&gt;
{
    # XXX -- currently this is parsed as \&amp;state()
    my $gen = eval '{ try { \state } }';
    $gen //= sub { \(my $x) };

    my $svar_ref = $gen();               # $svar == 0
    try { $$svar_ref++; $$svar_ref++ };  # $svar == 2

    my $svar_ref = $gen();               # $svar == 2
    is try { $$svar_ref }, 2, &quot;anonymous state() vars&quot;, :todo&lt;feature&gt;;
}

# L&lt;&quot;http://www.nntp.perl.org/group/perl.perl6.language/20888&quot;&gt;
# (&quot;Re: Declaration and definition of state() vars&quot; from Larry)
{
    my ($a, $b);
    eval '
        my $gen = {
            (state $svar) = 42;
            my $ret = { $svar++ };
        };

        $a = $gen();        # $svar == 42
        $a(); $a();         # $svar == 44
        $b = $gen()();      # $svar == 42
    ';
    is $b, 42, &quot;state() and parens&quot;; # svar == 43
}

# state() inside regular expressions
{
    my $str = &quot;abc&quot;;

    my $re  = {
    # Perl 5 RE, as we don't want to force people to install Parrot ATM. (The
    # test passes when using the Perl 6 RE, too.)
    $str ~~ s:Perl5/^(.)/{
      state $svar;
      ++$svar;
    }/;
    };
    $re();
    $re();
    $re();
    is +$str, 3, &quot;state() inside regular expressions works&quot;;
}

# state() inside subs, chained declaration
{
    sub step () {
        state $svar = state $svar2 = 42;
        try {
            $svar++;
            $svar2--;
            return ($svar, $svar2);
        }
    };

    is(step().perl, &quot;(43, 41)&quot;, &quot;chained state (#1)&quot;, :todo&lt;bug&gt;);
    is(step().perl, &quot;(44, 40)&quot;, &quot;chained state (#2)&quot;, :todo&lt;bug&gt;);
}

# state in cloned closures
{
    for &lt;first second&gt; {
        my $code = {
            state $foo = 42;
            ++$foo;
        };

        is $code(), 43, &quot;state was initialized properly ($_ time)&quot;;
        is $code(), 44, &quot;state keeps its value across calls ($_ time)&quot;;
    }
}</pre>
</div>


<p>Perl 5&#39;s &#34;<code>local</code>&#34; function has been renamed to <code>temp</code> to better reflect what it does. There is also a <code>let</code> function that sets a hypothetical value. It works exactly like <code>temp</code>, except that the value will be restored only if the current block exits unsuccessfully. (See Definition of Success below for more.) <code>temp</code> and <code>let</code> temporize or hypotheticalize the value or the variable depending on whether you do assignment or binding. One other difference from Perl 5 is that the default is not to undefine a variable. So</p>

<a name="msg_4"></a>
<a href="?hide_quotes=no#msg_4" onclick="return tog_quote(4);">
<div ID="header_shown_4" style="display: none;">
- Hide the snippet from t/var/let.t (line 7 ~ line 70) -
</div>
<div ID="header_hidden_4" style="display: block;">
- Show the snippet from t/var/let.t (line 7 ~ line 70, 64 lines) -
</div>
</a>
<div ID="hide_4" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/&quot;The Relationship of Blocks and Declarations&quot; /There is also a let function/&gt;
# L&lt;S04/&quot;Definition of Success&quot;&gt;
# let() should not restore the variable if the block exited successfully
# (returned a true value).
{
  my $a = 42;
  {
    let $a = 23;
    is $a, 23, &quot;let() changed the variable (1)&quot;;
    1;
  }
  is $a, 23, &quot;let() should not restore the variable, as our block exited succesfully (1)&quot;, :todo&lt;feature&gt;;
}

# let() should restore the variable if the block failed (returned a false
# value).
{
  my $a = 42;
  {
    let $a = 23;
    is $a, 23, &quot;let() changed the variable (1)&quot;;
    0;
  }
  is $a, 42, &quot;let() should restore the variable, as our block failed&quot;;
}

# Test that let() restores the variable at scope exit, not at subroutine
# entry.  (This might be a possibly bug.)
{
  my $a     = 42;
  my $get_a = { $a };
  {
    let $a = 23;
    is $a,       23, &quot;let() changed the variable (2-1)&quot;;
    is $get_a(), 23, &quot;let() changed the variable (2-2)&quot;, :todo&lt;feature&gt;;
    1;
  }
  is $a, 23, &quot;let() should not restore the variable, as our block exited succesfully (2)&quot;, :todo&lt;feature&gt;;
}

# Test that let() restores variable even when not exited regularly (using a
# (possibly implicit) call to return()), but when left because of an exception.
{
  my $a = 42;
  try {
    let $a = 23;
    is $a, 23, &quot;let() changed the variable in a try block&quot;;
    die 57;
  };
  is $a, 42, &quot;let() restored the variable, the block was exited using an exception&quot;;
}

eval('
{
  my @array = (0, 1, 2);
  {
    let @array[1] = 42;
    is @array[1], 42, &quot;let() changed our array element&quot;;
    0;
  }
  is @array[1], 1, &quot;let() restored our array element&quot;;
}
&quot;1 - delete this line when the parsefail eval() is removed&quot;;
') or skip(2, &quot;parsefail: let \@array[1]&quot;);</pre>
</div>


<a name="msg_2"></a>
<a href="?hide_quotes=no#msg_2" onclick="return tog_quote(2);">
<div ID="header_shown_2" style="display: none;">
- Hide the snippet from t/var/temp.t (line 7 ~ line 107) -
</div>
<div ID="header_hidden_2" style="display: block;">
- Show the snippet from t/var/temp.t (line 7 ~ line 107, 101 lines) -
</div>
</a>
<div ID="hide_2" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/&quot;The Relationship of Blocks and Declarations&quot; /function has been renamed/&gt;
{
  my $a = 42;
  {
    temp $a = 23;
    is $a, 23, &quot;temp() changed the variable (1)&quot;;
  }
  is $a, 42, &quot;temp() restored the variable (1)&quot;;
}

# Test that temp() restores the variable at scope exit, not at subroutine
# entry.
{
  my $a     = 42;
  my $get_a = { $a };
  {
    temp $a = 23;
    is $a,       23, &quot;temp() changed the variable (2-1)&quot;;
    is $get_a(), 23, &quot;temp() changed the variable (2-2)&quot;;
  }
  is $a, 42, &quot;temp() restored the variable (2)&quot;;
}

# temp() shouldn't change the variable containers
{
  my $a     = 42;
  my $get_a = { $a };
  {
    temp $a = 23;
    ok $a =:= $get_a(), &quot;temp() shouldn't change the variable containers&quot;;
  }
}

{
  our $pkgvar = 42;
  {
    temp $pkgvar = 'not 42';
    is $pkgvar, 'not 42', &quot;temp() changed the package variable (3-1)&quot;;
  }
  is $pkgvar, 42, &quot;temp() restored the package variable (3-2)&quot;;
}

# Test that temp() restores variable even when not exited regularly (using a
# (possibly implicit) call to return()), but when left because of an exception.
{
  my $a = 42;
  try {
    temp $a = 23;
    is $a, 23, &quot;temp() changed the variable in a try block&quot;;
    die 57;
  };
  is $a, 42, &quot;temp() restored the variable, the block was exited using an exception&quot;;
}

eval('
{
  my @array = (0, 1, 2);
  {
    temp @array[1] = 42;
    is @array[1], 42, &quot;temp() changed our array element&quot;;
  }
  is @array[1], 1, &quot;temp() restored our array element&quot;;
}
&quot;1 - delete this line when the parsefail eval() is removed&quot;;
') or skip(2, &quot;parsefail: temp \@array[1]&quot;);

eval('
{
  my %hash = (:a(1), :b(2), :c(3));
  {
    temp %hash&lt;b&gt; = 42;
    is %hash&lt;b&gt;, 42, &quot;temp() changed our hash element&quot;;
  }
  is %hash&lt;b&gt;, 2, &quot;temp() restored our array element&quot;;
}
&quot;1 - delete this line when the parsefail eval() is removed&quot;;
') or skip(2, &quot;parsefail: temp \%hash&lt;b&gt;&quot;);

eval('
{
  my $struct = [
    &quot;doesnt_matter&quot;,
    {
      doesnt_matter =&gt; &quot;doesnt_matter&quot;,
      key           =&gt; [
        &quot;doesnt_matter&quot;,
        42,
      ],
    },
  ];

  {
    temp $struct[1]&lt;key&gt;[1] = 23;
    is $struct[1]&lt;key&gt;[1], 23, &quot;temp() changed our nested arrayref/hashref element&quot;;
  }
  is $struct[1]&lt;key&gt;[1], 1, &quot;temp() restored our nested arrayref/hashref element&quot;, :todo&lt;feature&gt;;
}
&quot;1 - delete this line when the parsefail eval() is removed&quot;;
') or skip(2, &quot;parsefail: temp \$struct[1]&lt;key&gt;[1]&quot;);

# Block TEMP{}</pre>
</div>


<pre>    temp $x;</pre>

<p>causes <code>$x</code> to start with its current value. Use</p>

<pre>    temp undefine $x;</pre>

<p>to get the Perl 5 behavior.</p>

<p>Note that temporizations that are undone upon scope exit must be prepared to be redone if a continuation within that scope is taken.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Statement-ending_blocks"
>Statement-ending blocks</a></h1>

<p>A line ending with a closing brace &#34;<code>}</code>&#34;, followed by nothing but whitespace or comments, will terminate a statement if an end of statement can occur there. That is, these two statements are equivalent:</p>

<pre>    my $x = sub { 3 }
    my $x = sub { 3 };</pre>

<p>End-of-statement cannot occur within a bracketed expression, so this still works:</p>

<pre>    my $x = [
        sub { 3 },  # this comma is not optional
        sub { 3 }   # the statement won&#39;t terminate here 
    ];</pre>

<p>However, a nested hash block must be disambiguated by a trailing comma:</p>

<pre>    # Without the trailing comma, this becomes a code block
    my $hash = {
        1 =&#62; { 2 =&#62; 3, 4 =&#62; 5 },
    };</pre>

<p>Because subroutine declarations are expressions, not statements, this is now invalid:</p>

<pre>    sub f { 3 } sub g { 3 }     # two terms occur in a row</pre>

<p>But these two are valid:</p>

<pre>    sub f { 3 }; sub g { 3 };
    sub f { 3 }; sub g { 3 }    # the trailing semicolon is optional</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Conditional_statements"
>Conditional statements</a></h1>

<a name="msg_10"></a>
<a href="?hide_quotes=no#msg_10" onclick="return tog_quote(10);">
<div ID="header_shown_10" style="display: none;">
- Hide the snippet from t/statements/if.t (line 9 ~ line 110) -
</div>
<div ID="header_hidden_10" style="display: block;">
- Show the snippet from t/statements/if.t (line 9 ~ line 110, 102 lines) -
</div>
</a>
<div ID="hide_10" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S04/&quot;Conditional statements&quot;&gt;

=cut

plan 19;

my $x = 'test';
if ($x eq $x) { pass(&quot;if ($x eq $x) {} works&quot;); } else { flunk(&quot;if ($x eq $x) {} failed&quot;); }
if ($x ne $x) { flunk(&quot;if ($x ne $x) {} failed&quot;); } else { pass(&quot;if ($x ne $x) {} works&quot;); }
if (1) { pass(&quot;if (1) {} works&quot;); } else { flunk(&quot;if (1) {} failed&quot;); }
if (0) { flunk(&quot;if (0) {} failed&quot;); } else { pass(&quot;if (0) {} works&quot;); }
if (undef) { flunk(&quot;if (undef) {} failed&quot;); } else { pass(&quot;if (undef) {} works&quot;); }

# die called in the condition part of an if statement should die immediately
# rather than being evaluated as true
my $foo = 1;
try { if (die &quot;should die&quot;) { $foo = 3 } else { $foo = 2; } };
#say '# $foo = ' ~ $foo;
is $foo, 1, &quot;die should stop execution immediately.&quot;;

{
    my $foo = 1; # just in case
    if 1 &gt; 2 { $foo = 2 } else { $foo = 3 };
    is $foo, 3, 'if with no parens';
};

# if...elsif
{
    my $foo = 1;
    if (1) { $foo = 2 } elsif (1) { $foo = 3 };
    is $foo, 2, 'if (1) {} elsif (1) {}';
}

{
    my $foo = 1;
    if (1) { $foo = 2 } elsif (0) { $foo = 3 };
    is $foo, 2, 'if (1) {} elsif (0) {}';
}

{
    my $foo = 1;
    if (0) { $foo = 2 } elsif (1) { $foo = 3 };
    is $foo, 3, 'if (0) {} elsif (1) {}';
}

{
    my $foo = 1;
    if (0) { $foo = 2 } elsif (0) { $foo = 3 };
    is $foo, 1, 'if (0) {} elsif (0) {}';
}

# if...elsif...else

{
    my $foo = 1;
    if (0) { $foo = 2 } elsif (0) { $foo = 3 } else { $foo = 4 };
    is $foo, 4;
}

{
    my $foo = 1;
    if (1) { $foo = 2 } elsif (0) { $foo = 3 } else { $foo = 4 };
    is $foo, 2;
}

{
    my $foo = 1;
    if (1) { $foo = 2 } elsif (1) { $foo = 3 } else { $foo = 4 };
    is $foo, 2;
}

{
    my $foo = 1;
    if (0) { $foo = 2 } elsif (1) { $foo = 3 } else { $foo = 4 };
    is $foo, 3;
}

{
    my $foo = 1;
    if ({ 1 &gt; 0 }) { $foo = 2 } else { $foo = 3 };
    is $foo, 2, 'if with no parens, and closure as cond';
}

{
    my $var = 9;
    my sub func( $a, $b, $c ) { $var };
    if func 1, 2, 3 { $var = 4 } else { $var = 5 };
    is $var, 4, 'if with no parens, and call a function without parenthesis';
}

# I'm not sure where this should go

{
    eval_is(
        'if ( my $x = 2 ) == 2 { $x; }',
        2,
        &quot;'my' variable within 'if' conditional&quot;);
}

{
    isnt(eval('if 1; 2'), 2, 'test &quot;if 1&quot;');
}</pre>
</div>


<p>The <code>if</code> and <code>unless</code> statements work almost exactly as they do in Perl 5, except that you may omit the parentheses on the conditional:</p>

<pre>    if $foo == 123 {
        ...
    }
    elsif $foo == 321 {
        ...
    }
    else {
        ...
    }</pre>

<p>Conditional statement modifiers work as in Perl 5. So do the implicit conditionals implied by short-circuit operators.</p>

<a name="msg_9"></a>
<a href="?hide_quotes=no#msg_9" onclick="return tog_quote(9);">
<div ID="header_shown_9" style="display: none;">
- Hide the snippet from t/statements/values_in_bool_context.t (line 7 ~ line 89) -
</div>
<div ID="header_hidden_9" style="display: block;">
- Show the snippet from t/statements/values_in_bool_context.t (line 7 ~ line 89, 83 lines) -
</div>
</a>
<div ID="hide_9" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/Conditional statements/Conditional statement
#   modifiers work as in Perl 5&gt;

##  scalar checking  ##

{
    my $var = 20;

    my ($a, $b, $c, $d, $e, $f, $g, $h);

    $a = 1 if 1;
    $b = 1 if 0;
    $c = 1 if &quot;true&quot;;
    $d = 1 if &quot;&quot;;
    $e = 1 if &quot;1&quot;;
    $f = 1 if &quot;0&quot;;
    $g = 1 if undef;
    $h = 1 if $var;

    ok  $a, 'literal in bool context - numeric true value';
    ok !$b, 'literal in bool context - numeric false value';
    ok  $c, 'literal in bool context - string true value';
    ok !$d, 'literal in bool context - string false value';
    ok  $e, 'literal in bool context - stringified true value';
    ok !$f, 'literal in bool context - stringified false value';
    ok !$g, 'literal in bool context - undef value';
    ok  $h, 'literal in bool context - scalar variable';
}

##  array checking  ##

{
    my @array = (1, 0, &quot;true&quot;, &quot;&quot;, &quot;1&quot;, &quot;0&quot;, undef);

    my ($a, $b, $c, $d, $e, $f, $g, $h);

    $a = 1 if @array[0];
    $b = 1 if @array[1];
    $c = 1 if @array[2];
    $d = 1 if @array[3];
    $e = 1 if @array[4];
    $f = 1 if @array[5];
    $g = 1 if @array[6];
    $h = 1 if @array;

    ok  $a, 'array in bool context - numeric true value';
    ok !$b, 'array in bool context - numeric false value';
    ok  $c, 'array in bool context - string true value';
    ok !$d, 'array in bool context - string false value';
    ok  $e, 'array in bool context - stringified true value';
    ok !$f, 'array in bool context - stringified false value';
    ok !$g, 'array in bool context - undef value';
    ok  $h, 'array in bool context  array as a whole';
}

##  hash checking  ##

{
    my %hash = (
        0 =&gt; 1, 1 =&gt; 0, 2 =&gt; &quot;true&quot;,
        3 =&gt; &quot;&quot;, 4 =&gt; &quot;1&quot;, 5 =&gt; &quot;0&quot;, 6 =&gt; undef
    );

    my ($a, $b, $c, $d, $e, $f, $g, $h);

    $a = 1 if %hash{0};
    $b = 1 if %hash{1};
    $c = 1 if %hash{2};
    $d = 1 if %hash{3};
    $e = 1 if %hash{4};
    $f = 1 if %hash{5};
    $g = 1 if %hash{6};
    $h = 1 if %hash;

    ok  $a, 'hash in bool context - numeric true value';
    ok !$b, 'hash in bool context - numeric false value';
    ok  $c, 'hash in bool context - string true value';
    ok !$d, 'hash in bool context - string false value';
    ok  $e, 'hash in bool context - stringified true value';
    ok !$f, 'hash in bool context - stringified false value';
    ok !$g, 'hash in bool context - undef value';
    ok  $h, 'hash in bool context - hash as a whole';
}</pre>
</div>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Loop_statements"
>Loop statements</a></h1>

<a name="msg_16"></a>
<a href="?hide_quotes=no#msg_16" onclick="return tog_quote(16);">
<div ID="header_shown_16" style="display: none;">
- Hide the snippet from t/statements/loop.t (line 72 ~ line 142) -
</div>
<div ID="header_hidden_16" style="display: block;">
- Show the snippet from t/statements/loop.t (line 72 ~ line 142, 71 lines) -
</div>
</a>
<div ID="hide_16" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S04/&quot;Loop statements&quot;&gt;

=cut

{
  my $x = 0; repeat { $x++ } while $x &lt; 10;
  is($x, 10, 'repeat {} while');
}

{
  my $x = 1; repeat { $x++ } while 0;
  is($x, 2, 'ensure repeat {} while runs at least once');
}

{
  my $x = 0; try { repeat { $x++; redo if $x &lt; 10 } while 0 };
  is($x, 10, 'redo works in repeat', :todo&lt;feature&gt;);
}

{
  my $x = 0; repeat while $x &lt; 10 { $x++ }
  is($x, 10, 'repeat {} while');
}

{
  my $x = 1; repeat while 0 { $x++ }
  is($x, 2, 'ensure repeat {} while runs at least once');
}

{
  my $x = 0; try { repeat while 0 { $x++; redo if $x &lt; 10 } };
  is($x, 10, 'redo works in repeat', :todo&lt;feature&gt;);
}

{
  my $x = 0; repeat { $x++ } until $x &gt;= 10;
  is($x, 10, 'repeat {} until');
}

{
  my $x = 1; repeat { $x++ } until 1;
  is($x, 2, 'ensure repeat {} until runs at least once');
}

{
  my $x = 0; try { repeat { $x++; redo if $x &lt; 10 } until 1 };
  is($x, 10, 'redo works in repeat {} until', :todo&lt;feature&gt;);
}

{
  my $x = 0; repeat until $x &gt;= 10 { $x++ }
  is($x, 10, 'repeat until {}');
}

{
  my $x = 1; repeat until 1 { $x++ }
  is($x, 2, 'ensure repeat until {} runs at least once');
}

{
  my $x = 0; try { repeat until 1 { $x++; redo if $x &lt; 10 } };
  is($x, 10, 'redo works in repeat until {}', :todo&lt;feature&gt;);
}

my $loopvar = 0;

loop {
    is($loopvar, $loopvar, &quot;bare loop iterates $loopvar&quot;);
    last if ++$loopvar == 3;
}
is($loopvar, 3, &quot;bare loop exited after 3 iterations&quot;);</pre>
</div>


<a name="msg_13"></a>
<a href="?hide_quotes=no#msg_13" onclick="return tog_quote(13);">
<div ID="header_shown_13" style="display: none;">
- Hide the snippet from t/statements/while.t (line 9 ~ line 77) -
</div>
<div ID="header_hidden_13" style="display: block;">
- Show the snippet from t/statements/while.t (line 9 ~ line 77, 69 lines) -
</div>
</a>
<div ID="hide_13" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S04/&quot;Loop statements&quot;&gt;

=cut

plan 11;

{
  my $i = 0;
  while $i &lt; 5 { $i++; };
  is($i, 5, 'while $i &lt; 5 {} works');
}
{
  my $i = 0;
  while 5 &gt; $i { $i++; };
  is($i, 5, 'while 5 &gt; $i {} works');
}
# with parens
{
  my $i = 0;
  while ($i &lt; 5) { $i++; };
  is($i, 5, 'while ($i &lt; 5) {} works');
}
{
  my $i = 0;
  while (5 &gt; $i) { $i++; };
  is($i, 5, 'while (5 &gt; $i) {} works');
}

# single value
{
  my $j = 0;
  while 0 { $j++; };
  is($j, 0, 'while 0 {...} works');
}
{
  my $k = 0;
  while $k { $k++; };
  is($k, 0, 'while $var {...} works');
}

# other tests
{
  # this seems like a bit of a messy test, but the point is being able to
  # declare my $x within the while statement more suited for a file read
  # or iterator, but I didn't feel like creating one just for this test.
  eval_is(
    'my $y; while (my $x = 2) == 2 { $y = $x; last; } $y',
    2,
    &quot;'my' variable within 'while' conditional&quot;);
}

# while ... -&gt; $x {...}
{
  my @array = (0..5);
  my $was_in_while;
  my @new;
  eval 'while @array.shift -&gt; $x { $was_in_while++; push @new, $x }';
  ok $was_in_while,  'while ... -&gt; $x {...} worked (1)', :todo&lt;bug&gt;;
  is ~@new, ~@array, 'while ... -&gt; $x {...} worked (1)', :todo&lt;bug&gt;;
}

{
  my @array = (0..5);
  my $was_in_while;
  my @new;
  eval 'while shift @array -&gt; $x { $was_in_while++; push @new, $x }';
  ok $was_in_while,  'while ... -&gt; $x {...} worked (1)', :todo&lt;bug&gt;;
  is ~@new, ~@array, 'while ... -&gt; $x {...} worked (1)', :todo&lt;bug&gt;;
}</pre>
</div>


<p>Looping statement modifiers are the same as in Perl 5. Loop modifiers <code>next</code>, <code>last</code>, and <code>redo</code> also work as in Perl 5.</p>

<a name="msg_17"></a>
<a href="?hide_quotes=no#msg_17" onclick="return tog_quote(17);">
<div ID="header_shown_17" style="display: none;">
- Hide the snippet from t/statements/last.t (line 6 ~ line 83) -
</div>
<div ID="header_hidden_17" style="display: block;">
- Show the snippet from t/statements/last.t (line 6 ~ line 83, 78 lines) -
</div>
</a>
<div ID="hide_17" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S04/&quot;Loop statements&quot; /work as in Perl 5/&gt;
last
last if &lt;condition&gt;;
&lt;condition&gt; and last;
last &lt;label&gt;;
last in nested loops
last &lt;label&gt; in nested loops

=cut

plan 7;

# test for loops with last

{
    my $tracker = 0;
    for 1 .. 5 {
        $tracker = $_;
        last;  
    }
    is($tracker, 1, '... our loop only got to 1 (last)');
}

{
    my $tracker = 0;
    for 1 .. 5 {
        $tracker = $_;
        last if $_ == 3;  
    }
    is($tracker, 3, '... our loop only got to 3 (last if &lt;cond&gt;)');
}

{
    my $tracker = 0;
    for 1 .. 5 {
        $tracker = $_;
        $_ == 3 &amp;&amp; last;  
    }
    is($tracker, 3, '... our loop only got to 3 (&lt;cond&gt; &amp;&amp; last)');
}

{
    my $tracker = 0;
    for 1 .. 5 {
        $tracker = $_;
        $_ == 3 and last;  
    }
    is($tracker, 3, '... our loop only got to 3 (&lt;cond&gt; and last)');
}

{
    eval_is(
        'my $var=0; DONE: for (1..2) { last DONE; $var++;} $var',
        0,
        &quot;var is 0 because last before increment&quot;,
        :todo(1)
    );
}

{
    my $tracker = 0;
    for (1 .. 5) -&gt; $out {
        for (10 .. 11) -&gt; $in {
            $tracker = $in + $out;
            last;
        }
    }
    is($tracker, 15, 'our inner loop only runs once per (last inside nested loops)');
}

{
    eval_is(
        'my $var=0; OUT: for (1..2) { IN: for (1..2) { last OUT } $var++;} $var',
        0,
        &quot;var is 0 because last before increment in nested loop&quot;,
        :todo(1)
    );
}</pre>
</div>


<a name="msg_15"></a>
<a href="?hide_quotes=no#msg_15" onclick="return tog_quote(15);">
<div ID="header_shown_15" style="display: none;">
- Hide the snippet from t/statements/next.t (line 6 ~ line 151) -
</div>
<div ID="header_hidden_15" style="display: block;">
- Show the snippet from t/statements/next.t (line 6 ~ line 151, 146 lines) -
</div>
</a>
<div ID="hide_15" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S04/&quot;Loop statements&quot; /work as in Perl 5/&gt;
next
next if &lt;condition&gt;;
&lt;condition&gt; and next;
next &lt;label&gt;;
next in nested loops
next &lt;label&gt; in nested loops

=cut

plan 12;

# test for loops with next

{
    my $tracker=0;for (1..2) { next; $tracker++;}
    is(
        $tracker,
        0,
        &quot;tracker is 0 because next before increment&quot;,
    );
}

{
    my $tracker = 0; for (1..5) { next if 2 &lt; $_ &lt; 4; $tracker = $_;}
    is(
        $tracker,
        3,
        &quot;... nothing before or after 3 (next if &lt;cond&gt;)&quot;,
        :todo&lt;bug&gt;
    );
}

{
    my $tracker = 0; for (1..5) { $_ &gt; 3 &amp;&amp; next; $tracker = $_;}
    is(
        $tracker,
        3,
        &quot;... nothing after 3 (&lt;cond&gt; &amp;&amp; next)&quot;,
    );
}

{
    my $tracker = 0; for (1..5) { $_ &gt; 3 and next; $tracker = $_;}
    is(
        $tracker,
        3,
        &quot;... nothing after 3 (&lt;cond&gt; and next)&quot;,
    );
}

{
    my $tracker=&quot;err&quot;; eval '$tracker = 0; DONE: for (1..2) { next DONE; $tracker++;}';
    is(
        $tracker,
        0,
        &quot;tracker is 0 because next before increment&quot;,
        :todo&lt;bug&gt;
    );
}

{
    my $tracker=0;for (1..5)-&gt;$out {for (10..11)-&gt;$in {next if $out &gt; 2;$tracker = $in + $out;}}
    is($tracker,
        13,
        'inner loop skips once inner is run twice (next inside nested loops)',
    );
}

{
    my $tracker=&quot;err&quot;; eval '$tracker = 0; OUT: for (1..2) { IN: for (1..2) { next OUT; $tracker++; } }';
    is(
        $tracker,
        0,
        &quot;tracker is 0 because next before increment in nested loop&quot;,
        :todo&lt;bug&gt;
    );
}

=pod

Check that C&lt;next&gt; works on the correct loop/block

=cut

{
  my $foo;
  for 1..2 -&gt; $a {
    $foo ~= &quot;A&quot;;
    for 1..2 -&gt; $b {
        $foo ~= &quot;B&quot;;
        next;             # works on higher level loop, should work on inner
    }
  }
  is($foo, &quot;ABBABB&quot;, &quot;next works on inner loop of 2&quot;);
}

{
    my $bar;
    for 1..2 -&gt; $a {
        $bar ~= &quot;A&quot;;
        for 1..2 -&gt; $b {
            $bar ~= &quot;B&quot;;
            for 1..2 -&gt; $c {
                $bar ~= &quot;C&quot;;
                next;         # same thing
            }
        }
    }
    is($bar, &quot;ABCCBCCABCCBCC&quot;, &quot;next works on inner loop of 3&quot;);
}

{
    my @log;    
    my $i;
    while ++$i &lt; 2 {
        push @log, &quot;before&quot;;
        next;
        push @log, &quot;after&quot;;
    }
    
    is(~@log, &quot;before&quot;, &quot;statements after next are not executed&quot;);
}

{
    my $i = 0;
    
    for (1, 1, 0, 1, 0, 1) -&gt; $x {
        if ($x) { next }
        $i++;
    }
    
    is($i, 2, '$i++ executed only twice, because next ')
}

{
    my $i = 0;
    my $j;
    
    loop ($j = 0; $j &lt; 6; $j++) {
        if ($j % 2 == 0) { next }
        $i++;
    }
    
    is($i, 3, '$i++ was not executed when next was called before it in loop {}');
}</pre>
</div>


<a name="msg_14"></a>
<a href="?hide_quotes=no#msg_14" onclick="return tog_quote(14);">
<div ID="header_shown_14" style="display: none;">
- Hide the snippet from t/statements/redo.t (line 4 ~ line 104) -
</div>
<div ID="header_hidden_14" style="display: block;">
- Show the snippet from t/statements/redo.t (line 4 ~ line 104, 101 lines) -
</div>
</a>
<div ID="hide_14" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/&quot;Loop statements&quot; /work as in Perl 5/&gt;
plan 10;

{
    my $i = 0;
    while (defined($i)) { if (++$i &lt; 3) { redo }; last }
    is($i, 3, &quot;redo caused reapplication of block&quot;);
}

{
    my @log;    
    my $i;
    while ++$i &lt; 5 {
        push @log, &quot;before&quot;;
        if (++$i == 2) {
            redo;
        } else {
            push @log, &quot;no_redo&quot;;
        }
        push @log, &quot;after&quot;;
    }
    
    is(~@log, &quot;before before no_redo after before no_redo after&quot;, &quot;statements after redo are not executed&quot;);
}

{
    my $i = 0;
    my $j = 0;

    for (1, 0) -&gt; $x {
        if ($x &amp;&amp; (++$i % 2 == 0)) { redo };
        $j++;
    }

    is($j, 2, '$j++ encountered twice');
    is($i, 1, '$i++ encountered once');
}


{
    my $i = 0;
    my $j = 0;

    for (1, 0, 1, 0) -&gt; $x {
        if ($x &amp;&amp; (++$i % 2 == 0)) { redo };
        $j++;
    }

    is($j, 4, '$j++ encountered four times');
    is($i, 3, '$i++ encountered three times');
}


{
    my $i = 0;
    my $j;

    loop ($j = 0; $j &lt; 4; $j++) {
        if ($j % 2 == 0 and $i++ % 2 == 0) { redo }
        $i-=2;
    }

    is($j, 4, '$j unaltered by the fiasco');
    is($i, -4, '$i incremented and decremented correct number of times');
}

{
    # rubicon TestLoopStuff.rb
    #  def testRedoWithFor
    #    sum = 0
    #    for i in 1..10
    #      sum += i
    #      i -= 1
    #      if i &gt; 0
    #        redo
    #      end
    #    end
    #    assert_equal(220, sum)
    #  end
    my $stopping = 100;
    my $sum = 0;
    for 1..10 -&gt; $i is copy {
    $sum += $i;
    $i -= 1;
    last if !$stopping--;
    if $i &gt; 0 { redo }
    }
    is($sum, 220, &quot;testRedoWithFor&quot;, :todo&lt;bug&gt;);

    $stopping = 100;
    $sum = 0;
    my $j = 1;
    my $i;
    while do{$i = $j; $j++ &lt;= 10} {
    $sum += $i;
    $i -= 1;
    last if !$stopping--;
    if $i &gt; 0 { redo }
    }
    is($sum, 220, &quot;test redo with while&quot;);
}</pre>
</div>


<p>There is no longer a <code>continue</code> block. Instead, use a <code>NEXT</code> block within the body of the loop. See below.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_while_and_until_statements"
>The <code>while</code> and <code>until</code> statements</a></h2>

<p>The <code>while</code> and <code>until</code> statements work as in Perl 5, except that you may leave out the parentheses around the conditional:</p>

<pre>    while $bar &#60; 100 {
        ...
    }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_repeat_statement"
>The <code>repeat</code> statement</a></h2>

<p>Unlike in Perl 5, applying a statement modifier to a <code>do</code> block is specifically disallowed:</p>

<pre>    do {
        ...
    } while $x &#60; 10;    # ILLEGAL</pre>

<p>Instead, you should write the more Pascal-like <code>repeat</code> loop:</p>

<pre>    repeat {
        ...
    } while $x &#60; 10;</pre>

<p>or equivalently:</p>

<pre>    repeat {
        ...
    } until $x &#62;= 10;</pre>

<p>Unlike Perl 5&#39;s <code>do-while</code> loop, this is a real loop block now, so <code>next</code>, <code>last</code>, and <code>redo</code> work as expected. The loop conditional on a repeat block is required, so it will be recognized even if you put it on a line by its own:</p>

<pre>    repeat
    {
        ...
    }
    while $x &#60; 10;</pre>

<p>However, that&#39;s likely to be visually confused with a following <code>while</code> loop at the best of times, so it&#39;s also allowed to put the loop conditional at the front, with the same meaning. (The <code>repeat</code> keyword forces the conditional to be evaluated at the end of the loop, so it&#39;s still C&#39;s do-while semantics.) Therefore, even under GNU style rules, the previous example may be rewritten into a very clear:</p>

<pre>    repeat while $x &#60; 10
      {
        ...
      }</pre>

<p>or equivalently:</p>

<pre>    repeat until $x &#62;= 10
      {
        ...
      }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_general_loop_statement"
>The general loop statement</a></h2>

<a name="msg_33"></a>
<a href="?hide_quotes=no#msg_33" onclick="return tog_quote(33);">
<div ID="header_shown_33" style="display: none;">
- Hide the snippet from t/statements/loop.t (line 9 ~ line 71) -
</div>
<div ID="header_hidden_33" style="display: block;">
- Show the snippet from t/statements/loop.t (line 9 ~ line 71, 63 lines) -
</div>
</a>
<div ID="hide_33" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S04/&quot;The general loop statement&quot;&gt;

=cut

plan 26;

# basic loop

my $i = 0;
is($i, 0, 'verify our starting condition');
loop ($i = 0; $i &lt; 10; $i++) {}
is($i, 10, 'verify our ending condition');

# loop with last()

my $i = 0;
is($i, 0, 'verify our starting condition');
loop ($i = 0; $i &lt; 10; $i++) {
    if ($i == 5) { 
        last(); # should this really need the ()
    }
}
is($i, 5, 'verify our ending condition');

# infinite loop

my $i = 0;
is($i, 0, 'verify our starting condition');
loop (;;) { $i++; last(); }
is($i, 1, 'verify our ending condition');

# declare variable $j inside loop
my $count  = 0;
is($count, 0, 'verify our starting condition');
my $j; loop ($j = 0; $j &lt; 10; $j++) { $count++; };
is($count, 10, 'verify our ending condition');

# Ensure condition is tested on the first iteration
{
    my $never_did_body = 1;
    loop (;0;)
    {
        $never_did_body = 0;
    }
    ok($never_did_body, &quot;loop with an initially-false condition executes 0 times&quot;);
}

# Loop with next should still execute the continue expression
{
    my ($i,    $continued);
    loop ($i = 0;; $continued = 1)
    {
        last if $i;
        $i++;
        next;
    }
    ok($continued, &quot;next performs a loop's continue expression&quot;);
}

=kwid

repeat { } while tests... i.e. loops without the () bits</pre>
</div>


<p>The <code>loop</code> statement is the C-style <code>for</code> loop in disguise:</p>

<pre>    loop ($i = 0; $i &#60; 10; $i++) {
        ...
    }</pre>

<p>As in C, the parentheses are required if you supply the 3-part spec; however, the 3-part loop spec may be entirely omitted to write an infinite loop. That is,</p>

<pre>    loop {...}</pre>

<p>is equivalent to the Cish idiom:</p>

<pre>    loop (;;) {...}</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_for_statement"
>The <code>for</code> statement</a></h2>

<a name="msg_32"></a>
<a href="?hide_quotes=no#msg_32" onclick="return tog_quote(32);">
<div ID="header_shown_32" style="display: none;">
- Hide the snippet from t/statements/for.t (line 12 ~ line 18) -
</div>
<div ID="header_hidden_32" style="display: block;">
- Show the snippet from t/statements/for.t (line 12 ~ line 18, 7 lines) -
</div>
</a>
<div ID="hide_32" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S04/&quot;The C&lt;for&gt; statement&quot;&gt;

=cut

plan 36;

## for with plain old range operator w/out parens</pre>
</div>


<p>There is no <code>foreach</code> statement any more. It&#39;s always spelled <code>for</code> in Perl 6, so it always takes a list as an argument:</p>

<pre>    for @foo { print }</pre>

<p>As mentioned earlier, the loop variable is named by passing a parameter to the closure:</p>

<a name="msg_31"></a>
<a href="?hide_quotes=no#msg_31" onclick="return tog_quote(31);">
<div ID="header_shown_31" style="display: none;">
- Hide the snippet from t/statements/for.t (line 26 ~ line 275) -
</div>
<div ID="header_hidden_31" style="display: block;">
- Show the snippet from t/statements/for.t (line 26 ~ line 275, 250 lines) -
</div>
</a>
<div ID="hide_31" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/&quot;The C&lt;for&gt; statement&quot; /to the closure:/&gt;

my $b;
for 0 .. 5 -&gt; $_ { $b = $b ~ $_; };
is($b, '012345', 'for 0 .. 5 -&gt; {} works');

{
    my $str;
    my @a = 1..3;
    my @b = 4..6;
    for each(@a; @b) -&gt; $x, $y {
        $str ~= &quot;($x $y)&quot;;
    }
    is $str, &quot;(1 4)(2 5)(3 6)&quot;;
}

{
    my $str;
    my @a = 1..3;
    my @b = 5..6;
    eval q{
        for zip(@a; @b) -&gt; [$x, $y] {
            $str ~= &quot;($x $y)&quot;;
        }
    };
    is $str, &quot;(1 5)(2 4)(3 6)&quot;;
}

# ... with sub

my $c;
for (0 .. 5) sub { $c = $c ~ $_; };
is($c, '012345', 'for 0 .. 5 sub {} works');

# ... with referential sub

my $d;
sub some_sub_1 ($arg) { $d = $d ~ $arg; }
for (0 .. 5) { .some_sub_1 };
is($d, '012345', 'for 0 .. 5 { .some_sub } works');

## and now with parens around the range operator

my $e;
for (0 .. 5) { $e = $e ~ $_; };
is($e, '012345', 'for () {} works');

# ... with 'pointer'

my $f;
for (0 .. 5) -&gt; $_ { $f = $f ~ $_; };
is($f, '012345', 'for () -&gt; {} works');

# ... with sub

my $g;
for (0 .. 5) sub { $g = $g ~ $_; };
is($g, '012345', 'for (0 .. 5) sub {} works');

# ... with referential sub

my $h;
sub some_sub_2 ($arg) { $h = $h ~ $arg; }
for (0 .. 5) { .some_sub_2 };
is($h, '012345', 'for (0 .. 5) { .some_sub } works');

# ... with implicit topic

$_ = &quot;GLOBAL VALUE&quot;;
for &quot;INNER VALUE&quot; {
  is( .lc, &quot;inner value&quot;, &quot;Implicit default topic is seen by lc()&quot;);
};
is($_,&quot;GLOBAL VALUE&quot;,&quot;After the loop the implicit topic gets restored&quot;);

$_ = &quot;GLOBAL VALUE&quot;;
is( .lc, &quot;inner value&quot;, &quot;Implicit default topic is seen by lc()&quot; )
  for &quot;INNER VALUE&quot;;
is($_,&quot;GLOBAL VALUE&quot;,&quot;After the loop the implicit topic gets restored&quot;);

## and now for with 'topical' variables

# ... w/out parens

my $i;
for 0 .. 5 -&gt; $topic { $i = $i ~ $topic; };
is($i, '012345', 'for 0 .. 5 -&gt; $topic {} works');

# ... with parens

my $j;
for (0 .. 5) -&gt; $topic { $j = $j ~ $topic; };
is($j, '012345', 'for () -&gt; $topic {} works');


## for with @array operator w/out parens

my @array_k = (0 .. 5);
my $k;
for @array_k { $k = $k ~ $_; };
is($k, '012345', 'for @array {} works');

# ... with 'pointer'

my @array_l = (0 .. 5);
my $l;
for @array_l -&gt; $_ { $l = $l ~ $_; };
is($l, '012345', 'for @array -&gt; {} works');

# ... with sub

my @array_m = (0 .. 5);
my $m;
for (@array_m) sub { $m = $m ~ $_; };
is($m, '012345', 'for @array sub {} works');

# ... with referential sub

my @array_n = (0 .. 5);
my $n;
sub some_sub_3 ($arg) { $n = $n ~ $arg; }
for (@array_n) { .some_sub_3 };
is($n, '012345', 'for @array { .some_sub } works');

## and now with parens around the @array

my @array_o = (0 .. 5);
my $o;
for (@array_o) { $o = $o ~ $_; };
is($o, '012345', 'for (@array) {} works');

# ... with 'pointer'

my @array_p = (0 .. 5);
my $p;
for (@array_p) -&gt; $_ { $p = $p ~ $_; };
is($p, '012345', 'for (@array) -&gt; {} works');

# ... with sub

my @array_q = (0 .. 5);
my $q;
for (@array_q) sub { $q ~= $_; };
is($q, '012345', 'for (@array) sub {} works');

# ... with referential sub

my @array_r = (0 .. 5);
my $r;
sub some_sub_4 ($arg) { $r ~= $arg; }
for (@array_r) { .some_sub_4 };
is($r, '012345', 'for (@array) { .some_sub } works');


my @elems = &lt;a b c d e&gt;;

{
    my @a;
    for (@elems) {
        push @a, $_;
    }
    my @e = &lt;a b c d e&gt;;
    is(@a, @e, 'for (@a) { ... $_ ... } iterates all elems');
}

{
    my @a;
        for (@elems) -&gt; $_ { push @a, $_ };
    my @e = @elems;
    is(@a, @e, 'for (@a)-&gt;$_ { ... $_ ... } iterates all elems' );
}

{
    my @a;
    for (@elems) { push @a, $_, $_; }
    my @e = &lt;a a b b c c d d e e&gt;;
    is(@a, @e, 'for (@a) { ... $_ ... $_ ... } iterates all elems, not just odd');
}


# for with &quot;is rw&quot;

my @array_s = (0..2);
my @s = (1..3);
for @array_s { $_++ };
is(@array_s, @s, 'for @array { $_++ }');

my @array_t = (0..2);
my @t = (1..3);
for @array_t -&gt; $val is rw { $val++ };
is(@array_t, @t, 'for @array -&gt; $val is rw { $val++ }');

my @array_v = (0..2);
my @v = (1..3);
try { for @array_v.values -&gt; $val is rw { $val++ }; };
is(@array_v, @v, 'for @array.values -&gt; $val is rw { $val++ }', :todo&lt;feature&gt;);

my @array_kv = (0..2);
my @kv = (1..3);
try { for @array_kv.kv -&gt; $key, $val is rw { $val++ }; };
is(@array_kv, @kv, 'for @array.kv -&gt; $key, $val is rw { $val++ }', :todo&lt;feature&gt;);

my %hash_v = ( a =&gt; 1, b =&gt; 2, c =&gt; 3 );
my %v = ( a =&gt; 2, b =&gt; 3, c =&gt; 4 );
try { for %hash_v.values -&gt; $val is rw { $val++ }; };
is(%hash_v, %v, 'for %hash.values -&gt; $val is rw { $val++ }', :todo&lt;feature&gt;);

my %hash_kv = ( a =&gt; 1, b =&gt; 2, c =&gt; 3 );
my %kv = ( a =&gt; 2, b =&gt; 3, c =&gt; 4 );
try { for %hash_kv.kv -&gt; $key, $val is rw { $val++ }; };
is( %hash_kv.sort, %kv.sort, 'for %hash.kv -&gt; $key, $val is rw { $val++ }', :todo&lt;feature&gt;);


# .key //= ++$i for @array1;
{
   class TestClass is rw { has $.key; };
   my @array1 = (TestClass.new(),TestClass.new(:key&lt;2&gt;));
   my @array2 = (TestClass.new(:key&lt;1&gt;),TestClass.new(:key&lt;3&gt;));   
   
   my $i = 0;
   try { .key //= ++$i for @array1 };
   my $sum1 = @array1.map:{ $_.key };
   my $sum2 = @array2.map:{ $_.key };
   is( $sum1, $sum2, '.key //= ++$i for @array1;', :todo&lt;bug&gt;);

}

# .key = 1 for @array1;
{
   class TestClass is rw { has $.key; };
   my @array1 = (TestClass.new(),TestClass.new(:key&lt;2&gt;));
   my @array2 = (TestClass.new(:key&lt;1&gt;),TestClass.new(:key&lt;1&gt;));   

   try { .key = 1 for @array1 };
   my $sum1 = @array1.map:{ $_.key };
   my $sum2 = @array2.map:{ $_.key };
   is($sum1, $sum2, '.key = 1 for @array1;');
}

# $_.key = 1 for @array1;
{
   class TestClass is rw { has $.key; };
   my @array1 = (TestClass.new(),TestClass.new(:key&lt;2&gt;));
   my @array2 = (TestClass.new(:key&lt;1&gt;),TestClass.new(:key&lt;1&gt;));   

   try { $_.key = 1 for @array1 };
   my $sum1 = @array1.map:{ $_.key };
   my $sum2 = @array2.map:{ $_.key };
   is( $sum1, $sum2, '$_.key = 1 for @array1;');

}</pre>
</div>


<pre>    for @foo -&#62; $item { print $item }</pre>

<p>Multiple parameters may be passed, in which case the list is traversed more than one element at a time:</p>

<pre>    for %hash.kv -&#62; $key, $value { print &#34;$key =&#62; $value\n&#34; }</pre>

<p>To process two arrays in parallel, use the <code>each</code> function:</p>

<pre>    for each(@a;@b) -&#62; $a, $b { print &#34;[$a, $b]\n&#34; }</pre>

<p>or use the <code>zip</code> function to generate a list of <code>Seq</code> objects that each can be bound to multiple arguments enclosed in square brackets:</p>

<pre>    for zip(@a;@b) -&#62; [$a, $b] { print &#34;[$a, $b]\n&#34; }</pre>

<p>The list is evaluated lazily by default, so instead of using a <code>while</code> to read a file a line at a time as you would in Perl 5:</p>

<pre>    while (my $line = &#60;STDIN&#62;) {...}</pre>

<p>in Perl 6 you should use a <code>for</code> (plus a unary <code>=</code> &#34;iterate the iterator&#34; operator) instead:</p>

<pre>    for =$*IN -&#62; $line {...}</pre>

<p>This has the added benefit of limiting the scope of the <code>$line</code> parameter to the block it&#39;s bound to. (The <code>while</code>&#39;s declaration of <code>$line</code> continues to be visible past the end of the block. Remember, no implicit block scopes.) It is also possible to write</p>

<pre>    while =$*IN -&#62; $line {...}</pre>

<p>Note also that Perl 5&#39;s special rule causing</p>

<pre>    while (&#60;&#62;) {...}</pre>

<p>to automatically assign to <code>$_</code> is not carried over to Perl 6. That should now be written:</p>

<pre>    for =&#60;&#62; {...}</pre>

<p>which is short for</p>

<pre>    for =$*ARGS {...}</pre>

<p>Parameters are by default readonly within the block. You can declare a parameter read/write by including the &#34;<code>is rw</code>&#34; trait. If you rely on <code>$_</code> as the implicit parameter to a block, then <code>$_</code> is considered read/write by default. That is, the construct:</p>

<pre>    for @foo {...}</pre>

<p>is actually short for:</p>

<pre>    for @foo -&#62; $_ is rw {...}</pre>

<p>so you can modify the current list element in that case. However, any time you specify the arguments, they default to read only.</p>

<p>When used as statement modifers, <code>for</code> and <code>given</code> use a private instance of <code>$_</code> for the left side of the statement. The outer <code>$_</code> can be referred to as <code>$OUTER::_</code>. (And yes, this implies that the compiler may have to retroactively change the binding of &#60;$_&#62; on the left side. But it&#39;s what people expect of a pronoun like &#34;it&#34;.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_do-once_loop"
>The do-once loop</a></h2>

<p>In Perl 5, a bare block is deemed to be a do-once loop. In Perl 6, the bare block is not a do-once. Instead <code>do {...}</code> is the do-once loop (which is another reason you can&#39;t put a <code>while</code> or <code>until</code> modifier on it; use <code>repeat</code> for that).</p>

<a name="msg_29"></a>
<a href="?hide_quotes=no#msg_29" onclick="return tog_quote(29);">
<div ID="header_shown_29" style="display: none;">
- Hide the snippet from t/statements/do.t (line 7 ~ line 21) -
</div>
<div ID="header_hidden_29" style="display: block;">
- Show the snippet from t/statements/do.t (line 7 ~ line 21, 15 lines) -
</div>
</a>
<div ID="hide_29" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/The do-once loop/&quot;can't&quot; put while or until modifier&gt;
{
    my $i;
    ok !eval 'do { $i++ } while $i &lt; 5;',
        &quot;'do' can't take the 'while' modifier&quot;;
    is $i, undef, 'the code never run';
}

{
    my $i;
    ok !eval 'do { $i++ } until $i &gt; 4;',
        &quot;'do' can't take the 'until' modifier&quot;;
    is $i, undef, 'the code never run';
}</pre>
</div>


<p>For any statement, prefixing with a <code>do</code> allows you to return the value of that statement and use it in an expression:</p>

<pre>    $x = do if $a { $b } else { $c };</pre>

<p>This construct only allows you to attach a single statement to the end of an expression. If you want to continue the expression after the statement, or if you want to attach multiple statements. you must use the curly form. Since a bare expression may be used as a statement, you may use <code>do</code> on an expression, but its only effect is to function as an unmatched left parenthesis, much like the <code>$</code> operator in Haskell. That is, precedence decisions do not cross a <code>do</code> boundary. Conjectural: a <code>do</code> may be used within a subexpression, but only if terminated by an unmatched right bracket of some kind.</p>

<a name="msg_28"></a>
<a href="?hide_quotes=no#msg_28" onclick="return tog_quote(28);">
<div ID="header_shown_28" style="display: none;">
- Hide the snippet from t/statements/do.t (line 48 ~ line 56) -
</div>
<div ID="header_hidden_28" style="display: block;">
- Show the snippet from t/statements/do.t (line 48 ~ line 56, 9 lines) -
</div>
</a>
<div ID="hide_28" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/The do-once loop/&quot;you may use&quot; do &quot;on an expression&quot;&gt;
{
    my $ret = do 42;
    is($ret, 42, 'do EXPR should also work (single number)');

    $ret = do 3 + 2;
    is($ret, 5, 'do EXPR should also work (simple + expr)');
}</pre>
</div>


<p>Since <code>do</code> is defined as going in front of a statement, it follows that it can always be followed by a statement label. This is particularly useful for the do-once block, since it is offically a loop and can take therefore loop control statements.</p>

<a name="msg_27"></a>
<a href="?hide_quotes=no#msg_27" onclick="return tog_quote(27);">
<div ID="header_shown_27" style="display: none;">
- Hide the snippet from t/statements/do.t (line 57 ~ line 77) -
</div>
<div ID="header_hidden_27" style="display: block;">
- Show the snippet from t/statements/do.t (line 57 ~ line 77, 21 lines) -
</div>
</a>
<div ID="hide_27" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/The do-once loop/&quot;can take&quot; &quot;loop control statements&quot;&gt;
{
    my $i;
    do {
        $i++;
        next;
        $i--;
    }
    is $i, 1, &quot;'next' works in 'do' block&quot;;
}

{
    my $i;
    do {
        $i++;
        last;
        $i--;
    }
    is $i, 1, &quot;'last' works in 'do' block&quot;;
}</pre>
</div>


<p>Although a bare block is no longer a do-once loop, it still executes immediately as in Perl 5, as if it were immediately dereferenced with a <code>.()</code> postfix, so within such a block <code>CALLER::</code> refers to the scope surrounding the block. If you wish to return a closure from a function, you must use an explicit prefix such as <code>return</code> or <code>sub</code> or <code>-&#62;</code>. (Use of a placeholder parameter is deemed insufficiently explicit because it&#39;s not out front where it can be seen. You can, of course, use a placeholder parameter if you also use <code>return</code>.)</p>

<a name="msg_26"></a>
<a href="?hide_quotes=no#msg_26" onclick="return tog_quote(26);">
<div ID="header_shown_26" style="display: none;">
- Hide the snippet from t/statements/do.t (line 78 ~ line 89) -
</div>
<div ID="header_hidden_26" style="display: block;">
- Show the snippet from t/statements/do.t (line 78 ~ line 89, 12 lines) -
</div>
</a>
<div ID="hide_26" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/The do-once loop/&quot;bare block&quot; &quot;no longer a do-once loop&quot;&gt;
{
    my $i;
    ok !eval('{ $i++; next; $i--; }'), &quot;bare block can't take 'next'&quot;;
    is $i, undef, &quot;the code snippet never run&quot;;
}

{
    my $i;
    ok !eval('{ $i++; last; $i--; }'), &quot;bare block can't take 'last'&quot;;
    is $i, undef, &quot;the code snippet never run&quot;;
}</pre>
</div>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Switch_statements"
>Switch statements</a></h1>

<p>A switch statement is a means of topicalizing, so the switch keyword is the English topicalizer, <code>given</code>. The keyword for individual cases is <code>when</code>:</p>

<pre>    given EXPR {
        when EXPR { ... }
        when EXPR { ... }
        default { ... }
    }</pre>

<p>The current topic is always aliased to the special variable <code>$_</code>. The <code>given</code> block is just one way to set the current topic, but a switch statement can be any block that sets <code>$_</code>, including a <code>for</code> loop (in which the first loop parameter is the topic) or the body of a method (if you have declared the invocant as <code>$_</code>). So switching behavior is actually caused by the <code>when</code> statements in the block, not by the nature of the block itself. A <code>when</code> statement implicitly does a &#34;smart match&#34; between the current topic (<code>$_</code>) and the argument of the <code>when</code>. If the smart match succeeds, the associated closure is executed, and the surrounding block is automatically broken out of. If the smart match fails, control passes to the next statement normally, which may or may not be a <code>when</code> statement. Since <code>when</code> statements are presumed to be executed in order like normal statements, it&#39;s not required that all the statements in a switch block be <code>when</code> statements (though it helps the optimizer to have a sequence of contiguous <code>when</code> statements, because then it can arrange to jump directly to the first appropriate test that might possibly match.)</p>

<p>The default case:</p>

<pre>    default {...}</pre>

<p>is exactly equivalent to</p>

<a name="msg_8"></a>
<a href="?hide_quotes=no#msg_8" onclick="return tog_quote(8);">
<div ID="header_shown_8" style="display: none;">
- Hide the snippet from t/statements/given.t (line 211 ~ line 286) -
</div>
<div ID="header_hidden_8" style="display: block;">
- Show the snippet from t/statements/given.t (line 211 ~ line 286, 76 lines) -
</div>
</a>
<div ID="hide_8" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/&quot;Switch statements&quot; /&quot;is exactly equivalent to&quot;&gt;
eval '
    my @input = (0, 1);
    my @got;

    for @input -&gt; $x {
        given $x {
              when true { push @got, &quot;true&quot; }
          default { push @got, &quot;false&quot; }
                  #when !true { push @got, &quot;false&quot; }
        }
    }

    is(@got.join(&quot;,&quot;), &quot;false,true&quot;, q!given { when true { } }!);
';
flunk(&quot;when true is parsefail&quot;, :todo&lt;feature&gt;) if $!;

# given + hash deref
{
    my %h;
    given %h { .{'key'} = 'value'; }
    ok(%h{'key'} eq 'value', 'given and hash deref using .{}');
    given %h { .&lt;key&gt; = &quot;value&quot;; }
    ok(%h{'key'} eq 'value', 'given and hash deref using .&lt;&gt;');
}

# given + 0-arg closure
{
    my $x;
    given 41 {
        when ({ $_ == 49 }) { diag &quot;this really shouldn't happen&quot;; $x = 49 }
        when ({ $_ == 41 }) { $x++ }
    }
    ok $x, 'given tests 0-arg closures for truth';
}

# given + 1-arg closure
{
    my $x;
    given 41 {
        when (-&gt; $t { $t == 49 }) { diag &quot;this really shouldn't happen&quot;; $x = 49 }
        when (-&gt; $t { $t == 41 }) { $x++ }
    }
    ok $x, 'given tests 1-arg closures for truth';
}

# given + n&gt;1-arg closure (should fail)
{
    dies_ok {
        given 41 {
            when (-&gt; $t, $r { $t == $r }) { ... }
        }
    }, 'fail on arities &gt; 1';
    is $!, 'Unexpected arity in smart match: 2', '...with useful error message';
}

# given + 0-arg sub
{
    my $x = 41;
    sub always_true { Bool::True }
    given 1 {
        when &amp;always_true { $x++ }
    }
    is $x, 42, 'given tests 0-arg subs for truth';
}

# given + 1-arg sub
{
    my $x = 41;
    sub maybe_true ($value) { $value eq &quot;mytopic&quot; }
    given &quot;mytopic&quot; {
        when &amp;maybe_true { $x++ }
    }
    is $x, 42, 'given tests 1-arg subs for truth';
}</pre>
</div>


<pre>    when * {...}</pre>

<p>Because <code>when</code> statements are executed in order, the default must come last. You don&#39;t have to use an explicit default--you can just fall off the last <code>when</code> into ordinary code. But use of a <code>default</code> block is good documentation.</p>

<p>If you use a <code>for</code> loop with a named parameter, the parameter is also aliased to <code>$_</code> so that it can function as the topic of any <code>when</code> statements within the loop. If you use a <code>for</code> statement with multiple parameters, only the first parameter is aliased to <code>$_</code> as the topic.</p>

<p>You can explicitly break out of a <code>when</code> block (and its surrounding switch) early using the <code>break</code> verb. You can explicitly break out of a <code>when</code> block and go to the next statement by using <code>continue</code>. (Note that, unlike C&#39;s idea of falling through, subsequent <code>when</code> conditions are evaluated. To jump into the next <code>when</code> block you must use a <code>goto</code>.)</p>

<p>If you have a switch that is the main block of a <code>for</code> loop, and you break out of the switch either implicitly or explicitly, it merely goes to the next iteration of the loop. You must use <code>last</code> to break out of the entire loop early. Of course, an explicit <code>next</code> would be clearer than a <code>break</code> if you really want to go to the next iteration. Possibly we&#39;ll outlaw <code>break</code> in a loop topicalizer.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Exception_handlers"
>Exception handlers</a></h1>

<p>Unlike many other languages, Perl 6 specifies exception handlers by placing a <code>CATCH</code> block <i>within</i> that block that is having its exceptions handled.</p>

<p>The Perl 6 equivalent to Perl 5&#39;s <code>eval {...}</code> is <code>try {...}</code>. (Perl 6&#39;s <code>eval</code> function only evaluates strings, not blocks.) A <code>try</code> block by default has a <code>CATCH</code> block that handles all exceptions by ignoring them. If you define a <code>CATCH</code> block within the <code>try</code>, it replaces the default <code>CATCH</code>. It also makes the <code>try</code> keyword redundant, because any block can function as a <code>try</code> block if you put a <code>CATCH</code> block within it.</p>

<p>An exception handler is just a switch statement on an implicit topic supplied within the <code>CATCH</code> block. That implicit topic is the current exception object, also known as <code>$!</code>. Inside the <code>CATCH</code> block, it&#39;s also bound to <code>$_</code>, since it&#39;s the topic. Because of smart matching, ordinary <code>when</code> statements are sufficiently powerful to pattern match the current exception against classes or patterns or numbers without any special syntax for exception handlers. If none of the cases in the <code>CATCH</code> handles the exception, the exception is rethrown. To ignore all unhandled exceptions, use an empty <code>default</code> case. (In other words, there is an implicit <code>die $!</code> just inside the end of the <code>CATCH</code> block. Handled exceptions break out past this implicit rethrow.)</p>

<p>A <code>CATCH</code> block sees the lexical scope in which it was defined, but its caller is the dynamic location that threw the exception. That is, the stack is not unwound until some exception handler chooses to unwind it by &#34;handling&#34; the exception in question. So logically, if the <code>CATCH</code> block throws its own exception, you would expect the <code>CATCH</code> block to catch its own exception recursively forever. However, a <code>CATCH</code> must not behave that way, so we say that a <code>CATCH</code> block never attempts to handle any exception thrown within its own dynamic scope. (Otherwise the <code>die</code> in the previous paragraph would never work.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Control_Exceptions"
>Control Exceptions</a></h1>

<p>All abnormal control flow is, in the general case, handled by the exception mechanism (which is likely to be optimized away in specific cases.) Here &#34;abnormal&#34; means any transfer of control outward that is not just falling off the end of a block. A <code>return</code>, for example, is considered a form of abnormal control flow, since it can jump out of multiple levels of closures to the end of the scope of the current subroutine definition. Loop commands like <code>next</code> are abnormal, but looping because you hit the end of the block is not. The implicit break of a <code>when</code> block is abnormal.</p>

<p>A <code>CATCH</code> block handles only &#34;bad&#34; exceptions, and lets control exceptions pass unhindered. Control exceptions may be caught with a <code>CONTROL</code> block. Generally you don&#39;t need to worry about this unless you&#39;re defining a control construct. You may have one <code>CATCH</code> block and one <code>CONTROL</code> block, since some user-defined constructs may wish to supply an implicit <code>CONTROL</code> block to your closure, but let you define your own <code>CATCH</code> block.</p>

<p>A <code>return</code> always exits from the lexically surrounding sub or method definition (that is, from a function officially declared with the <code>sub</code>, <code>method</code>, or <code>submethod</code> keywords). Pointy blocks and bare closures are transparent to <code>return</code>. If you pass a closure object outside of its official &#34;sub&#34; scope, it is illegal to return from it. You may only leave the closure block itself with <code>leave</code> or by falling off the end of it.</p>

<p>To return a value from a pointy block or bare closure, you either just let the block return the value of its final expression, or you can use <code>leave</code>. A <code>leave</code> by default exits from the innermost block. But you may change the behavior of <code>leave</code> with a selector as the first argument:</p>

<pre>    leave Loop where { .label ~~ &#39;LINE&#39; }, 1,2,3;</pre>

<p>The innermost block matching the selection criteria will be exited. The return value, if any, must be passed as the second and subsequent arguments. To return pairs as part of the value, you can use a feed operator:</p>

<pre>    leave &#60;== :foo:bar:baz(1) if $leaving;</pre>

<p>or going the other way:</p>

<pre>    $leaving and :foo:bar:baz(1) ==&#62; leave;</pre>

<p>In theory, any user-defined control construct can catch any control exception it likes. However, there have to be some culturally enforced standards on which constructs capture which exceptions. Much like <code>return</code> may only return from an &#34;official&#34; subroutine or method, a loop exit like <code>next</code> should be caught by the construct the user expects it to be caught by. In particular, if the user labels a loop with a specific label, and calls a loop control from within the lexical scope of that loop, and if that call mentions the outer loop&#39;s label, then that outer loop is the one that must be controlled. (This search of lexical scopes is limited to the current &#34;official&#34; subroutine.)</p>

<p>If there is no such lexically scoped outer loop in the current subroutine, then a fallback search is made outward through the dynamic scopes in the same way Perl 5 does. (The difference between Perl 5 and Perl 6 in this respect arises only because Perl 5 didn&#39;t have user-defined control structures, hence the sub&#39;s lexical scope was <i>always</i> the innermost dynamic scope, so the preference to the lexical scope in the current sub was implicit. For Perl 6 we have to make this preference explicit.)</p>

<p>Warnings are produced in Perl 6 by throwing a resumable control exception to the outermost scope, which by default prints the warning and resumes the exception by extracting a resume continuation from the exception, which must be supplied by the warn() function (or equivalent). Exceptions are not resumable in Perl 6 unless the exception object does the <code>Resumable</code> role. (Note that fatal exception types can do the <code>Resumable</code> role even if thrown via <code>fail()</code>--when uncaught they just hit the outermost fatal handler instead of the outermost warning handler, so some inner scope has to explicitly treat them as warnings and resume them.)</p>

<p>Since warnings are processed using the standard control exception mechanism, they may be intercepted and either suppressed or fatalized anywhere within the dynamic scope by supplying a suitable <code>CONTROL</code> block. This dynamic control is orthogonal to any lexically scoped warning controls, which merely decide whether to call <code>warn()</code> in the first place.</p>

<p>As with calls to <code>return</code>, the warning control exception is an abstraction that the compiler is free to optimize away (along with the associated continuation) when the compiler or runtime can determine that the semantics would be preserved by merely printing out the error and going on. Since all exception handlers run in the dynamic context of the throw, that reduces to simply returning from the <code>warn</code> function most of the time.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="The_goto_statement"
>The goto statement</a></h1>

<p>In addition to <code>next</code>, <code>last</code>, and <code>redo</code>, Perl 6 also supports <code>goto</code>. As with ordinary loop controls, the label is searched for first lexically within the current subroutine, then dynamically outside of it. Unlike with loop controls, however, scanning a scope includes a scan of any lexical scopes included within the current candidate scope. As in Perl 5, it is possible to <code>goto</code> into a lexical scope, but only for lexical scopes that require no special initialization of parameters. (Initialization of ordinary variables does not count--presumably the presence of a label will prevent code-movement optimizations past the label.) So, for instance, it&#39;s always possible to <code>goto</code> into the next case of a <code>when</code> or into either the &#34;then&#34; or &#34;else&#34; branch of a conditional. You may not go into a <code>given</code> or a <code>for</code>, though, because that would bypass a formal parameter binding (not to mention list generation in the case of <code>for</code>). (Note: the implicit default binding of an outer $_ to an inner $_ can be emulated for a bare block, so that doesn&#39;t fall under the prohibition on bypassing formal binding.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Exceptions"
>Exceptions</a></h1>

<p>As in Perl 5, many built-in functions simply return undef when you ask for a value out of range, or the function fails somehow. Perl 6 has <code>Failure</code> objects, any of which refers to an unthrown <code>Exception</code> object in <code>$!</code> and knows whether it has been handled or not.</p>

<p>If you test a <code>Failure</code> for <code>.defined</code> or <code>.true</code>, it causes <code>$!</code> to mark the exception as <i>handled</i>, and acts as a harmless <code>Undef</code> value thereafter. Any other use of the <code>Failure</code> will throw its associated exception immediately.</p>

<p>Because the contextual variable <code>$!</code> contains all exceptions collected in the current lexical scope, saying <code>die $!</code> will throw all exceptions, whether they were handled or not. A bare <code>die</code>/<code>fail</code> takes <code>$!</code> as the default argument.</p>

<p>At scope exit, <code>$!</code> discards all handled exceptions from itself, then performs a garbage-collection check for all remaining (unhandled) exceptions. If all of them are still alive (e.g. by becoming part of the return value), then they are appended to <code>CALLER::&#60;$!&#62;</code>. Otherwise, it calls <code>die</code> to throw those exceptions as a single new exception, which may then be caught with a <code>CATCH</code> block in the current (or caller&#39;s) scope.</p>

<p>You can cause built-ins to automatically throw exceptions on failure using</p>

<pre>    use fatal;</pre>

<p>The <code>fail</code> function responds to the caller&#39;s <code>use fatal</code> state. It either returns an unthrown exception, or throws the exception.</p>

<a name="msg_12"></a>
<a href="?hide_quotes=no#msg_12" onclick="return tog_quote(12);">
<div ID="header_shown_12" style="display: none;">
- Hide the snippet from t/builtins/control_flow/fail.t (line 7 ~ line 34) -
</div>
<div ID="header_hidden_12" style="display: block;">
- Show the snippet from t/builtins/control_flow/fail.t (line 7 ~ line 34, 28 lines) -
</div>
</a>
<div ID="hide_12" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/&quot;Exceptions&quot; /The fail function/&gt;

{
  # &quot;use fatal&quot; is not standard, so we don't have to disable it here
  my $was_after_fail  = 0;
  my $was_before_fail = 0;
  my $sub = sub { $was_before_fail++; my $exception = fail_ 42; $was_after_fail++ };

  my $unthrown_exception = $sub();
  # Note: We don't further access $unthrown_exception, so it doesn't get thrown
  is $was_before_fail, 1, &quot;fail() doesn't cause our sub to not get executed&quot;;
  is $was_after_fail,  0, &quot;fail() causes our sub to return (1)&quot;;
}

{
  # Explicitly &quot;use fatal&quot;
  # use fatal; -- Commented as there's no fatal.pm yet.
  # Instead, we set the magical variable $?FAIL_SHOULD_DIE to a true value.
  my $?FAIL_SHOULD_DIE = 1;
  my $was_after_fail = 0;
  my $was_after_sub  = 0;
  my $sub = sub { fail_ 42; $was_after_fail++ };

  try { $sub(); $was_after_sub++ };

  is $was_after_fail, 0, &quot;fail() causes our sub to return (2)&quot;;
  is $was_after_sub,  0, &quot;fail() causes our try{} to die&quot;;
}</pre>
</div>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Closure_traits"
>Closure traits</a></h1>

<a name="msg_23"></a>
<a href="?hide_quotes=no#msg_23" onclick="return tog_quote(23);">
<div ID="header_shown_23" style="display: none;">
- Hide the snippet from t/closure_traits/in_loop.t (line 18 ~ line 70) -
</div>
<div ID="header_hidden_23" style="display: block;">
- Show the snippet from t/closure_traits/in_loop.t (line 18 ~ line 70, 53 lines) -
</div>
</a>
<div ID="hide_23" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/&quot;Closure traits&quot;&gt;

{
    my $str;

    for 1..10 -&gt; $i {
        last if $i &gt; 3;
        $str ~= &quot;($i a)&quot;;
        next if $i % 2 == 1;
        $str ~= &quot;($i b)&quot;;
        LAST  { $str ~= &quot;($i Last)&quot; }
        LEAVE { $str ~= &quot;($i Leave)&quot; }
        NEXT  { $str ~= &quot;($i N)&quot; }
        START { $str ~= &quot;($i S)&quot; }
        ENTER { $str ~= &quot;($i E)&quot; }
    }

    is $str, &quot;(1 S)(1 E)(1 a)&quot; ~ &quot;(1 N)(1 Leave)&quot; ~
                  &quot;(2 E)(2 a)(2 b)(2 N)(2 Leave)&quot; ~
                  &quot;(3 E)(3 a)&quot; ~ &quot;(3 N)(3 Leave)&quot; ~
                  &quot;(4 E)&quot;  ~  &quot;(4 Last)(4 Leave)&quot;,
       'trait blocks work properly in for loop';
}

{
    my $str;

    for 1..10 -&gt; $i {
        last if $i &gt; 3;
        $str ~= &quot;($i a)&quot;;

        ENTER { $str ~= &quot;($i E1)&quot; }
        LAST  { $str ~= &quot;($i Last1)&quot; }
        START { $str ~= &quot;($i S1)&quot; }
        LEAVE { $str ~= &quot;($i Leave1)&quot; }

        next if $i % 2 == 1;
        $str ~= &quot;($i b)&quot;;

        LAST  { $str ~= &quot;($i Last2)&quot; }
        NEXT  { $str ~= &quot;($i N1)&quot; }
        START { $str ~= &quot;($i S2)&quot; }
        LEAVE { $str ~= &quot;($i Leave2)&quot; }
        ENTER { $str ~= &quot;($i E2)&quot; }
        NEXT  { $str ~= &quot;($i N2)&quot; }
    }

    is $str, &quot;(1 S1)(1 S2)(1 E1)(1 E2)(1 a)&quot; ~ &quot;(1 N1)(1 N2)&quot; ~  &quot;(1 Leave1)(1 Leave2)&quot; ~
                         &quot;(2 E1)(2 E2)(2 a)(2 b)(2 N1)(2 N2)&quot; ~  &quot;(2 Leave1)(2 Leave2)&quot; ~
                         &quot;(3 E1)(3 E2)(3 a)&quot; ~ &quot;(3 N1)(3 N2)&quot; ~  &quot;(3 Leave1)(3 Leave2)&quot; ~
                         &quot;(4 E1)(4 E2)&quot;  ~     &quot;(4 Last1)(4 Last2)(4 Leave1)(4 Leave2)&quot;,
       'trait blocks work properly in for loop';
}</pre>
</div>


<p>A <code>CATCH</code> block is just a trait of the closure containing it. Other blocks can be installed as traits as well. These other blocks are called at various times, and some of them respond to various control exceptions and exit values:</p>

<pre>      BEGIN {...}*      at compile time, ASAP, only ever runs once
      CHECK {...}*      at compile time, ALAP, only ever runs once
       INIT {...}*      at run time, ASAP, only ever runs once</pre>

<a name="msg_22"></a>
<a href="?hide_quotes=no#msg_22" onclick="return tog_quote(22);">
<div ID="header_shown_22" style="display: none;">
- Hide the snippet from t/closure_traits/init.t (line 7 ~ line 68) -
</div>
<div ID="header_hidden_22" style="display: block;">
- Show the snippet from t/closure_traits/init.t (line 7 ~ line 68, 62 lines) -
</div>
</a>
<div ID="hide_22" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/&quot;Closure traits&quot;/INIT &quot;at run time&quot; ASAP&gt;
# INIT {...} blocks in &quot;void&quot; context
{
    my $str;
    is $str, &quot;begin1 begin2 init &quot;, &quot;init blocks run after begin blocks&quot;;

    BEGIN { $str ~= &quot;begin1 &quot;; }
    INIT  { $str ~= &quot;init &quot;; }
    BEGIN { $str ~= &quot;begin2 &quot;; }
}

{
    my $str;
    is $str, &quot;check2 check1 init &quot;, &quot;init blocks run after check blocks&quot;;

    CHECK { $str ~= &quot;check1 &quot;; }
    INIT  { $str ~= &quot;init &quot;; }
    CHECK { $str ~= &quot;check2 &quot;; }
}

{
    my $str;
    is $str, &quot;begin init1 init2 &quot;, &quot;init blocks run in forward order&quot;;

    INIT  { $str ~= &quot;init1 &quot;; }
    BEGIN { $str ~= &quot;begin &quot;; }
    INIT  { $str ~= &quot;init2 &quot;; }
}

# INIT {...} blocks as rvalues
{
    my $str;
    my $handle = { my $retval = INIT { $str ~= 'I' } };

    is $str, 'I', 'our INIT {...} block already gets called';
    is $handle(), 'I', 'our INIT {...} block returned the correct var (1)';
    is $handle(), 'I', 'our INIT {...} block returned the correct var (2)';
    is $str, 'I', 'our rvalue INIT {...} block was executed exactly once';
}

# IRC note:
# ---------------------------------------------------------------
# &lt;TimToady1&gt; also, the INIT's settings are going to get wiped
#             out when the my is executed, so you probably just
#             end up with 'o'
{
    my $str = 'o';
    INIT { $str ~= 'i' }
    is $str, 'o', 'the value set by INIT {} wiped out by the initializer of $str';
}

# IRC note:
# ---------------------------------------------------------------
# &lt;TimToady1&gt; INIT runs once just before the mainline code runs.
# &lt;agentzh&gt; even if INIT is in a block?
# &lt;TimToady1&gt; yes.
my $str ~= 'o';  # Note that this is different from  &quot;my $str = 'o';&quot;.
{
    INIT { $str ~= 'i' }
}
is $str, 'io', 'INIT {} always runs before the mainline code runs';</pre>
</div>


<pre>        END {...}       at run time, ALAP, only ever runs once</pre>

<a name="msg_25"></a>
<a href="?hide_quotes=no#msg_25" onclick="return tog_quote(25);">
<div ID="header_shown_25" style="display: none;">
- Hide the snippet from t/closure_traits/ascending_order.t (line 11 ~ line 59) -
</div>
<div ID="header_hidden_25" style="display: block;">
- Show the snippet from t/closure_traits/ascending_order.t (line 11 ~ line 59, 49 lines) -
</div>
</a>
<div ID="hide_25" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/Closure traits/END &quot;at run time&quot; ALAP&gt;

my $var;
my ($var_at_begin, $var_at_check, $var_at_init, $var_at_start, $var_at_enter);
my $eof_var;

$var = 13;

my $hist;

BEGIN {
    $hist ~= 'begin ';
    $var_at_begin = $var;
}

CHECK {
    $hist ~= 'check ';
    $var_at_check = $var;
}

INIT {
    $hist ~= 'init ';
    $var_at_init = $var;
}

ENTER {
    $hist ~= 'enter ';
    $var_at_enter = $var;
}

START {
    $hist ~= 'start ';
    $var_at_start = $var + 1;
}

END {
    # tests for END blocks:
    is $var, 13, '$var gets initialized at END time';
    is $eof_var, 29, '$eof_var gets assigned at END time';
}

is $hist, 'begin check init start ', 'BEGIN {} runs only once';
is $var_at_begin, undef, 'BEGIN {...} ran at compile time';
is $var_at_check, undef, 'CHECK {...} ran at compile time';
is $var_at_init, undef, 'INIT {...} ran at runtime, but ASAP';
is $var_at_enter, undef, 'ENTER {...} at runtime, but before the mainline body';
is $var_at_start, 14, 'START {...} at runtime, just in time';

$eof_var = 29;</pre>
</div>


<a name="msg_24"></a>
<a href="?hide_quotes=no#msg_24" onclick="return tog_quote(24);">
<div ID="header_shown_24" style="display: none;">
- Hide the snippet from t/closure_traits/descending_order.t (line 11 ~ line 53) -
</div>
<div ID="header_hidden_24" style="display: block;">
- Show the snippet from t/closure_traits/descending_order.t (line 11 ~ line 53, 43 lines) -
</div>
</a>
<div ID="hide_24" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/Closure traits/END &quot;at run time&quot; ALAP&gt;

my $var;
my ($var_at_enter, $var_at_init, $var_at_check, $var_at_begin);
my $eof_var;

$var = 13;

my $hist;

END {
    # tests for END blocks:
    is $var, 13, '$var gets initialized at END time';
    is $eof_var, 29, '$eof_var gets assigned at END time';
}

ENTER {
    $hist ~= 'enter ';
    $var_at_enter = $var;
}

INIT {
    $hist ~= 'init ';
    $var_at_init = $var;
}

CHECK {
    $hist ~= 'check ';
    $var_at_check = $var;
}

BEGIN {
    $hist ~= 'begin ';
    $var_at_begin = $var;
}

is $hist, 'begin check init first ', 'BEGIN {} runs only once';
is $var_at_begin, undef, 'BEGIN {...} ran at compile time';
is $var_at_check, undef, 'CHECK {...} ran at compile time';
is $var_at_init, undef, 'INIT {...} ran at runtime, but ASAP';
is $var_at_enter, undef, 'ENTER {...} at runtime, but before the mainline body';

$eof_var = 29;</pre>
</div>


<a name="msg_20"></a>
<a href="?hide_quotes=no#msg_20" onclick="return tog_quote(20);">
<div ID="header_shown_20" style="display: none;">
- Hide the snippet from t/closure_traits/interpolate.t (line 11 ~ line 40) -
</div>
<div ID="header_hidden_20" style="display: block;">
- Show the snippet from t/closure_traits/interpolate.t (line 11 ~ line 40, 30 lines) -
</div>
</a>
<div ID="hide_20" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/Closure traits/END &quot;at run time&quot; ALAP&gt;

# IRC log:
# ----------------------------------------------------------------
# agentzh   question: should BEGIN blocks interpolated in double-quoted
#           strings be fired at compile-time or run-time?
#           for example, say &quot;This is { BEGIN { say 'hi' } }&quot;;
# audreyt   compile time.
#           qq is not eval.

my $hist;

END {
    is $hist, 'BCISE', 'interpolated END {...} executed';
}

is &quot;{ END { $hist ~= 'E' } }&quot;, undef,
    'END {...} not yet executed';

is &quot;{ START { $hist ~= 'S' } }&quot;, &quot;BCIS&quot;,
    'START {...} fired at run-time, entry time of the mainline code';

is &quot;{ INIT { $hist ~= 'I' } }&quot;, 'BCI',
    'INIT {...} fired at the beginning of runtime';

is &quot;{ CHECK { $hist ~= 'C' } }&quot;, &quot;BC&quot;,
    'CHECK {...} fired at compile-time, ALAP';

is &quot;{ BEGIN { $hist ~= 'B' } }&quot;, &quot;B&quot;,
    'BEGIN {...} fired at compile-time, ASAP';</pre>
</div>


<pre>      START {...}*      on first ever execution, once per closure clone

      ENTER {...}*      at every block entry time, repeats on loop blocks.
      LEAVE {...}       at every block exit time 
       KEEP {...}       at every successful block exit, part of LEAVE queue
       UNDO {...}       at every unsuccessful block exit, part of LEAVE queue

      FIRST {...}*      at loop initialization time, before any ENTER
       NEXT {...}       at loop continuation time, before any LEAVE
       LAST {...}       at loop termination time, after any LEAVE

        PRE {...}       assert precondition at every block entry, before any
       POST {...}       assert postcondition at every block exit, after any

      CATCH {...}       catch exceptions, before LEAVE
    CONTROL {...}       catch control exceptions, before LEAVE</pre>

<p>Those marked with a <code>*</code> can also be used within an expression:</p>

<a name="msg_18"></a>
<a href="?hide_quotes=no#msg_18" onclick="return tog_quote(18);">
<div ID="header_shown_18" style="display: none;">
- Hide the snippet from t/closure_traits/rvalue.t (line 10 ~ line 49) -
</div>
<div ID="header_hidden_18" style="display: block;">
- Show the snippet from t/closure_traits/rvalue.t (line 10 ~ line 49, 40 lines) -
</div>
</a>
<div ID="hide_18" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/Closure traits/&quot;marked with a *&quot; &quot;used within&quot; expression&gt;

my $hist = '';

# Test INIT {} as rval:

my $init_val;
my $init = {
    $init_val = INIT { $hist ~= 'I' };
}

is $init(), 'BCI', 'INIT {} runs only once';
is $init_val, 'BCI', 'INIT {} as rval is its ret val';
is $init(), 'BCI', 'INIT {} runs only once';

# Test CHECK {} as rval:

my $check_val;
my $check = {
    $check_val = CHECK { $hist ~= 'C' };
}

is $check(), 'BC', 'CHECK {} runs only once';
is $check_val, 'BC', 'CHECK {} as rval is its ret val';
is $check(), 'BC', 'CHECK {} runs only once';

# Test BEGIN {} as rval:

my $begin_val;
my $begin = {
    $begin_val = BEGIN { $hist ~= 'B' };
}

is $begin(), 'B', 'BEGIN {} runs only once';
is $begin_val, 'B', 'BEGIN {} as rval is its ret val';
is $begin(), 'B', 'BEGIN {} runs only once';

# Test END {} as rval:

ok !eval 'my $end_val = END { 3 }', &quot;END {} can't be used as a rvalue&quot;;</pre>
</div>


<pre>    my $compiletime = BEGIN { localtime };
    our $temphandle = START { maketemp() };</pre>

<p>Code that is generated at run time can still fire off <code>CHECK</code> and <code>INIT</code> blocks, though of course those blocks can&#39;t do things that would require travel back in time.</p>

<p>Some of these also have corresponding traits that can be set on variables. These have the advantage of passing the variable in question into the closure as its topic:</p>

<pre>    my $r will start { .set_random_seed() };
    our $h will enter { .rememberit() } will undo { .forgetit() };</pre>

<p>Apart from <code>CATCH</code> and <code>CONTROL</code>, which can only occur once, most of these can occur multiple times within the block. So they aren&#39;t really traits, exactly--they add themselves onto a list stored in the actual trait (except for <code>START</code>, which executes inline). So if you examine the <code>ENTER</code> trait of a block, you&#39;ll find that it&#39;s really a list of closures rather than a single closure.</p>

<a name="msg_19"></a>
<a href="?hide_quotes=no#msg_19" onclick="return tog_quote(19);">
<div ID="header_shown_19" style="display: none;">
- Hide the snippet from t/closure_traits/multiple.t (line 11 ~ line 38) -
</div>
<div ID="header_hidden_19" style="display: block;">
- Show the snippet from t/closure_traits/multiple.t (line 11 ~ line 38, 28 lines) -
</div>
</a>
<div ID="hide_19" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/Closure traits/&quot;occur multiple times&quot;&gt;
# IRC log:
# [05:41] &lt;agentzh&gt; TimToady: S04 doesn't discuss the running order 
#                   of multiple closure traits (say, two END {} in 
#                   the same scope), so should we assume it's the
#                   same as in Perl 5?
# [05:41] &lt;TimToady&gt; yes

my $hist;

END { is $hist, 'B b c C I i S s end End ', 'running order of multiple closure traits' }

END { $hist ~= 'End ' }
END { $hist ~= 'end ' }

START { $hist ~= 'S ' }
START { $hist ~= 's ' }

INIT { $hist ~= 'I ' }
INIT { $hist ~= 'i ' }

CHECK { $hist ~= 'C ' }
CHECK { $hist ~= 'c ' }

BEGIN { $hist ~= 'B ' }
BEGIN { $hist ~= 'b ' }

is $hist, 'B b c C I i S s ', 'running order of multiple closure traits';</pre>
</div>


<p>The semantics of <code>INIT</code> and <code>START</code> are not equivalent to each other in the case of cloned closures. An <code>INIT</code> only runs once for all copies of a cloned closure. A <code>START</code> runs separately for each clone, so separate clones can keep separate state variables:</p>

<a name="msg_21"></a>
<a href="?hide_quotes=no#msg_21" onclick="return tog_quote(21);">
<div ID="header_shown_21" style="display: none;">
- Hide the snippet from t/closure_traits/init.t (line 69 ~ line 76) -
</div>
<div ID="header_hidden_21" style="display: block;">
- Show the snippet from t/closure_traits/init.t (line 69 ~ line 76, 8 lines) -
</div>
</a>
<div ID="hide_21" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/Closure traits/INIT &quot;runs once for all copies of&quot; &quot;cloned closure&quot;&gt;
{
	my $var;
	for &lt;first second&gt; {
		my $sub = { INIT { $var++ } };
		is $var, 1, &quot;INIT has run exactly once ($_ time)&quot;;
	}
}</pre>
</div>


<pre>    our $i = 0;
    ...
    $func = { state $x will start { $x = $i++ }; dostuff($i) };</pre>

<p>But <code>state</code> automatically applies &#34;start&#34; semantics to any initializer, so this also works:</p>

<pre>    $func = { state $x = $i++; dostuff($i) }</pre>

<p>Each subsequent clone gets an initial state that is one higher than the previous, and each clone maintains its own state of <code>$x</code>, because that&#39;s what <code>state</code> variables do.</p>

<p>Even in the absence of closure cloning, <code>INIT</code> runs before the mainline code, while <code>START</code> puts off the initialization till the last possible moment, then runs exactly once, and caches its value for all subsequent calls (assuming it wasn&#39;t called in void context, in which case the <code>START</code> is evaluated once only for its side effects).</p>

<p>All of these trait blocks can see any previously declared lexical variables, even if those variables have not been elaborated yet when the closure is invoked (in which case the variables evaluate to an undefined value.)</p>

<p>Note: Apocalypse 4 confused the notions of <code>PRE</code>/<code>POST</code> with <code>ENTER</code>/<code>LEAVE</code>. These are now separate notions. <code>ENTER</code> and <code>LEAVE</code> are used only for their side effects. <code>PRE</code> and <code>POST</code> must return boolean values that are evaluated according to the usual Design by Contract (DBC) rules. (Plus, if you use <code>ENTER</code>/<code>LEAVE</code> in a class block, they only execute when the class block is executed, but <code>PRE</code>/<code>POST</code> in a class block are evaluated around every method in the class.) <code>KEEP</code> and <code>UNDO</code> are just variants of <code>LEAVE</code>, and for execution order are treated as part of the queue of <code>LEAVE</code> blocks.</p>

<p><code>FIRST</code>, <code>NEXT</code>, and <code>LAST</code> are meaningful only within the lexical scope of a loop, and may occur only at the top level of such a loop block. A <code>NEXT</code> executes only if the end of the loop block is reached normally, or an explicit <code>next</code> is executed. In distinction to <code>LEAVE</code> blocks, a <code>NEXT</code> block is not executed if the loop block is exited via any exception other than the control exception thrown by <code>next</code>. In particular, a <code>last</code> bypasses evaluation of <code>NEXT</code> blocks.</p>

<p>[Note: the name <code>FIRST</code> used to be associated with <code>state</code> declarations. Now it is associated only with loops. See the <code>START</code> above for <code>state</code> semantics.]</p>

<p><code>LEAVE</code> blocks are evaluated after <code>CATCH</code> and <code>CONTROL</code> blocks, including the <code>LEAVE</code> variants, <code>KEEP</code> and <code>UNDO</code>. <code>POST</code> blocks are evaluated after everything else, to guarantee that even <code>LEAVE</code> blocks can&#39;t violate DBC. Likewise <code>PRE</code> blocks fire off before any <code>ENTER</code> or <code>FIRST</code> (though not before <code>BEGIN</code>, <code>CHECK</code>, or <code>INIT</code>, since those are done at compile or process initialization time).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Statement_parsing"
>Statement parsing</a></h1>

<p>In this statement:</p>

<pre>    given EXPR {
        when EXPR { ... }
        when EXPR { ... }
        ...
    }</pre>

<p>parentheses aren&#39;t necessary around <code>EXPR</code> because the whitespace between <code>EXPR</code> and the block forces the block to be considered a block rather than a subscript. This works for all control structures, not just the new ones in Perl 6. A top-level bare block is always considered a statement block if there&#39;s space before it:</p>

<pre>    if $foo { ... }
    elsif $bar { ... }
    else { ... }
    while $more { ... }
    for 1..10 { ... }</pre>

<p>You can still parenthesize the expression argument for old times&#39; sake, as long as there&#39;s a space between the closing paren and the opening brace. You <i>must</i> parenthesize the expression if there is a bare block or pointy block that would be misinterpreted as the statement&#39;s block. This is regardless of whether a term or operator is expected where the block occurs. (A block inside brackets, or used as a postcircumfix is fine, though.) Any block with whitespace in front of it will be taken as terminating the conditional, even if the conditional expression could take another argument. Therefore</p>

<pre>    if rand { say &#34;exists&#34; } { extra() }
    if rand -&#62; $x { say &#34;exists&#34; } { extra() }</pre>

<p>is always parsed as</p>

<pre>    if (rand) { say &#34;exists&#34; }; { extra() }
    if (rand) -&#62; $x { say &#34;exists&#34; }; { extra() }</pre>

<p>rather than</p>

<pre>    if (rand { say &#34;exists&#34; }) { extra() }
    if (rand (-&#62; $x { say &#34;exists&#34; })) { extra() }</pre>

<p>Apart from that, it is illegal to use a bare closure where an operator is expected. (Remove the whitespace if you wish it to be a postcircumfix.)</p>

<p>Anywhere a term is expected, a block is taken to be a closure definition (an anonymous subroutine). If the closure is empty, or appears to contain nothing but a comma-separated list starting with a pair or a hash (counting a single pair or hash as a list of one element), the closure will be immediately executed as a hash composer.</p>

<pre>    $hash = { };
    $hash = { %stuff };
    $hash = { &#34;a&#34; =&#62; 1 };
    $hash = { &#34;a&#34; =&#62; 1, $b, $c, %stuff, @nonsense };

    $code = { ; };
    $code = { @stuff };
    $code = { &#34;a&#34;, 1 };
    $code = { &#34;a&#34; =&#62; 1, $b, $c ==&#62; print };</pre>

<p>If you wish to be less ambiguous, the <code>hash</code> list operator will explicitly evaluate a list and compose a hash of the returned value, while <code>sub</code> introduces an anonymous subroutine:</p>

<pre>    $code = sub { &#34;a&#34; =&#62; 1 };
    $hash = hash(&#34;a&#34; =&#62; 1);
    $hash = hash(&#34;a&#34;, 1);</pre>

<p>If a closure is the right argument of the dot operator, the closure is interpreted as a hash subscript.</p>

<pre>    $code = {$x};       # closure because term expected
    if $term{$x}        # subscript because postfix expected
    if $term {$x}       # expression followed by statement block
    if $term.{$x}       # valid subscript with dot
    if $term\ .{$x}     # valid subscript with &#34;long dot&#34;</pre>

<p>Similar rules apply to array subscripts:</p>

<pre>    $array = [$x];      # array composer because term expected
    if $term[$x]        # subscript because postfix expected
    if $term [$x]       # syntax error (two terms in a row)
    if $term.[$x]       # valid subscript with dot
    if $term\ .[$x]     # valid subscript with &#34;long dot&#34;</pre>

<p>And to the parentheses delimiting function arguments:</p>

<pre>    $scalar = ($x);     # grouping parens because term expected
    if $term($x)        # function call because operator expected
    if $term ($x)       # syntax error (two terms in a row)
    if $term.($x)       # valid function call with dot
    if $term\ .($x)     # valid function call with &#34;long dot&#34;</pre>

<p>Outside of any kind of expression brackets, a final closing curly on a line (not counting whitespace or comments) always reverts to the precedence of semicolon whether or not you put a semicolon after it. (In the absence of an explicit semicolon, the current statement may continue on a subsequent line, but only with valid statement continuators such as <code>else</code> that cannot be confused with the beginning of a new statement. Anything else, such as a statement modifier (on, say, a <code>loop</code> statement) must continue on the same line, unless the newline be escaped using the &#34;unspace&#34; construct--see S02.)</p>

<p>Final blocks on statement-level constructs always imply semicolon precedence afterwards regardless of the position of the closing curly. Statement-level constructs are distinguished in the grammar by being declared in the statement syntactic group:</p>

<pre>    macro statement_control:&#60;if&#62; ($expr, &#38;ifblock) {...}
    macro statement_control:&#60;while&#62; ($expr, &#38;whileblock) {...}
    macro statement_control:&#60;BEGIN&#62; (&#38;beginblock) {...}</pre>

<p>Statement-level constructs may start only where the parser is expecting the start of a statement. To embed a statement in an expression you must use something like <code>do {...}</code> or <code>try {...}</code>.</p>

<a name="msg_11"></a>
<a href="?hide_quotes=no#msg_11" onclick="return tog_quote(11);">
<div ID="header_shown_11" style="display: none;">
- Hide the snippet from t/builtins/control_flow/try.t (line 5 ~ line 174) -
</div>
<div ID="header_hidden_11" style="display: block;">
- Show the snippet from t/builtins/control_flow/try.t (line 5 ~ line 174, 170 lines) -
</div>
</a>
<div ID="hide_11" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/&quot;Statement parsing&quot;/&quot;or try {...}&quot;&gt;

plan 26;

{
    # simple try
    my $lived = undef;
    try { die &quot;foo&quot; };
    is($!, &quot;foo&quot;, &quot;error var was set&quot;);
};

# try should work when returning an array or hash
{
    my @array = try { 42 };
    is +@array,    1, '@array = try {...} worked (1)';
    is ~@array, &quot;42&quot;, '@array = try {...} worked (2)';
}

{
    my @array = try { (42,) };
    is +@array,    1, '@array = try {...} worked (3)';
    is ~@array, &quot;42&quot;, '@array = try {...} worked (4)';
}

{
    my %hash = try { &quot;a&quot; };
    is +%hash,        1, '%hash = try {...} worked (1)';
    is ~%hash.keys, &quot;a&quot;, '%hash = try {...} worked (2)';
}

{
    my %hash = try { (&quot;a&quot;,) };
    is +%hash,        1, '%hash = try {...} worked (3)';
    is ~%hash.keys, &quot;a&quot;, '%hash = try {...} worked (4)';
}

{
    warn &quot;Please ignore the next warning about odd number of elements,\n&quot;;
    warn &quot;it's expected.\n&quot;;
    my %hash = try { hash(&quot;a&quot;,) };
    is +%hash,        1, '%hash = try {...} worked (5)';
    is ~%hash.keys, &quot;a&quot;, '%hash = try {...} worked (6)';
}

{
    my %hash;
    # Extra try necessary because current Pugs dies without it.
    try { %hash = try { a =&gt; 3 } };
    is +%hash,        1, '%hash = try {...} worked (7)', :todo&lt;bug&gt;;
    is ~%hash.keys, &quot;a&quot;, '%hash = try {...} worked (8)', :todo&lt;bug&gt;;
    is ~%hash&lt;a&gt;,     3, '%hash = try {...} worked (9)', :todo&lt;bug&gt;;
}

{
    # try with a catch
    my $caught;
    eval 'try {
        die &quot;blah&quot;

        CATCH { $caught = 1 }
    }';

    ok($caught, &quot;exception caught&quot;, :todo);
};

# return inside try{}-blocks
# PIL2JS *seems* to work, but it does not, actually:
# The &quot;return 42&quot; works without problems, and the caller actually sees the
# return value 42. But when the end of the test is reached, &amp;try will
# **resume after the return**, effectively running the tests twice.
# (Therefore I moved the tests to the end, so not all tests are rerun).
{
    my $was_in_foo;
    sub foo {
        $was_in_foo++;
        try { return 42 };
        $was_in_foo++;
        return 23;
    }
    is foo(), 42,      'return() inside try{}-blocks works (1)', :todo&lt;bug&gt;;
    is $was_in_foo, 1, 'return() inside try{}-blocks works (2)', :todo&lt;bug&gt;;
}

{
    my sub test1 {
        try { return 42 };
        return 23;
    }

    my sub test2 {
        test1();
        die 42;
    }

    dies_ok { test2() },
        &quot;return() inside a try{}-block should cause following exceptions to really die&quot;;
}

unless (eval 'Exception.new') {
    skip_rest &quot;No Exception objects&quot;; exit
}

{
    # exception classes
    class Naughty is Exception {};

    my ($not_died, $caught);
    eval 'try {
        die Naughty &quot;error&quot;

        $not_died = 1;

        CATCH {
            when Naughty {
                $caught = 1;
            }
        }
    }';

    ok(!$not_died, &quot;did not live after death&quot;);
    ok($caught, &quot;caught exception of class Naughty&quot;, :todo);
};

{
    # exception superclass
    class Naughty::Specific is Naughty {};
    class Naughty::Other is Naughty {};

    my ($other, $naughty);
    eval 'try {
        die Naughty::Specific &quot;error&quot;;

        CATCH {
            when Naughty::Other {
                $other = 1;
            }
            when Naughty {
                $naughty = 1;
            }
        }
    }';

    ok(!$other, &quot;did not catch sibling error class&quot;);
    ok($naughty, &quot;caught superclass&quot;, :todo);
};

{
    # uncaught class
    eval 'class Dandy is Exception {}';

    my ($naughty, $lived);
    eval 'try {
        die Dandy &quot;error&quot;;
        
        CATCH {
            when Naughty {
                $naughty = 1;
            }
        }
    };

    $lived = 1;
    ';

    ok(!$lived, &quot;did not live past uncaught throw in try&quot;);
    ok(~ref($!), '$! is an object');
    ok(!$naughty, &quot;did not get caught by wrong handler&quot;);
    is(eval('ref($!)'), Dandy, &quot;.. of the right class&quot;, :todo&lt;bug&gt;);
};</pre>
</div>


<pre>    $x =  do { given $foo { when 1 {2} when 3 {4} }} + $bar;
    $x = try { given $foo { when 1 {2} when 3 {4} }} + $bar;</pre>

<p>The existence of a <code>statement_control:&#60;BEGIN&#62;</code> does not preclude us from also defining a <code>prefix:&#60;BEGIN&#62;</code> that <i>can</i> be used within an expression:</p>

<pre>    macro prefix:&#60;BEGIN&#62; (&#38;beginblock) { beginblock().repr }</pre>

<p>Then you can say things like:</p>

<pre>    $recompile_by = BEGIN { time } + $expiration_time;</pre>

<p>But <code>statement_control:&#60;BEGIN&#62;</code> hides <code>prefix:&#60;BEGIN&#62;</code> at the start of a statement. You could also conceivably define a <code>prefix:&#60;if&#62;</code>, but then you may not get what you want when you say:</p>

<pre>    .print if $foo;</pre>

<p>since <code>prefix:&#60;if&#62;</code> would hide <code>statement_modifier:&#60;if&#62;</code>.</p>

<p>Built-in statement-level keywords require whitespace between the keyword and the first argument, as well as before any terminating loop. In particular, a syntax error will be reported for C-isms such as these:</p>

<pre>    if(...) {...}
    while(...) {...}
    for(...) {...}</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Definition_of_Success"
>Definition of Success</a></h1>

<a name="msg_30"></a>
<a href="?hide_quotes=no#msg_30" onclick="return tog_quote(30);">
<div ID="header_shown_30" style="display: none;">
- Hide the snippet from t/var/let.t (line 8 ~ line 70) -
</div>
<div ID="header_hidden_30" style="display: block;">
- Show the snippet from t/var/let.t (line 8 ~ line 70, 63 lines) -
</div>
</a>
<div ID="hide_30" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S04/&quot;Definition of Success&quot;&gt;
# let() should not restore the variable if the block exited successfully
# (returned a true value).
{
  my $a = 42;
  {
    let $a = 23;
    is $a, 23, &quot;let() changed the variable (1)&quot;;
    1;
  }
  is $a, 23, &quot;let() should not restore the variable, as our block exited succesfully (1)&quot;, :todo&lt;feature&gt;;
}

# let() should restore the variable if the block failed (returned a false
# value).
{
  my $a = 42;
  {
    let $a = 23;
    is $a, 23, &quot;let() changed the variable (1)&quot;;
    0;
  }
  is $a, 42, &quot;let() should restore the variable, as our block failed&quot;;
}

# Test that let() restores the variable at scope exit, not at subroutine
# entry.  (This might be a possibly bug.)
{
  my $a     = 42;
  my $get_a = { $a };
  {
    let $a = 23;
    is $a,       23, &quot;let() changed the variable (2-1)&quot;;
    is $get_a(), 23, &quot;let() changed the variable (2-2)&quot;, :todo&lt;feature&gt;;
    1;
  }
  is $a, 23, &quot;let() should not restore the variable, as our block exited succesfully (2)&quot;, :todo&lt;feature&gt;;
}

# Test that let() restores variable even when not exited regularly (using a
# (possibly implicit) call to return()), but when left because of an exception.
{
  my $a = 42;
  try {
    let $a = 23;
    is $a, 23, &quot;let() changed the variable in a try block&quot;;
    die 57;
  };
  is $a, 42, &quot;let() restored the variable, the block was exited using an exception&quot;;
}

eval('
{
  my @array = (0, 1, 2);
  {
    let @array[1] = 42;
    is @array[1], 42, &quot;let() changed our array element&quot;;
    0;
  }
  is @array[1], 1, &quot;let() restored our array element&quot;;
}
&quot;1 - delete this line when the parsefail eval() is removed&quot;;
') or skip(2, &quot;parsefail: let \@array[1]&quot;);</pre>
</div>


<p>Hypothetical variables are somewhat transactional--they keep their new values only on successful exit of the current block, and otherwise are rolled back to their original values.</p>

<p>It is, of course, a failure to leave the block by propagating an error exception, though returning a defined value after catching an exception is okay.</p>

<p>In the absence of error exception propagation, a successful exit is one that returns a defined value in scalar context, or any number of values in list context as long as the length is defined. (A length of +Inf is considered a defined length. A length of 0 is also a defined length, which means it&#39;s a &#34;successful&#34; return even though the list would evaluate to false in a boolean context.) A list can have a defined length even if it contains undefined scalar values. A list is of undefined length only if it contains an undefined generator, which, happily, is what is returned by the <code>undef</code> function when used in list context. So any Perl 6 function can say</p>

<pre>    return undef;</pre>

<p>and not care about whether the fu