<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<meta HTTP-EQUIV="content-type" CONTENT="text/html; charset=UTF-8">
<head>
<title>S04</title>
<link rel="stylesheet" href="http://dev.perl.org/css/perl.css" type="text/css" />
<link rev="made" href="mailto:" />
<script language="javascript1.2"><!--
var agt = navigator.userAgent.toLowerCase();

var is_opera = (agt.indexOf("opera") != -1);
var is_ie = (agt.indexOf("msie") != -1) && document.all && !is_opera;
var is_ie5 = (agt.indexOf("msie 5") != -1) && document.all;

function tog() {
  // tog: toggle the visibility of html elements (arguments[1..]) from none to
  // arguments[0].  Return what should be returned in a javascript onevent().
  display = arguments[0];
  for( var i=1; i<arguments.length; i++ ) {    
    var x = document.getElementById(arguments[i]);
    if (!x) continue;
    if (x.style.display == "none" || x.style.display == "") {
      x.style.display = display;
    } else {
      x.style.display = "none";
    }
  } 

  var e = is_ie ? window.event : this;
  if (e) {
    if (is_ie) {
      e.cancelBubble = true;
      e.returnValue = false;
      return false;
    } else {
      return false;
    }
  }
}

function tog_quote( idnum ) {
  return tog( 'block', 'header_shown_' + idnum, 'header_hidden_' + idnum,
	   'hide_' + idnum );
}

//--></script>
</head>

<body>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" valign="middle">
<big><strong><span class="block">&nbsp;TITLE</span></strong></big>
</td></tr>
</table>

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#TITLE">TITLE</a></li>
	<li><a href="#AUTHOR">AUTHOR</a></li>
	<li><a href="#VERSION">VERSION</a></li>
	<li><a href="#The20Relationship20of20Blocks20and20Declarations">The Relationship of Blocks and Declarations</a></li>
	<li><a href="#Statement2dending20blocks">Statement-ending blocks</a></li>
	<li><a href="#Conditional20statements">Conditional statements</a></li>
	<li><a href="#Loop20statements">Loop statements</a></li>
	<ul>

		<li><a href="#The20while20and20until20statements">The <code>while</code> and <code>until</code> statements</a></li>
		<li><a href="#The20repeat20statement">The <code>repeat</code> statement</a></li>
		<li><a href="#The20general20loop20statement">The general loop statement</a></li>
		<li><a href="#The20for20statement">The <code>for</code> statement</a></li>
		<li><a href="#The20do2donce20loop">The do-once loop</a></li>
	</ul>

	<li><a href="#Switch20statements">Switch statements</a></li>
	<li><a href="#Exception20handlers">Exception handlers</a></li>
	<li><a href="#Control20Exceptions">Control Exceptions</a></li>
	<li><a href="#The20goto20statement">The goto statement</a></li>
	<li><a href="#Exceptions">Exceptions</a></li>
	<li><a href="#Closure20traits">Closure traits</a></li>
	<li><a href="#Statement20parsing">Statement parsing</a></li>
	<li><a href="#Definition20of20Success">Definition of Success</a></li>
	<li><a href="#When20is20a20closure20not20a20closure">When is a closure not a closure</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="TITLE">TITLE</a></h1>
<p>Synopsis 4: Blocks and Statements</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="AUTHOR">AUTHOR</a></h1>
<p>Larry Wall &lt;<a href="mailto:larry@wall.org">larry@wall.org</a>&gt;</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="VERSION">VERSION</a></h1>
<pre>
  Maintainer: Larry Wall &lt;larry@wall.org&gt;
  Date: 19 Aug 2004
  Last Modified: 18 Aug 2006
  Number: 4
  Version: 37</pre>
<p>This document summarizes Apocalypse 4, which covers the block and
statement syntax of Perl.</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="The20Relationship20of20Blocks20and20Declarations">The Relationship of Blocks and Declarations</a></h1>
<a name="msg_8"></a>
<a href="?hide_quotes=no#msg_8" onclick="return tog_quote(8);">
<div ID=header_shown_8 style="display: none;">
- Hide the snippet from t/var/var.t (line 13 ~ line 134) -
</div>
<div ID=header_hidden_8 style="display: block;">
- Show the snippet from t/var/var.t (line 13 ~ line 134, 122 lines) -</div>
</a>
<div ID=hide_8 style="display:none; border:1px solid">
<pre>
# L&lt;S04/"The Relationship of Blocks and Declarations"&gt;
ok eval('my $x; my $x; 1'),       'it is legal to declare $x twice in the same scope.';
ok eval('state $x; state $x; 1'), 'it is legal to declare $x twice in the same scope.';

# XXX -- dunno why test test fails, but the next outer test works. --iblech
{ my $a = 1; {
   my $a=2; {
      my $a=3;
      is($a, 3,               'get regular a'); 
      is($OUTER::a, 2,        'get $OUTER::a'); 
      is($OUTER::OUTER::a, 1, 'get $OUTER::OUTER::a');
}}}

{
  my $a = 1;
  is $a, 1, 'get regular $a (1)';

  {
    is $a, 1, 'get regular $a (2)';
    my $a = 2;
    is $a, 2, 'get new regular $a (1)';

    {
      is $a, 2, 'get new regular $a (2)';
      my $a = 3;

      is $a,               3, 'get very new regular $a';
      is $OUTER::a,        2, 'get $OUTER::a';
      is $OUTER::OUTER::a, 1, 'get $OUTER::OUTER::a';
    }
  }
}

{
  my $a = 3;
  my $sub = { $a++ };

  {
    my $a = -10;
    is $a, -10,   'get regular $a';
    is $sub(), 3, 'get hidden $a (1)';
    is $sub(), 4, 'get hidden $a (2)';
    is $sub(), 5, 'get hidden $a (3)';
  }
}

{
  my $sub = -&gt; $stop {
    my $x = 3;
    if $stop {
      $x++;
    } else {
      $sub(1);
      $x;
    }
  };

  is $sub(0), 3,
    "recursively called subref shouldn't stomp on the lexical vars of other instances";
}

{
  sub stomptest ($stop) {
    my $x = 3;
    if $stop {
      $x++;
    } else {
      stomptest 1;
      $x;
    }
  };

  is stomptest(0), 3,
    "recursively called sub shouldn't stomp on the lexical vars of other instances";
}

{
  is foo(), 0, "get variable not yet declared using a sub (1)";
  is foo(), 1, "get variable not yet declared using a sub (2)";
  is foo(), 2, "get variable not yet declared using a sub (3)";

  my $a;
  sub foo { $a++ }
}

{
  is bar(), 0, "runtime part of my not yet executed (1)";
  is bar(), 1, "runtime part of my not yet executed (2)";
  is bar(), 2, "runtime part of my not yet executed (3)";

  my $a = 3;
  sub bar { $a++ }
}

{
  is baz(), 3, "runtime part of my not yet executed (1)";
  is baz(), 4, "runtime part of my not yet executed (2)";
  is baz(), 5, "runtime part of my not yet executed (3)";

  my $a; BEGIN { $a = 3 };
  sub baz { $a++ }
}

{
  {
    my $a = 3;
    sub grtz { $a++ }
  }

  is grtz(), 3, "get real hidden var using a sub (1)";
  is grtz(), 4, "get real hidden var using a sub (1)";
  is grtz(), 5, "get real hidden var using a sub (1)";
}

{
  my $a;
  sub rmbl { $a++ }

  is rmbl(), 0, "var captured by sub is the right var (1)";
  $a++;
  is rmbl(), 2, "var captured by sub is the right var (2)";
}</pre>
</div><a name="msg_3"></a>
<a href="?hide_quotes=no#msg_3" onclick="return tog_quote(3);">
<div ID=header_shown_3 style="display: none;">
- Hide the snippet from t/data_types/anon_block.t (line 13 ~ line 104) -
</div>
<div ID=header_hidden_3 style="display: block;">
- Show the snippet from t/data_types/anon_block.t (line 13 ~ line 104, 92 lines) -</div>
</a>
<div ID=hide_3 style="display:none; border:1px solid">
<pre>
L&lt;S04/"The Relationship of Blocks and Declarations"&gt;

=cut

plan 32;

# anon blocks L&lt;S06/"Standard Subroutines"&gt;
my $anon_sub = sub { 1 };
isa_ok($anon_sub, 'Sub');
is($anon_sub(), 1, 'sub { } works');

my $anon_sub_w_arg = sub ($arg) { 1 + $arg };
isa_ok($anon_sub_w_arg, 'Sub');
is($anon_sub_w_arg(3), 4, 'sub ($arg) {} works');

# anon blocks L&lt;S06/"Blocks"&gt;
my $anon_block = { 1 };
isa_ok($anon_block, 'Block');
is($anon_block(), 1, '{} &lt;anon block&gt; works');

# pointy subs L&lt;S06/"Pointy subs"&gt;
my $pointy_block = -&gt; { 1 };
isa_ok($pointy_block, 'Block');
is($pointy_block(), 1, '-&gt; {} &lt;"pointy" block&gt; works');

my $pointy_block_w_arg = -&gt; $arg { 1 + $arg };
isa_ok($pointy_block_w_arg, 'Block');
is($pointy_block_w_arg(3), 4, '-&gt; $arg {} &lt;"pointy" block w/args&gt; works');

my $pointy_block_w_multiple_args = -&gt; $arg1, $arg2 { $arg1 + $arg2 };
isa_ok($pointy_block_w_multiple_args, 'Block');
is($pointy_block_w_multiple_args(3, 4), 7, '-&gt; $arg1, $arg2 {} &lt;"pointy" block w/multiple args&gt; works');

my $pointy_block_nested = -&gt; $a { -&gt; $b { $a + $b }};
isa_ok($pointy_block_nested, Block);
isa_ok($pointy_block_nested(5), Block);
is $pointy_block_nested(5)(6), 11, '-&gt; $a { -&gt; $b { $a+$b }} nested &lt;"pointy" block&gt; works';

# bare blocks L&lt;S06/"Blocks"&gt;

my $foo;
{$foo = "blah"};
is($foo, "blah", "lone block actually executes it's content");

my $foo2;
{$foo2 = "blah"};
is($foo2, "blah", "lone block w/out a semicolon actually executes it's content");

my $foo3;
({$foo3 = "blah"});
ok(!defined($foo3), "block enclosed by parentheses should not auto-execute (1)", :todo&lt;bug&gt;);

my $foo4;
({$foo4 = "blah"},);
ok(!defined($foo4), "block enclosed by parentheses should not auto-execute (2)");

my ($one, $two);
# The try's here because it should die: $foo{...} should only work if $foo isa
# Hash (or sth. which provides appropriate tieing/&amp;postcircumfix:&lt;{
# }&gt;/whatever, but a Code should surely not support hash access).
# Additionally, a smart compiler will detect thus errors at compile-time, so I
# added an eval().  --iblech
try { eval '{$one = 1}{$two = 2}' };
is($one, undef, 'two blocks ({} {}) no semicolon after either,.. first block does not execute');
is($two, 2, '... but second block does (parsed as hash subscript)');

my ($one_a, $two_a);
{$one_a = 1}; {$two_a = 2}
is($one_a, 1, '... two blocks ({}; {}) semicolon after the first only,.. first block does execute');
is($two_a, 2, '... and second block does too');

my ($one_b, $two_b);
{
    $one_b = 1
}
{
    $two_b = 2
};
is($one_b, 1, '... two stand-alone blocks ({\n...\n}\n{\n...\n}),.. first block does execute');
is($two_b, 2, '... and second block does too');

my ($one_c, $two_c);
{$one_c = 1}; {$two_c = 2};
is($one_c, 1, '... two blocks ({}; {};) semicolon after both,.. first block does execute');
is($two_c, 2, '... and second block does too');

sub f { { 3 } }
is(f(), 3, 'bare blocks immediately runs even as the last statement');
is((sub { { 3 } }).(), 3, 'ditto for anonymous subs');
is((sub { { { 3 } } }).(), 3, 'ditto, even if nested');
dies_ok({(sub { { $^x } }).()}, 'implicit params become errors');
isnt((sub { -&gt; { 3 } }).(), 3, 'as are pointies');</pre>
</div><p>Every block is a closure.  (That is, in the abstract, they're all
anonymous subroutines that take a snapshot of their lexical scope.)
How a block is invoked and how its results are used are matters of
context, but closures all work the same on the inside.</p>
<p>Blocks are delimited by curlies, or by the beginning and end of the
current compilation unit (either the current file or the current
<code>eval</code> string).  Unlike in Perl 5, there are (by policy) no implicit
blocks around standard control structures.  (You could write a macro
that violates this, but resist the urge.)  Variables that mediate
between an outer statement and an inner block (such as loop variables)
should generally be declared as formal parameters to that block.  There
are three ways to declare formal parameters to a closure.</p>
<pre>
    $func = sub ($a, $b) { print if $a eq $b };  # standard sub declaration
    $func = -&gt; $a, $b { print if $a eq $b };     # a &quot;pointy&quot; block
    $func = { print if $^a eq $^b }              # placeholder arguments</pre>
<p>A bare closure without placeholder arguments that uses <code>$_</code>
(either explicitly or implicitly) is treated as though <code>$_</code> were a
formal parameter:</p>
<pre>
    $func = { print if $_ };   # Same as: $func = -&gt; $_ { print if $_ };
    $func(&quot;printme&quot;);</pre>
<p>In any case, all formal parameters are the equivalent of <code>my</code> variables
within the block.  See S06 for more on function parameters.</p>
<p>Except for such formal parameter declarations, all lexically scoped
declarations are visible from the point of declaration to the end of
the enclosing block.  Period.  Lexicals may not ``leak'' from a block to any
other external scope (at least, not without some explicit aliasing
action on the part of the block, such as exportation of a symbol
from a module).  The ``point of declaration'' is the moment the compiler
sees ``<code>my $foo</code>'', not the end of the statement as in Perl 5, so</p>
<pre>
    my $x = $x;</pre>
<p>will no longer see the value of the outer <code>$x</code>; you'll need to say
either</p>
<pre>
    my $x = $OUTER::x;</pre>
<p>or</p>
<pre>
    my $x = OUTER::&lt;$x&gt;;</pre>
<p>instead.</p>
<p>If you declare a lexical twice in the same scope, it is the same lexical:</p>
<pre>
    my $x;
    my $x;</pre>
<p>If you've referred to <code>$x</code> prior to the first declaration, and the compiler
tentatively bound it to <code>$OUTER::x</code>, then it's an error to declare it, and
the compiler is required to complain at that point.  If such use can't
be detected because it is hidden in an eval, then it is erroneous, since
the <code>eval()</code> compiler might bind to either <code>$OUTER::x</code> or the subsequently
declared ``<code>my $x</code>''.</p>
<a name="msg_2"></a>
<a href="?hide_quotes=no#msg_2" onclick="return tog_quote(2);">
<div ID=header_shown_2 style="display: none;">
- Hide the snippet from t/builtins/my.t (line 29 ~ line 99) -
</div>
<div ID=header_hidden_2 style="display: block;">
- Show the snippet from t/builtins/my.t (line 29 ~ line 99, 71 lines) -</div>
</a>
<div ID=hide_2 style="display:none; border:1px solid">
<pre>
# L&lt;S04/"The Relationship of Blocks and Declarations" /prior to the first declaration/&gt;
# "If you've referred to $x prior to the first declaration, and the
#  compiler tentatively bound it to $OUTER::x, then it's an error to
#  declare it, and the compiler is allowed to complain at that point."
# A fully conformant compiler will fail this test.  At best,
#   is($d, 1, '$d is still the outer $d');
# passes "tentatively", and the subsequent my is an uncomplained error.

# shadowing a lexical with a new lexical of the same name
# and that lexical does not leak out into the outer scope

my $d = 1;
if (1) { # create a new lexical scope
    is($d, 1, '$d is still the outer $d');
    my $d = 2;
    is($d, 2, '$d is now the lexical (inner) $d');    
}
is($d, 1, '$d is available, and the outer value has not changed');

# check closures with functions

my $func;
my $func2;
if (1) { # create a new lexical scope
    my $e = 0;
    $func = sub { $e++ }; # one to inc
    $func2 = sub { $e };  # one to access it
}

ok(!(eval '$e'), '$e is the not available in this scope');
is($func2(), 0, '$func2() just returns the $e lexical which is held by the closure');
$func();
is($func2(), 1, '$func() increments the $e lexical which is held by the closure');
$func();
is($func2(), 2, '... and one more time just to be sure');

# check my as simultaneous lvalue and rvalue

is(eval('my $e1 = my $e2 = 42'), 42, 'can parse squinting my value');
is(eval('my $e1 = my $e2 = 42; $e1'), 42, 'can capture squinting my value');
is(eval('my $e1 = my $e2 = 42; $e2'), 42, 'can set squinting my variable');

is(eval('my $x = 1, my $y = 2; $y'), 2, 'precedence of my wrt = and ,');

# check proper scoping of my in while condition

my $result;
my $x = 0;
is(eval('while my $x = 1 { $result = $x; last } $result'), 1, 'my in while cond seen from body');
is(eval('while my $x = 1 { last } $x'), 1, 'my in while cond seen after');

# check proper scoping of my in if condition

is(eval('if my $x = 1 { $x } else { 0 }'), 1, 'my in if cond seen from then');
is(eval('if not my $x = 1 { 0 } else { $x }'), 1, 'my in if cond seen from else');
is(eval('if my $x = 1 { 0 } else { 0 } $x'), 1, 'my in if cond seen after');

# check proper scoping of my in loop initializer

is(eval('loop (my $x = 1, my $y = 2; $x &gt; 0; $x--) { $result = $x; last } $result'), 1, '1st my in loop cond seen from body');
is(eval('loop (my $x = 1, my $y = 2; $x &gt; 0; $x--) { $result = $y; last } $result'), 2, '2nd my in loop cond seen from body');
is(eval('loop (my $x = 1, my $y = 2; $x &gt; 0; $x--) { last } $x'), 1, '1st my in loop cond seen after');
is(eval('loop (my $x = 1, my $y = 2; $x &gt; 0; $x--) { last } $y'), 2, '2nd my in loop cond seen after');

# check that can declaring lexical twice is noop
{
    my $f;
    $f = 5;
    my $f;
    is($f, 5, "two lexicals declared in scope is noop");
}</pre>
</div><p>As in Perl 5, ``<code>our $foo</code>'' introduces a lexically scoped alias for
a variable in the current package.</p>
<p>The new <code>constant</code> declarator introduces a lexically scoped name
for a compile-time constant, either a variable or a 0-ary sub, which
may be initialized with either a pseudo-assignment or a block:</p>
<pre>
    constant Num $pi = 3;
    constant Num PI { 3 }
    constant Num π  = atan(2,2) * 4;</pre>
<p>In any case the initializing value is evaluated at BEGIN time.</p>
<a name="msg_4"></a>
<a href="?hide_quotes=no#msg_4" onclick="return tog_quote(4);">
<div ID=header_shown_4 style="display: none;">
- Hide the snippet from t/var/constant.t (line 181 ~ line 193) -
</div>
<div ID=header_hidden_4 style="display: block;">
- Show the snippet from t/var/constant.t (line 181 ~ line 193, 13 lines) -</div>
</a>
<div ID=hide_4 style="display:none; border:1px solid">
<pre>
# L&lt;S04/"The Relationship of Blocks and Declarations" /In any case the initializing value is evaluated at BEGIN time./&gt;
{
    my $ok;

    eval '
        my $foo = 42;
        BEGIN { $foo = 23 }
        my constant timecheck = $foo;
        $ok++ if timecheck == 23;
    ';

    ok $ok, "the initializing values for constants are evaluated at compile-time", :todo&lt;feature&gt;;
}</pre>
</div><p>There is a new <code>state</code> declarator that introduces a lexically scoped
variable like <code>my</code> does, but with a lifetime that persists for the
life of the closure, so that it keeps its value from the end of one
call to the beginning of the next.  Separate clones of the closure
get separate state variables.</p>
<a name="msg_6"></a>
<a href="?hide_quotes=no#msg_6" onclick="return tog_quote(6);">
<div ID=header_shown_6 style="display: none;">
- Hide the snippet from t/var/state.t (line 7 ~ line 158) -
</div>
<div ID=header_hidden_6 style="display: block;">
- Show the snippet from t/var/state.t (line 7 ~ line 158, 152 lines) -</div>
</a>
<div ID=hide_6 style="display:none; border:1px solid">
<pre>
# L&lt;S04/"The Relationship of Blocks and Declarations" /There is a new state declarator that introduces/&gt;

# state() inside subs
{
    sub inc () {
        state $svar;
        $svar++;
        return $svar;
    };

    is(inc(), 1, "state() works inside subs (#1)");
    is(inc(), 2, "state() works inside subs (#2)");
    is(inc(), 3, "state() works inside subs (#3)");
}

# state() inside coderefs
{
    my $gen = {
        # Note: The following line is only executed once, because it's equivalent
        # to
        #   state $svar will first { 42 };
        # See L&lt;S04/"Closure traits" /emantics to any initializer, so this also works/&gt;
        state $svar = 42;
        my $ret = { $svar++ };
    };

    my $a = $gen(); # $svar == 42
    $a(); $a();     # $svar == 44
    my $b = $gen(); # $svar == 44

    is $b(), 44, "state() works inside coderefs";
}

# state() inside for-loops
{
    for 1,2,3 -&gt; $val {
        state $svar;
        $svar++;

        # Only check on last run
        if $val == 3 {
            is $svar, 3, "state() works inside for-loops";
        }
    }
}

# state will first {...}
{
    my ($a, $b);
    eval '
        my $gen = {
            state $svar will first { 42 };
            -&gt; { $svar++ };
        }
        $a = $gen();    # $svar == 42
        $a(); $a();     # $svar == 44
        $b = $gen()();  # $svar == 44
    ';

    is $b, 44, 'state will first {...} works', :todo&lt;feature&gt;;
}

# Return of a reference to a state() var
{
    my $gen = {
        state $svar = 42;
        \$svar;
    };

    my $svar_ref = $gen();
    $$svar_ref++; $$svar_ref++;

    my $svar_ref = $gen();
    is $$svar_ref, 44, "reference to a state() var", :todo&lt;bug&gt;;
}

# Anonymous state vars
# L&lt;"http://groups.google.de/group/perl.perl6.language/msg/07aefb88f5fc8429"&gt;
{
    # XXX -- currently this is parsed as \&amp;state()
    my $gen = eval '{ try { \state } }';
    $gen //= sub { \(my $x) };

    my $svar_ref = $gen();               # $svar == 0
    try { $$svar_ref++; $$svar_ref++ };  # $svar == 2

    my $svar_ref = $gen();               # $svar == 2
    is try { $$svar_ref }, 2, "anonymous state() vars", :todo&lt;feature&gt;;
}

# L&lt;"http://www.nntp.perl.org/group/perl.perl6.language/20888"&gt;
# ("Re: Declaration and definition of state() vars" from Larry)
{
    my ($a, $b);
    eval '
        my $gen = {
            (state $svar) = 42;
            my $ret = { $svar++ };
        };

        $a = $gen();        # $svar == 42
        $a(); $a();         # $svar == 44
        $b = $gen()();      # $svar == 42
    ';
    is $b, 42, "state() and parens"; # svar == 43
}

# state() inside regular expressions
{
    my $str = "abc";

    my $re  = {
    # Perl 5 RE, as we don't want to force people to install Parrot ATM. (The
    # test passes when using the Perl 6 RE, too.)
    $str ~~ s:Perl5/^(.)/{
      state $svar;
      ++$svar;
    }/;
    };
    $re();
    $re();
    $re();
    is +$str, 3, "state() inside regular expressions works";
}

# state() inside subs, chained declaration
{
    sub step () {
        state $svar = state $svar2 = 42;
        try {
            $svar++;
            $svar2--;
            return ($svar, $svar2);
        }
    };

    is(step().perl, "(43, 41)", "chained state (#1)", :todo&lt;bug&gt;);
    is(step().perl, "(44, 40)", "chained state (#2)", :todo&lt;bug&gt;);
}

# state in cloned closures
{
    for &lt;first second&gt; {
        my $code = {
            state $foo = 42;
            ++$foo;
        };

        is $code(), 43, "state was initialized properly ($_ time)";
        is $code(), 44, "state keeps its value across calls ($_ time)";
    }
}</pre>
</div><p>Perl 5's ``<code>local</code>'' function has been renamed to <code>temp</code> to better
reflect what it does.  There is also a <code>let</code> function that sets a
hypothetical value.  It works exactly like <code>temp</code>, except that the
value will be restored only if the current block exits unsuccessfully.
(See Definition of Success below for more.)  <code>temp</code> and <code>let</code> temporize
or hypotheticalize the value or the variable depending on whether you
do assignment or binding.  One other difference from Perl 5 is that
the default is not to undefine a variable.  So</p>
<a name="msg_7"></a>
<a href="?hide_quotes=no#msg_7" onclick="return tog_quote(7);">
<div ID=header_shown_7 style="display: none;">
- Hide the snippet from t/var/temp.t (line 7 ~ line 107) -
</div>
<div ID=header_hidden_7 style="display: block;">
- Show the snippet from t/var/temp.t (line 7 ~ line 107, 101 lines) -</div>
</a>
<div ID=hide_7 style="display:none; border:1px solid">
<pre>
# L&lt;S04/"The Relationship of Blocks and Declarations" /function has been renamed/&gt;
{
  my $a = 42;
  {
    temp $a = 23;
    is $a, 23, "temp() changed the variable (1)";
  }
  is $a, 42, "temp() restored the variable (1)";
}

# Test that temp() restores the variable at scope exit, not at subroutine
# entry.
{
  my $a     = 42;
  my $get_a = { $a };
  {
    temp $a = 23;
    is $a,       23, "temp() changed the variable (2-1)";
    is $get_a(), 23, "temp() changed the variable (2-2)";
  }
  is $a, 42, "temp() restored the variable (2)";
}

# temp() shouldn't change the variable containers
{
  my $a     = 42;
  my $get_a = { $a };
  {
    temp $a = 23;
    ok $a =:= $get_a(), "temp() shouldn't change the variable containers";
  }
}

{
  our $pkgvar = 42;
  {
    temp $pkgvar = 'not 42';
    is $pkgvar, 'not 42', "temp() changed the package variable (3-1)";
  }
  is $pkgvar, 42, "temp() restored the package variable (3-2)";
}

# Test that temp() restores variable even when not exited regularly (using a
# (possibly implicit) call to return()), but when left because of an exception.
{
  my $a = 42;
  try {
    temp $a = 23;
    is $a, 23, "temp() changed the variable in a try block";
    die 57;
  };
  is $a, 42, "temp() restored the variable, the block was exited using an exception";
}

eval('
{
  my @array = (0, 1, 2);
  {
    temp @array[1] = 42;
    is @array[1], 42, "temp() changed our array element";
  }
  is @array[1], 1, "temp() restored our array element";
}
"1 - delete this line when the parsefail eval() is removed";
') or skip(2, "parsefail: temp \@array[1]");

eval('
{
  my %hash = (:a(1), :b(2), :c(3));
  {
    temp %hash&lt;b&gt; = 42;
    is %hash&lt;b&gt;, 42, "temp() changed our hash element";
  }
  is %hash&lt;b&gt;, 2, "temp() restored our array element";
}
"1 - delete this line when the parsefail eval() is removed";
') or skip(2, "parsefail: temp \%hash&lt;b&gt;");

eval('
{
  my $struct = [
    "doesnt_matter",
    {
      doesnt_matter =&gt; "doesnt_matter",
      key           =&gt; [
        "doesnt_matter",
        42,
      ],
    },
  ];

  {
    temp $struct[1]&lt;key&gt;[1] = 23;
    is $struct[1]&lt;key&gt;[1], 23, "temp() changed our nested arrayref/hashref element";
  }
  is $struct[1]&lt;key&gt;[1], 1, "temp() restored our nested arrayref/hashref element", :todo&lt;feature&gt;;
}
"1 - delete this line when the parsefail eval() is removed";
') or skip(2, "parsefail: temp \$struct[1]&lt;key&gt;[1]");

# Block TEMP{}</pre>
</div><a name="msg_5"></a>
<a href="?hide_quotes=no#msg_5" onclick="return tog_quote(5);">
<div ID=header_shown_5 style="display: none;">
- Hide the snippet from t/var/let.t (line 7 ~ line 7) -
</div>
<div ID=header_hidden_5 style="display: block;">
- Show the snippet from t/var/let.t (line 7 ~ line 7, 1 lines) -</div>
</a>
<div ID=hide_5 style="display:none; border:1px solid">
<pre>
# L&lt;S04/"The Relationship of Blocks and Declarations" /There is also a let function/&gt;</pre>
</div><pre>
    temp $x;</pre>
<p>causes <code>$x</code> to start with its current value.  Use</p>
<pre>
    temp undefine $x;</pre>
<p>to get the Perl 5 behavior.</p>
<p>Note that temporizations that are undone upon scope exit must be
prepared to be redone if a continuation within that scope is taken.</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Statement2dending20blocks">Statement-ending blocks</a></h1>
<p>A line ending with a closing brace ``<code>}</code>'', followed by nothing but
whitespace or comments, will terminate a statement if an end of statement
can occur there.  That is, these two statements are equivalent:</p>
<pre>
    my $x = sub { 3 }
    my $x = sub { 3 };</pre>
<p>End-of-statement cannot occur within a bracketed expression, so
this still works:</p>
<pre>
    my $x = [
        sub { 3 },  # this comma is not optional
        sub { 3 }   # the statement won't terminate here 
    ];</pre>
<p>However, a nested hash block must be disambiguated by a trailing comma:</p>
<pre>
    # Without the trailing comma, this becomes a code block
    my $hash = {
        1 =&gt; { 2 =&gt; 3, 4 =&gt; 5 },
    };</pre>
<p>Because subroutine declarations are expressions, not statements,
this is now invalid:</p>
<pre>
    sub f { 3 } sub g { 3 }     # two terms occur in a row</pre>
<p>But these two are valid:</p>
<pre>
    sub f { 3 }; sub g { 3 };
    sub f { 3 }; sub g { 3 }    # the trailing semicolon is optional</pre>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Conditional20statements">Conditional statements</a></h1>
<a name="msg_10"></a>
<a href="?hide_quotes=no#msg_10" onclick="return tog_quote(10);">
<div ID=header_shown_10 style="display: none;">
- Hide the snippet from t/statements/if.t (line 9 ~ line 110) -
</div>
<div ID=header_hidden_10 style="display: block;">
- Show the snippet from t/statements/if.t (line 9 ~ line 110, 102 lines) -</div>
</a>
<div ID=hide_10 style="display:none; border:1px solid">
<pre>
L&lt;S04/"Conditional statements"&gt;

=cut

plan 19;

my $x = 'test';
if ($x eq $x) { pass("if ($x eq $x) {} works"); } else { flunk("if ($x eq $x) {} failed"); }
if ($x ne $x) { flunk("if ($x ne $x) {} failed"); } else { pass("if ($x ne $x) {} works"); }
if (1) { pass("if (1) {} works"); } else { flunk("if (1) {} failed"); }
if (0) { flunk("if (0) {} failed"); } else { pass("if (0) {} works"); }
if (undef) { flunk("if (undef) {} failed"); } else { pass("if (undef) {} works"); }

# die called in the condition part of an if statement should die immediately
# rather than being evaluated as true
my $foo = 1;
try { if (die "should die") { $foo = 3 } else { $foo = 2; } };
#say '# $foo = ' ~ $foo;
is $foo, 1, "die should stop execution immediately.";

{
    my $foo = 1; # just in case
    if 1 &gt; 2 { $foo = 2 } else { $foo = 3 };
    is $foo, 3, 'if with no parens';
};

# if...elsif
{
    my $foo = 1;
    if (1) { $foo = 2 } elsif (1) { $foo = 3 };
    is $foo, 2, 'if (1) {} elsif (1) {}';
}

{
    my $foo = 1;
    if (1) { $foo = 2 } elsif (0) { $foo = 3 };
    is $foo, 2, 'if (1) {} elsif (0) {}';
}

{
    my $foo = 1;
    if (0) { $foo = 2 } elsif (1) { $foo = 3 };
    is $foo, 3, 'if (0) {} elsif (1) {}';
}

{
    my $foo = 1;
    if (0) { $foo = 2 } elsif (0) { $foo = 3 };
    is $foo, 1, 'if (0) {} elsif (0) {}';
}

# if...elsif...else

{
    my $foo = 1;
    if (0) { $foo = 2 } elsif (0) { $foo = 3 } else { $foo = 4 };
    is $foo, 4;
}

{
    my $foo = 1;
    if (1) { $foo = 2 } elsif (0) { $foo = 3 } else { $foo = 4 };
    is $foo, 2;
}

{
    my $foo = 1;
    if (1) { $foo = 2 } elsif (1) { $foo = 3 } else { $foo = 4 };
    is $foo, 2;
}

{
    my $foo = 1;
    if (0) { $foo = 2 } elsif (1) { $foo = 3 } else { $foo = 4 };
    is $foo, 3;
}

{
    my $foo = 1;
    if ({ 1 &gt; 0 }) { $foo = 2 } else { $foo = 3 };
    is $foo, 2, 'if with no parens, and closure as cond';
}

{
    my $var = 9;
    my sub func( $a, $b, $c ) { $var };
    if func 1, 2, 3 { $var = 4 } else { $var = 5 };
    is $var, 4, 'if with no parens, and call a function without parenthesis';
}

# I'm not sure where this should go

{
    eval_is(
        'if ( my $x = 2 ) == 2 { $x; }',
        2,
        "'my' variable within 'if' conditional");
}

{
    isnt(eval('if 1; 2'), 2, 'test "if 1"');
}</pre>
</div><p>The <code>if</code> and <code>unless</code> statements work almost exactly as they do in
Perl 5, except that you may omit the parentheses on the conditional:</p>
<pre>
    if $foo == 123 {
        ...
    }
    elsif $foo == 321 {
        ...
    }
    else {
        ...
    }</pre>
<p>Conditional statement modifiers work as in Perl 5.  So do the
implicit conditionals implied by short-circuit operators.</p>
<a name="msg_11"></a>
<a href="?hide_quotes=no#msg_11" onclick="return tog_quote(11);">
<div ID=header_shown_11 style="display: none;">
- Hide the snippet from t/statements/values_in_bool_context.t (line 7 ~ line 89) -
</div>
<div ID=header_hidden_11 style="display: block;">
- Show the snippet from t/statements/values_in_bool_context.t (line 7 ~ line 89, 83 lines) -</div>
</a>
<div ID=hide_11 style="display:none; border:1px solid">
<pre>
# L&lt;S04/Conditional statements/Conditional statement
#   modifiers work as in Perl 5&gt;

##  scalar checking  ##

{
    my $var = 20;

    my ($a, $b, $c, $d, $e, $f, $g, $h);

    $a = 1 if 1;
    $b = 1 if 0;
    $c = 1 if "true";
    $d = 1 if "";
    $e = 1 if "1";
    $f = 1 if "0";
    $g = 1 if undef;
    $h = 1 if $var;

    ok  $a, 'literal in bool context - numeric true value';
    ok !$b, 'literal in bool context - numeric false value';
    ok  $c, 'literal in bool context - string true value';
    ok !$d, 'literal in bool context - string false value';
    ok  $e, 'literal in bool context - stringified true value';
    ok !$f, 'literal in bool context - stringified false value';
    ok !$g, 'literal in bool context - undef value';
    ok  $h, 'literal in bool context - scalar variable';
}

##  array checking  ##

{
    my @array = (1, 0, "true", "", "1", "0", undef);

    my ($a, $b, $c, $d, $e, $f, $g, $h);

    $a = 1 if @array[0];
    $b = 1 if @array[1];
    $c = 1 if @array[2];
    $d = 1 if @array[3];
    $e = 1 if @array[4];
    $f = 1 if @array[5];
    $g = 1 if @array[6];
    $h = 1 if @array;

    ok  $a, 'array in bool context - numeric true value';
    ok !$b, 'array in bool context - numeric false value';
    ok  $c, 'array in bool context - string true value';
    ok !$d, 'array in bool context - string false value';
    ok  $e, 'array in bool context - stringified true value';
    ok !$f, 'array in bool context - stringified false value';
    ok !$g, 'array in bool context - undef value';
    ok  $h, 'array in bool context  array as a whole';
}

##  hash checking  ##

{
    my %hash = (
        0 =&gt; 1, 1 =&gt; 0, 2 =&gt; "true",
        3 =&gt; "", 4 =&gt; "1", 5 =&gt; "0", 6 =&gt; undef
    );

    my ($a, $b, $c, $d, $e, $f, $g, $h);

    $a = 1 if %hash{0};
    $b = 1 if %hash{1};
    $c = 1 if %hash{2};
    $d = 1 if %hash{3};
    $e = 1 if %hash{4};
    $f = 1 if %hash{5};
    $g = 1 if %hash{6};
    $h = 1 if %hash;

    ok  $a, 'hash in bool context - numeric true value';
    ok !$b, 'hash in bool context - numeric false value';
    ok  $c, 'hash in bool context - string true value';
    ok !$d, 'hash in bool context - string false value';
    ok  $e, 'hash in bool context - stringified true value';
    ok !$f, 'hash in bool context - stringified false value';
    ok !$g, 'hash in bool context - undef value';
    ok  $h, 'hash in bool context - hash as a whole';
}</pre>
</div><p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Loop20statements">Loop statements</a></h1>
<a name="msg_22"></a>
<a href="?hide_quotes=no#msg_22" onclick="return tog_quote(22);">
<div ID=header_shown_22 style="display: none;">
- Hide the snippet from t/statements/while.t (line 9 ~ line 77) -
</div>
<div ID=header_hidden_22 style="display: block;">
- Show the snippet from t/statements/while.t (line 9 ~ line 77, 69 lines) -</div>
</a>
<div ID=hide_22 style="display:none; border:1px solid">
<pre>
L&lt;S04/"Loop statements"&gt;

=cut

plan 11;

{
  my $i = 0;
  while $i &lt; 5 { $i++; };
  is($i, 5, 'while $i &lt; 5 {} works');
}
{
  my $i = 0;
  while 5 &gt; $i { $i++; };
  is($i, 5, 'while 5 &gt; $i {} works');
}
# with parens
{
  my $i = 0;
  while ($i &lt; 5) { $i++; };
  is($i, 5, 'while ($i &lt; 5) {} works');
}
{
  my $i = 0;
  while (5 &gt; $i) { $i++; };
  is($i, 5, 'while (5 &gt; $i) {} works');
}

# single value
{
  my $j = 0;
  while 0 { $j++; };
  is($j, 0, 'while 0 {...} works');
}
{
  my $k = 0;
  while $k { $k++; };
  is($k, 0, 'while $var {...} works');
}

# other tests
{
  # this seems like a bit of a messy test, but the point is being able to
  # declare my $x within the while statement more suited for a file read
  # or iterator, but I didn't feel like creating one just for this test.
  eval_is(
    'my $y; while (my $x = 2) == 2 { $y = $x; last; } $y',
    2,
    "'my' variable within 'while' conditional");
}

# while ... -&gt; $x {...}
{
  my @array = (0..5);
  my $was_in_while;
  my @new;
  eval 'while @array.shift -&gt; $x { $was_in_while++; push @new, $x }';
  ok $was_in_while,  'while ... -&gt; $x {...} worked (1)', :todo&lt;bug&gt;;
  is ~@new, ~@array, 'while ... -&gt; $x {...} worked (1)', :todo&lt;bug&gt;;
}

{
  my @array = (0..5);
  my $was_in_while;
  my @new;
  eval 'while shift @array -&gt; $x { $was_in_while++; push @new, $x }';
  ok $was_in_while,  'while ... -&gt; $x {...} worked (1)', :todo&lt;bug&gt;;
  is ~@new, ~@array, 'while ... -&gt; $x {...} worked (1)', :todo&lt;bug&gt;;
}</pre>
</div><a name="msg_15"></a>
<a href="?hide_quotes=no#msg_15" onclick="return tog_quote(15);">
<div ID=header_shown_15 style="display: none;">
- Hide the snippet from t/statements/loop.t (line 72 ~ line 142) -
</div>
<div ID=header_hidden_15 style="display: block;">
- Show the snippet from t/statements/loop.t (line 72 ~ line 142, 71 lines) -</div>
</a>
<div ID=hide_15 style="display:none; border:1px solid">
<pre>
L&lt;S04/"Loop statements"&gt;

=cut

{
  my $x = 0; repeat { $x++ } while $x &lt; 10;
  is($x, 10, 'repeat {} while');
}

{
  my $x = 1; repeat { $x++ } while 0;
  is($x, 2, 'ensure repeat {} while runs at least once');
}

{
  my $x = 0; try { repeat { $x++; redo if $x &lt; 10 } while 0 };
  is($x, 10, 'redo works in repeat', :todo&lt;feature&gt;);
}

{
  my $x = 0; repeat while $x &lt; 10 { $x++ }
  is($x, 10, 'repeat {} while');
}

{
  my $x = 1; repeat while 0 { $x++ }
  is($x, 2, 'ensure repeat {} while runs at least once');
}

{
  my $x = 0; try { repeat while 0 { $x++; redo if $x &lt; 10 } };
  is($x, 10, 'redo works in repeat', :todo&lt;feature&gt;);
}

{
  my $x = 0; repeat { $x++ } until $x &gt;= 10;
  is($x, 10, 'repeat {} until');
}

{
  my $x = 1; repeat { $x++ } until 1;
  is($x, 2, 'ensure repeat {} until runs at least once');
}

{
  my $x = 0; try { repeat { $x++; redo if $x &lt; 10 } until 1 };
  is($x, 10, 'redo works in repeat {} until', :todo&lt;feature&gt;);
}

{
  my $x = 0; repeat until $x &gt;= 10 { $x++ }
  is($x, 10, 'repeat until {}');
}

{
  my $x = 1; repeat until 1 { $x++ }
  is($x, 2, 'ensure repeat until {} runs at least once');
}

{
  my $x = 0; try { repeat until 1 { $x++; redo if $x &lt; 10 } };
  is($x, 10, 'redo works in repeat until {}', :todo&lt;feature&gt;);
}

my $loopvar = 0;

loop {
    is($loopvar, $loopvar, "bare loop iterates $loopvar");
    last if ++$loopvar == 3;
}
is($loopvar, 3, "bare loop exited after 3 iterations");</pre>
</div><p>Looping statement modifiers are the same as in Perl 5.
Loop modifiers <code>next</code>, <code>last</code>, and <code>redo</code> also work as in Perl 5.</p>
<a name="msg_18"></a>
<a href="?hide_quotes=no#msg_18" onclick="return tog_quote(18);">
<div ID=header_shown_18 style="display: none;">
- Hide the snippet from t/statements/redo.t (line 4 ~ line 104) -
</div>
<div ID=header_hidden_18 style="display: block;">
- Show the snippet from t/statements/redo.t (line 4 ~ line 104, 101 lines) -</div>
</a>
<div ID=hide_18 style="display:none; border:1px solid">
<pre>
# L&lt;S04/"Loop statements" /work as in Perl 5/&gt;
plan 10;

{
    my $i = 0;
    while (defined($i)) { if (++$i &lt; 3) { redo }; last }
    is($i, 3, "redo caused reapplication of block");
}

{
    my @log;    
    my $i;
    while ++$i &lt; 5 {
        push @log, "before";
        if (++$i == 2) {
            redo;
        } else {
            push @log, "no_redo";
        }
        push @log, "after";
    }
    
    is(~@log, "before before no_redo after before no_redo after", "statements after redo are not executed");
}

{
    my $i = 0;
    my $j = 0;

    for (1, 0) -&gt; $x {
        if ($x &amp;&amp; (++$i % 2 == 0)) { redo };
        $j++;
    }

    is($j, 2, '$j++ encountered twice');
    is($i, 1, '$i++ encountered once');
}


{
    my $i = 0;
    my $j = 0;

    for (1, 0, 1, 0) -&gt; $x {
        if ($x &amp;&amp; (++$i % 2 == 0)) { redo };
        $j++;
    }

    is($j, 4, '$j++ encountered four times');
    is($i, 3, '$i++ encountered three times');
}


{
    my $i = 0;
    my $j;

    loop ($j = 0; $j &lt; 4; $j++) {
        if ($j % 2 == 0 and $i++ % 2 == 0) { redo }
        $i-=2;
    }

    is($j, 4, '$j unaltered by the fiasco');
    is($i, -4, '$i incremented and decremented correct number of times');
}

{
    # rubicon TestLoopStuff.rb
    #  def testRedoWithFor
    #    sum = 0
    #    for i in 1..10
    #      sum += i
    #      i -= 1
    #      if i &gt; 0
    #        redo
    #      end
    #    end
    #    assert_equal(220, sum)
    #  end
    my $stopping = 100;
    my $sum = 0;
    for 1..10 -&gt; $i is copy {
    $sum += $i;
    $i -= 1;
    last if !$stopping--;
    if $i &gt; 0 { redo }
    }
    is($sum, 220, "testRedoWithFor", :todo&lt;bug&gt;);

    $stopping = 100;
    $sum = 0;
    my $j = 1;
    my $i;
    while do{$i = $j; $j++ &lt;= 10} {
    $sum += $i;
    $i -= 1;
    last if !$stopping--;
    if $i &gt; 0 { redo }
    }
    is($sum, 220, "test redo with while");
}</pre>
</div><a name="msg_16"></a>
<a href="?hide_quotes=no#msg_16" onclick="return tog_quote(16);">
<div ID=header_shown_16 style="display: none;">
- Hide the snippet from t/statements/next.t (line 6 ~ line 151) -
</div>
<div ID=header_hidden_16 style="display: block;">
- Show the snippet from t/statements/next.t (line 6 ~ line 151, 146 lines) -</div>
</a>
<div ID=hide_16 style="display:none; border:1px solid">
<pre>
L&lt;S04/"Loop statements" /work as in Perl 5/&gt;
next
next if &lt;condition&gt;;
&lt;condition&gt; and next;
next &lt;label&gt;;
next in nested loops
next &lt;label&gt; in nested loops

=cut

plan 12;

# test for loops with next

{
    my $tracker=0;for (1..2) { next; $tracker++;}
    is(
        $tracker,
        0,
        "tracker is 0 because next before increment",
    );
}

{
    my $tracker = 0; for (1..5) { next if 2 &lt; $_ &lt; 4; $tracker = $_;}
    is(
        $tracker,
        3,
        "... nothing before or after 3 (next if &lt;cond&gt;)",
        :todo&lt;bug&gt;
    );
}

{
    my $tracker = 0; for (1..5) { $_ &gt; 3 &amp;&amp; next; $tracker = $_;}
    is(
        $tracker,
        3,
        "... nothing after 3 (&lt;cond&gt; &amp;&amp; next)",
    );
}

{
    my $tracker = 0; for (1..5) { $_ &gt; 3 and next; $tracker = $_;}
    is(
        $tracker,
        3,
        "... nothing after 3 (&lt;cond&gt; and next)",
    );
}

{
    my $tracker="err"; eval '$tracker = 0; DONE: for (1..2) { next DONE; $tracker++;}';
    is(
        $tracker,
        0,
        "tracker is 0 because next before increment",
        :todo&lt;bug&gt;
    );
}

{
    my $tracker=0;for (1..5)-&gt;$out {for (10..11)-&gt;$in {next if $out &gt; 2;$tracker = $in + $out;}}
    is($tracker,
        13,
        'inner loop skips once inner is run twice (next inside nested loops)',
    );
}

{
    my $tracker="err"; eval '$tracker = 0; OUT: for (1..2) { IN: for (1..2) { next OUT; $tracker++; } }';
    is(
        $tracker,
        0,
        "tracker is 0 because next before increment in nested loop",
        :todo&lt;bug&gt;
    );
}

=pod

Check that C&lt;next&gt; works on the correct loop/block

=cut

{
  my $foo;
  for 1..2 -&gt; $a {
    $foo ~= "A";
    for 1..2 -&gt; $b {
        $foo ~= "B";
        next;             # works on higher level loop, should work on inner
    }
  }
  is($foo, "ABBABB", "next works on inner loop of 2");
}

{
    my $bar;
    for 1..2 -&gt; $a {
        $bar ~= "A";
        for 1..2 -&gt; $b {
            $bar ~= "B";
            for 1..2 -&gt; $c {
                $bar ~= "C";
                next;         # same thing
            }
        }
    }
    is($bar, "ABCCBCCABCCBCC", "next works on inner loop of 3");
}

{
    my @log;    
    my $i;
    while ++$i &lt; 2 {
        push @log, "before";
        next;
        push @log, "after";
    }
    
    is(~@log, "before", "statements after next are not executed");
}

{
    my $i = 0;
    
    for (1, 1, 0, 1, 0, 1) -&gt; $x {
        if ($x) { next }
        $i++;
    }
    
    is($i, 2, '$i++ executed only twice, because next ')
}

{
    my $i = 0;
    my $j;
    
    loop ($j = 0; $j &lt; 6; $j++) {
        if ($j % 2 == 0) { next }
        $i++;
    }
    
    is($i, 3, '$i++ was not executed when next was called before it in loop {}');
}</pre>
</div><a name="msg_19"></a>
<a href="?hide_quotes=no#msg_19" onclick="return tog_quote(19);">
<div ID=header_shown_19 style="display: none;">
- Hide the snippet from t/statements/redo.t (line 4 ~ line 104) -
</div>
<div ID=header_hidden_19 style="display: block;">
- Show the snippet from t/statements/redo.t (line 4 ~ line 104, 101 lines) -</div>
</a>
<div ID=hide_19 style="display:none; border:1px solid">
<pre>
# L&lt;S04/"Loop statements" /work as in Perl 5/&gt;
plan 10;

{
    my $i = 0;
    while (defined($i)) { if (++$i &lt; 3) { redo }; last }
    is($i, 3, "redo caused reapplication of block");
}

{
    my @log;    
    my $i;
    while ++$i &lt; 5 {
        push @log, "before";
        if (++$i == 2) {
            redo;
        } else {
            push @log, "no_redo";
        }
        push @log, "after";
    }
    
    is(~@log, "before before no_redo after before no_redo after", "statements after redo are not executed");
}

{
    my $i = 0;
    my $j = 0;

    for (1, 0) -&gt; $x {
        if ($x &amp;&amp; (++$i % 2 == 0)) { redo };
        $j++;
    }

    is($j, 2, '$j++ encountered twice');
    is($i, 1, '$i++ encountered once');
}


{
    my $i = 0;
    my $j = 0;

    for (1, 0, 1, 0) -&gt; $x {
        if ($x &amp;&amp; (++$i % 2 == 0)) { redo };
        $j++;
    }

    is($j, 4, '$j++ encountered four times');
    is($i, 3, '$i++ encountered three times');
}


{
    my $i = 0;
    my $j;

    loop ($j = 0; $j &lt; 4; $j++) {
        if ($j % 2 == 0 and $i++ % 2 == 0) { redo }
        $i-=2;
    }

    is($j, 4, '$j unaltered by the fiasco');
    is($i, -4, '$i incremented and decremented correct number of times');
}

{
    # rubicon TestLoopStuff.rb
    #  def testRedoWithFor
    #    sum = 0
    #    for i in 1..10
    #      sum += i
    #      i -= 1
    #      if i &gt; 0
    #        redo
    #      end
    #    end
    #    assert_equal(220, sum)
    #  end
    my $stopping = 100;
    my $sum = 0;
    for 1..10 -&gt; $i is copy {
    $sum += $i;
    $i -= 1;
    last if !$stopping--;
    if $i &gt; 0 { redo }
    }
    is($sum, 220, "testRedoWithFor", :todo&lt;bug&gt;);

    $stopping = 100;
    $sum = 0;
    my $j = 1;
    my $i;
    while do{$i = $j; $j++ &lt;= 10} {
    $sum += $i;
    $i -= 1;
    last if !$stopping--;
    if $i &gt; 0 { redo }
    }
    is($sum, 220, "test redo with while");
}</pre>
</div><a name="msg_14"></a>
<a href="?hide_quotes=no#msg_14" onclick="return tog_quote(14);">
<div ID=header_shown_14 style="display: none;">
- Hide the snippet from t/statements/last.t (line 6 ~ line 83) -
</div>
<div ID=header_hidden_14 style="display: block;">
- Show the snippet from t/statements/last.t (line 6 ~ line 83, 78 lines) -</div>
</a>
<div ID=hide_14 style="display:none; border:1px solid">
<pre>
L&lt;S04/"Loop statements" /work as in Perl 5/&gt;
last
last if &lt;condition&gt;;
&lt;condition&gt; and last;
last &lt;label&gt;;
last in nested loops
last &lt;label&gt; in nested loops

=cut

plan 7;

# test for loops with last

{
    my $tracker = 0;
    for 1 .. 5 {
        $tracker = $_;
        last;  
    }
    is($tracker, 1, '... our loop only got to 1 (last)');
}

{
    my $tracker = 0;
    for 1 .. 5 {
        $tracker = $_;
        last if $_ == 3;  
    }
    is($tracker, 3, '... our loop only got to 3 (last if &lt;cond&gt;)');
}

{
    my $tracker = 0;
    for 1 .. 5 {
        $tracker = $_;
        $_ == 3 &amp;&amp; last;  
    }
    is($tracker, 3, '... our loop only got to 3 (&lt;cond&gt; &amp;&amp; last)');
}

{
    my $tracker = 0;
    for 1 .. 5 {
        $tracker = $_;
        $_ == 3 and last;  
    }
    is($tracker, 3, '... our loop only got to 3 (&lt;cond&gt; and last)');
}

{
    eval_is(
        'my $var=0; DONE: for (1..2) { last DONE; $var++;} $var',
        0,
        "var is 0 because last before increment",
        :todo(1)
    );
}

{
    my $tracker = 0;
    for (1 .. 5) -&gt; $out {
        for (10 .. 11) -&gt; $in {
            $tracker = $in + $out;
            last;
        }
    }
    is($tracker, 15, 'our inner loop only runs once per (last inside nested loops)');
}

{
    eval_is(
        'my $var=0; OUT: for (1..2) { IN: for (1..2) { last OUT } $var++;} $var',
        0,
        "var is 0 because last before increment in nested loop",
        :todo(1)
    );
}</pre>
</div><a name="msg_20"></a>
<a href="?hide_quotes=no#msg_20" onclick="return tog_quote(20);">
<div ID=header_shown_20 style="display: none;">
- Hide the snippet from t/statements/redo.t (line 4 ~ line 104) -
</div>
<div ID=header_hidden_20 style="display: block;">
- Show the snippet from t/statements/redo.t (line 4 ~ line 104, 101 lines) -</div>
</a>
<div ID=hide_20 style="display:none; border:1px solid">
<pre>
# L&lt;S04/"Loop statements" /work as in Perl 5/&gt;
plan 10;

{
    my $i = 0;
    while (defined($i)) { if (++$i &lt; 3) { redo }; last }
    is($i, 3, "redo caused reapplication of block");
}

{
    my @log;    
    my $i;
    while ++$i &lt; 5 {
        push @log, "before";
        if (++$i == 2) {
            redo;
        } else {
            push @log, "no_redo";
        }
        push @log, "after";
    }
    
    is(~@log, "before before no_redo after before no_redo after", "statements after redo are not executed");
}

{
    my $i = 0;
    my $j = 0;

    for (1, 0) -&gt; $x {
        if ($x &amp;&amp; (++$i % 2 == 0)) { redo };
        $j++;
    }

    is($j, 2, '$j++ encountered twice');
    is($i, 1, '$i++ encountered once');
}


{
    my $i = 0;
    my $j = 0;

    for (1, 0, 1, 0) -&gt; $x {
        if ($x &amp;&amp; (++$i % 2 == 0)) { redo };
        $j++;
    }

    is($j, 4, '$j++ encountered four times');
    is($i, 3, '$i++ encountered three times');
}


{
    my $i = 0;
    my $j;

    loop ($j = 0; $j &lt; 4; $j++) {
        if ($j % 2 == 0 and $i++ % 2 == 0) { redo }
        $i-=2;
    }

    is($j, 4, '$j unaltered by the fiasco');
    is($i, -4, '$i incremented and decremented correct number of times');
}

{
    # rubicon TestLoopStuff.rb
    #  def testRedoWithFor
    #    sum = 0
    #    for i in 1..10
    #      sum += i
    #      i -= 1
    #      if i &gt; 0
    #        redo
    #      end
    #    end
    #    assert_equal(220, sum)
    #  end
    my $stopping = 100;
    my $sum = 0;
    for 1..10 -&gt; $i is copy {
    $sum += $i;
    $i -= 1;
    last if !$stopping--;
    if $i &gt; 0 { redo }
    }
    is($sum, 220, "testRedoWithFor", :todo&lt;bug&gt;);

    $stopping = 100;
    $sum = 0;
    my $j = 1;
    my $i;
    while do{$i = $j; $j++ &lt;= 10} {
    $sum += $i;
    $i -= 1;
    last if !$stopping--;
    if $i &gt; 0 { redo }
    }
    is($sum, 220, "test redo with while");
}</pre>
</div><a name="msg_17"></a>
<a href="?hide_quotes=no#msg_17" onclick="return tog_quote(17);">
<div ID=header_shown_17 style="display: none;">
- Hide the snippet from t/statements/next.t (line 6 ~ line 151) -
</div>
<div ID=header_hidden_17 style="display: block;">
- Show the snippet from t/statements/next.t (line 6 ~ line 151, 146 lines) -</div>
</a>
<div ID=hide_17 style="display:none; border:1px solid">
<pre>
L&lt;S04/"Loop statements" /work as in Perl 5/&gt;
next
next if &lt;condition&gt;;
&lt;condition&gt; and next;
next &lt;label&gt;;
next in nested loops
next &lt;label&gt; in nested loops

=cut

plan 12;

# test for loops with next

{
    my $tracker=0;for (1..2) { next; $tracker++;}
    is(
        $tracker,
        0,
        "tracker is 0 because next before increment",
    );
}

{
    my $tracker = 0; for (1..5) { next if 2 &lt; $_ &lt; 4; $tracker = $_;}
    is(
        $tracker,
        3,
        "... nothing before or after 3 (next if &lt;cond&gt;)",
        :todo&lt;bug&gt;
    );
}

{
    my $tracker = 0; for (1..5) { $_ &gt; 3 &amp;&amp; next; $tracker = $_;}
    is(
        $tracker,
        3,
        "... nothing after 3 (&lt;cond&gt; &amp;&amp; next)",
    );
}

{
    my $tracker = 0; for (1..5) { $_ &gt; 3 and next; $tracker = $_;}
    is(
        $tracker,
        3,
        "... nothing after 3 (&lt;cond&gt; and next)",
    );
}

{
    my $tracker="err"; eval '$tracker = 0; DONE: for (1..2) { next DONE; $tracker++;}';
    is(
        $tracker,
        0,
        "tracker is 0 because next before increment",
        :todo&lt;bug&gt;
    );
}

{
    my $tracker=0;for (1..5)-&gt;$out {for (10..11)-&gt;$in {next if $out &gt; 2;$tracker = $in + $out;}}
    is($tracker,
        13,
        'inner loop skips once inner is run twice (next inside nested loops)',
    );
}

{
    my $tracker="err"; eval '$tracker = 0; OUT: for (1..2) { IN: for (1..2) { next OUT; $tracker++; } }';
    is(
        $tracker,
        0,
        "tracker is 0 because next before increment in nested loop",
        :todo&lt;bug&gt;
    );
}

=pod

Check that C&lt;next&gt; works on the correct loop/block

=cut

{
  my $foo;
  for 1..2 -&gt; $a {
    $foo ~= "A";
    for 1..2 -&gt; $b {
        $foo ~= "B";
        next;             # works on higher level loop, should work on inner
    }
  }
  is($foo, "ABBABB", "next works on inner loop of 2");
}

{
    my $bar;
    for 1..2 -&gt; $a {
        $bar ~= "A";
        for 1..2 -&gt; $b {
            $bar ~= "B";
            for 1..2 -&gt; $c {
                $bar ~= "C";
                next;         # same thing
            }
        }
    }
    is($bar, "ABCCBCCABCCBCC", "next works on inner loop of 3");
}

{
    my @log;    
    my $i;
    while ++$i &lt; 2 {
        push @log, "before";
        next;
        push @log, "after";
    }
    
    is(~@log, "before", "statements after next are not executed");
}

{
    my $i = 0;
    
    for (1, 1, 0, 1, 0, 1) -&gt; $x {
        if ($x) { next }
        $i++;
    }
    
    is($i, 2, '$i++ executed only twice, because next ')
}

{
    my $i = 0;
    my $j;
    
    loop ($j = 0; $j &lt; 6; $j++) {
        if ($j % 2 == 0) { next }
        $i++;
    }
    
    is($i, 3, '$i++ was not executed when next was called before it in loop {}');
}</pre>
</div><a name="msg_21"></a>
<a href="?hide_quotes=no#msg_21" onclick="return tog_quote(21);">
<div ID=header_shown_21 style="display: none;">
- Hide the snippet from t/statements/redo.t (line 4 ~ line 104) -
</div>
<div ID=header_hidden_21 style="display: block;">
- Show the snippet from t/statements/redo.t (line 4 ~ line 104, 101 lines) -</div>
</a>
<div ID=hide_21 style="display:none; border:1px solid">
<pre>
# L&lt;S04/"Loop statements" /work as in Perl 5/&gt;
plan 10;

{
    my $i = 0;
    while (defined($i)) { if (++$i &lt; 3) { redo }; last }
    is($i, 3, "redo caused reapplication of block");
}

{
    my @log;    
    my $i;
    while ++$i &lt; 5 {
        push @log, "before";
        if (++$i == 2) {
            redo;
        } else {
            push @log, "no_redo";
        }
        push @log, "after";
    }
    
    is(~@log, "before before no_redo after before no_redo after", "statements after redo are not executed");
}

{
    my $i = 0;
    my $j = 0;

    for (1, 0) -&gt; $x {
        if ($x &amp;&amp; (++$i % 2 == 0)) { redo };
        $j++;
    }

    is($j, 2, '$j++ encountered twice');
    is($i, 1, '$i++ encountered once');
}


{
    my $i = 0;
    my $j = 0;

    for (1, 0, 1, 0) -&gt; $x {
        if ($x &amp;&amp; (++$i % 2 == 0)) { redo };
        $j++;
    }

    is($j, 4, '$j++ encountered four times');
    is($i, 3, '$i++ encountered three times');
}


{
    my $i = 0;
    my $j;

    loop ($j = 0; $j &lt; 4; $j++) {
        if ($j % 2 == 0 and $i++ % 2 == 0) { redo }
        $i-=2;
    }

    is($j, 4, '$j unaltered by the fiasco');
    is($i, -4, '$i incremented and decremented correct number of times');
}

{
    # rubicon TestLoopStuff.rb
    #  def testRedoWithFor
    #    sum = 0
    #    for i in 1..10
    #      sum += i
    #      i -= 1
    #      if i &gt; 0
    #        redo
    #      end
    #    end
    #    assert_equal(220, sum)
    #  end
    my $stopping = 100;
    my $sum = 0;
    for 1..10 -&gt; $i is copy {
    $sum += $i;
    $i -= 1;
    last if !$stopping--;
    if $i &gt; 0 { redo }
    }
    is($sum, 220, "testRedoWithFor", :todo&lt;bug&gt;);

    $stopping = 100;
    $sum = 0;
    my $j = 1;
    my $i;
    while do{$i = $j; $j++ &lt;= 10} {
    $sum += $i;
    $i -= 1;
    last if !$stopping--;
    if $i &gt; 0 { redo }
    }
    is($sum, 220, "test redo with while");
}</pre>
</div><p>There is no longer a <code>continue</code> block.  Instead, use a <code>NEXT</code> block
within the body of the loop.  See below.</p>
<p>
</p>
<h2><a name="The20while20and20until20statements">The <code>while</code> and <code>until</code> statements</a></h2>
<p>The <code>while</code> and <code>until</code> statements work as in Perl 5, except that you
may leave out the parentheses around the conditional:</p>
<pre>
    while $bar &lt; 100 {
        ...
    }</pre>
<p>
</p>
<h2><a name="The20repeat20statement">The <code>repeat</code> statement</a></h2>
<p>Unlike in Perl 5, applying a statement modifier to a <code>do</code> block is
specifically disallowed:</p>
<pre>
    do {
        ...
    } while $x &lt; 10;    # ILLEGAL</pre>
<p>Instead, you should write the more Pascal-like <code>repeat</code> loop:</p>
<pre>
    repeat {
        ...
    } while $x &lt; 10;</pre>
<p>or equivalently:</p>
<pre>
    repeat {
        ...
    } until $x &gt;= 10;</pre>
<p>Unlike Perl 5's <code>do-while</code> loop, this is a real loop block now, so
<code>next</code>, <code>last</code>, and <code>redo</code> work as expected.  The loop conditional
on a repeat block is required, so it will be recognized even if you
put it on a line by its own:</p>
<pre>
    repeat
    {
        ...
    }
    while $x &lt; 10;</pre>
<p>However, that's likely to be visually confused with a following
<code>while</code> loop at the best of times, so it's also allowed to put the
loop conditional at the front, with the same meaning. (The <code>repeat</code>
keyword forces the conditional to be evaluated at the end of the loop,
so it's still C's do-while semantics.)  Therefore, even under GNU style
rules, the previous example may be rewritten into a very clear:</p>
<pre>
    repeat while $x &lt; 10
      {
        ...
      }</pre>
<p>or equivalently:</p>
<pre>
    repeat until $x &gt;= 10
      {
        ...
      }</pre>
<p>
</p>
<h2><a name="The20general20loop20statement">The general loop statement</a></h2>
<a name="msg_42"></a>
<a href="?hide_quotes=no#msg_42" onclick="return tog_quote(42);">
<div ID=header_shown_42 style="display: none;">
- Hide the snippet from t/statements/loop.t (line 9 ~ line 71) -
</div>
<div ID=header_hidden_42 style="display: block;">
- Show the snippet from t/statements/loop.t (line 9 ~ line 71, 63 lines) -</div>
</a>
<div ID=hide_42 style="display:none; border:1px solid">
<pre>
L&lt;S04/"The general loop statement"&gt;

=cut

plan 26;

# basic loop

my $i = 0;
is($i, 0, 'verify our starting condition');
loop ($i = 0; $i &lt; 10; $i++) {}
is($i, 10, 'verify our ending condition');

# loop with last()

my $i = 0;
is($i, 0, 'verify our starting condition');
loop ($i = 0; $i &lt; 10; $i++) {
    if ($i == 5) { 
        last(); # should this really need the ()
    }
}
is($i, 5, 'verify our ending condition');

# infinite loop

my $i = 0;
is($i, 0, 'verify our starting condition');
loop (;;) { $i++; last(); }
is($i, 1, 'verify our ending condition');

# declare variable $j inside loop
my $count  = 0;
is($count, 0, 'verify our starting condition');
my $j; loop ($j = 0; $j &lt; 10; $j++) { $count++; };
is($count, 10, 'verify our ending condition');

# Ensure condition is tested on the first iteration
{
    my $never_did_body = 1;
    loop (;0;)
    {
        $never_did_body = 0;
    }
    ok($never_did_body, "loop with an initially-false condition executes 0 times");
}

# Loop with next should still execute the continue expression
{
    my ($i,    $continued);
    loop ($i = 0;; $continued = 1)
    {
        last if $i;
        $i++;
        next;
    }
    ok($continued, "next performs a loop's continue expression");
}

=kwid

repeat { } while tests... i.e. loops without the () bits
</pre>
</div><p>The <code>loop</code> statement is the C-style <code>for</code> loop in disguise:</p>
<pre>
    loop ($i = 0; $i &lt; 10; $i++) {
        ...
    }</pre>
<p>As in C, the parentheses are required if you supply the 3-part spec; however,
the 3-part loop spec may be entirely omitted to write an infinite loop.
That is,</p>
<pre>
    loop {...}</pre>
<p>is equivalent to the Cish idiom:</p>
<pre>
    loop (;;) {...}</pre>
<p>
</p>
<h2><a name="The20for20statement">The <code>for</code> statement</a></h2>
<a name="msg_40"></a>
<a href="?hide_quotes=no#msg_40" onclick="return tog_quote(40);">
<div ID=header_shown_40 style="display: none;">
- Hide the snippet from t/statements/for.t (line 12 ~ line 18) -
</div>
<div ID=header_hidden_40 style="display: block;">
- Show the snippet from t/statements/for.t (line 12 ~ line 18, 7 lines) -</div>
</a>
<div ID=hide_40 style="display:none; border:1px solid">
<pre>
L&lt;S04/"The C&lt;for&gt; statement"&gt;

=cut

plan 36;

## for with plain old range operator w/out parens</pre>
</div><p>There is no <code>foreach</code> statement any more. It's always spelled <code>for</code>
in Perl 6, so it always takes a list as an argument:</p>
<pre>
    for @foo { print }</pre>
<p>As mentioned earlier, the loop variable is named by passing a parameter
to the closure:</p>
<a name="msg_41"></a>
<a href="?hide_quotes=no#msg_41" onclick="return tog_quote(41);">
<div ID=header_shown_41 style="display: none;">
- Hide the snippet from t/statements/for.t (line 26 ~ line 275) -
</div>
<div ID=header_hidden_41 style="display: block;">
- Show the snippet from t/statements/for.t (line 26 ~ line 275, 250 lines) -</div>
</a>
<div ID=hide_41 style="display:none; border:1px solid">
<pre>
# L&lt;S04/"The C&lt;for&gt; statement" /to the closure:/&gt;

my $b;
for 0 .. 5 -&gt; $_ { $b = $b ~ $_; };
is($b, '012345', 'for 0 .. 5 -&gt; {} works');

{
    my $str;
    my @a = 1..3;
    my @b = 4..6;
    for each(@a; @b) -&gt; $x, $y {
        $str ~= "($x $y)";
    }
    is $str, "(1 4)(2 5)(3 6)";
}

{
    my $str;
    my @a = 1..3;
    my @b = 5..6;
    eval q{
        for zip(@a; @b) -&gt; [$x, $y] {
            $str ~= "($x $y)";
        }
    };
    is $str, "(1 5)(2 4)(3 6)";
}

# ... with sub

my $c;
for (0 .. 5) sub { $c = $c ~ $_; };
is($c, '012345', 'for 0 .. 5 sub {} works');

# ... with referential sub

my $d;
sub some_sub_1 ($arg) { $d = $d ~ $arg; }
for (0 .. 5) { .some_sub_1 };
is($d, '012345', 'for 0 .. 5 { .some_sub } works');

## and now with parens around the range operator

my $e;
for (0 .. 5) { $e = $e ~ $_; };
is($e, '012345', 'for () {} works');

# ... with 'pointer'

my $f;
for (0 .. 5) -&gt; $_ { $f = $f ~ $_; };
is($f, '012345', 'for () -&gt; {} works');

# ... with sub

my $g;
for (0 .. 5) sub { $g = $g ~ $_; };
is($g, '012345', 'for (0 .. 5) sub {} works');

# ... with referential sub

my $h;
sub some_sub_2 ($arg) { $h = $h ~ $arg; }
for (0 .. 5) { .some_sub_2 };
is($h, '012345', 'for (0 .. 5) { .some_sub } works');

# ... with implicit topic

$_ = "GLOBAL VALUE";
for "INNER VALUE" {
  is( .lc, "inner value", "Implicit default topic is seen by lc()");
};
is($_,"GLOBAL VALUE","After the loop the implicit topic gets restored");

$_ = "GLOBAL VALUE";
is( .lc, "inner value", "Implicit default topic is seen by lc()" )
  for "INNER VALUE";
is($_,"GLOBAL VALUE","After the loop the implicit topic gets restored");

## and now for with 'topical' variables

# ... w/out parens

my $i;
for 0 .. 5 -&gt; $topic { $i = $i ~ $topic; };
is($i, '012345', 'for 0 .. 5 -&gt; $topic {} works');

# ... with parens

my $j;
for (0 .. 5) -&gt; $topic { $j = $j ~ $topic; };
is($j, '012345', 'for () -&gt; $topic {} works');


## for with @array operator w/out parens

my @array_k = (0 .. 5);
my $k;
for @array_k { $k = $k ~ $_; };
is($k, '012345', 'for @array {} works');

# ... with 'pointer'

my @array_l = (0 .. 5);
my $l;
for @array_l -&gt; $_ { $l = $l ~ $_; };
is($l, '012345', 'for @array -&gt; {} works');

# ... with sub

my @array_m = (0 .. 5);
my $m;
for (@array_m) sub { $m = $m ~ $_; };
is($m, '012345', 'for @array sub {} works');

# ... with referential sub

my @array_n = (0 .. 5);
my $n;
sub some_sub_3 ($arg) { $n = $n ~ $arg; }
for (@array_n) { .some_sub_3 };
is($n, '012345', 'for @array { .some_sub } works');

## and now with parens around the @array

my @array_o = (0 .. 5);
my $o;
for (@array_o) { $o = $o ~ $_; };
is($o, '012345', 'for (@array) {} works');

# ... with 'pointer'

my @array_p = (0 .. 5);
my $p;
for (@array_p) -&gt; $_ { $p = $p ~ $_; };
is($p, '012345', 'for (@array) -&gt; {} works');

# ... with sub

my @array_q = (0 .. 5);
my $q;
for (@array_q) sub { $q ~= $_; };
is($q, '012345', 'for (@array) sub {} works');

# ... with referential sub

my @array_r = (0 .. 5);
my $r;
sub some_sub_4 ($arg) { $r ~= $arg; }
for (@array_r) { .some_sub_4 };
is($r, '012345', 'for (@array) { .some_sub } works');


my @elems = &lt;a b c d e&gt;;

{
    my @a;
    for (@elems) {
        push @a, $_;
    }
    my @e = &lt;a b c d e&gt;;
    is(@a, @e, 'for (@a) { ... $_ ... } iterates all elems');
}

{
    my @a;
        for (@elems) -&gt; $_ { push @a, $_ };
    my @e = @elems;
    is(@a, @e, 'for (@a)-&gt;$_ { ... $_ ... } iterates all elems' );
}

{
    my @a;
    for (@elems) { push @a, $_, $_; }
    my @e = &lt;a a b b c c d d e e&gt;;
    is(@a, @e, 'for (@a) { ... $_ ... $_ ... } iterates all elems, not just odd');
}


# for with "is rw"

my @array_s = (0..2);
my @s = (1..3);
for @array_s { $_++ };
is(@array_s, @s, 'for @array { $_++ }');

my @array_t = (0..2);
my @t = (1..3);
for @array_t -&gt; $val is rw { $val++ };
is(@array_t, @t, 'for @array -&gt; $val is rw { $val++ }');

my @array_v = (0..2);
my @v = (1..3);
try { for @array_v.values -&gt; $val is rw { $val++ }; };
is(@array_v, @v, 'for @array.values -&gt; $val is rw { $val++ }', :todo&lt;feature&gt;);

my @array_kv = (0..2);
my @kv = (1..3);
try { for @array_kv.kv -&gt; $key, $val is rw { $val++ }; };
is(@array_kv, @kv, 'for @array.kv -&gt; $key, $val is rw { $val++ }', :todo&lt;feature&gt;);

my %hash_v = ( a =&gt; 1, b =&gt; 2, c =&gt; 3 );
my %v = ( a =&gt; 2, b =&gt; 3, c =&gt; 4 );
try { for %hash_v.values -&gt; $val is rw { $val++ }; };
is(%hash_v, %v, 'for %hash.values -&gt; $val is rw { $val++ }', :todo&lt;feature&gt;);

my %hash_kv = ( a =&gt; 1, b =&gt; 2, c =&gt; 3 );
my %kv = ( a =&gt; 2, b =&gt; 3, c =&gt; 4 );
try { for %hash_kv.kv -&gt; $key, $val is rw { $val++ }; };
is( %hash_kv.sort, %kv.sort, 'for %hash.kv -&gt; $key, $val is rw { $val++ }', :todo&lt;feature&gt;);


# .key //= ++$i for @array1;
{
   class TestClass is rw { has $.key; };
   my @array1 = (TestClass.new(),TestClass.new(:key&lt;2&gt;));
   my @array2 = (TestClass.new(:key&lt;1&gt;),TestClass.new(:key&lt;3&gt;));   
   
   my $i = 0;
   try { .key //= ++$i for @array1 };
   my $sum1 = @array1.map:{ $_.key };
   my $sum2 = @array2.map:{ $_.key };
   is( $sum1, $sum2, '.key //= ++$i for @array1;', :todo&lt;bug&gt;);

}

# .key = 1 for @array1;
{
   class TestClass is rw { has $.key; };
   my @array1 = (TestClass.new(),TestClass.new(:key&lt;2&gt;));
   my @array2 = (TestClass.new(:key&lt;1&gt;),TestClass.new(:key&lt;1&gt;));   

   try { .key = 1 for @array1 };
   my $sum1 = @array1.map:{ $_.key };
   my $sum2 = @array2.map:{ $_.key };
   is($sum1, $sum2, '.key = 1 for @array1;');
}

# $_.key = 1 for @array1;
{
   class TestClass is rw { has $.key; };
   my @array1 = (TestClass.new(),TestClass.new(:key&lt;2&gt;));
   my @array2 = (TestClass.new(:key&lt;1&gt;),TestClass.new(:key&lt;1&gt;));   

   try { $_.key = 1 for @array1 };
   my $sum1 = @array1.map:{ $_.key };
   my $sum2 = @array2.map:{ $_.key };
   is( $sum1, $sum2, '$_.key = 1 for @array1;');

}</pre>
</div><pre>
    for @foo -&gt; $item { print $item }</pre>
<p>Multiple parameters may be passed, in which case the list is traversed
more than one element at a time:</p>
<pre>
    for %hash.kv -&gt; $key, $value { print &quot;$key =&gt; $value\n&quot; }</pre>
<p>To process two arrays in parallel, use the <code>each</code> function:</p>
<pre>
    for each(@a;@b) -&gt; $a, $b { print &quot;[$a, $b]\n&quot; }</pre>
<p>or use the <code>zip</code> function to generate a list of <code>Seq</code> objects that each can
be bound to multiple arguments enclosed in square brackets:</p>
<pre>
    for zip(@a;@b) -&gt; [$a, $b] { print &quot;[$a, $b]\n&quot; }</pre>
<p>The list is evaluated lazily by default, so instead of using a <code>while</code>
to read a file a line at a time as you would in Perl 5:</p>
<pre>
    while (my $line = &lt;STDIN&gt;) {...}</pre>
<p>in Perl 6 you should use a <code>for</code> (plus a unary <code>=</code> ``iterate the
iterator'' operator) instead:</p>
<pre>
    for =$*IN -&gt; $line {...}</pre>
<p>This has the added benefit of limiting the scope of the <code>$line</code>
parameter to the block it's bound to.  (The <code>while</code>'s declaration of
<code>$line</code> continues to be visible past the end of the block.  Remember,
no implicit block scopes.)  It is also possible to write</p>
<pre>
    while =$*IN -&gt; $line {...}</pre>
<p>Note also that Perl 5's special rule causing</p>
<pre>
    while (&lt;&gt;) {...}</pre>
<p>to automatically assign to <code>$_</code> is not carried over to Perl 6.  That
should now be written:</p>
<pre>
    for =&lt;&gt; {...}</pre>
<p>which is short for</p>
<pre>
    for =$*ARGS {...}</pre>
<p>Parameters are by default readonly within the block.  You can
declare a parameter read/write by including the ``<code>is rw</code>'' trait.
If you rely on <code>$_</code> as the implicit parameter to a block,
then <code>$_</code> is considered read/write by default.  That is,
the construct:</p>
<pre>
    for @foo {...}</pre>
<p>is actually short for:</p>
<pre>
    for @foo -&gt; $_ is rw {...}</pre>
<p>so you can modify the current list element in that case.  However,
any time you specify the arguments, they default to read only.</p>
<p>When used as statement modifers, <code>for</code> and <code>given</code> use a private
instance of <code>$_</code> for the left side of the statement.  The outer <code>$_</code>
can be referred to as <code>$OUTER::_</code>.  (And yes, this implies that the
compiler may have to retroactively change the binding of &lt;$_&gt; on the
left side.  But it's what people expect of a pronoun like ``it''.)</p>
<p>
</p>
<h2><a name="The20do2donce20loop">The do-once loop</a></h2>
<p>In Perl 5, a bare block is deemed to be a do-once loop.  In Perl 6,
the bare block is not a do-once.  Instead <code>do {...}</code> is the do-once
loop (which is another reason you can't put a <code>while</code> or <code>until</code>
modifier on it; use <code>repeat</code> for that).</p>
<a name="msg_35"></a>
<a href="?hide_quotes=no#msg_35" onclick="return tog_quote(35);">
<div ID=header_shown_35 style="display: none;">
- Hide the snippet from t/statements/do.t (line 7 ~ line 21) -
</div>
<div ID=header_hidden_35 style="display: block;">
- Show the snippet from t/statements/do.t (line 7 ~ line 21, 15 lines) -</div>
</a>
<div ID=hide_35 style="display:none; border:1px solid">
<pre>
# L&lt;S04/The do-once loop/"can't" put while or until modifier&gt;
{
    my $i;
    ok !eval 'do { $i++ } while $i &lt; 5;',
        "'do' can't take the 'while' modifier";
    is $i, undef, 'the code never run';
}

{
    my $i;
    ok !eval 'do { $i++ } until $i &gt; 4;',
        "'do' can't take the 'until' modifier";
    is $i, undef, 'the code never run';
}
</pre>
</div><p>For any statement, prefixing with a <code>do</code> allows you to 
return the value of that statement and use it in an expression:</p>
<pre>
    $x = do if $a { $b } else { $c };</pre>
<p>This construct only allows you to attach a single statement to the end
of an expression.  If you want to continue the expression after the
statement, or if you want to attach multiple statements. you must use
the curly form.  Since a bare expression may be used as a statement,
you may use <code>do</code> on an expression, but its only effect is to function
as an unmatched left parenthesis, much like the <code>$</code> operator in
Haskell.  That is, precedence decisions do not cross a <code>do</code> boundary.
Conjectural: a <code>do</code> may be used within a subexpression, but only if
terminated by an unmatched right bracket of some kind.</p>
<a name="msg_36"></a>
<a href="?hide_quotes=no#msg_36" onclick="return tog_quote(36);">
<div ID=header_shown_36 style="display: none;">
- Hide the snippet from t/statements/do.t (line 48 ~ line 56) -
</div>
<div ID=header_hidden_36 style="display: block;">
- Show the snippet from t/statements/do.t (line 48 ~ line 56, 9 lines) -</div>
</a>
<div ID=hide_36 style="display:none; border:1px solid">
<pre>
# L&lt;S04/The do-once loop/"you may use" do "on an expression"&gt;
{
    my $ret = do 42;
    is($ret, 42, 'do EXPR should also work (single number)');

    $ret = do 3 + 2;
    is($ret, 5, 'do EXPR should also work (simple + expr)');
}
</pre>
</div><p>Since <code>do</code> is defined as going in front of a statement, it follows
that it can always be followed by a statement label.  This is particularly
useful for the do-once block, since it is offically a loop and can take
therefore loop control statements.</p>
<a name="msg_37"></a>
<a href="?hide_quotes=no#msg_37" onclick="return tog_quote(37);">
<div ID=header_shown_37 style="display: none;">
- Hide the snippet from t/statements/do.t (line 57 ~ line 77) -
</div>
<div ID=header_hidden_37 style="display: block;">
- Show the snippet from t/statements/do.t (line 57 ~ line 77, 21 lines) -</div>
</a>
<div ID=hide_37 style="display:none; border:1px solid">
<pre>
# L&lt;S04/The do-once loop/"can take" "loop control statements"&gt;
{
    my $i;
    do {
        $i++;
        next;
        $i--;
    }
    is $i, 1, "'next' works in 'do' block";
}

{
    my $i;
    do {
        $i++;
        last;
        $i--;
    }
    is $i, 1, "'last' works in 'do' block";
}
</pre>
</div><p>Although a bare block is no longer a do-once loop, it still executes
immediately as in Perl 5, as if it were immediately dereferenced with
a <code>.()</code> postfix, so within such a block <code>CALLER::</code> refers to the
scope surrounding the block.  If you wish to return a closure from a
function, you must use an explicit prefix such as <code>return</code> or <code>sub</code>
or <code>-&gt;</code>.  (Use of a placeholder parameter is deemed insufficiently
explicit because it's not out front where it can be seen.  You can, of
course, use a placeholder parameter if you also use <code>return</code>.)</p>
<a name="msg_38"></a>
<a href="?hide_quotes=no#msg_38" onclick="return tog_quote(38);">
<div ID=header_shown_38 style="display: none;">
- Hide the snippet from t/statements/do.t (line 78 ~ line 89) -
</div>
<div ID=header_hidden_38 style="display: block;">
- Show the snippet from t/statements/do.t (line 78 ~ line 89, 12 lines) -</div>
</a>
<div ID=hide_38 style="display:none; border:1px solid">
<pre>
# L&lt;S04/The do-once loop/"bare block" "no longer a do-once loop"&gt;
{
    my $i;
    ok !eval('{ $i++; next; $i--; }'), "bare block can't take 'next'";
    is $i, undef, "the code snippet never run";
}

{
    my $i;
    ok !eval('{ $i++; last; $i--; }'), "bare block can't take 'last'";
    is $i, undef, "the code snippet never run";
}</pre>
</div><p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Switch20statements">Switch statements</a></h1>
<p>A switch statement is a means of topicalizing, so the switch keyword
is the English topicalizer, <code>given</code>.  The keyword for individual
cases is <code>when</code>:</p>
<pre>
    given EXPR {
        when EXPR { ... }
        when EXPR { ... }
        default { ... }
    }</pre>
<p>The current topic is always aliased to the special variable <code>$_</code>.
The <code>given</code> block is just one way to set the current topic, but a
switch statement can be any block that sets <code>$_</code>, including a <code>for</code>
loop (in which the first loop parameter is the topic) or the body
of a method (if you have declared the invocant as <code>$_</code>).  So switching
behavior is actually caused by the <code>when</code> statements in the block,
not by the nature of the block itself.  A <code>when</code> statement implicitly
does a ``smart match'' between the current topic (<code>$_</code>) and the argument
of the <code>when</code>.  If the smart match succeeds, the associated closure
is executed, and the surrounding block is automatically broken out
of.  If the smart match fails, control passes to the next statement
normally, which may or may not be a <code>when</code> statement.  Since <code>when</code>
statements are presumed to be executed in order like normal statements,
it's not required that all the statements in a switch block be <code>when</code>
statements (though it helps the optimizer to have a sequence of
contiguous <code>when</code> statements, because then it can arrange to jump
directly to the first appropriate test that might possibly match.)</p>
<p>The default case:</p>
<pre>
    default {...}</pre>
<p>is exactly equivalent to</p>
<a name="msg_9"></a>
<a href="?hide_quotes=no#msg_9" onclick="return tog_quote(9);">
<div ID=header_shown_9 style="display: none;">
- Hide the snippet from t/statements/given.t (line 211 ~ line 286) -
</div>
<div ID=header_hidden_9 style="display: block;">
- Show the snippet from t/statements/given.t (line 211 ~ line 286, 76 lines) -</div>
</a>
<div ID=hide_9 style="display:none; border:1px solid">
<pre>
# L&lt;S04/"Switch statements" /"is exactly equivalent to"&gt;
eval '
    my @input = (0, 1);
    my @got;

    for @input -&gt; $x {
        given $x {
              when true { push @got, "true" }
          default { push @got, "false" }
                  #when !true { push @got, "false" }
        }
    }

    is(@got.join(","), "false,true", q!given { when true { } }!);
';
flunk("when true is parsefail", :todo&lt;feature&gt;) if $!;

# given + hash deref
{
    my %h;
    given %h { .{'key'} = 'value'; }
    ok(%h{'key'} eq 'value', 'given and hash deref using .{}');
    given %h { .&lt;key&gt; = "value"; }
    ok(%h{'key'} eq 'value', 'given and hash deref using .&lt;&gt;');
}

# given + 0-arg closure
{
    my $x;
    given 41 {
        when ({ $_ == 49 }) { diag "this really shouldn't happen"; $x = 49 }
        when ({ $_ == 41 }) { $x++ }
    }
    ok $x, 'given tests 0-arg closures for truth';
}

# given + 1-arg closure
{
    my $x;
    given 41 {
        when (-&gt; $t { $t == 49 }) { diag "this really shouldn't happen"; $x = 49 }
        when (-&gt; $t { $t == 41 }) { $x++ }
    }
    ok $x, 'given tests 1-arg closures for truth';
}

# given + n&gt;1-arg closure (should fail)
{
    dies_ok {
        given 41 {
            when (-&gt; $t, $r { $t == $r }) { ... }
        }
    }, 'fail on arities &gt; 1';
    is $!, 'Unexpected arity in smart match: 2', '...with useful error message';
}

# given + 0-arg sub
{
    my $x = 41;
    sub always_true { Bool::True }
    given 1 {
        when &amp;always_true { $x++ }
    }
    is $x, 42, 'given tests 0-arg subs for truth';
}

# given + 1-arg sub
{
    my $x = 41;
    sub maybe_true ($value) { $value eq "mytopic" }
    given "mytopic" {
        when &amp;maybe_true { $x++ }
    }
    is $x, 42, 'given tests 1-arg subs for truth';
}
</pre>
</div><pre>
    when * {...}</pre>
<p>Because <code>when</code> statements are executed in order, the default must
come last.  You don't have to use an explicit default--you can just
fall off the last <code>when</code> into ordinary code.  But use of a <code>default</code>
block is good documentation.</p>
<p>If you use a <code>for</code> loop with a named parameter, the parameter is
also aliased to <code>$_</code> so that it can function as the topic of any
<code>when</code> statements within the loop.  If you use a <code>for</code> statement
with multiple parameters, only the first parameter is aliased to <code>$_</code>
as the topic.</p>
<p>You can explicitly break out of a <code>when</code> block (and its surrounding
switch) early using the <code>break</code> verb.  You can explicitly break out
of a <code>when</code> block and go to the next statement by using <code>continue</code>.
(Note that, unlike C's idea of falling through, subsequent <code>when</code>
conditions are evaluated.  To jump into the next <code>when</code> block you
must use a <code>goto</code>.)</p>
<p>If you have a switch that is the main block of a <code>for</code> loop, and
you break out of the switch either implicitly or explicitly, it merely
goes to the next iteration of the loop.  You must use <code>last</code> to break
out of the entire loop early.  Of course, an explicit <code>next</code> would
be clearer than a <code>break</code> if you really want to go to the next iteration.
Possibly we'll outlaw <code>break</code> in a loop topicalizer.</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Exception20handlers">Exception handlers</a></h1>
<p>Unlike many other languages, Perl 6 specifies exception handlers by
placing a <code>CATCH</code> block <em>within</em> that block that is having its exceptions
handled.</p>
<p>The Perl 6 equivalent to Perl 5's <code>eval {...}</code> is <code>try {...}</code>.
(Perl 6's <code>eval</code> function only evaluates strings, not blocks.)
A <code>try</code> block by default has a <code>CATCH</code> block that handles all
exceptions by ignoring them.  If you define a <code>CATCH</code> block within
the <code>try</code>, it replaces the default <code>CATCH</code>.  It also makes the <code>try</code>
keyword redundant, because any block can function as a <code>try</code> block
if you put a <code>CATCH</code> block within it.</p>
<p>An exception handler is just a switch statement on an implicit topic
supplied within the <code>CATCH</code> block.  That implicit topic is the current
exception object, also known as <code>$!</code>.  Inside the <code>CATCH</code> block, it's
also bound to <code>$_</code>, since it's the topic.  Because of smart matching,
ordinary <code>when</code> statements are sufficiently powerful to pattern
match the current exception against classes or patterns or numbers
without any special syntax for exception handlers.  If none of the
cases in the <code>CATCH</code> handles the exception, the exception is rethrown.
To ignore all unhandled exceptions, use an empty <code>default</code> case.
(In other words, there is an implicit <code>die $!</code> just inside the end
of the <code>CATCH</code> block.  Handled exceptions break out past this implicit
rethrow.)</p>
<p>A <code>CATCH</code> block sees the lexical scope in which it was defined, but
its caller is the dynamic location that threw the exception.  That is,
the stack is not unwound until some exception handler chooses to
unwind it by ``handling'' the exception in question.  So logically,
if the <code>CATCH</code> block throws its own exception, you would expect the
<code>CATCH</code> block to catch its own exception recursively forever.  However,
a <code>CATCH</code> must not behave that way, so we say that a <code>CATCH</code> block
never attempts to handle any exception thrown within its own dynamic scope.
(Otherwise the <code>die</code> in the previous paragraph would never work.)</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Control20Exceptions">Control Exceptions</a></h1>
<p>All abnormal control flow is, in the general case, handled by the
exception mechanism (which is likely to be optimized away in specific
cases.)  Here ``abnormal'' means any transfer of control outward that
is not just falling off the end of a block.  A <code>return</code>,
for example, is considered a form of abnormal control flow, since it
can jump out of multiple levels of closures to the end of the scope
of the current subroutine definition.  Loop commands like <code>next</code>
are abnormal, but looping because you hit the end of the block is not.
The implicit break of a <code>when</code> block is abnormal.</p>
<p>A <code>CATCH</code> block handles only ``bad'' exceptions, and lets control
exceptions pass unhindered.  Control exceptions may be caught with a
<code>CONTROL</code> block.  Generally you don't need to worry about this unless
you're defining a control construct.  You may have one <code>CATCH</code> block
and one <code>CONTROL</code> block, since some user-defined constructs may wish to
supply an implicit <code>CONTROL</code> block to your closure, but let you define
your own <code>CATCH</code> block.</p>
<p>A <code>return</code> always exits from the lexically surrounding sub
or method definition (that is, from a function officially declared
with the <code>sub</code>, <code>method</code>, or <code>submethod</code> keywords).  Pointy blocks
and bare closures are transparent to <code>return</code>.  If you pass a closure
object outside of its official ``sub'' scope, it is illegal to
return from it.  You may only leave the closure block itself with <code>leave</code>
or by falling off the end of it.</p>
<p>To return a value from a pointy block or bare closure, you either
just let the block return the value of its final expression, or you can
use <code>leave</code>.  A <code>leave</code> by default exits from the innermost block.
But you may change the behavior of <code>leave</code> with a selector as the
first argument:</p>
<pre>
    leave Loop where { .label ~~ 'LINE' }, 1,2,3;</pre>
<p>The innermost block matching the selection criteria will be exited.
The return value, if any, must be passed as the second and subsequent arguments.
To return pairs as part of the value, you can use a feed operator:</p>
<pre>
    leave &lt;== :foo:bar:baz(1) if $leaving;</pre>
<p>or going the other way:</p>
<pre>
    $leaving and :foo:bar:baz(1) ==&gt; leave;</pre>
<p>In theory, any user-defined control construct can catch any control
exception it likes.  However, there have to be some culturally enforced
standards on which constructs capture which exceptions.  Much like
<code>return</code> may only return from an ``official'' subroutine or method,
a loop exit like <code>next</code> should be caught by the construct the user
expects it to be caught by.  In particular, if the user labels a loop
with a specific label, and calls a loop control from within the lexical
scope of that loop, and if that call mentions the outer loop's label,
then that outer loop is the one that must be controlled. (This search
of lexical scopes is limited to the current ``official'' subroutine.)</p>
<p>If there is no such lexically scoped outer loop in the current subroutine,
then a fallback search is made outward through the dynamic scopes in
the same way Perl 5 does.  (The difference between Perl 5 and Perl 6
in this respect arises only because Perl 5 didn't have user-defined
control structures, hence the sub's lexical scope was <em>always</em>
the innermost dynamic scope, so the preference to the lexical scope
in the current sub was implicit.  For Perl 6 we have to make this
preference explicit.)</p>
<p>Warnings are produced in Perl 6 by throwing a resumable control
exception to the outermost scope, which by default prints the
warning and resumes the exception by extracting a resume continuation
from the exception, which must be supplied by the <code>warn()</code> function
(or equivalent).  Exceptions are not resumable in Perl 6 unless
the exception object does the <code>Resumable</code> role.  (Note that fatal
exception types can do the <code>Resumable</code> role even if thrown via
<code>fail()</code>--when uncaught they just hit the outermost fatal handler
instead of the outermost warning handler, so some inner scope has to
explicitly treat them as warnings and resume them.)</p>
<p>Since warnings are processed using the standard control exception
mechanism, they may be intercepted and either suppressed or fatalized
anywhere within the dynamic scope by supplying a suitable <code>CONTROL</code>
block.  This dynamic control is orthogonal to any lexically scoped
warning controls, which merely decide whether to call <code>warn()</code>
in the first place.</p>
<p>As with calls to <code>return</code>, the warning control exception is an
abstraction that the compiler is free to optimize away (along with the
associated continuation) when the compiler or runtime can determine
that the semantics would be preserved by merely printing out the
error and going on.  Since all exception handlers run in the dynamic
context of the throw, that reduces to simply returning from the <code>warn</code>
function most of the time.</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="The20goto20statement">The goto statement</a></h1>
<p>In addition to <code>next</code>, <code>last</code>, and <code>redo</code>, Perl 6 also supports
<code>goto</code>.  As with ordinary loop controls, the label is searched for
first lexically within the current subroutine, then dynamically outside
of it.  Unlike with loop controls, however, scanning a scope includes
a scan of any lexical scopes included within the current candidate
scope.  As in Perl 5, it is possible to <code>goto</code> into a lexical scope,
but only for lexical scopes that require no special initialization
of parameters.  (Initialization of ordinary variables does not
count--presumably the presence of a label will prevent code-movement
optimizations past the label.)  So, for instance, it's always possible
to <code>goto</code> into the next case of a <code>when</code> or into either the ``then''
or ``else'' branch of a conditional.  You may not go into a <code>given</code>
or a <code>for</code>, though, because that would bypass a formal parameter
binding (not to mention list generation in the case of <code>for</code>).
(Note: the implicit default binding of an outer $_ to an inner $_
can be emulated for a bare block, so that doesn't fall under the
prohibition on bypassing formal binding.)</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Exceptions">Exceptions</a></h1>
<p>As in Perl 5, many built-in functions simply return undef when you ask
for a value out of range, or the function fails somehow.  Perl 6 has
<code>Failure</code> objects, any of which refers to an unthrown <code>Exception</code> object in
<code>$!</code> and knows whether it has been handled or not.</p>
<p>If you test a <code>Failure</code> for <code>.defined</code> or <code>.true</code>, it causes
<code>$!</code> to mark the exception as <em>handled</em>, and acts as a harmless <code>Undef</code>
value thereafter.  Any other use of the <code>Failure</code> will throw its associated
exception immediately.</p>
<p>Because the contextual variable <code>$!</code> contains all exceptions collected in the
current lexical scope, saying <code>die $!</code> will throw all exceptions,
whether they were handled or not.  A bare <code>die</code>/<code>fail</code> takes <code>$!</code> as the
default argument.</p>
<p>At scope exit, <code>$!</code> discards all handled exceptions from itself, then performs
a garbage-collection check for all remaining (unhandled) exceptions.  If all of
them are still alive (e.g. by becoming part of the return value), then they are
appended to <code>CALLER::&lt;$!&gt;</code>.  Otherwise, it calls <code>die</code> to throw those
exceptions as a single new exception, which may then be caught with a <code>CATCH</code>
block in the current (or caller's) scope.</p>
<p>You can cause built-ins to automatically throw exceptions on failure using</p>
<pre>
    use fatal;</pre>
<p>The <code>fail</code> function responds to the caller's <code>use fatal</code> state.  It
either returns an unthrown exception, or throws the exception.</p>
<a name="msg_13"></a>
<a href="?hide_quotes=no#msg_13" onclick="return tog_quote(13);">
<div ID=header_shown_13 style="display: none;">
- Hide the snippet from t/builtins/control_flow/fail.t (line 7 ~ line 34) -
</div>
<div ID=header_hidden_13 style="display: block;">
- Show the snippet from t/builtins/control_flow/fail.t (line 7 ~ line 34, 28 lines) -</div>
</a>
<div ID=hide_13 style="display:none; border:1px solid">
<pre>
# L&lt;S04/"Exceptions" /The fail function/&gt;

{
  # "use fatal" is not standard, so we don't have to disable it here
  my $was_after_fail  = 0;
  my $was_before_fail = 0;
  my $sub = sub { $was_before_fail++; my $exception = fail_ 42; $was_after_fail++ };

  my $unthrown_exception = $sub();
  # Note: We don't further access $unthrown_exception, so it doesn't get thrown
  is $was_before_fail, 1, "fail() doesn't cause our sub to not get executed";
  is $was_after_fail,  0, "fail() causes our sub to return (1)";
}

{
  # Explicitly "use fatal"
  # use fatal; -- Commented as there's no fatal.pm yet.
  # Instead, we set the magical variable $?FAIL_SHOULD_DIE to a true value.
  my $?FAIL_SHOULD_DIE = 1;
  my $was_after_fail = 0;
  my $was_after_sub  = 0;
  my $sub = sub { fail_ 42; $was_after_fail++ };

  try { $sub(); $was_after_sub++ };

  is $was_after_fail, 0, "fail() causes our sub to return (2)";
  is $was_after_sub,  0, "fail() causes our try{} to die";
}</pre>
</div><p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Closure20traits">Closure traits</a></h1>
<a name="msg_26"></a>
<a href="?hide_quotes=no#msg_26" onclick="return tog_quote(26);">
<div ID=header_shown_26 style="display: none;">
- Hide the snippet from t/closure_traits/in_loop.t (line 18 ~ line 70) -
</div>
<div ID=header_hidden_26 style="display: block;">
- Show the snippet from t/closure_traits/in_loop.t (line 18 ~ line 70, 53 lines) -</div>
</a>
<div ID=hide_26 style="display:none; border:1px solid">
<pre>
# L&lt;S04/"Closure traits"&gt;

{
    my $str;

    for 1..10 -&gt; $i {
        last if $i &gt; 3;
        $str ~= "($i a)";
        next if $i % 2 == 1;
        $str ~= "($i b)";
        LAST  { $str ~= "($i Last)" }
        LEAVE { $str ~= "($i Leave)" }
        NEXT  { $str ~= "($i N)" }
        START { $str ~= "($i S)" }
        ENTER { $str ~= "($i E)" }
    }

    is $str, "(1 S)(1 E)(1 a)" ~ "(1 N)(1 Leave)" ~
                  "(2 E)(2 a)(2 b)(2 N)(2 Leave)" ~
                  "(3 E)(3 a)" ~ "(3 N)(3 Leave)" ~
                  "(4 E)"  ~  "(4 Last)(4 Leave)",
       'trait blocks work properly in for loop';
}

{
    my $str;

    for 1..10 -&gt; $i {
        last if $i &gt; 3;
        $str ~= "($i a)";

        ENTER { $str ~= "($i E1)" }
        LAST  { $str ~= "($i Last1)" }
        START { $str ~= "($i S1)" }
        LEAVE { $str ~= "($i Leave1)" }

        next if $i % 2 == 1;
        $str ~= "($i b)";

        LAST  { $str ~= "($i Last2)" }
        NEXT  { $str ~= "($i N1)" }
        START { $str ~= "($i S2)" }
        LEAVE { $str ~= "($i Leave2)" }
        ENTER { $str ~= "($i E2)" }
        NEXT  { $str ~= "($i N2)" }
    }

    is $str, "(1 S1)(1 S2)(1 E1)(1 E2)(1 a)" ~ "(1 N1)(1 N2)" ~  "(1 Leave1)(1 Leave2)" ~
                         "(2 E1)(2 E2)(2 a)(2 b)(2 N1)(2 N2)" ~  "(2 Leave1)(2 Leave2)" ~
                         "(3 E1)(3 E2)(3 a)" ~ "(3 N1)(3 N2)" ~  "(3 Leave1)(3 Leave2)" ~
                         "(4 E1)(4 E2)"  ~     "(4 Last1)(4 Last2)(4 Leave1)(4 Leave2)",
       'trait blocks work properly in for loop';
}</pre>
</div><p>A <code>CATCH</code> block is just a trait of the closure containing it.  Other
blocks can be installed as traits as well.  These other blocks are
called at various times, and some of them respond to various control
exceptions and exit values:</p>
<pre>
      BEGIN {...}*      at compile time, ASAP, only ever runs once
      CHECK {...}*      at compile time, ALAP, only ever runs once
       INIT {...}*      at run time, ASAP, only ever runs once</pre>
<a name="msg_27"></a>
<a href="?hide_quotes=no#msg_27" onclick="return tog_quote(27);">
<div ID=header_shown_27 style="display: none;">
- Hide the snippet from t/closure_traits/init.t (line 7 ~ line 68) -
</div>
<div ID=header_hidden_27 style="display: block;">
- Show the snippet from t/closure_traits/init.t (line 7 ~ line 68, 62 lines) -</div>
</a>
<div ID=hide_27 style="display:none; border:1px solid">
<pre>
# L&lt;S04/"Closure traits"/INIT "at run time" ASAP&gt;
# INIT {...} blocks in "void" context
{
    my $str;
    is $str, "begin1 begin2 init ", "init blocks run after begin blocks";

    BEGIN { $str ~= "begin1 "; }
    INIT  { $str ~= "init "; }
    BEGIN { $str ~= "begin2 "; }
}

{
    my $str;
    is $str, "check2 check1 init ", "init blocks run after check blocks";

    CHECK { $str ~= "check1 "; }
    INIT  { $str ~= "init "; }
    CHECK { $str ~= "check2 "; }
}

{
    my $str;
    is $str, "begin init1 init2 ", "init blocks run in forward order";

    INIT  { $str ~= "init1 "; }
    BEGIN { $str ~= "begin "; }
    INIT  { $str ~= "init2 "; }
}

# INIT {...} blocks as rvalues
{
    my $str;
    my $handle = { my $retval = INIT { $str ~= 'I' } };

    is $str, 'I', 'our INIT {...} block already gets called';
    is $handle(), 'I', 'our INIT {...} block returned the correct var (1)';
    is $handle(), 'I', 'our INIT {...} block returned the correct var (2)';
    is $str, 'I', 'our rvalue INIT {...} block was executed exactly once';
}

# IRC note:
# ---------------------------------------------------------------
# &lt;TimToady1&gt; also, the INIT's settings are going to get wiped
#             out when the my is executed, so you probably just
#             end up with 'o'
{
    my $str = 'o';
    INIT { $str ~= 'i' }
    is $str, 'o', 'the value set by INIT {} wiped out by the initializer of $str';
}

# IRC note:
# ---------------------------------------------------------------
# &lt;TimToady1&gt; INIT runs once just before the mainline code runs.
# &lt;agentzh&gt; even if INIT is in a block?
# &lt;TimToady1&gt; yes.
my $str ~= 'o';  # Note that this is different from  "my $str = 'o';".
{
    INIT { $str ~= 'i' }
}
is $str, 'io', 'INIT {} always runs before the mainline code runs';
</pre>
</div><pre>
        END {...}       at run time, ALAP, only ever runs once</pre>
<a name="msg_29"></a>
<a href="?hide_quotes=no#msg_29" onclick="return tog_quote(29);">
<div ID=header_shown_29 style="display: none;">
- Hide the snippet from t/closure_traits/interpolate.t (line 11 ~ line 40) -
</div>
<div ID=header_hidden_29 style="display: block;">
- Show the snippet from t/closure_traits/interpolate.t (line 11 ~ line 40, 30 lines) -</div>
</a>
<div ID=hide_29 style="display:none; border:1px solid">
<pre>
# L&lt;S04/Closure traits/END "at run time" ALAP&gt;

# IRC log:
# ----------------------------------------------------------------
# agentzh   question: should BEGIN blocks interpolated in double-quoted
#           strings be fired at compile-time or run-time?
#           for example, say "This is { BEGIN { say 'hi' } }";
# audreyt   compile time.
#           qq is not eval.

my $hist;

END {
    is $hist, 'BCISE', 'interpolated END {...} executed';
}

is "{ END { $hist ~= 'E' } }", undef,
    'END {...} not yet executed';

is "{ START { $hist ~= 'S' } }", "BCIS",
    'START {...} fired at run-time, entry time of the mainline code';

is "{ INIT { $hist ~= 'I' } }", 'BCI',
    'INIT {...} fired at the beginning of runtime';

is "{ CHECK { $hist ~= 'C' } }", "BC",
    'CHECK {...} fired at compile-time, ALAP';

is "{ BEGIN { $hist ~= 'B' } }", "B",
    'BEGIN {...} fired at compile-time, ASAP';</pre>
</div><a name="msg_24"></a>
<a href="?hide_quotes=no#msg_24" onclick="return tog_quote(24);">
<div ID=header_shown_24 style="display: none;">
- Hide the snippet from t/closure_traits/descending_order.t (line 11 ~ line 53) -
</div>
<div ID=header_hidden_24 style="display: block;">
- Show the snippet from t/closure_traits/descending_order.t (line 11 ~ line 53, 43 lines) -</div>
</a>
<div ID=hide_24 style="display:none; border:1px solid">
<pre>
# L&lt;S04/Closure traits/END "at run time" ALAP&gt;

my $var;
my ($var_at_enter, $var_at_init, $var_at_check, $var_at_begin);
my $eof_var;

$var = 13;

my $hist;

END {
    # tests for END blocks:
    is $var, 13, '$var gets initialized at END time';
    is $eof_var, 29, '$eof_var gets assigned at END time';
}

ENTER {
    $hist ~= 'enter ';
    $var_at_enter = $var;
}

INIT {
    $hist ~= 'init ';
    $var_at_init = $var;
}

CHECK {
    $hist ~= 'check ';
    $var_at_check = $var;
}

BEGIN {
    $hist ~= 'begin ';
    $var_at_begin = $var;
}

is $hist, 'begin check init first ', 'BEGIN {} runs only once';
is $var_at_begin, undef, 'BEGIN {...} ran at compile time';
is $var_at_check, undef, 'CHECK {...} ran at compile time';
is $var_at_init, undef, 'INIT {...} ran at runtime, but ASAP';
is $var_at_enter, undef, 'ENTER {...} at runtime, but before the mainline body';

$eof_var = 29;</pre>
</div><a name="msg_30"></a>
<a href="?hide_quotes=no#msg_30" onclick="return tog_quote(30);">
<div ID=header_shown_30 style="display: none;">
- Hide the snippet from t/closure_traits/interpolate.t (line 11 ~ line 40) -
</div>
<div ID=header_hidden_30 style="display: block;">
- Show the snippet from t/closure_traits/interpolate.t (line 11 ~ line 40, 30 lines) -</div>
</a>
<div ID=hide_30 style="display:none; border:1px solid">
<pre>
# L&lt;S04/Closure traits/END "at run time" ALAP&gt;

# IRC log:
# ----------------------------------------------------------------
# agentzh   question: should BEGIN blocks interpolated in double-quoted
#           strings be fired at compile-time or run-time?
#           for example, say "This is { BEGIN { say 'hi' } }";
# audreyt   compile time.
#           qq is not eval.

my $hist;

END {
    is $hist, 'BCISE', 'interpolated END {...} executed';
}

is "{ END { $hist ~= 'E' } }", undef,
    'END {...} not yet executed';

is "{ START { $hist ~= 'S' } }", "BCIS",
    'START {...} fired at run-time, entry time of the mainline code';

is "{ INIT { $hist ~= 'I' } }", 'BCI',
    'INIT {...} fired at the beginning of runtime';

is "{ CHECK { $hist ~= 'C' } }", "BC",
    'CHECK {...} fired at compile-time, ALAP';

is "{ BEGIN { $hist ~= 'B' } }", "B",
    'BEGIN {...} fired at compile-time, ASAP';</pre>
</div><a name="msg_23"></a>
<a href="?hide_quotes=no#msg_23" onclick="return tog_quote(23);">
<div ID=header_shown_23 style="display: none;">
- Hide the snippet from t/closure_traits/ascending_order.t (line 11 ~ line 59) -
</div>
<div ID=header_hidden_23 style="display: block;">
- Show the snippet from t/closure_traits/ascending_order.t (line 11 ~ line 59, 49 lines) -</div>
</a>
<div ID=hide_23 style="display:none; border:1px solid">
<pre>
# L&lt;S04/Closure traits/END "at run time" ALAP&gt;

my $var;
my ($var_at_begin, $var_at_check, $var_at_init, $var_at_start, $var_at_enter);
my $eof_var;

$var = 13;

my $hist;

BEGIN {
    $hist ~= 'begin ';
    $var_at_begin = $var;
}

CHECK {
    $hist ~= 'check ';
    $var_at_check = $var;
}

INIT {
    $hist ~= 'init ';
    $var_at_init = $var;
}

ENTER {
    $hist ~= 'enter ';
    $var_at_enter = $var;
}

START {
    $hist ~= 'start ';
    $var_at_start = $var + 1;
}

END {
    # tests for END blocks:
    is $var, 13, '$var gets initialized at END time';
    is $eof_var, 29, '$eof_var gets assigned at END time';
}

is $hist, 'begin check init start ', 'BEGIN {} runs only once';
is $var_at_begin, undef, 'BEGIN {...} ran at compile time';
is $var_at_check, undef, 'CHECK {...} ran at compile time';
is $var_at_init, undef, 'INIT {...} ran at runtime, but ASAP';
is $var_at_enter, undef, 'ENTER {...} at runtime, but before the mainline body';
is $var_at_start, 14, 'START {...} at runtime, just in time';

$eof_var = 29;</pre>
</div><a name="msg_31"></a>
<a href="?hide_quotes=no#msg_31" onclick="return tog_quote(31);">
<div ID=header_shown_31 style="display: none;">
- Hide the snippet from t/closure_traits/interpolate.t (line 11 ~ line 40) -
</div>
<div ID=header_hidden_31 style="display: block;">
- Show the snippet from t/closure_traits/interpolate.t (line 11 ~ line 40, 30 lines) -</div>
</a>
<div ID=hide_31 style="display:none; border:1px solid">
<pre>
# L&lt;S04/Closure traits/END "at run time" ALAP&gt;

# IRC log:
# ----------------------------------------------------------------
# agentzh   question: should BEGIN blocks interpolated in double-quoted
#           strings be fired at compile-time or run-time?
#           for example, say "This is { BEGIN { say 'hi' } }";
# audreyt   compile time.
#           qq is not eval.

my $hist;

END {
    is $hist, 'BCISE', 'interpolated END {...} executed';
}

is "{ END { $hist ~= 'E' } }", undef,
    'END {...} not yet executed';

is "{ START { $hist ~= 'S' } }", "BCIS",
    'START {...} fired at run-time, entry time of the mainline code';

is "{ INIT { $hist ~= 'I' } }", 'BCI',
    'INIT {...} fired at the beginning of runtime';

is "{ CHECK { $hist ~= 'C' } }", "BC",
    'CHECK {...} fired at compile-time, ALAP';

is "{ BEGIN { $hist ~= 'B' } }", "B",
    'BEGIN {...} fired at compile-time, ASAP';</pre>
</div><a name="msg_25"></a>
<a href="?hide_quotes=no#msg_25" onclick="return tog_quote(25);">
<div ID=header_shown_25 style="display: none;">
- Hide the snippet from t/closure_traits/descending_order.t (line 11 ~ line 53) -
</div>
<div ID=header_hidden_25 style="display: block;">
- Show the snippet from t/closure_traits/descending_order.t (line 11 ~ line 53, 43 lines) -</div>
</a>
<div ID=hide_25 style="display:none; border:1px solid">
<pre>
# L&lt;S04/Closure traits/END "at run time" ALAP&gt;

my $var;
my ($var_at_enter, $var_at_init, $var_at_check, $var_at_begin);
my $eof_var;

$var = 13;

my $hist;

END {
    # tests for END blocks:
    is $var, 13, '$var gets initialized at END time';
    is $eof_var, 29, '$eof_var gets assigned at END time';
}

ENTER {
    $hist ~= 'enter ';
    $var_at_enter = $var;
}

INIT {
    $hist ~= 'init ';
    $var_at_init = $var;
}

CHECK {
    $hist ~= 'check ';
    $var_at_check = $var;
}

BEGIN {
    $hist ~= 'begin ';
    $var_at_begin = $var;
}

is $hist, 'begin check init first ', 'BEGIN {} runs only once';
is $var_at_begin, undef, 'BEGIN {...} ran at compile time';
is $var_at_check, undef, 'CHECK {...} ran at compile time';
is $var_at_init, undef, 'INIT {...} ran at runtime, but ASAP';
is $var_at_enter, undef, 'ENTER {...} at runtime, but before the mainline body';

$eof_var = 29;</pre>
</div><a name="msg_32"></a>
<a href="?hide_quotes=no#msg_32" onclick="return tog_quote(32);">
<div ID=header_shown_32 style="display: none;">
- Hide the snippet from t/closure_traits/interpolate.t (line 11 ~ line 40) -
</div>
<div ID=header_hidden_32 style="display: block;">
- Show the snippet from t/closure_traits/interpolate.t (line 11 ~ line 40, 30 lines) -</div>
</a>
<div ID=hide_32 style="display:none; border:1px solid">
<pre>
# L&lt;S04/Closure traits/END "at run time" ALAP&gt;

# IRC log:
# ----------------------------------------------------------------
# agentzh   question: should BEGIN blocks interpolated in double-quoted
#           strings be fired at compile-time or run-time?
#           for example, say "This is { BEGIN { say 'hi' } }";
# audreyt   compile time.
#           qq is not eval.

my $hist;

END {
    is $hist, 'BCISE', 'interpolated END {...} executed';
}

is "{ END { $hist ~= 'E' } }", undef,
    'END {...} not yet executed';

is "{ START { $hist ~= 'S' } }", "BCIS",
    'START {...} fired at run-time, entry time of the mainline code';

is "{ INIT { $hist ~= 'I' } }", 'BCI',
    'INIT {...} fired at the beginning of runtime';

is "{ CHECK { $hist ~= 'C' } }", "BC",
    'CHECK {...} fired at compile-time, ALAP';

is "{ BEGIN { $hist ~= 'B' } }", "B",
    'BEGIN {...} fired at compile-time, ASAP';</pre>
</div><pre>
      START {...}*      on first ever execution, once per closure clone</pre>
<pre>
      ENTER {...}*      at every block entry time, repeats on loop blocks.
      LEAVE {...}       at every block exit time 
       KEEP {...}       at every successful block exit, part of LEAVE queue
       UNDO {...}       at every unsuccessful block exit, part of LEAVE queue</pre>
<pre>
      FIRST {...}*      at loop initialization time, before any ENTER
       NEXT {...}       at loop continuation time, before any LEAVE
       LAST {...}       at loop termination time, after any LEAVE</pre>
<pre>
        PRE {...}       assert precondition at every block entry, before any
       POST {...}       assert postcondition at every block exit, after any</pre>
<pre>
      CATCH {...}       catch exceptions, before LEAVE
    CONTROL {...}       catch control exceptions, before LEAVE</pre>
<p>Those marked with a <code>*</code> can also be used within an expression:</p>
<a name="msg_34"></a>
<a href="?hide_quotes=no#msg_34" onclick="return tog_quote(34);">
<div ID=header_shown_34 style="display: none;">
- Hide the snippet from t/closure_traits/rvalue.t (line 10 ~ line 49) -
</div>
<div ID=header_hidden_34 style="display: block;">
- Show the snippet from t/closure_traits/rvalue.t (line 10 ~ line 49, 40 lines) -</div>
</a>
<div ID=hide_34 style="display:none; border:1px solid">
<pre>
# L&lt;S04/Closure traits/"marked with a *" "used within" expression&gt;

my $hist = '';

# Test INIT {} as rval:

my $init_val;
my $init = {
    $init_val = INIT { $hist ~= 'I' };
}

is $init(), 'BCI', 'INIT {} runs only once';
is $init_val, 'BCI', 'INIT {} as rval is its ret val';
is $init(), 'BCI', 'INIT {} runs only once';

# Test CHECK {} as rval:

my $check_val;
my $check = {
    $check_val = CHECK { $hist ~= 'C' };
}

is $check(), 'BC', 'CHECK {} runs only once';
is $check_val, 'BC', 'CHECK {} as rval is its ret val';
is $check(), 'BC', 'CHECK {} runs only once';

# Test BEGIN {} as rval:

my $begin_val;
my $begin = {
    $begin_val = BEGIN { $hist ~= 'B' };
}

is $begin(), 'B', 'BEGIN {} runs only once';
is $begin_val, 'B', 'BEGIN {} as rval is its ret val';
is $begin(), 'B', 'BEGIN {} runs only once';

# Test END {} as rval:

ok !eval 'my $end_val = END { 3 }', "END {} can't be used as a rvalue";</pre>
</div><pre>
    my $compiletime = BEGIN { localtime };
    our $temphandle = START { maketemp() };</pre>
<p>Code that is generated at run time can still fire off <code>CHECK</code>
and <code>INIT</code> blocks, though of course those blocks can't do things that
would require travel back in time.</p>
<p>Some of these also have corresponding traits that can be set on variables.
These have the advantage of passing the variable in question into
the closure as its topic:</p>
<pre>
    my $r will start { .set_random_seed() };
    our $h will enter { .rememberit() } will undo { .forgetit() };</pre>
<p>Apart from <code>CATCH</code> and <code>CONTROL</code>, which can only occur once, most
of these can occur multiple times within the block.  So they aren't
really traits, exactly--they add themselves onto a list stored in the
actual trait (except for <code>START</code>, which executes inline).  So if you
examine the <code>ENTER</code> trait of a block, you'll find that it's really
a list of closures rather than a single closure.</p>
<a name="msg_33"></a>
<a href="?hide_quotes=no#msg_33" onclick="return tog_quote(33);">
<div ID=header_shown_33 style="display: none;">
- Hide the snippet from t/closure_traits/multiple.t (line 11 ~ line 38) -
</div>
<div ID=header_hidden_33 style="display: block;">
- Show the snippet from t/closure_traits/multiple.t (line 11 ~ line 38, 28 lines) -</div>
</a>
<div ID=hide_33 style="display:none; border:1px solid">
<pre>
# L&lt;S04/Closure traits/"occur multiple times"&gt;
# IRC log:
# [05:41] &lt;agentzh&gt; TimToady: S04 doesn't discuss the running order 
#                   of multiple closure traits (say, two END {} in 
#                   the same scope), so should we assume it's the
#                   same as in Perl 5?
# [05:41] &lt;TimToady&gt; yes

my $hist;

END { is $hist, 'B b c C I i S s end End ', 'running order of multiple closure traits' }

END { $hist ~= 'End ' }
END { $hist ~= 'end ' }

START { $hist ~= 'S ' }
START { $hist ~= 's ' }

INIT { $hist ~= 'I ' }
INIT { $hist ~= 'i ' }

CHECK { $hist ~= 'C ' }
CHECK { $hist ~= 'c ' }

BEGIN { $hist ~= 'B ' }
BEGIN { $hist ~= 'b ' }

is $hist, 'B b c C I i S s ', 'running order of multiple closure traits';</pre>
</div><p>The semantics of <code>INIT</code> and <code>START</code> are not equivalent to each
other in the case of cloned closures.  An <code>INIT</code> only runs once for
all copies of a cloned closure.  A <code>START</code> runs separately for each
clone, so separate clones can keep separate state variables:</p>
<a name="msg_28"></a>
<a href="?hide_quotes=no#msg_28" onclick="return tog_quote(28);">
<div ID=header_shown_28 style="display: none;">
- Hide the snippet from t/closure_traits/init.t (line 69 ~ line 76) -
</div>
<div ID=header_hidden_28 style="display: block;">
- Show the snippet from t/closure_traits/init.t (line 69 ~ line 76, 8 lines) -</div>
</a>
<div ID=hide_28 style="display:none; border:1px solid">
<pre>
# L&lt;S04/Closure traits/INIT "runs once for all copies of" "cloned closure"&gt;
{
	my $var;
	for &lt;first second&gt; {
		my $sub = { INIT { $var++ } };
		is $var, 1, "INIT has run exactly once ($_ time)";
	}
}</pre>
</div><pre>
    our $i = 0;
    ...
    $func = { state $x will start { $x = $i++ }; dostuff($i) };</pre>
<p>But <code>state</code> automatically applies ``start'' semantics to any initializer,
so this also works:</p>
<pre>
    $func = { state $x = $i++; dostuff($i) }</pre>
<p>Each subsequent clone gets an initial state that is one higher than the
previous, and each clone maintains its own state of <code>$x</code>, because that's
what <code>state</code> variables do.</p>
<p>Even in the absence of closure cloning, <code>INIT</code> runs before the
mainline code, while <code>START</code> puts off the initialization till the
last possible moment, then runs exactly once, and caches its value
for all subsequent calls (assuming it wasn't called in void context,
in which case the <code>START</code> is evaluated once only for its side effects).</p>
<p>All of these trait blocks can see any previously declared lexical
variables, even if those variables have not been elaborated yet when
the closure is invoked (in which case the variables evaluate to an
undefined value.)</p>
<p>Note: Apocalypse 4 confused the notions of <code>PRE</code>/<code>POST</code> with <code>ENTER</code>/<code>LEAVE</code>.
These are now separate notions.  <code>ENTER</code> and <code>LEAVE</code> are used only for
their side effects.  <code>PRE</code> and <code>POST</code> must return boolean values that are
evaluated according to the usual Design by Contract (DBC) rules.  (Plus,
if you use <code>ENTER</code>/<code>LEAVE</code> in a class block, they only execute when the
class block is executed, but <code>PRE</code>/<code>POST</code> in a class block are evaluated
around every method in the class.)  <code>KEEP</code> and <code>UNDO</code> are just variants
of <code>LEAVE</code>, and for execution order are treated as part of the queue of
<code>LEAVE</code> blocks.</p>
<p><code>FIRST</code>, <code>NEXT</code>, and <code>LAST</code> are meaningful only within the
lexical scope of a loop, and may occur only at the top level of such
a loop block.  A <code>NEXT</code> executes only if the end of the loop block is
reached normally, or an explicit <code>next</code> is executed.  In distinction
to <code>LEAVE</code> blocks, a <code>NEXT</code> block is not executed if the loop block
is exited via any exception other than the control exception thrown
by <code>next</code>.  In particular, a <code>last</code> bypasses evaluation of <code>NEXT</code>
blocks.</p>
<p>[Note: the name <code>FIRST</code> used to be associated with <code>state</code>
declarations.  Now it is associated only with loops.  See the <code>START</code>
above for <code>state</code> semantics.]</p>
<p><code>LEAVE</code> blocks are evaluated after <code>CATCH</code> and <code>CONTROL</code> blocks, including
the <code>LEAVE</code> variants, <code>KEEP</code> and <code>UNDO</code>.  <code>POST</code> blocks are evaluated after
everything else, to guarantee that even <code>LEAVE</code> blocks can't violate DBC.
Likewise <code>PRE</code> blocks fire off before any <code>ENTER</code> or <code>FIRST</code> (though not
before <code>BEGIN</code>, <code>CHECK</code>, or <code>INIT</code>, since those are done at compile or
process initialization time).</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Statement20parsing">Statement parsing</a></h1>
<p>In this statement:</p>
<pre>
    given EXPR {
        when EXPR { ... }
        when EXPR { ... }
        ...
    }</pre>
<p>parentheses aren't necessary around <code>EXPR</code> because the whitespace
between <code>EXPR</code> and the block forces the block to be considered a
block rather than a subscript.  This works for all control structures,
not just the new ones in Perl 6.  A top-level bare block
is always considered a statement block if there's space
before it:</p>
<pre>
    if $foo { ... }
    elsif $bar { ... }
    else { ... }
    while $more { ... }
    for 1..10 { ... }</pre>
<p>You can still parenthesize the expression argument for old times'
sake, as long as there's a space between the closing paren and the
opening brace.  You <em>must</em> parenthesize the expression if there is
a bare block or pointy block that would be misinterpreted as the statement's
block.  This is regardless of whether a term or operator is expected where
the block occurs.  (A block inside brackets, or used as a
postcircumfix is fine, though.)  Any block with whitespace
in front of it will be taken as terminating the conditional, even if
the conditional expression could take another argument.  Therefore</p>
<pre>
    if rand { say &quot;exists&quot; } { extra() }
    if rand -&gt; $x { say &quot;exists&quot; } { extra() }</pre>
<p>is always parsed as</p>
<pre>
    if (rand) { say &quot;exists&quot; }; { extra() }
    if (rand) -&gt; $x { say &quot;exists&quot; }; { extra() }</pre>
<p>rather than</p>
<pre>
    if (rand { say &quot;exists&quot; }) { extra() }
    if (rand (-&gt; $x { say &quot;exists&quot; })) { extra() }</pre>
<p>Apart from that, it is illegal to use a bare closure where an
operator is expected.  (Remove the whitespace if you wish it to be
a postcircumfix.)</p>
<p>Anywhere a term is expected, a block is taken to be a closure definition
(an anonymous subroutine).  If the closure is empty, or appears to contain
nothing but a comma-separated list starting with a pair or a hash (counting
a single pair or hash as a list of one element), the closure will be
immediately executed as a hash composer.</p>
<pre>
    $hash = { };
    $hash = { %stuff };
    $hash = { &quot;a&quot; =&gt; 1 };
    $hash = { &quot;a&quot; =&gt; 1, $b, $c, %stuff, @nonsense };</pre>
<pre>
    $code = { ; };
    $code = { @stuff };
    $code = { &quot;a&quot;, 1 };
    $code = { &quot;a&quot; =&gt; 1, $b, $c ==&gt; print };</pre>
<p>If you wish to be less ambiguous, the <code>hash</code> list operator will
explicitly evaluate a list and compose a hash of the returned value,
while <code>sub</code> introduces an anonymous subroutine:</p>
<pre>
    $code = sub { &quot;a&quot; =&gt; 1 };
    $hash = hash(&quot;a&quot; =&gt; 1);
    $hash = hash(&quot;a&quot;, 1);</pre>
<p>If a closure is the right argument of the dot operator, the closure
is interpreted as a hash subscript.</p>
<pre>
    $code = {$x};       # closure because term expected
    if $term{$x}        # subscript because postfix expected
    if $term {$x}       # expression followed by statement block
    if $term.{$x}       # valid subscript with dot
    if $term\ .{$x}     # valid subscript with &quot;long dot&quot;</pre>
<p>Similar rules apply to array subscripts:</p>
<pre>
    $array = [$x];      # array composer because term expected
    if $term[$x]        # subscript because postfix expected
    if $term [$x]       # syntax error (two terms in a row)
    if $term.[$x]       # valid subscript with dot
    if $term\ .[$x]     # valid subscript with &quot;long dot&quot;</pre>
<p>And to the parentheses delimiting function arguments:</p>
<pre>
    $scalar = ($x);     # grouping parens because term expected
    if $term($x)        # function call because operator expected
    if $term ($x)       # syntax error (two terms in a row)
    if $term.($x)       # valid function call with dot
    if $term\ .($x)     # valid function call with &quot;long dot&quot;</pre>
<p>Outside of any kind of expression brackets, a final closing curly
on a line (not counting whitespace or comments) always reverts
to the precedence of semicolon whether or not you put a semicolon
after it.  (In the absence of an explicit semicolon, the current
statement may continue on a subsequent line, but only with valid
statement continuators such as <code>else</code> that cannot be confused with
the beginning of a new statement.  Anything else, such as a statement
modifier (on, say, a <code>loop</code> statement) must continue on the same line,
unless the newline be escaped using the ``unspace'' construct--see S02.)</p>
<p>Final blocks on statement-level constructs always imply semicolon
precedence afterwards regardless of the position of the closing curly.
Statement-level constructs are distinguished in the grammar by being
declared in the statement syntactic group:</p>
<pre>
    macro statement_control:&lt;if&gt; ($expr, &amp;ifblock) {...}
    macro statement_control:&lt;while&gt; ($expr, &amp;whileblock) {...}
    macro statement_control:&lt;BEGIN&gt; (&amp;beginblock) {...}</pre>
<p>Statement-level constructs may start only where the parser is expecting
the start of a statement.  To embed a statement in an expression you
must use something like <code>do {...}</code> or <code>try {...}</code>.</p>
<a name="msg_12"></a>
<a href="?hide_quotes=no#msg_12" onclick="return tog_quote(12);">
<div ID=header_shown_12 style="display: none;">
- Hide the snippet from t/builtins/control_flow/try.t (line 5 ~ line 174) -
</div>
<div ID=header_hidden_12 style="display: block;">
- Show the snippet from t/builtins/control_flow/try.t (line 5 ~ line 174, 170 lines) -</div>
</a>
<div ID=hide_12 style="display:none; border:1px solid">
<pre>
# L&lt;S04/"Statement parsing"/"or try {...}"&gt;

plan 26;

{
    # simple try
    my $lived = undef;
    try { die "foo" };
    is($!, "foo", "error var was set");
};

# try should work when returning an array or hash
{
    my @array = try { 42 };
    is +@array,    1, '@array = try {...} worked (1)';
    is ~@array, "42", '@array = try {...} worked (2)';
}

{
    my @array = try { (42,) };
    is +@array,    1, '@array = try {...} worked (3)';
    is ~@array, "42", '@array = try {...} worked (4)';
}

{
    my %hash = try { "a" };
    is +%hash,        1, '%hash = try {...} worked (1)';
    is ~%hash.keys, "a", '%hash = try {...} worked (2)';
}

{
    my %hash = try { ("a",) };
    is +%hash,        1, '%hash = try {...} worked (3)';
    is ~%hash.keys, "a", '%hash = try {...} worked (4)';
}

{
    warn "Please ignore the next warning about odd number of elements,\n";
    warn "it's expected.\n";
    my %hash = try { hash("a",) };
    is +%hash,        1, '%hash = try {...} worked (5)';
    is ~%hash.keys, "a", '%hash = try {...} worked (6)';
}

{
    my %hash;
    # Extra try necessary because current Pugs dies without it.
    try { %hash = try { a =&gt; 3 } };
    is +%hash,        1, '%hash = try {...} worked (7)', :todo&lt;bug&gt;;
    is ~%hash.keys, "a", '%hash = try {...} worked (8)', :todo&lt;bug&gt;;
    is ~%hash&lt;a&gt;,     3, '%hash = try {...} worked (9)', :todo&lt;bug&gt;;
}

{
    # try with a catch
    my $caught;
    eval 'try {
        die "blah"

        CATCH { $caught = 1 }
    }';

    ok($caught, "exception caught", :todo);
};

# return inside try{}-blocks
# PIL2JS *seems* to work, but it does not, actually:
# The "return 42" works without problems, and the caller actually sees the
# return value 42. But when the end of the test is reached, &amp;try will
# **resume after the return**, effectively running the tests twice.
# (Therefore I moved the tests to the end, so not all tests are rerun).
{
    my $was_in_foo;
    sub foo {
        $was_in_foo++;
        try { return 42 };
        $was_in_foo++;
        return 23;
    }
    is foo(), 42,      'return() inside try{}-blocks works (1)', :todo&lt;bug&gt;;
    is $was_in_foo, 1, 'return() inside try{}-blocks works (2)', :todo&lt;bug&gt;;
}

{
    my sub test1 {
        try { return 42 };
        return 23;
    }

    my sub test2 {
        test1();
        die 42;
    }

    dies_ok { test2() },
        "return() inside a try{}-block should cause following exceptions to really die";
}

unless (eval 'Exception.new') {
    skip_rest "No Exception objects"; exit
}

{
    # exception classes
    class Naughty is Exception {};

    my ($not_died, $caught);
    eval 'try {
        die Naughty "error"

        $not_died = 1;

        CATCH {
            when Naughty {
                $caught = 1;
            }
        }
    }';

    ok(!$not_died, "did not live after death");
    ok($caught, "caught exception of class Naughty", :todo);
};

{
    # exception superclass
    class Naughty::Specific is Naughty {};
    class Naughty::Other is Naughty {};

    my ($other, $naughty);
    eval 'try {
        die Naughty::Specific "error";

        CATCH {
            when Naughty::Other {
                $other = 1;
            }
            when Naughty {
                $naughty = 1;
            }
        }
    }';

    ok(!$other, "did not catch sibling error class");
    ok($naughty, "caught superclass", :todo);
};

{
    # uncaught class
    eval 'class Dandy is Exception {}';

    my ($naughty, $lived);
    eval 'try {
        die Dandy "error";
        
        CATCH {
            when Naughty {
                $naughty = 1;
            }
        }
    };

    $lived = 1;
    ';

    ok(!$lived, "did not live past uncaught throw in try");
    ok(~ref($!), '$! is an object');
    ok(!$naughty, "did not get caught by wrong handler");
    is(eval('ref($!)'), Dandy, ".. of the right class", :todo&lt;bug&gt;);
};
</pre>
</div><pre>
    $x =  do { given $foo { when 1 {2} when 3 {4} }} + $bar;
    $x = try { given $foo { when 1 {2} when 3 {4} }} + $bar;</pre>
<p>The existence of a <code>statement_control:&lt;BEGIN&gt;</code> does not preclude us from
also defining a <code>prefix:&lt;BEGIN&gt;</code> that <em>can</em> be used within an expression:</p>
<pre>
    macro prefix:&lt;BEGIN&gt; (&amp;beginblock) { beginblock().repr }</pre>
<p>Then you can say things like:</p>
<pre>
    $recompile_by = BEGIN { time } + $expiration_time;</pre>
<p>But <code>statement_control:&lt;BEGIN&gt;</code> hides <code>prefix:&lt;BEGIN&gt;</code> at the start of a statement.
You could also conceivably define a <code>prefix:&lt;if&gt;</code>, but then you may not
get what you want when you say:</p>
<pre>
    .print if $foo;</pre>
<p>since <code>prefix:&lt;if&gt;</code> would hide <code>statement_modifier:&lt;if&gt;</code>.</p>
<p>Built-in statement-level keywords require whitespace between the
keyword and the first argument, as well as before any terminating loop.
In particular, a syntax error will be reported for C-isms such as these:</p>
<pre>
    if(...) {...}
    while(...) {...}
    for(...) {...}</pre>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Definition20of20Success">Definition of Success</a></h1>
<a name="msg_39"></a>
<a href="?hide_quotes=no#msg_39" onclick="return tog_quote(39);">
<div ID=header_shown_39 style="display: none;">
- Hide the snippet from t/var/let.t (line 8 ~ line 70) -
</div>
<div ID=header_hidden_39 style="display: block;">
- Show the snippet from t/var/let.t (line 8 ~ line 70, 63 lines) -</div>
</a>
<div ID=hide_39 style="display:none; border:1px solid">
<pre>
# L&lt;S04/"Definition of Success"&gt;
# let() should not restore the variable if the block exited successfully
# (returned a true value).
{
  my $a = 42;
  {
    let $a = 23;
    is $a, 23, "let() changed the variable (1)";
    1;
  }
  is $a, 23, "let() should not restore the variable, as our block exited succesfully (1)", :todo&lt;feature&gt;;
}

# let() should restore the variable if the block failed (returned a false
# value).
{
  my $a = 42;
  {
    let $a = 23;
    is $a, 23, "let() changed the variable (1)";
    0;
  }
  is $a, 42, "let() should restore the variable, as our block failed";
}

# Test that let() restores the variable at scope exit, not at subroutine
# entry.  (This might be a possibly bug.)
{
  my $a     = 42;
  my $get_a = { $a };
  {
    let $a = 23;
    is $a,       23, "let() changed the variable (2-1)";
    is $get_a(), 23, "let() changed the variable (2-2)", :todo&lt;feature&gt;;
    1;
  }
  is $a, 23, "let() should not restore the variable, as our block exited succesfully (2)", :todo&lt;feature&gt;;
}

# Test that let() restores variable even when not exited regularly (using a
# (possibly implicit) call to return()), but when left because of an exception.
{
  my $a = 42;
  try {
    let $a = 23;
    is $a, 23, "let() changed the variable in a try block";
    die 57;
  };
  is $a, 42, "let() restored the variable, the block was exited using an exception";
}

eval('
{
  my @array = (0, 1, 2);
  {
    let @array[1] = 42;
    is @array[1], 42, "let() changed our array element";
    0;
  }
  is @array[1], 1, "let() restored our array element";
}
"1 - delete this line when the parsefail eval() is removed";
') or skip(2, "parsefail: let \@array[1]");</pre>
</div><p>Hypothetical variables are somewhat transactional--they keep their
new values only on successful exit of the current block, and otherwise
are rolled back to their original values.</p>
<p>It is, of course, a failure to leave the block by propagating an error
exception, though returning a defined value after catching an exception
is okay.</p>
<p>In the absence of error exception propagation, a successful exit is one that
returns a defined value in scalar context, or any number of values
in list context as long as the length is defined.  (A length of +Inf
is considered a defined length.  A length of 0 is also a defined length,
which means it's a ``successful'' return even though the list would evaluate
to false in a boolean context.)  A list can have a defined length
even if it contains undefined scalar values.  A list is of undefined
length only if it contains an undefined generator, which, happily, is
what is returned by the <code>undef</code> function when used in list context.
So any Perl 6 function can say</p>
<pre>
    return undef;</pre>
<p>and not care about whether the function is being called in scalar or list
context.  To return an explicit scalar undef, you can always say</p>
<pre>
    return scalar(undef);</pre>
<p>Then in list context, you're returning a list of length 1, which is
defined (much like in Perl 5).  But generally you should be using
<code>fail</code> in such a case to return an exception object.  Exception
objects also behave like undefined generators in list context.
In any case, returning an unthrown exception is considered failure
from the standpoint of <code>let</code>.  Backtracking over a closure in a regex
is also considered failure of the closure, which is how hypothetical
variables are managed by regexes.  (And on the flip side, use of <code>fail</code>
within a regex closure initiates backtracking of the regex.)</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="When20is20a20closure20not20a20closure">When is a closure not a closure</a></h1>
<p>Everything is conceptually a closure in Perl 6, but the optimizer
is free to turn unreferenced closures into mere blocks of code.
It is also free to turn referenced closures into mere anonymous
subroutines if the block does not refer to any external lexicals that
should themselves be cloned.  In particular, named subroutines in any
scope do not consider themselves closures unless you take a reference
to them.  So</p>
<pre>
    sub foo {
        my $x = 1;
        my sub bar { print $x }         # not cloned yet
        my &amp;baz = { bar(); print $x };  # cloned immediately
        my $code = &amp;bar;                # now bar is cloned
        return &amp;baz;
    }</pre>
<p>When we say ``clone'', we mean the way the system takes a snapshot of the
routine's lexical scope and binds it to the current instance of the routine
so that if you ever use the current reference to the routine, it gets
the current snapshot of its world, lexically speaking.</p>
<p>Some closures produce <code>Code</code> objects at compile time that cannot be
cloned, because they're not attached to any runtime code that can
actually clone them.  <code>BEGIN</code>, <code>CHECK</code>, <code>INIT</code>, and <code>END</code> blocks
fall into this category.  Therefore you can't reliably refer to
run-time variables from these closures even if they appear to be in the
scope.  (The compile-time closure may, in fact, see some kind of permanent
copy of the variable for some storage classes, but the variable is
likely to be undefined when the closure is run in any case.)  It's
only safe to refer to package variables and file-scoped lexicals from
such a routine.</p>
<p>On the other hand, it is required that <code>CATCH</code> and <code>LEAVE</code> blocks be able
to see transient variables in their current lexical scope, so their
cloning status depends at least on the cloning status of the block
they're in.</p>
<p><a href="#__index__"><small>Back to Top</small></a></p>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" valign="middle">
<big><strong><span class="block">&nbsp;TITLE</span></strong></big>
</td></tr>
</table>

</body>

</html>
