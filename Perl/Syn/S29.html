<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
           "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>S29</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="http://dev.perl.org/css/perl.css">

<script type="text/javascript">
var agt = navigator.userAgent.toLowerCase();

var is_opera = (agt.indexOf("opera") != -1);
var is_ie = (agt.indexOf("msie") != -1) && document.all && !is_opera;
var is_ie5 = (agt.indexOf("msie 5") != -1) && document.all;

function tog() {
  // tog: toggle the visibility of html elements (arguments[1..]) from none to
  // arguments[0].  Return what should be returned in a javascript onevent().
  display = arguments[0];
  for( var i=1; i<arguments.length; i++ ) {
    var x = document.getElementById(arguments[i]);
    if (!x) continue;
    if (x.style.display == "none" || x.style.display == "") {
      x.style.display = display;
    } else {
      x.style.display = "none";
    }
  }

  var e = is_ie ? window.event : this;
  if (e) {
    if (is_ie) {
      e.cancelBubble = true;
      e.returnValue = false;
      return false;
    } else {
      return false;
    }
  }
}

function tog_quote( idnum ) {
  return tog( 'block', 'header_shown_' + idnum, 'header_hidden_' + idnum,
       'hide_' + idnum );
}

</script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.03,
  using Pod::Simple::PullParser v2.02,
  under Perl v5.008007 at Sat Aug 26 07:33:51 2006 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
            <I>This page was generated at 2006-08-26 07:33:52 GMT.
            (syn <strong>r11421</strong>, pugs <strong>r12707</strong>)</I>
        
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#Title'>Title</a>
  <li class='indexItem indexItem1'><a href='#Version'>Version</a>
  <li class='indexItem indexItem1'><a href='#Notes'>Notes</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Operators_vs._Functions'>Operators vs. Functions</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Type_Declarations'>Type Declarations</a>
  <li class='indexItem indexItem1'><a href='#Function_Packages'>Function Packages</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Math%3A%3ABasic'>Math::Basic</a>
    <li class='indexItem indexItem2'><a href='#Math%3A%3ATrig'>Math::Trig</a>
    <li class='indexItem indexItem2'><a href='#Scalar'>Scalar</a>
    <li class='indexItem indexItem2'><a href='#Container'>Container</a>
    <li class='indexItem indexItem2'><a href='#Array'>Array</a>
    <li class='indexItem indexItem2'><a href='#List'>List</a>
    <li class='indexItem indexItem2'><a href='#Hash'>Hash</a>
    <li class='indexItem indexItem2'><a href='#Str'>Str</a>
    <li class='indexItem indexItem2'><a href='#Control%3A%3ABasic'>Control::Basic</a>
    <li class='indexItem indexItem2'><a href='#Conversions'>Conversions</a>
    <li class='indexItem indexItem2'><a href='#Time'>Time</a>
    <li class='indexItem indexItem2'><a href='#OS'>OS</a>
    <li class='indexItem indexItem2'><a href='#Concurrency'>Concurrency</a>
    <li class='indexItem indexItem2'><a href='#Obsolete'>Obsolete</a>
    <li class='indexItem indexItem2'><a href='#Pending_Apocalypse'>Pending Apocalypse</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Unfiled'>Unfiled</a>
  <li class='indexItem indexItem1'><a href='#Additions'>Additions</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Title"
>Title</a></h1>

<p>Synopsis 29: Builtin Functions</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Version"
>Version</a></h1>

<pre> Author:        Rod Adams &#60;rod@rodadams.net&#62;
 Maintainer:    Larry Wall &#60;larry@wall.org&#62;
 Contributions: Aaron Sherman &#60;ajs@ajs.com&#62;
 Date:          12 Mar 2005
 Last Modified: 08 Jul 2006
 Version:       4</pre>

<p>This document attempts to document the list of builtin functions in Perl 6. It assumes familiarity with Perl 5 and prior synopses.</p>

<p>The document is now the official S29. It&#39;s still here in the pugs repository temporarily to allow easy access to pugs implementors, but eventually it will be copied over to svn.perl.org. Despite its being &#34;official&#34;, feel free to hack on it as long as it&#39;s in the pugs space. -law</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Notes"
>Notes</a></h1>

<p>In Perl 6, all builtin functions belong to a named package. Not all functions are guaranteed to be imported into the global package <code>::*</code>. In addition, the list of functions imported into <code>::*</code> will be subject to change with each release of Perl. Authors wishing to &#34;Future Proof&#34; their code should either specifically import the functions they will be using, or always refer to the functions by their full name.</p>

<p>After 6.0.0 comes out, global aliases will not be removed lightly, and will never be removed at all without having gone through a deprecation cycle of at least a year. In any event, you can specify that you want the interface for a particular version of Perl, and that can be emulated by later versions of Perl to the extent that security updates allow.</p>

<p>Where code is given here, it is intended to define semantics, not to dictate implementation.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Operators_vs._Functions"
>Operators vs. Functions</a></h2>

<p>There is no particular difference between an operator and a function, but for the sake of documentation, only functions declared without specifying a grammatical category or with a category of <code>term:</code> (see <a href="http://search.cpan.org/perldoc?S02#Bits_and_Pieces" class="podlinkpod"
>&#34;Bits and Pieces&#34; in S02</a>) will be described as &#34;functions&#34;, and everything else as &#34;operators&#34; which are outside of the scope of this document.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Type_Declarations"
>Type Declarations</a></h1>

<p>The following type declarations are assumed:</p>

<dl>
<dt><a name="AnyChar"
>AnyChar</a></dt>

<dd>
<p>The root class of all &#34;character&#34; types, regardless of level.</p>

<p>This is a subtype of <code>Str</code>, limited to a length of 1 at it&#39;s highest supported Unicode level.</p>

<p>The type name <code>Char</code> is aliased to the maximum supported Unicode level in the current lexical scope (where &#34;current&#34; is taken to mean the eventual lexical scope for generic code (roles and macros), not the scope in which the generic code is defined). In other words, use <code>Char</code> when you don&#39;t care which level you&#39;re writing for.</p>

<p>Subclasses (things that are <code>isa AnyChar</code>):</p>

<dl>
<dt><a name="LinguaChar_or_Ling_(language-defined_characters)"
>LinguaChar or Ling (language-defined characters)
<dt><a name="GraphemeChar_or_Graf_(language-independent_graphemes)"
>GraphemeChar or Graf (language-independent graphemes)
<dt><a name="CodePoint_or_Uni_(Unicode_codepoints)"
>CodePoint or Uni (Unicode codepoints)
<dt><a name="Byte"
>Byte</a></dt>

<dd>
<p>Yes, Byte is both a string and a number.</p>
</dd>
</dl>

<dt><a name="MatchTest"
>MatchTest</a></dt>

<dd>
<pre> subset MatchTest of Item | Junction;</pre>

<p>Used to supply a test to match against. Assume <code>~~</code> will be used against it.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Function_Packages"
>Function Packages</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Math::Basic"
>Math::Basic</a></h2>

<p><b>API document</b>: <a href="http://search.cpan.org/perldoc?Math%3A%3ABasic" class="podlinkpod"
>Math::Basic</a></p>

<p><code>Math::Basic</code> provides a number of constants in addition to the basic mathematical functions. To get these constants, you must request them:</p>

<pre> use Math::Basic :constants;</pre>

<p>or use the full name, e.g. <code>Math::Basic::pi</code>.</p>

<dl>
<dt><a name="abs"
>abs</a></dt>

<dd>
<pre> our Num multi Math::Basic::abs ( Num $x )</pre>

<p>Absolute Value.</p>

<dt><a name="floor"
>floor</a></dt>

<dd>
<pre> our Int multi Math::Basic::floor ( Num $x )</pre>

<p>Returns the highest integer not greater than $x.</p>

<dt><a name="ceiling"
>ceiling</a></dt>

<dd>
<pre> our Int multi Math::Basic::ceiling ( Num $x )
 our Int multi Math::Basic::ceil ( Num $x )</pre>

<p>Returns the lowest integer not less than $x.</p>

<dt><a name="round"
>round</a></dt>

<dd>
<pre> our Int multi Math::Basic::round ( Num $x )</pre>

<p>Returns the nearest integer to $x. The algorithm is floor($x + 0.5). (Other rounding algorithms will be given extended names beginning with &#34;round&#34;.)</p>

<dt><a name="truncate"
>truncate</a></dt>

<dd>
<pre> our Int multi Math::Basic::truncate ( Num $x )
 our Int multi Math::Basic::int ( Num $x )</pre>

<p>Returns the closest integer to $x whose absolute value is not greater than the absolute value of $x. (In other words, just chuck any fractional part.) This is the default rounding function used by an <code>int()</code> cast, for historic reasons. But see Int constructor above for a rounded version.</p>

<dt><a name="exp"
>exp</a></dt>

<dd>
<pre> our Num multi Math::Basic::exp ( Num $exponent, Num :$base = Num::e )</pre>

<p>Performs similar to <code>$base ** $exponent</code>. <code>$base</code> defaults to the constant <i>e</i>.</p>

<dt><a name="log"
>log</a></dt>

<dd>
<pre> our Num multi Math::Basic::log ( Num $x, Num :$base )</pre>

<p>Logarithm of base <code>$base</code>, default Natural. Calling with <code>$x == 0</code> is an error.</p>

<dt><a name="log10"
>log10</a></dt>

<dd>
<pre> our Num multi Math::Basic::log10 (Num $x);</pre>

<p>A base <code>10</code> logarithm, othewise identical to <code>log</code>.</p>

<dt><a name="rand"
>rand</a></dt>

<dd>
<a name="msg_63"></a>
<a href="?hide_quotes=no#msg_63" onclick="return tog_quote(63);">
<div ID="header_shown_63" style="display: none;">
- Hide the snippet from t/builtins/math/rand.t (line 13 ~ line 21) -
</div>
<div ID="header_hidden_63" style="display: block;">
- Show the snippet from t/builtins/math/rand.t (line 13 ~ line 21, 9 lines) -
</div>
</a>
<div ID="hide_63" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Math::Basic&quot; /rand/&gt;

ok(rand() &gt;= 0, 'rand() returns numbers greater than or equal to 0');
ok(rand() &lt; 1, 'rand() returns numbers less than 1');

for 1 .. 10 {
  ok rand(10) &gt;=  0, &quot;rand(10) always returns numbers greater than or equal to 0 ($_)&quot;;
  ok rand(10)  &lt; 10, &quot;rand(10) always returns numbers less than 10 ($_)&quot;;
}</pre>
</div>


<pre> our Num multi Math::Basic::rand ( Num $x = 1 )</pre>

<a name="msg_64"></a>
<a href="?hide_quotes=no#msg_64" onclick="return tog_quote(64);">
<div ID="header_shown_64" style="display: none;">
- Hide the snippet from t/builtins/math/rand.t (line 13 ~ line 21) -
</div>
<div ID="header_hidden_64" style="display: block;">
- Show the snippet from t/builtins/math/rand.t (line 13 ~ line 21, 9 lines) -
</div>
</a>
<div ID="hide_64" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Math::Basic&quot; /rand/&gt;

ok(rand() &gt;= 0, 'rand() returns numbers greater than or equal to 0');
ok(rand() &lt; 1, 'rand() returns numbers less than 1');

for 1 .. 10 {
  ok rand(10) &gt;=  0, &quot;rand(10) always returns numbers greater than or equal to 0 ($_)&quot;;
  ok rand(10)  &lt; 10, &quot;rand(10) always returns numbers less than 10 ($_)&quot;;
}</pre>
</div>


<p>Pseudo random number in range <code>0 ..^ $x</code>. That is, <code>0</code> is theoretically possible, while <code>$x</code> is not.</p>

<a name="msg_65"></a>
<a href="?hide_quotes=no#msg_65" onclick="return tog_quote(65);">
<div ID="header_shown_65" style="display: none;">
- Hide the snippet from t/builtins/math/rand.t (line 13 ~ line 21) -
</div>
<div ID="header_hidden_65" style="display: block;">
- Show the snippet from t/builtins/math/rand.t (line 13 ~ line 21, 9 lines) -
</div>
</a>
<div ID="hide_65" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Math::Basic&quot; /rand/&gt;

ok(rand() &gt;= 0, 'rand() returns numbers greater than or equal to 0');
ok(rand() &lt; 1, 'rand() returns numbers less than 1');

for 1 .. 10 {
  ok rand(10) &gt;=  0, &quot;rand(10) always returns numbers greater than or equal to 0 ($_)&quot;;
  ok rand(10)  &lt; 10, &quot;rand(10) always returns numbers less than 10 ($_)&quot;;
}</pre>
</div>


<dt><a name="sign"
>sign</a></dt>

<dd>
<pre> our Int multi Math::Basic::sign ( Num $x )</pre>

<p>Returns 1 when <code>$x</code> is greater than 0, -1 when it is less than 0, 0 when it is equal to 0, or undefined when the value passed is undefined.</p>

<dt><a name="srand"
>srand</a></dt>

<dd>
<a name="msg_66"></a>
<a href="?hide_quotes=no#msg_66" onclick="return tog_quote(66);">
<div ID="header_shown_66" style="display: none;">
- Hide the snippet from t/builtins/math/rand.t (line 13 ~ line 21) -
</div>
<div ID="header_hidden_66" style="display: block;">
- Show the snippet from t/builtins/math/rand.t (line 13 ~ line 21, 9 lines) -
</div>
</a>
<div ID="hide_66" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Math::Basic&quot; /rand/&gt;

ok(rand() &gt;= 0, 'rand() returns numbers greater than or equal to 0');
ok(rand() &lt; 1, 'rand() returns numbers less than 1');

for 1 .. 10 {
  ok rand(10) &gt;=  0, &quot;rand(10) always returns numbers greater than or equal to 0 ($_)&quot;;
  ok rand(10)  &lt; 10, &quot;rand(10) always returns numbers less than 10 ($_)&quot;;
}</pre>
</div>


<pre> multi Math::Basic::srand ( Num $seed = default_seed_algorithm())</pre>

<a name="msg_67"></a>
<a href="?hide_quotes=no#msg_67" onclick="return tog_quote(67);">
<div ID="header_shown_67" style="display: none;">
- Hide the snippet from t/builtins/math/rand.t (line 13 ~ line 21) -
</div>
<div ID="header_hidden_67" style="display: block;">
- Show the snippet from t/builtins/math/rand.t (line 13 ~ line 21, 9 lines) -
</div>
</a>
<div ID="hide_67" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Math::Basic&quot; /rand/&gt;

ok(rand() &gt;= 0, 'rand() returns numbers greater than or equal to 0');
ok(rand() &lt; 1, 'rand() returns numbers less than 1');

for 1 .. 10 {
  ok rand(10) &gt;=  0, &quot;rand(10) always returns numbers greater than or equal to 0 ($_)&quot;;
  ok rand(10)  &lt; 10, &quot;rand(10) always returns numbers less than 10 ($_)&quot;;
}</pre>
</div>


<p>Seed the generator <code>rand</code> uses. <code>$seed</code> defaults to some combination of various platform dependent characteristics to yield a non-deterministic seed. Note that you get one <code>srand()</code> for free when you start a Perl program, so you <i>must</i> call <code>srand()</code> yourself if you wish to specify a deterministic seed (or if you wish to be differently nondeterministic).</p>

<a name="msg_68"></a>
<a href="?hide_quotes=no#msg_68" onclick="return tog_quote(68);">
<div ID="header_shown_68" style="display: none;">
- Hide the snippet from t/builtins/math/rand.t (line 13 ~ line 21) -
</div>
<div ID="header_hidden_68" style="display: block;">
- Show the snippet from t/builtins/math/rand.t (line 13 ~ line 21, 9 lines) -
</div>
</a>
<div ID="hide_68" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Math::Basic&quot; /rand/&gt;

ok(rand() &gt;= 0, 'rand() returns numbers greater than or equal to 0');
ok(rand() &lt; 1, 'rand() returns numbers less than 1');

for 1 .. 10 {
  ok rand(10) &gt;=  0, &quot;rand(10) always returns numbers greater than or equal to 0 ($_)&quot;;
  ok rand(10)  &lt; 10, &quot;rand(10) always returns numbers less than 10 ($_)&quot;;
}</pre>
</div>


<dt><a name="sqrt"
>sqrt</a></dt>

<dd>
<pre> our Num multi Math::Basic::sqrt ( Num $x )</pre>

<p>Returns the square root of the parameter.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Math::Trig"
>Math::Trig</a></h2>

<a name="msg_13"></a>
<a href="?hide_quotes=no#msg_13" onclick="return tog_quote(13);">
<div ID="header_shown_13" style="display: none;">
- Hide the snippet from t/builtins/math/trig.t (line 61 ~ line 102) -
</div>
<div ID="header_hidden_13" style="display: block;">
- Show the snippet from t/builtins/math/trig.t (line 61 ~ line 102, 42 lines) -
</div>
</a>
<div ID="hide_13" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Math::Trig&quot;&gt;
# -- sin, cos, tan
# sin
ok(approx(sin(0/4*$PI), 0));
ok(approx(sin(1/4*$PI), 1/2*sqrt(2)));
ok(approx(sin(2/4*$PI), 1));
ok(approx(sin(3/4*$PI), 1/2*sqrt(2)));
ok(approx(sin(4/4*$PI), 0));
ok(approx(sin(5/4*$PI), -1/2*sqrt(2)));
ok(approx(sin(6/4*$PI), -1));
ok(approx(sin(7/4*$PI), -1/2*sqrt(2)));
ok(approx(sin(8/4*$PI), 0));

# cos
ok(approx(cos(0/4*$PI), 1));
ok(approx(cos(1/4*$PI), 1/2*sqrt(2)));
ok(approx(cos(2/4*$PI), 0));
ok(approx(cos(3/4*$PI), -1/2*sqrt(2)));
ok(approx(cos(4/4*$PI), -1));
ok(approx(cos(5/4*$PI), -1/2*sqrt(2)));
ok(approx(cos(6/4*$PI), 0));
ok(approx(cos(7/4*$PI), 1/2*sqrt(2)));
ok(approx(cos(8/4*$PI), 1));

# tan
ok(approx(tan(0/4*$PI), 0));
ok(approx(tan(1/4*$PI), 1));
ok(approx(tan(3/4*$PI), -1));
ok(approx(tan(4/4*$PI), 0));
ok(approx(tan(5/4*$PI), 1));
ok(approx(tan(7/4*$PI), -1));
ok(approx(tan(8/4*$PI), 0));

# asin
ok(approx(try {asin(0)},            0));
ok(approx(try {asin(1/2*sqrt(2))},  1/4*$PI), :todo&lt;feature&gt;);
ok(approx(try {asin(1)},            2/4*$PI), :todo&lt;feature&gt;);

# acos
ok(approx(try {acos(0)},            2/4*$PI), :todo&lt;feature&gt;);
ok(approx(try {acos(1/2*sqrt(2))},  1/4*$PI), :todo&lt;feature&gt;);
ok(approx(try {acos(1)},            0/4*$PI));</pre>
</div>


<dl>
<dt><a name="Standard_Trig_Functions"
><i>Standard Trig Functions</i></a></dt>

<dd>
<pre> our Num multi Num::func ( Num  $x, $base = &#39;radians&#39; )
 our Num multi Math::Trig::func ( Num $x, $base = &#39;radians&#39; )</pre>

<p>where <i>func</i> is one of: sin, cos, tan, asin, acos, atan, sec, cosec, cotan, asec, acosec, acotan, sinh, cosh, tanh, asinh, acosh, atanh, sech, cosech, cotanh, asech, acosech, acotanh.</p>

<p>Performs the various trigonometric functions.</p>

<p>Option <code>$base</code> is used to declare how you measure your angles. Given the value of an arc representing a single full revolution.</p>

<pre> $base      Result
 ----       -------
 /:i ^r/    Radians  (2*pi)
 /:i ^d/    Degrees  (360)
 /:i ^g/    Gradians (400)
 Num        Units of 1 revolution.</pre>

<p>Note that module currying can be used within a lexical scope to specify a consistent base so you don&#39;t have to supply it with every call:</p>

<pre> my module Trig ::= Math::Trig.assuming(:base&#60;degrees&#62;);</pre>

<p>This overrides the default of &#34;radians&#34;.</p>

<dt><a name="atan2"
>atan2</a></dt>

<dd>
<pre> our Num multi Math::Trig::atan2 ( Num $y, Num $x = 1, Num $base )</pre>

<p>This second form of <code>atan</code> computes the arctangent of $y/$x, and takes the quadrant into account. Otherwise behaves as other trigonometric functions.</p>

<p>[Note: changed atan back to atan2, or the default $x = 1 will confuse MMD. The other alternative would be to remove the default. --law]</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Scalar"
>Scalar</a></h2>

<dl>
<dt><a name="defined"
>defined</a></dt>

<dd>
<pre>  our Bool multi Scalar::defined ( Any $thing )
  our Bool multi Scalar::defined ( Any $thing, ::role )
  our Bool multi method Scalar::defined ( Scalar $thing: )
  our Bool multi method Scalar::defined ( Scalar $thing: ::role )</pre>

<p><code>defined</code> returns true if the parameter has a value and that value is not the undefined value (per <code>undef</code>), otherwise false is returned.</p>

<p>Same as Perl 5, only takes extra optional argument to ask if value is defined with respect to a particular role:</p>

<pre>    $x.defined(SomeRole);</pre>

<p>A value may be defined according to one role and undefined according to another. Without the extra argument, defaults to the definition of defined supplied by the type of the object.</p>

<dt><a name="undefine"
>undefine</a></dt>

<dd>
<pre>  our multi Any::undefine( Any $thing )
  our multi method Any::undefine ( Any $thing: )</pre>

<p>Takes any variable as a parameter and attempts to &#34;remove&#34; its definition. For simple scalar variables this means assigning the undefined value to the variable. For objects, this is equivalent to invoking their undefine method. For arrays, hashes and other complex data, this might require emptying the structures associated with the object.</p>

<p>In all cases, calling <code>undefine</code> on a variable should place the object in the same state as if it was just declared.</p>

<dt><a name="undef"
>undef</a></dt>

<dd>
<pre>  constant Scalar Scalar::undef</pre>

<p>Returns the undefined scalar object. <code>undef</code> has no value at all, but for historical compatibility, it will numify to <code>0</code> and stringify to the empty string, potentially generating a warning in doing so. There are two ways to determine if a value equal to undef: the <code>defined</code> function (or method) can be called or the <code>//</code> (or <code>err</code>) operator can be used.</p>

<p><code>undef</code> is also considered to be false in a boolean context. Such a conversion does not generate a warning.</p>

<p>Perl 5&#39;s unary <code>undef</code> function is renamed <code>undefine</code> to avoid confusion with the value <code>undef</code> (which is always 0-ary now).</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Container"
>Container</a></h2>

<dl>
<dt><a name="cat"
>cat</a></dt>

<dd>
<pre> our Lazy multi Container::cat( *@@list );</pre>

<p><code>cat</code> reads arrays serially rather than in parallel as <code>each</code> does. It returns all of the elements of the containers that were passed to it like so:</p>

<pre> cat(@a;@b;@c);</pre>

<p>Typically, you could just write <code>(@a,@b,@c)</code>, but sometimes it&#39;s nice to be explicit about that:</p>

<pre> @foo := [[1,2,3],[4,5,6]]; say cat([;] @foo); # 1,2,3,4,5,6</pre>

<dt><a name="each"
>each</a></dt>

<dd>
<pre> our Lazy multi Container::each( Bool :$shortest, Bool :$finite, *@@list )</pre>

<p>Unlike Perl 5&#39;s each, <code>each</code> is a general method that traverses any composite container in a type-specific manner. <code>each</code> is like <code>zip</code>, but does not create tuples as return values. An example of its use is:</p>

<pre> for each(:parity, =&#60;&#62;; 1..*) -&#62; ($line, $lineno) {
   say &#34;$lineno: $line&#34;;
 }</pre>

<p>The optional <code>:shortest</code> named parameter causes <code>each</code> to stop processing its input lists as soon as <i>any</i> of them is exhausted. This modifier can also be used on individual containers, causing <code>each</code> to stop when <i>that</i> parameter is empty.</p>

<p>The optional <code>:finite</code> named parameter causes <code>each</code> to stop processing its input lists as long as only those which are known at run-time to represent infinite ranges are left.</p>

<p>For P5-like traversal, see <code>Hash::kv</code> or <code>Hash::pairs</code> instead, and put into <code>for</code> instead of <code>while</code>. Perhaps there is a <code>Perl5::p5each</code> emulation.</p>

<dt><a name="roundrobin"
>roundrobin</a></dt>

<dd>
<pre> our Lazy multi Container::roundrobin( Bool :$shortest, Bool :$finite, *@@list )</pre>

<p><code>roundrobin</code> is very similar to <code>each</code>, and in fact</p>

<pre> roundrobin( :shortest, @a; @b; @c );</pre>

<p>and</p>

<pre> each( :shortest, @a; @b; @c );</pre>

<p>Are exactly the same. The difference is that, by default <code>roundrobin</code> will not return <code>undef</code> as a &#34;spacer&#34; for an array that has been emptied. Thus:</p>

<pre> my @a = 1;
 my @b = 1..2;
 my @c = 1..3;
 for roundrobin( @a; @b; @c ) -&#62; $x { ... }</pre>

<p>will get the following values for <code>$x</code>: <code>1, 1, 1, 2, 2, 3</code></p>

<p><code>each</code> would get: <code>1, 1, 1, 2, 2, undef, 3, undef, undef</code></p>

<dt><a name="zip"
>zip</a></dt>

<dd>
<pre> our Iterator multi Container::zip ( Bool :$shortest, Bool :$finite, *@@list )
 our Iterator multi infix:Container::&#165; ( Bool :$shortest, Bool :$finite, *@@list )
 our Iterator multi infix:Container::Y ( Bool :$shortest, Bool :$finite, *@@list )</pre>

<p>zip takes any number of arrays and returns one tuple for every index. This is easier to read in an example:</p>

<pre> for zip(@a;@b;@c) -&#62; [$nth_a,$nth_b,$nth_c] {
   ...
 }</pre>

<p>mnemonic: the input arrays are &#34;zipped&#34; up like a zipper.</p>

<p>The optional <code>:shortest</code> named parameter causes <code>zip</code> to stop processing its input lists as soon as <i>any</i> of them is exhausted. This modifier can also be used on individual containers, causing <code>zip</code> to stop when <i>that</i> parameter is empty.</p>

<p>The optional <code>:finite</code> named parameter causes <code>zip</code> to stop processing its input lists as long as only those which are known at run-time to represent infinite ranges are left.</p>

<p><code>&#165;</code> (and its ASCII equivalent, <code>Y</code>) is an infix equivalent for zip:</p>

<pre> for @a &#165; @b &#165; @c -&#62; [$a,$b,$c] {...}</pre>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Array"
>Array</a></h2>

<dl>
<dt><a name="delete"
>delete</a></dt>

<dd>
<pre> our List multi method Array::delete (@array : *@indices )</pre>

<p>Sets elements specified by <code>@indices</code> in the invocant to a non-existent state, as if they never had a value. Deleted elements at the end of an Array shorten the length of the Array, unless doing so would violate an <code>is shape()</code> definition.</p>

<p><code>@indices</code> is interpreted the same way as subscripting is in terms of slices and multidimensionality. See Synopsis 9 for details.</p>

<p>Returns the value(s) previously held in deleted locations.</p>

<p>An unary form is expected. See <code>Hash::delete</code>.</p>

<dt><a name="exists"
>exists</a></dt>

<dd>
<pre> our Bool multi method Array::exists (@array : Int *@indices )</pre>

<p>True if the specified Array element has been assigned to. This is not the same as being defined.</p>

<p>Supplying a different number of indices than invocant has dimensions is an error.</p>

<p>An unary form is expected. See <code>Hash::delete</code>.</p>

<dt><a name="pop"
>pop</a></dt>

<dd>
<pre> our Scalar multi Array::pop ( @array is rw )
 our Scalar multi method Array::pop ( @array: )</pre>

<p>Remove the last element of <code>@array</code> and return it.</p>

<dt><a name="push"
>push</a></dt>

<dd>
<pre> our Int multi Array::push ( @array is rw, *@values )
 our Int multi method Array::push ( @array: *@values )</pre>

<p>Add to the end of <code>@array</code>, all of the subsequent arguments.</p>

<dt><a name="shift"
>shift</a></dt>

<dd>
<pre> our Scalar multi Array::shift ( @array is rw  )
 our Scalar multi method Array::shift ( @array:  )</pre>

<p>Remove the first element from <code>@array</code> and return it.</p>

<dt><a name="splice"
>splice</a></dt>

<dd>
<pre> our List multi Array::splice( @array is rw, Int $offset = 0, Int $size?, *@values )</pre>

<p><code>splice</code> fills many niches in array-management, but its fundamental behavior is to remove zero or more elements from an array and replace them with a new (and potentially empty) list. This operation can shorten or lengthen the target array.</p>

<p><code>$offset</code> is the index of the array element to start with. It defaults to <code>0</code>.</p>

<p><code>$size</code> is the number of elements to remove from <code>@array</code>. It defaults to removing the rest of the array from <code>$offset</code> on.</p>

<p>The slurpy list of values (if any) is then inserted at <code>$offset</code>.</p>

<p>Calling splice with a traditional parameter list, you must define <code>$offset</code> and <code>$size</code> if you wish to pass a replacement list of values. To avoid having to pass these otherwise optional parameters, use the piping operator(s):</p>

<pre> splice(@array,10) &#60;== 1..*;</pre>

<p>which replaces <code>@array[10]</code> and all subsequent elements with an infinite series starting at <code>1</code>.</p>

<p>This behaves similarly to Perl 5&#39;s <code>splice</code>.</p>

<p>If <code>@array</code> is multidimensional, <code>splice</code> operates only on the first dimension, and works with Array References.</p>

<dt><a name="unshift"
>unshift</a></dt>

<dd>
<pre> our Int multi Array::unshift ( @array is rw, *@values )
 our Int multi method Array::unshift ( @array: *@values )</pre>

<p><code>unshift</code> adds the values onto the start of the <code>@array</code>.</p>

<dt><a name="keys"
>keys
<dt><a name="kv"
>kv
<dt><a name="pairs"
>pairs
<dt><a name="values"
>values</a></dt>

<dd>
<pre> multi Int|List Array::keys ( @array ; MatchTest *@indextests )
 multi Int|List Array::kv ( @array ; MatchTest *@indextests )
 multi Int|(List of Pair) Array::pairs  (@array ; MatchTest *@indextests )
 multi Int|List Array::values ( @array ; MatchTest *@indextests )</pre>

<p>(XXX these signatures are wrong. -luqui)</p>

<p>Iterates the elements of <code>@array</code>, in order.</p>

<p>If <code>@indextests</code> are provided, only elements whose indices match <code>$index ~~ any(@indextests)</code> are iterated.</p>

<p>What is returned at each element of the iteration varies with function. <code>values</code> returns the value of the associated element; <code>kv</code> returns a 2 element list in (index, value) order, <code>pairs</code> a <code>Pair(index, value)</code>.</p>

<p><code>@array</code> is considered single dimensional. If it is in fact multi-dimensional, the values returned will be array references to the sub array.</p>

<p>In Scalar context, they all return the count of elements that would have been iterated.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="List"
>List</a></h2>

<dl>
<dt><a name="grep"
>grep</a></dt>

<dd>
<pre> our Lazy multi Array::grep ( @values, Code *&#38;test )
 our Lazy multi Array::grep ( @values, MatchTest $test )
 our Lazy multi List::grep ( MatchTest $test, *@values )</pre>

<p><code>grep</code> takes a list or array of values and returns a lazily evaluated list comprised of all of the values from the original list for which the <code>$test</code> smart-matches as true.</p>

<p>Here is an example of its use:</p>

<pre> @friends = grep { .is_friend } @coworkers;</pre>

<p>This takes the array <code>@coworkers</code>, checks every element to see which ones return true for the <code>.is_friend</code> method, and returns the resulting list to store into <code>@friends</code>.</p>

<dt><a name="join"
>join</a></dt>

<dd>
<pre> our Str multi Array::join ( @values, Str $separator? )
 our Str multi List::join ( Str $separator?, *@values )</pre>

<p><code>join</code> returns a single string comprised of all of the elements of <code>@values</code>, separated by <code>$separator</code>. The separator defaults to a single space.</p>

<p>Given an empty list, <code>join</code> returns the empty string.</p>

<dt><a name="map"
>map</a></dt>

<dd>
<pre> our Lazy multi Array::map ( @values, Code *&#38;expression )
 our Lazy multi List::map ( Code $expression?, *@values )</pre>

<p><code>map</code> returns a lazily evaluated list which is comprised of the return value of the expression, evaluated once for every one of the <code>@values</code> that are passed in.</p>

<p>Here is an example of its use:</p>

<pre> @addresses = map { %addresses_by_name&#60;$_&#62; } @names;</pre>

<p>Here we take an array of names, and look each name up in <code>%addresses_by_name</code> in order to build the corresponding list of addresses.</p>

<p>If the expression returns no values or multiple values, then the resulting list may not be the same length as the number of values that were passed. For example:</p>

<pre> @factors = map { prime_factors($_) } @composites;</pre>

<dt><a name="reduce"
>reduce</a></dt>

<dd>
<pre> our Scalar multi Array::reduce ( @values ; Code *&#38;expression )
 our Scalar multi List::reduce ( Code $expression ; *@values )
   my $res;
   for @values -&#62; $cur {
     FIRST {$res = $cur; next;}
     $res = &#38;$expression($res, $cur);
   }
   $res;
 }</pre>

<dt><a name="reverse"
>reverse</a></dt>

<dd>
<pre> our Hash multi Hash::reverse ( %hash ) {
   (my %result){%hash.values} = %hash.keys;
   %result;
 }

 multi Lazy Array::reverse ( @values )
 multi Lazy List::reverse ( *@values ) {
    gather {
        1 while take pop @values;
    }
 }

 multi Str Str::reverse ( $str ) {
    split(&#39;&#39;, $str).reverse.join
 )</pre>

<dt><a name="sort"
>sort</a></dt>

<dd>
<pre> subset KeyExtractor of Code(Any --&#62; Any);
 subset Comparator   of Code(Any, Any --&#62; Int );
 subset SortCriterion of KeyExtractor | Comparator | Pair(KeyExtractor, Comparator);

 our Array multi Array::sort( @values is rw, *&#38;by, Bit $inplace? )
 our Array multi Array::sort( @values is rw, SortCriterion @by, Bit $inplace? )
 our Array multi Array::sort( @values is rw, SortCriterion $by = &#38;infix:&#60;cmp&#62;, Bit $inplace? )

 our List multi List::sort( SortCriterion @by,  *@values )
 our List multi List::sort( SortCriterion $by = &#38;infix:&#60;cmp&#62;, *@values )</pre>

<p>Returns <code>@values</code> sorted, using criteria <code>$by</code> or <code>@by</code> for comparisons. <code>@by</code> differs from <code>$by</code> in that each criteria is applied, in order, until a non-zero (tie) result is achieved.</p>

<p>Criterion can take a few different forms:</p>

<dl>
<dt><a name="Comparator"
>Comparator</a></dt>

<dd>
<p>A closure with arity of 2, which returns negative/zero/positive, signaling the first argument should be before/tied with/after the second in the final ordering of the List. aka &#34;The Perl 5 way&#34;</p>

<dt><a name="KeyExtractor"
>KeyExtractor</a></dt>

<dd>
<p>A closure with arity of 1, which returns the &#34;key&#34; by which to sort. If the closure returns a Num, <code>&#60;=&#62;</code> is used for comparison, otherwise <code>cmp</code>.</p>

<dt><a name="Pair(KeyExtractor,_Comparator)"
>Pair(KeyExtractor, Comparator)</a></dt>

<dd>
<p>A combination of the two methods above, for when one wishes to take advantage of the internal caching of keys that is expected to happen, but wishes to compare them with something other than <code>&#60;=&#62;</code> or <code>cmp</code>.</p>
</dd>
</dl>

<p>Any Criterion may receive either or both of the traits <code>is descending</code> and <code>is insensitive</code> to reverse the order of sort, or the adjust the case sensitivity of <code>cmp</code> as a Comparator.</p>

<p>If all criteria are exhausted when comparing two elements, sort should return them in the same relative order they had in <code>@values</code>.</p>

<p>If <code>$inplace</code> is specified, the array is sorted in place.</p>

<p>See <a href="http://www.nntp.perl.org/group/perl.perl6.language/16578" class="podlinkurl"
>http://www.nntp.perl.org/group/perl.perl6.language/16578</a> for more details and examples.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Hash"
>Hash</a></h2>

<dl>
<dt><a name="delete"
>delete</a></dt>

<dd>
<pre> our List  multi method Hash::delete ( *@keys )
 our Scalar multi method Hash::delete ( $key ) is default</pre>

<p>Deletes the elements specified by <code>$key</code> or <code>$keys</code> from the invocant. returns the value(s) that were associated to those keys.</p>

<dl>
<dt><a name="Unary_Form"
>Unary Form</a></dt>

<dd>
<p>Implementations should create a suitable macro, or otherwise support the unary form <code>delete %hash{$key}</code> in all its forms. Below are some example translations. This list is <i>not</i> exhaustive.</p>

<pre> delete %hash{$key}                %hash.delete{$key}
 delete %hash&#60;key&#62;                 %hash.delete{&#39;key&#39;}
 delete %hash&#60;key1&#62;{@keys}         %hash&#60;key1&#62;.delete{@keys}</pre>
</dd>
</dl>

<dt><a name="exists"
>exists</a></dt>

<dd>
<pre> our Bool multi method Hash::exists ( $key )</pre>

<p>True if invocant has an element whose key matches <code>$key</code>, false otherwise.</p>

<p>A unary form is expected. See Hash::delete.</p>

<p>See also Code::exists to determine if a function has been declared. (Use defined() to determine whether the function body is defined. A body of ... counts as undefined.)</p>

<dt><a name="keys"
>keys
<dt><a name="kv"
>kv
<dt><a name="pairs"
>pairs
<dt><a name="values"
>values</a></dt>

<dd>
<pre> multi Int|List Hash::keys ( %hash ; MatchTest *@keytests )
 multi Int|List Hash::kv ( %hash ; MatchTest *@keytests )
 multi Int|(List of Pair) Hash::pairs  (%hash ; MatchTest *@keytests )
 multi Int|List Hash::values ( %hash ; MatchTest *@keytests )</pre>

<p>Iterates the elements of <code>%hash</code> in no apparent order, but the order will be the same between successive calls to these functions, as long as <code>%hash</code> doesn&#39;t change.</p>

<p>If <code>@keytests</code> are provided, only elements whose keys evaluate <code>$key ~~ any(@keytests)</code> as true are iterated.</p>

<p>What is returned at each element of the iteration varies with function. <code>keys</code> only returns the key; <code>values</code> the value; <code>kv</code> returns both as a 2 element list in (key, value) order, <code>pairs</code> a <code>Pair(key, value)</code>.</p>

<p>Note that <code>kv %hash</code> returns the same as <code>zip(keys %hash; values %hash)</code></p>

<p>In Scalar context, they all return the count of elements that would have been iterated.</p>

<p>The lvalue form of <code>keys</code> is not longer supported. Use the <code>.buckets</code> property instead.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Str"
>Str</a></h2>

<p>General notes about strings:</p>

<p>A Str can exist at several Unicode levels at once. Which level you interact with typically depends on what your current lexical context has declared the &#34;working Unicode level to be&#34;. Default is GChar.</p>

<p>[Q: Default can&#39;t be LChar because we don&#39;t go into &#34;language&#34; mode unless there&#39;s a specific language declaration saying either exactly what language we&#39;re going into, or what environmental parameter to pay attention to to select our language. So I believe the default should be GChar. -law]</p>

<p>Attempting to use a string at a level higher it can support is handled without warning. The current highest supported level of the string is simply mapped Char for Char to the new higher level. However, attempting to stuff something of a higher level a lower-level string is an error (for example, attempting to store Kanji in a Byte string). And explicit conversion function must be used to tell it how you want it encoded.</p>

<p>Attempting to use a string at a level lower than what it supports is not allowed.</p>

<p>If a function takes a <code>Str</code> and returns a <code>Str</code>, the returned <code>Str</code> will support the same levels as the input, unless specified otherwise.</p>

<dl>
<dt><a name="p5chop"
>p5chop</a></dt>

<dd>
<pre> our Char multi P5emul::Str::p5chop ( Str  $string is rw )
 our Char multi P5emul::Str::p5chop ( Str *@strings = ($+_) is rw )</pre>

<p>Trims the last character from <code>$string</code>, and returns it. Called with a list, it chops each item in turn, and returns the last character chopped.</p>

<dt><a name="chop"
>chop</a></dt>

<dd>
<pre> our Str method Str::chop ( Str  $string: )</pre>

<p>Returns string with one Char removed from the end.</p>

<dt><a name="p5chomp"
>p5chomp</a></dt>

<dd>
<a name="msg_57"></a>
<a href="?hide_quotes=no#msg_57" onclick="return tog_quote(57);">
<div ID="header_shown_57" style="display: none;">
- Hide the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37) -
</div>
<div ID="header_hidden_57" style="display: block;">
- Show the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37, 25 lines) -
</div>
</a>
<div ID="hide_57" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /chomp/&gt;
# Also see L&lt;&quot;http://use.perl.org/~autrijus/journal/25351&quot;&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.
# Since currently the behaviour with regards to arrays is not defined, I'm
# assuming the correct behaviour is an extension of the behaviour for
# a single string.

{
    my @foo = (&quot;foo\n&quot;,&quot;bar\n&quot;,&quot;baz\n&quot;);
    chomp(@foo);
    is(@foo[0], &quot;foo\n&quot;, '1st element was not yet chomped');
    is(@foo[1], &quot;bar\n&quot;, '2nd element was not yet chomped');
    is(@foo[2], &quot;baz\n&quot;, '3rd element was not yet chomped');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element chomped correctly');
    is(@foo[1], 'bar', '2nd element chomped correctly');
    is(@foo[2], 'baz', '3rd element chomped correctly');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element is chomped again with no effect');
    is(@foo[1], 'bar', '2nd element is chomped again with no effect');
    is(@foo[2], 'baz', '3rd element is chomped again with no effect');
}</pre>
</div>


<a name="msg_49"></a>
<a href="?hide_quotes=no#msg_49" onclick="return tog_quote(49);">
<div ID="header_shown_49" style="display: none;">
- Hide the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116) -
</div>
<div ID="header_hidden_49" style="display: block;">
- Show the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116, 104 lines) -
</div>
</a>
<div ID="hide_49" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /chomp/&gt;
# Also see L&lt;&quot;http://use.perl.org/~autrijus/journal/25351&quot;&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.

{
    my $foo = &quot;foo\n&quot;;
    chomp($foo);
    is($foo, &quot;foo\n&quot;, 'our variable was not yet chomped');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = &quot;foo\n\n&quot;;
    $foo .= chomp;
    is($foo, &quot;foo\n&quot;, 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = &quot;foo\nbar\n&quot;;
    $foo .= chomp;
    is($foo, &quot;foo\nbar&quot;, 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, &quot;foo\nbar&quot;, 'our variable is chomped again with no effect');
}

{
    my $foo = &quot;foo\n &quot;;
    $foo .= chomp;
    is($foo, &quot;foo\n &quot;, 'our variable is chomped with no effect');
}

{
    my $foo = &quot;foo\n&quot;;
    my $chomped_foo = try { chomp($foo).newline };
    is($chomped_foo, &quot;\n&quot;, 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, &quot;foo\n&quot;, 'and our variable was not chomped');
}

{
    my $foo = &quot;foo\n&quot;;
    $foo .= chomp;
    my $chomped_foo = try { $foo.newline };
    is($chomped_foo, &quot;\n&quot;, 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, &quot;foo&quot;, 'and our variable was chomped');
}

{
    my $foo = &quot;foo\n\n&quot;;
    my $chomped = $foo.chomp;
    is($foo, &quot;foo\n\n&quot;, &quot;.chomp has no effect on the original string&quot;);
    is($chomped, &quot;foo\n&quot;, &quot;.chomp returns correctly chomped value&quot;);
    
    # $chomped.chomp.newline

    $chomped = $chomped.chomp;
    is($chomped, &quot;foo&quot;, &quot;.chomp returns correctly chomped value again&quot;);
}

# chomp in list context
{
    is_deeply(chomp(()), [], &quot;chomp on empty list&quot;);
    is_deeply(chomp((&quot;abc\n&quot;)), (&quot;abc&quot;), &quot;one element list&quot;);
    is_deeply(chomp((&quot;abc\n&quot;, &quot;bcd\n&quot;)), (&quot;abc&quot;, &quot;bcd&quot;), &quot;two element list&quot;);
    is_deeply((&quot;abc\n&quot;, &quot;bcd\n&quot;).chomp, (&quot;abc&quot;, &quot;bcd&quot;), &quot;two element list&quot;);
}
{
    my @foo = ();
    my @bar = chomp @foo;
    is_deeply(@bar, @foo, &quot;chomp empty array&quot;);
}
{
    my @foo = (&quot;abc\n&quot;);
    my @bar = chomp @foo;
    my @baz = (&quot;abc&quot;);
    is_deeply(@bar, @baz, &quot;chomp array with one element&quot;);
}
{
    my @foo = (&quot;abc\n&quot;, &quot;bcd\n&quot;);
    my @bar = chomp @foo;
    my @baz = (&quot;abc&quot;, &quot;bcd&quot;);
    is_deeply(@bar, @baz, &quot;chomp array with 2 elements&quot;);


    @bar = @foo.chomp;
    is_deeply(@bar, @baz, &quot;chomp array with 2 elements&quot;);

    my @morgo = (&quot;abc\n\n&quot;, &quot;bcd\n\n&quot;);
    my @hapci = chomp @morgo;
    is_deeply(@hapci, @foo, &quot;chomp array with 2 elements with duplicate newlines&quot;);

    my @szundi = @morgo.chomp;
    is_deeply(@szundi, @foo, &quot;chomp array with 2 elements with duplicate newlines&quot;);
}</pre>
</div>


<pre> our Int multi P5emul::Str::p5chomp ( Str  $string is rw )</pre>

<a name="msg_58"></a>
<a href="?hide_quotes=no#msg_58" onclick="return tog_quote(58);">
<div ID="header_shown_58" style="display: none;">
- Hide the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37) -
</div>
<div ID="header_hidden_58" style="display: block;">
- Show the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37, 25 lines) -
</div>
</a>
<div ID="hide_58" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /chomp/&gt;
# Also see L&lt;&quot;http://use.perl.org/~autrijus/journal/25351&quot;&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.
# Since currently the behaviour with regards to arrays is not defined, I'm
# assuming the correct behaviour is an extension of the behaviour for
# a single string.

{
    my @foo = (&quot;foo\n&quot;,&quot;bar\n&quot;,&quot;baz\n&quot;);
    chomp(@foo);
    is(@foo[0], &quot;foo\n&quot;, '1st element was not yet chomped');
    is(@foo[1], &quot;bar\n&quot;, '2nd element was not yet chomped');
    is(@foo[2], &quot;baz\n&quot;, '3rd element was not yet chomped');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element chomped correctly');
    is(@foo[1], 'bar', '2nd element chomped correctly');
    is(@foo[2], 'baz', '3rd element chomped correctly');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element is chomped again with no effect');
    is(@foo[1], 'bar', '2nd element is chomped again with no effect');
    is(@foo[2], 'baz', '3rd element is chomped again with no effect');
}</pre>
</div>


<a name="msg_50"></a>
<a href="?hide_quotes=no#msg_50" onclick="return tog_quote(50);">
<div ID="header_shown_50" style="display: none;">
- Hide the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116) -
</div>
<div ID="header_hidden_50" style="display: block;">
- Show the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116, 104 lines) -
</div>
</a>
<div ID="hide_50" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /chomp/&gt;
# Also see L&lt;&quot;http://use.perl.org/~autrijus/journal/25351&quot;&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.

{
    my $foo = &quot;foo\n&quot;;
    chomp($foo);
    is($foo, &quot;foo\n&quot;, 'our variable was not yet chomped');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = &quot;foo\n\n&quot;;
    $foo .= chomp;
    is($foo, &quot;foo\n&quot;, 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = &quot;foo\nbar\n&quot;;
    $foo .= chomp;
    is($foo, &quot;foo\nbar&quot;, 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, &quot;foo\nbar&quot;, 'our variable is chomped again with no effect');
}

{
    my $foo = &quot;foo\n &quot;;
    $foo .= chomp;
    is($foo, &quot;foo\n &quot;, 'our variable is chomped with no effect');
}

{
    my $foo = &quot;foo\n&quot;;
    my $chomped_foo = try { chomp($foo).newline };
    is($chomped_foo, &quot;\n&quot;, 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, &quot;foo\n&quot;, 'and our variable was not chomped');
}

{
    my $foo = &quot;foo\n&quot;;
    $foo .= chomp;
    my $chomped_foo = try { $foo.newline };
    is($chomped_foo, &quot;\n&quot;, 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, &quot;foo&quot;, 'and our variable was chomped');
}

{
    my $foo = &quot;foo\n\n&quot;;
    my $chomped = $foo.chomp;
    is($foo, &quot;foo\n\n&quot;, &quot;.chomp has no effect on the original string&quot;);
    is($chomped, &quot;foo\n&quot;, &quot;.chomp returns correctly chomped value&quot;);
    
    # $chomped.chomp.newline

    $chomped = $chomped.chomp;
    is($chomped, &quot;foo&quot;, &quot;.chomp returns correctly chomped value again&quot;);
}

# chomp in list context
{
    is_deeply(chomp(()), [], &quot;chomp on empty list&quot;);
    is_deeply(chomp((&quot;abc\n&quot;)), (&quot;abc&quot;), &quot;one element list&quot;);
    is_deeply(chomp((&quot;abc\n&quot;, &quot;bcd\n&quot;)), (&quot;abc&quot;, &quot;bcd&quot;), &quot;two element list&quot;);
    is_deeply((&quot;abc\n&quot;, &quot;bcd\n&quot;).chomp, (&quot;abc&quot;, &quot;bcd&quot;), &quot;two element list&quot;);
}
{
    my @foo = ();
    my @bar = chomp @foo;
    is_deeply(@bar, @foo, &quot;chomp empty array&quot;);
}
{
    my @foo = (&quot;abc\n&quot;);
    my @bar = chomp @foo;
    my @baz = (&quot;abc&quot;);
    is_deeply(@bar, @baz, &quot;chomp array with one element&quot;);
}
{
    my @foo = (&quot;abc\n&quot;, &quot;bcd\n&quot;);
    my @bar = chomp @foo;
    my @baz = (&quot;abc&quot;, &quot;bcd&quot;);
    is_deeply(@bar, @baz, &quot;chomp array with 2 elements&quot;);


    @bar = @foo.chomp;
    is_deeply(@bar, @baz, &quot;chomp array with 2 elements&quot;);

    my @morgo = (&quot;abc\n\n&quot;, &quot;bcd\n\n&quot;);
    my @hapci = chomp @morgo;
    is_deeply(@hapci, @foo, &quot;chomp array with 2 elements with duplicate newlines&quot;);

    my @szundi = @morgo.chomp;
    is_deeply(@szundi, @foo, &quot;chomp array with 2 elements with duplicate newlines&quot;);
}</pre>
</div>


<pre> our Int multi P5emul::Str::p5chomp ( Str *@strings = ($+_) is rw )</pre>

<a name="msg_59"></a>
<a href="?hide_quotes=no#msg_59" onclick="return tog_quote(59);">
<div ID="header_shown_59" style="display: none;">
- Hide the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37) -
</div>
<div ID="header_hidden_59" style="display: block;">
- Show the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37, 25 lines) -
</div>
</a>
<div ID="hide_59" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /chomp/&gt;
# Also see L&lt;&quot;http://use.perl.org/~autrijus/journal/25351&quot;&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.
# Since currently the behaviour with regards to arrays is not defined, I'm
# assuming the correct behaviour is an extension of the behaviour for
# a single string.

{
    my @foo = (&quot;foo\n&quot;,&quot;bar\n&quot;,&quot;baz\n&quot;);
    chomp(@foo);
    is(@foo[0], &quot;foo\n&quot;, '1st element was not yet chomped');
    is(@foo[1], &quot;bar\n&quot;, '2nd element was not yet chomped');
    is(@foo[2], &quot;baz\n&quot;, '3rd element was not yet chomped');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element chomped correctly');
    is(@foo[1], 'bar', '2nd element chomped correctly');
    is(@foo[2], 'baz', '3rd element chomped correctly');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element is chomped again with no effect');
    is(@foo[1], 'bar', '2nd element is chomped again with no effect');
    is(@foo[2], 'baz', '3rd element is chomped again with no effect');
}</pre>
</div>


<a name="msg_51"></a>
<a href="?hide_quotes=no#msg_51" onclick="return tog_quote(51);">
<div ID="header_shown_51" style="display: none;">
- Hide the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116) -
</div>
<div ID="header_hidden_51" style="display: block;">
- Show the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116, 104 lines) -
</div>
</a>
<div ID="hide_51" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /chomp/&gt;
# Also see L&lt;&quot;http://use.perl.org/~autrijus/journal/25351&quot;&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.

{
    my $foo = &quot;foo\n&quot;;
    chomp($foo);
    is($foo, &quot;foo\n&quot;, 'our variable was not yet chomped');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = &quot;foo\n\n&quot;;
    $foo .= chomp;
    is($foo, &quot;foo\n&quot;, 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = &quot;foo\nbar\n&quot;;
    $foo .= chomp;
    is($foo, &quot;foo\nbar&quot;, 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, &quot;foo\nbar&quot;, 'our variable is chomped again with no effect');
}

{
    my $foo = &quot;foo\n &quot;;
    $foo .= chomp;
    is($foo, &quot;foo\n &quot;, 'our variable is chomped with no effect');
}

{
    my $foo = &quot;foo\n&quot;;
    my $chomped_foo = try { chomp($foo).newline };
    is($chomped_foo, &quot;\n&quot;, 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, &quot;foo\n&quot;, 'and our variable was not chomped');
}

{
    my $foo = &quot;foo\n&quot;;
    $foo .= chomp;
    my $chomped_foo = try { $foo.newline };
    is($chomped_foo, &quot;\n&quot;, 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, &quot;foo&quot;, 'and our variable was chomped');
}

{
    my $foo = &quot;foo\n\n&quot;;
    my $chomped = $foo.chomp;
    is($foo, &quot;foo\n\n&quot;, &quot;.chomp has no effect on the original string&quot;);
    is($chomped, &quot;foo\n&quot;, &quot;.chomp returns correctly chomped value&quot;);
    
    # $chomped.chomp.newline

    $chomped = $chomped.chomp;
    is($chomped, &quot;foo&quot;, &quot;.chomp returns correctly chomped value again&quot;);
}

# chomp in list context
{
    is_deeply(chomp(()), [], &quot;chomp on empty list&quot;);
    is_deeply(chomp((&quot;abc\n&quot;)), (&quot;abc&quot;), &quot;one element list&quot;);
    is_deeply(chomp((&quot;abc\n&quot;, &quot;bcd\n&quot;)), (&quot;abc&quot;, &quot;bcd&quot;), &quot;two element list&quot;);
    is_deeply((&quot;abc\n&quot;, &quot;bcd\n&quot;).chomp, (&quot;abc&quot;, &quot;bcd&quot;), &quot;two element list&quot;);
}
{
    my @foo = ();
    my @bar = chomp @foo;
    is_deeply(@bar, @foo, &quot;chomp empty array&quot;);
}
{
    my @foo = (&quot;abc\n&quot;);
    my @bar = chomp @foo;
    my @baz = (&quot;abc&quot;);
    is_deeply(@bar, @baz, &quot;chomp array with one element&quot;);
}
{
    my @foo = (&quot;abc\n&quot;, &quot;bcd\n&quot;);
    my @bar = chomp @foo;
    my @baz = (&quot;abc&quot;, &quot;bcd&quot;);
    is_deeply(@bar, @baz, &quot;chomp array with 2 elements&quot;);


    @bar = @foo.chomp;
    is_deeply(@bar, @baz, &quot;chomp array with 2 elements&quot;);

    my @morgo = (&quot;abc\n\n&quot;, &quot;bcd\n\n&quot;);
    my @hapci = chomp @morgo;
    is_deeply(@hapci, @foo, &quot;chomp array with 2 elements with duplicate newlines&quot;);

    my @szundi = @morgo.chomp;
    is_deeply(@szundi, @foo, &quot;chomp array with 2 elements with duplicate newlines&quot;);
}</pre>
</div>


<p>Related to <code>p5chop</code>, only removes trailing chars that match <code>/\n/</code>. In either case, it returns the number of chars removed.</p>

<dt><a name="chomp"
>chomp</a></dt>

<dd>
<a name="msg_60"></a>
<a href="?hide_quotes=no#msg_60" onclick="return tog_quote(60);">
<div ID="header_shown_60" style="display: none;">
- Hide the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37) -
</div>
<div ID="header_hidden_60" style="display: block;">
- Show the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37, 25 lines) -
</div>
</a>
<div ID="hide_60" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /chomp/&gt;
# Also see L&lt;&quot;http://use.perl.org/~autrijus/journal/25351&quot;&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.
# Since currently the behaviour with regards to arrays is not defined, I'm
# assuming the correct behaviour is an extension of the behaviour for
# a single string.

{
    my @foo = (&quot;foo\n&quot;,&quot;bar\n&quot;,&quot;baz\n&quot;);
    chomp(@foo);
    is(@foo[0], &quot;foo\n&quot;, '1st element was not yet chomped');
    is(@foo[1], &quot;bar\n&quot;, '2nd element was not yet chomped');
    is(@foo[2], &quot;baz\n&quot;, '3rd element was not yet chomped');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element chomped correctly');
    is(@foo[1], 'bar', '2nd element chomped correctly');
    is(@foo[2], 'baz', '3rd element chomped correctly');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element is chomped again with no effect');
    is(@foo[1], 'bar', '2nd element is chomped again with no effect');
    is(@foo[2], 'baz', '3rd element is chomped again with no effect');
}</pre>
</div>


<a name="msg_52"></a>
<a href="?hide_quotes=no#msg_52" onclick="return tog_quote(52);">
<div ID="header_shown_52" style="display: none;">
- Hide the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116) -
</div>
<div ID="header_hidden_52" style="display: block;">
- Show the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116, 104 lines) -
</div>
</a>
<div ID="hide_52" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /chomp/&gt;
# Also see L&lt;&quot;http://use.perl.org/~autrijus/journal/25351&quot;&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.

{
    my $foo = &quot;foo\n&quot;;
    chomp($foo);
    is($foo, &quot;foo\n&quot;, 'our variable was not yet chomped');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = &quot;foo\n\n&quot;;
    $foo .= chomp;
    is($foo, &quot;foo\n&quot;, 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = &quot;foo\nbar\n&quot;;
    $foo .= chomp;
    is($foo, &quot;foo\nbar&quot;, 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, &quot;foo\nbar&quot;, 'our variable is chomped again with no effect');
}

{
    my $foo = &quot;foo\n &quot;;
    $foo .= chomp;
    is($foo, &quot;foo\n &quot;, 'our variable is chomped with no effect');
}

{
    my $foo = &quot;foo\n&quot;;
    my $chomped_foo = try { chomp($foo).newline };
    is($chomped_foo, &quot;\n&quot;, 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, &quot;foo\n&quot;, 'and our variable was not chomped');
}

{
    my $foo = &quot;foo\n&quot;;
    $foo .= chomp;
    my $chomped_foo = try { $foo.newline };
    is($chomped_foo, &quot;\n&quot;, 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, &quot;foo&quot;, 'and our variable was chomped');
}

{
    my $foo = &quot;foo\n\n&quot;;
    my $chomped = $foo.chomp;
    is($foo, &quot;foo\n\n&quot;, &quot;.chomp has no effect on the original string&quot;);
    is($chomped, &quot;foo\n&quot;, &quot;.chomp returns correctly chomped value&quot;);
    
    # $chomped.chomp.newline

    $chomped = $chomped.chomp;
    is($chomped, &quot;foo&quot;, &quot;.chomp returns correctly chomped value again&quot;);
}

# chomp in list context
{
    is_deeply(chomp(()), [], &quot;chomp on empty list&quot;);
    is_deeply(chomp((&quot;abc\n&quot;)), (&quot;abc&quot;), &quot;one element list&quot;);
    is_deeply(chomp((&quot;abc\n&quot;, &quot;bcd\n&quot;)), (&quot;abc&quot;, &quot;bcd&quot;), &quot;two element list&quot;);
    is_deeply((&quot;abc\n&quot;, &quot;bcd\n&quot;).chomp, (&quot;abc&quot;, &quot;bcd&quot;), &quot;two element list&quot;);
}
{
    my @foo = ();
    my @bar = chomp @foo;
    is_deeply(@bar, @foo, &quot;chomp empty array&quot;);
}
{
    my @foo = (&quot;abc\n&quot;);
    my @bar = chomp @foo;
    my @baz = (&quot;abc&quot;);
    is_deeply(@bar, @baz, &quot;chomp array with one element&quot;);
}
{
    my @foo = (&quot;abc\n&quot;, &quot;bcd\n&quot;);
    my @bar = chomp @foo;
    my @baz = (&quot;abc&quot;, &quot;bcd&quot;);
    is_deeply(@bar, @baz, &quot;chomp array with 2 elements&quot;);


    @bar = @foo.chomp;
    is_deeply(@bar, @baz, &quot;chomp array with 2 elements&quot;);

    my @morgo = (&quot;abc\n\n&quot;, &quot;bcd\n\n&quot;);
    my @hapci = chomp @morgo;
    is_deeply(@hapci, @foo, &quot;chomp array with 2 elements with duplicate newlines&quot;);

    my @szundi = @morgo.chomp;
    is_deeply(@szundi, @foo, &quot;chomp array with 2 elements with duplicate newlines&quot;);
}</pre>
</div>


<pre> our Str method Str::chomp ( Str $string: )</pre>

<a name="msg_61"></a>
<a href="?hide_quotes=no#msg_61" onclick="return tog_quote(61);">
<div ID="header_shown_61" style="display: none;">
- Hide the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37) -
</div>
<div ID="header_hidden_61" style="display: block;">
- Show the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37, 25 lines) -
</div>
</a>
<div ID="hide_61" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /chomp/&gt;
# Also see L&lt;&quot;http://use.perl.org/~autrijus/journal/25351&quot;&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.
# Since currently the behaviour with regards to arrays is not defined, I'm
# assuming the correct behaviour is an extension of the behaviour for
# a single string.

{
    my @foo = (&quot;foo\n&quot;,&quot;bar\n&quot;,&quot;baz\n&quot;);
    chomp(@foo);
    is(@foo[0], &quot;foo\n&quot;, '1st element was not yet chomped');
    is(@foo[1], &quot;bar\n&quot;, '2nd element was not yet chomped');
    is(@foo[2], &quot;baz\n&quot;, '3rd element was not yet chomped');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element chomped correctly');
    is(@foo[1], 'bar', '2nd element chomped correctly');
    is(@foo[2], 'baz', '3rd element chomped correctly');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element is chomped again with no effect');
    is(@foo[1], 'bar', '2nd element is chomped again with no effect');
    is(@foo[2], 'baz', '3rd element is chomped again with no effect');
}</pre>
</div>


<a name="msg_53"></a>
<a href="?hide_quotes=no#msg_53" onclick="return tog_quote(53);">
<div ID="header_shown_53" style="display: none;">
- Hide the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116) -
</div>
<div ID="header_hidden_53" style="display: block;">
- Show the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116, 104 lines) -
</div>
</a>
<div ID="hide_53" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /chomp/&gt;
# Also see L&lt;&quot;http://use.perl.org/~autrijus/journal/25351&quot;&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.

{
    my $foo = &quot;foo\n&quot;;
    chomp($foo);
    is($foo, &quot;foo\n&quot;, 'our variable was not yet chomped');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = &quot;foo\n\n&quot;;
    $foo .= chomp;
    is($foo, &quot;foo\n&quot;, 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = &quot;foo\nbar\n&quot;;
    $foo .= chomp;
    is($foo, &quot;foo\nbar&quot;, 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, &quot;foo\nbar&quot;, 'our variable is chomped again with no effect');
}

{
    my $foo = &quot;foo\n &quot;;
    $foo .= chomp;
    is($foo, &quot;foo\n &quot;, 'our variable is chomped with no effect');
}

{
    my $foo = &quot;foo\n&quot;;
    my $chomped_foo = try { chomp($foo).newline };
    is($chomped_foo, &quot;\n&quot;, 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, &quot;foo\n&quot;, 'and our variable was not chomped');
}

{
    my $foo = &quot;foo\n&quot;;
    $foo .= chomp;
    my $chomped_foo = try { $foo.newline };
    is($chomped_foo, &quot;\n&quot;, 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, &quot;foo&quot;, 'and our variable was chomped');
}

{
    my $foo = &quot;foo\n\n&quot;;
    my $chomped = $foo.chomp;
    is($foo, &quot;foo\n\n&quot;, &quot;.chomp has no effect on the original string&quot;);
    is($chomped, &quot;foo\n&quot;, &quot;.chomp returns correctly chomped value&quot;);
    
    # $chomped.chomp.newline

    $chomped = $chomped.chomp;
    is($chomped, &quot;foo&quot;, &quot;.chomp returns correctly chomped value again&quot;);
}

# chomp in list context
{
    is_deeply(chomp(()), [], &quot;chomp on empty list&quot;);
    is_deeply(chomp((&quot;abc\n&quot;)), (&quot;abc&quot;), &quot;one element list&quot;);
    is_deeply(chomp((&quot;abc\n&quot;, &quot;bcd\n&quot;)), (&quot;abc&quot;, &quot;bcd&quot;), &quot;two element list&quot;);
    is_deeply((&quot;abc\n&quot;, &quot;bcd\n&quot;).chomp, (&quot;abc&quot;, &quot;bcd&quot;), &quot;two element list&quot;);
}
{
    my @foo = ();
    my @bar = chomp @foo;
    is_deeply(@bar, @foo, &quot;chomp empty array&quot;);
}
{
    my @foo = (&quot;abc\n&quot;);
    my @bar = chomp @foo;
    my @baz = (&quot;abc&quot;);
    is_deeply(@bar, @baz, &quot;chomp array with one element&quot;);
}
{
    my @foo = (&quot;abc\n&quot;, &quot;bcd\n&quot;);
    my @bar = chomp @foo;
    my @baz = (&quot;abc&quot;, &quot;bcd&quot;);
    is_deeply(@bar, @baz, &quot;chomp array with 2 elements&quot;);


    @bar = @foo.chomp;
    is_deeply(@bar, @baz, &quot;chomp array with 2 elements&quot;);

    my @morgo = (&quot;abc\n\n&quot;, &quot;bcd\n\n&quot;);
    my @hapci = chomp @morgo;
    is_deeply(@hapci, @foo, &quot;chomp array with 2 elements with duplicate newlines&quot;);

    my @szundi = @morgo.chomp;
    is_deeply(@szundi, @foo, &quot;chomp array with 2 elements with duplicate newlines&quot;);
}</pre>
</div>


<p>Returns string with newline removed from the end. An arbitrary terminator can be removed if the input filehandle has marked the string for where the &#34;newline&#34; begins. (Presumably this is stored as a property of the string.) Otherwise a standard newline is removed.</p>

<p>Note: Most users should just let their I/O handles autochomp instead. (Autochomping is the default.)</p>

<a name="msg_62"></a>
<a href="?hide_quotes=no#msg_62" onclick="return tog_quote(62);">
<div ID="header_shown_62" style="display: none;">
- Hide the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37) -
</div>
<div ID="header_hidden_62" style="display: block;">
- Show the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37, 25 lines) -
</div>
</a>
<div ID="hide_62" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /chomp/&gt;
# Also see L&lt;&quot;http://use.perl.org/~autrijus/journal/25351&quot;&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.
# Since currently the behaviour with regards to arrays is not defined, I'm
# assuming the correct behaviour is an extension of the behaviour for
# a single string.

{
    my @foo = (&quot;foo\n&quot;,&quot;bar\n&quot;,&quot;baz\n&quot;);
    chomp(@foo);
    is(@foo[0], &quot;foo\n&quot;, '1st element was not yet chomped');
    is(@foo[1], &quot;bar\n&quot;, '2nd element was not yet chomped');
    is(@foo[2], &quot;baz\n&quot;, '3rd element was not yet chomped');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element chomped correctly');
    is(@foo[1], 'bar', '2nd element chomped correctly');
    is(@foo[2], 'baz', '3rd element chomped correctly');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element is chomped again with no effect');
    is(@foo[1], 'bar', '2nd element is chomped again with no effect');
    is(@foo[2], 'baz', '3rd element is chomped again with no effect');
}</pre>
</div>


<a name="msg_54"></a>
<a href="?hide_quotes=no#msg_54" onclick="return tog_quote(54);">
<div ID="header_shown_54" style="display: none;">
- Hide the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116) -
</div>
<div ID="header_hidden_54" style="display: block;">
- Show the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116, 104 lines) -
</div>
</a>
<div ID="hide_54" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /chomp/&gt;
# Also see L&lt;&quot;http://use.perl.org/~autrijus/journal/25351&quot;&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.

{
    my $foo = &quot;foo\n&quot;;
    chomp($foo);
    is($foo, &quot;foo\n&quot;, 'our variable was not yet chomped');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = &quot;foo\n\n&quot;;
    $foo .= chomp;
    is($foo, &quot;foo\n&quot;, 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = &quot;foo\nbar\n&quot;;
    $foo .= chomp;
    is($foo, &quot;foo\nbar&quot;, 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, &quot;foo\nbar&quot;, 'our variable is chomped again with no effect');
}

{
    my $foo = &quot;foo\n &quot;;
    $foo .= chomp;
    is($foo, &quot;foo\n &quot;, 'our variable is chomped with no effect');
}

{
    my $foo = &quot;foo\n&quot;;
    my $chomped_foo = try { chomp($foo).newline };
    is($chomped_foo, &quot;\n&quot;, 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, &quot;foo\n&quot;, 'and our variable was not chomped');
}

{
    my $foo = &quot;foo\n&quot;;
    $foo .= chomp;
    my $chomped_foo = try { $foo.newline };
    is($chomped_foo, &quot;\n&quot;, 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, &quot;foo&quot;, 'and our variable was chomped');
}

{
    my $foo = &quot;foo\n\n&quot;;
    my $chomped = $foo.chomp;
    is($foo, &quot;foo\n\n&quot;, &quot;.chomp has no effect on the original string&quot;);
    is($chomped, &quot;foo\n&quot;, &quot;.chomp returns correctly chomped value&quot;);
    
    # $chomped.chomp.newline

    $chomped = $chomped.chomp;
    is($chomped, &quot;foo&quot;, &quot;.chomp returns correctly chomped value again&quot;);
}

# chomp in list context
{
    is_deeply(chomp(()), [], &quot;chomp on empty list&quot;);
    is_deeply(chomp((&quot;abc\n&quot;)), (&quot;abc&quot;), &quot;one element list&quot;);
    is_deeply(chomp((&quot;abc\n&quot;, &quot;bcd\n&quot;)), (&quot;abc&quot;, &quot;bcd&quot;), &quot;two element list&quot;);
    is_deeply((&quot;abc\n&quot;, &quot;bcd\n&quot;).chomp, (&quot;abc&quot;, &quot;bcd&quot;), &quot;two element list&quot;);
}
{
    my @foo = ();
    my @bar = chomp @foo;
    is_deeply(@bar, @foo, &quot;chomp empty array&quot;);
}
{
    my @foo = (&quot;abc\n&quot;);
    my @bar = chomp @foo;
    my @baz = (&quot;abc&quot;);
    is_deeply(@bar, @baz, &quot;chomp array with one element&quot;);
}
{
    my @foo = (&quot;abc\n&quot;, &quot;bcd\n&quot;);
    my @bar = chomp @foo;
    my @baz = (&quot;abc&quot;, &quot;bcd&quot;);
    is_deeply(@bar, @baz, &quot;chomp array with 2 elements&quot;);


    @bar = @foo.chomp;
    is_deeply(@bar, @baz, &quot;chomp array with 2 elements&quot;);

    my @morgo = (&quot;abc\n\n&quot;, &quot;bcd\n\n&quot;);
    my @hapci = chomp @morgo;
    is_deeply(@hapci, @foo, &quot;chomp array with 2 elements with duplicate newlines&quot;);

    my @szundi = @morgo.chomp;
    is_deeply(@szundi, @foo, &quot;chomp array with 2 elements with duplicate newlines&quot;);
}</pre>
</div>


<dt><a name="crypt"
>crypt</a></dt>

<dd>
<pre> our Str multi Str::crypt ( Str $plaintext, Str $salt )
 our Str multi method Str::crypt ( Str $plaintext: Str $salt )</pre>

<p>Encrypts the string using a one-way hash function. This yields a string which cannot be &#34;decrypted&#34;. This is used for verifying strings such as passwords. The <code>$plaintext</code> is the text to be encrypted. The <code>$salt</code> is a string which controls how the encryption is done. Typically, this is a random string of two characters that matches the following pattern:</p>

<a name="msg_17"></a>
<a href="?hide_quotes=no#msg_17" onclick="return tog_quote(17);">
<div ID="header_shown_17" style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID="header_hidden_17" style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -
</div>
</a>
<div ID="hide_17" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /uc/&gt;

is(uc(&quot;Hello World&quot;), &quot;HELLO WORLD&quot;, &quot;simple&quot;);
is(uc(&quot;&quot;), &quot;&quot;, &quot;empty string&quot;); 
is(uc(&quot;åäö&quot;), &quot;ÅÄÖ&quot;, &quot;some finnish non-ascii chars&quot;);
is(uc(&quot;óòúù&quot;), &quot;ÓÒÚÙ&quot;, &quot;accented chars&quot;);

# given does not return proper value yet
$_ = &quot;Hello World&quot;;
my $x = .uc;
is $x, &quot;HELLO WORLD&quot;, 'uc uses the default $_';

{   
    my $x = &quot;Hello World&quot;;
    is $x.uc, &quot;HELLO WORLD&quot;, '$x.uc works';
    is &quot;Hello World&quot;.uc, &quot;HELLO WORLD&quot;, '&quot;Hello World&quot;.uc works';
}

# Bug: GERMAN SHARP S (&quot;ß&quot;) should uc() to &quot;SS&quot;, but it doesn't
# Compare with: perl -we 'use utf8; print uc &quot;ß&quot;'
is(uc(&quot;ß&quot;), &quot;SS&quot;, &quot;uc() of non-ascii chars may result in two chars&quot;);

is(&quot;áéíöüóűőú&quot;.uc, &quot;ÁÉÍÖÜÓŰŐÚ&quot;, &quot;.uc on Hungarian vowels&quot;);</pre>
</div>


<pre> token Str::CryptBasicSalt { &#60;[./0-9A-Za-z]&#62; **{2} }</pre>

<p>There are other formats of salt as well, though their use is not universal. Check your operating system&#39;s <b>crypt</b> function for more details. Often these other functions are used when strings of length greater than eight are to be used (the default crypt mode only recognizes the first eight characters of the string as significant).</p>

<p>If you have a previously encrypted string and a plaintext password, you can check to see of the password is correct like so:</p>

<pre> sub checkpw ( $encrypted, $plaintext ) {
   return crypt($plaintext, $encrypted) ~~ $encrypted;
 }</pre>

<p>This works because the first part of the encrypted form of the password is the salt, so an encrypted text can be passed in place of the salt (everything after the salt is ignored).</p>

<dt><a name="lc"
>lc</a></dt>

<dd>
<a name="msg_43"></a>
<a href="?hide_quotes=no#msg_43" onclick="return tog_quote(43);">
<div ID="header_shown_43" style="display: none;">
- Hide the snippet from t/builtins/strings/lc.t (line 7 ~ line 24) -
</div>
<div ID="header_hidden_43" style="display: block;">
- Show the snippet from t/builtins/strings/lc.t (line 7 ~ line 24, 18 lines) -
</div>
</a>
<div ID="hide_43" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /lc/&gt;

is(lc(&quot;Hello World&quot;), &quot;hello world&quot;, &quot;simple lc test&quot;);
is(lc(&quot;&quot;), &quot;&quot;, &quot;empty string&quot;);
is(lc(&quot;ÅÄÖ&quot;), &quot;åäö&quot;, &quot;some finnish non-ascii chars&quot;);
is(lc(&quot;ÓÒÚÙ&quot;), &quot;óòúù&quot;, &quot;accented chars&quot;);

$_ = &quot;Hello World&quot;; 
my $x = .lc;
is($x, &quot;hello world&quot;, 'lc uses $_ as default');

{ # test invocant syntax for lc
    my $x = &quot;Hello World&quot;;
    is($x.lc, &quot;hello world&quot;, '$x.lc works');
    is(&quot;Hello World&quot;.lc, &quot;hello world&quot;, '&quot;Hello World&quot;.lc works');
}

is(&quot;ÁÉÍÖÜÓŰŐÚ&quot;.lc, &quot;áéíöüóűőú&quot;, &quot;.lc on Hungarian vowels&quot;);</pre>
</div>


<pre> our Str multi Str::lc ( Str $string )</pre>

<a name="msg_44"></a>
<a href="?hide_quotes=no#msg_44" onclick="return tog_quote(44);">
<div ID="header_shown_44" style="display: none;">
- Hide the snippet from t/builtins/strings/lc.t (line 7 ~ line 24) -
</div>
<div ID="header_hidden_44" style="display: block;">
- Show the snippet from t/builtins/strings/lc.t (line 7 ~ line 24, 18 lines) -
</div>
</a>
<div ID="hide_44" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /lc/&gt;

is(lc(&quot;Hello World&quot;), &quot;hello world&quot;, &quot;simple lc test&quot;);
is(lc(&quot;&quot;), &quot;&quot;, &quot;empty string&quot;);
is(lc(&quot;ÅÄÖ&quot;), &quot;åäö&quot;, &quot;some finnish non-ascii chars&quot;);
is(lc(&quot;ÓÒÚÙ&quot;), &quot;óòúù&quot;, &quot;accented chars&quot;);

$_ = &quot;Hello World&quot;; 
my $x = .lc;
is($x, &quot;hello world&quot;, 'lc uses $_ as default');

{ # test invocant syntax for lc
    my $x = &quot;Hello World&quot;;
    is($x.lc, &quot;hello world&quot;, '$x.lc works');
    is(&quot;Hello World&quot;.lc, &quot;hello world&quot;, '&quot;Hello World&quot;.lc works');
}

is(&quot;ÁÉÍÖÜÓŰŐÚ&quot;.lc, &quot;áéíöüóűőú&quot;, &quot;.lc on Hungarian vowels&quot;);</pre>
</div>


<p>Returns the input string after converting each character to its lowercase form, if uppercase.</p>

<dt><a name="lcfirst"
>lcfirst</a></dt>

<dd>
<a name="msg_45"></a>
<a href="?hide_quotes=no#msg_45" onclick="return tog_quote(45);">
<div ID="header_shown_45" style="display: none;">
- Hide the snippet from t/builtins/strings/lc.t (line 7 ~ line 24) -
</div>
<div ID="header_hidden_45" style="display: block;">
- Show the snippet from t/builtins/strings/lc.t (line 7 ~ line 24, 18 lines) -
</div>
</a>
<div ID="hide_45" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /lc/&gt;

is(lc(&quot;Hello World&quot;), &quot;hello world&quot;, &quot;simple lc test&quot;);
is(lc(&quot;&quot;), &quot;&quot;, &quot;empty string&quot;);
is(lc(&quot;ÅÄÖ&quot;), &quot;åäö&quot;, &quot;some finnish non-ascii chars&quot;);
is(lc(&quot;ÓÒÚÙ&quot;), &quot;óòúù&quot;, &quot;accented chars&quot;);

$_ = &quot;Hello World&quot;; 
my $x = .lc;
is($x, &quot;hello world&quot;, 'lc uses $_ as default');

{ # test invocant syntax for lc
    my $x = &quot;Hello World&quot;;
    is($x.lc, &quot;hello world&quot;, '$x.lc works');
    is(&quot;Hello World&quot;.lc, &quot;hello world&quot;, '&quot;Hello World&quot;.lc works');
}

is(&quot;ÁÉÍÖÜÓŰŐÚ&quot;.lc, &quot;áéíöüóűőú&quot;, &quot;.lc on Hungarian vowels&quot;);</pre>
</div>


<a name="msg_41"></a>
<a href="?hide_quotes=no#msg_41" onclick="return tog_quote(41);">
<div ID="header_shown_41" style="display: none;">
- Hide the snippet from t/builtins/strings/lcfirst.t (line 7 ~ line 24) -
</div>
<div ID="header_hidden_41" style="display: block;">
- Show the snippet from t/builtins/strings/lcfirst.t (line 7 ~ line 24, 18 lines) -
</div>
</a>
<div ID="hide_41" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /lcfirst/&gt;

is lcfirst(&quot;HELLO WORLD&quot;), &quot;hELLO WORLD&quot;, &quot;simple&quot;;
is lcfirst(&quot;&quot;),            &quot;&quot;,            &quot;empty string&quot;;
is lcfirst(&quot;ÜÜÜÜ&quot;),        &quot;üÜÜÜ&quot;,        &quot;umlaut&quot;;
is lcfirst(&quot;ÓÓÓÓŃ&quot;),       &quot;óÓÓÓŃ&quot;,       &quot;accented chars&quot;;

is &quot;HELLO WORLD&quot;.lcfirst,  &quot;hELLO WORLD&quot;, &quot;simple.lcfirst&quot;;

my $str = &quot;Some String&quot;;
is $str.lcfirst,    &quot;some String&quot;,          &quot;simple.lcfirst on scalar variable&quot;;
is &quot;Other String&quot;.lcfirst,  &quot;other String&quot;, &quot;.lcfirst on  literal string&quot;;

$_ = &quot;HELLO WORLD&quot;;
my $x = .lcfirst;
is $x, &quot;hELLO WORLD&quot;, 'lcfirst uses $_ as default'</pre>
</div>


<pre> our Str multi Str::lcfirst ( Str $string )</pre>

<a name="msg_46"></a>
<a href="?hide_quotes=no#msg_46" onclick="return tog_quote(46);">
<div ID="header_shown_46" style="display: none;">
- Hide the snippet from t/builtins/strings/lc.t (line 7 ~ line 24) -
</div>
<div ID="header_hidden_46" style="display: block;">
- Show the snippet from t/builtins/strings/lc.t (line 7 ~ line 24, 18 lines) -
</div>
</a>
<div ID="hide_46" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /lc/&gt;

is(lc(&quot;Hello World&quot;), &quot;hello world&quot;, &quot;simple lc test&quot;);
is(lc(&quot;&quot;), &quot;&quot;, &quot;empty string&quot;);
is(lc(&quot;ÅÄÖ&quot;), &quot;åäö&quot;, &quot;some finnish non-ascii chars&quot;);
is(lc(&quot;ÓÒÚÙ&quot;), &quot;óòúù&quot;, &quot;accented chars&quot;);

$_ = &quot;Hello World&quot;; 
my $x = .lc;
is($x, &quot;hello world&quot;, 'lc uses $_ as default');

{ # test invocant syntax for lc
    my $x = &quot;Hello World&quot;;
    is($x.lc, &quot;hello world&quot;, '$x.lc works');
    is(&quot;Hello World&quot;.lc, &quot;hello world&quot;, '&quot;Hello World&quot;.lc works');
}

is(&quot;ÁÉÍÖÜÓŰŐÚ&quot;.lc, &quot;áéíöüóűőú&quot;, &quot;.lc on Hungarian vowels&quot;);</pre>
</div>


<a name="msg_42"></a>
<a href="?hide_quotes=no#msg_42" onclick="return tog_quote(42);">
<div ID="header_shown_42" style="display: none;">
- Hide the snippet from t/builtins/strings/lcfirst.t (line 7 ~ line 24) -
</div>
<div ID="header_hidden_42" style="display: block;">
- Show the snippet from t/builtins/strings/lcfirst.t (line 7 ~ line 24, 18 lines) -
</div>
</a>
<div ID="hide_42" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /lcfirst/&gt;

is lcfirst(&quot;HELLO WORLD&quot;), &quot;hELLO WORLD&quot;, &quot;simple&quot;;
is lcfirst(&quot;&quot;),            &quot;&quot;,            &quot;empty string&quot;;
is lcfirst(&quot;ÜÜÜÜ&quot;),        &quot;üÜÜÜ&quot;,        &quot;umlaut&quot;;
is lcfirst(&quot;ÓÓÓÓŃ&quot;),       &quot;óÓÓÓŃ&quot;,       &quot;accented chars&quot;;

is &quot;HELLO WORLD&quot;.lcfirst,  &quot;hELLO WORLD&quot;, &quot;simple.lcfirst&quot;;

my $str = &quot;Some String&quot;;
is $str.lcfirst,    &quot;some String&quot;,          &quot;simple.lcfirst on scalar variable&quot;;
is &quot;Other String&quot;.lcfirst,  &quot;other String&quot;, &quot;.lcfirst on  literal string&quot;;

$_ = &quot;HELLO WORLD&quot;;
my $x = .lcfirst;
is $x, &quot;hELLO WORLD&quot;, 'lcfirst uses $_ as default'</pre>
</div>


<p>Like <code>lc</code>, but only affects the first character.</p>

<a name="msg_47"></a>
<a href="?hide_quotes=no#msg_47" onclick="return tog_quote(47);">
<div ID="header_shown_47" style="display: none;">
- Hide the snippet from t/builtins/strings/lc.t (line 7 ~ line 24) -
</div>
<div ID="header_hidden_47" style="display: block;">
- Show the snippet from t/builtins/strings/lc.t (line 7 ~ line 24, 18 lines) -
</div>
</a>
<div ID="hide_47" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /lc/&gt;

is(lc(&quot;Hello World&quot;), &quot;hello world&quot;, &quot;simple lc test&quot;);
is(lc(&quot;&quot;), &quot;&quot;, &quot;empty string&quot;);
is(lc(&quot;ÅÄÖ&quot;), &quot;åäö&quot;, &quot;some finnish non-ascii chars&quot;);
is(lc(&quot;ÓÒÚÙ&quot;), &quot;óòúù&quot;, &quot;accented chars&quot;);

$_ = &quot;Hello World&quot;; 
my $x = .lc;
is($x, &quot;hello world&quot;, 'lc uses $_ as default');

{ # test invocant syntax for lc
    my $x = &quot;Hello World&quot;;
    is($x.lc, &quot;hello world&quot;, '$x.lc works');
    is(&quot;Hello World&quot;.lc, &quot;hello world&quot;, '&quot;Hello World&quot;.lc works');
}

is(&quot;ÁÉÍÖÜÓŰŐÚ&quot;.lc, &quot;áéíöüóűőú&quot;, &quot;.lc on Hungarian vowels&quot;);</pre>
</div>


<dt><a name="uc"
>uc</a></dt>

<dd>
<a name="msg_18"></a>
<a href="?hide_quotes=no#msg_18" onclick="return tog_quote(18);">
<div ID="header_shown_18" style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID="header_hidden_18" style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -
</div>
</a>
<div ID="hide_18" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /uc/&gt;

is(uc(&quot;Hello World&quot;), &quot;HELLO WORLD&quot;, &quot;simple&quot;);
is(uc(&quot;&quot;), &quot;&quot;, &quot;empty string&quot;); 
is(uc(&quot;åäö&quot;), &quot;ÅÄÖ&quot;, &quot;some finnish non-ascii chars&quot;);
is(uc(&quot;óòúù&quot;), &quot;ÓÒÚÙ&quot;, &quot;accented chars&quot;);

# given does not return proper value yet
$_ = &quot;Hello World&quot;;
my $x = .uc;
is $x, &quot;HELLO WORLD&quot;, 'uc uses the default $_';

{   
    my $x = &quot;Hello World&quot;;
    is $x.uc, &quot;HELLO WORLD&quot;, '$x.uc works';
    is &quot;Hello World&quot;.uc, &quot;HELLO WORLD&quot;, '&quot;Hello World&quot;.uc works';
}

# Bug: GERMAN SHARP S (&quot;ß&quot;) should uc() to &quot;SS&quot;, but it doesn't
# Compare with: perl -we 'use utf8; print uc &quot;ß&quot;'
is(uc(&quot;ß&quot;), &quot;SS&quot;, &quot;uc() of non-ascii chars may result in two chars&quot;);

is(&quot;áéíöüóűőú&quot;.uc, &quot;ÁÉÍÖÜÓŰŐÚ&quot;, &quot;.uc on Hungarian vowels&quot;);</pre>
</div>


<pre> our Str multi Str::uc ( Str $string )</pre>

<a name="msg_19"></a>
<a href="?hide_quotes=no#msg_19" onclick="return tog_quote(19);">
<div ID="header_shown_19" style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID="header_hidden_19" style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -
</div>
</a>
<div ID="hide_19" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /uc/&gt;

is(uc(&quot;Hello World&quot;), &quot;HELLO WORLD&quot;, &quot;simple&quot;);
is(uc(&quot;&quot;), &quot;&quot;, &quot;empty string&quot;); 
is(uc(&quot;åäö&quot;), &quot;ÅÄÖ&quot;, &quot;some finnish non-ascii chars&quot;);
is(uc(&quot;óòúù&quot;), &quot;ÓÒÚÙ&quot;, &quot;accented chars&quot;);

# given does not return proper value yet
$_ = &quot;Hello World&quot;;
my $x = .uc;
is $x, &quot;HELLO WORLD&quot;, 'uc uses the default $_';

{   
    my $x = &quot;Hello World&quot;;
    is $x.uc, &quot;HELLO WORLD&quot;, '$x.uc works';
    is &quot;Hello World&quot;.uc, &quot;HELLO WORLD&quot;, '&quot;Hello World&quot;.uc works';
}

# Bug: GERMAN SHARP S (&quot;ß&quot;) should uc() to &quot;SS&quot;, but it doesn't
# Compare with: perl -we 'use utf8; print uc &quot;ß&quot;'
is(uc(&quot;ß&quot;), &quot;SS&quot;, &quot;uc() of non-ascii chars may result in two chars&quot;);

is(&quot;áéíöüóűőú&quot;.uc, &quot;ÁÉÍÖÜÓŰŐÚ&quot;, &quot;.uc on Hungarian vowels&quot;);</pre>
</div>


<p>Returns the input string after converting each character to its uppercase form, if lowercase. This is not a Unicode &#34;titlecase&#34; operation, but a full &#34;uppercase&#34;.</p>

<dt><a name="ucfirst"
>ucfirst</a></dt>

<dd>
<a name="msg_20"></a>
<a href="?hide_quotes=no#msg_20" onclick="return tog_quote(20);">
<div ID="header_shown_20" style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID="header_hidden_20" style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -
</div>
</a>
<div ID="hide_20" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /uc/&gt;

is(uc(&quot;Hello World&quot;), &quot;HELLO WORLD&quot;, &quot;simple&quot;);
is(uc(&quot;&quot;), &quot;&quot;, &quot;empty string&quot;); 
is(uc(&quot;åäö&quot;), &quot;ÅÄÖ&quot;, &quot;some finnish non-ascii chars&quot;);
is(uc(&quot;óòúù&quot;), &quot;ÓÒÚÙ&quot;, &quot;accented chars&quot;);

# given does not return proper value yet
$_ = &quot;Hello World&quot;;
my $x = .uc;
is $x, &quot;HELLO WORLD&quot;, 'uc uses the default $_';

{   
    my $x = &quot;Hello World&quot;;
    is $x.uc, &quot;HELLO WORLD&quot;, '$x.uc works';
    is &quot;Hello World&quot;.uc, &quot;HELLO WORLD&quot;, '&quot;Hello World&quot;.uc works';
}

# Bug: GERMAN SHARP S (&quot;ß&quot;) should uc() to &quot;SS&quot;, but it doesn't
# Compare with: perl -we 'use utf8; print uc &quot;ß&quot;'
is(uc(&quot;ß&quot;), &quot;SS&quot;, &quot;uc() of non-ascii chars may result in two chars&quot;);

is(&quot;áéíöüóűőú&quot;.uc, &quot;ÁÉÍÖÜÓŰŐÚ&quot;, &quot;.uc on Hungarian vowels&quot;);</pre>
</div>


<a name="msg_14"></a>
<a href="?hide_quotes=no#msg_14" onclick="return tog_quote(14);">
<div ID="header_shown_14" style="display: none;">
- Hide the snippet from t/builtins/strings/ucfirst.t (line 7 ~ line 12) -
</div>
<div ID="header_hidden_14" style="display: block;">
- Show the snippet from t/builtins/strings/ucfirst.t (line 7 ~ line 12, 6 lines) -
</div>
</a>
<div ID="hide_14" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /ucfirst/&gt;

is ucfirst(&quot;hello world&quot;), &quot;Hello world&quot;, &quot;simple&quot;;
is ucfirst(&quot;&quot;),            &quot;&quot;,            &quot;empty string&quot;;
is ucfirst(&quot;üüüü&quot;),        &quot;Üüüü&quot;,        &quot;umlaut&quot;;
is ucfirst(&quot;óóóó&quot;),        &quot;Óóóó&quot;,        &quot;accented chars&quot;;</pre>
</div>


<pre> our Str multi Str::ucfirst ( Str $string )</pre>

<a name="msg_21"></a>
<a href="?hide_quotes=no#msg_21" onclick="return tog_quote(21);">
<div ID="header_shown_21" style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID="header_hidden_21" style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -
</div>
</a>
<div ID="hide_21" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /uc/&gt;

is(uc(&quot;Hello World&quot;), &quot;HELLO WORLD&quot;, &quot;simple&quot;);
is(uc(&quot;&quot;), &quot;&quot;, &quot;empty string&quot;); 
is(uc(&quot;åäö&quot;), &quot;ÅÄÖ&quot;, &quot;some finnish non-ascii chars&quot;);
is(uc(&quot;óòúù&quot;), &quot;ÓÒÚÙ&quot;, &quot;accented chars&quot;);

# given does not return proper value yet
$_ = &quot;Hello World&quot;;
my $x = .uc;
is $x, &quot;HELLO WORLD&quot;, 'uc uses the default $_';

{   
    my $x = &quot;Hello World&quot;;
    is $x.uc, &quot;HELLO WORLD&quot;, '$x.uc works';
    is &quot;Hello World&quot;.uc, &quot;HELLO WORLD&quot;, '&quot;Hello World&quot;.uc works';
}

# Bug: GERMAN SHARP S (&quot;ß&quot;) should uc() to &quot;SS&quot;, but it doesn't
# Compare with: perl -we 'use utf8; print uc &quot;ß&quot;'
is(uc(&quot;ß&quot;), &quot;SS&quot;, &quot;uc() of non-ascii chars may result in two chars&quot;);

is(&quot;áéíöüóűőú&quot;.uc, &quot;ÁÉÍÖÜÓŰŐÚ&quot;, &quot;.uc on Hungarian vowels&quot;);</pre>
</div>


<a name="msg_15"></a>
<a href="?hide_quotes=no#msg_15" onclick="return tog_quote(15);">
<div ID="header_shown_15" style="display: none;">
- Hide the snippet from t/builtins/strings/ucfirst.t (line 7 ~ line 12) -
</div>
<div ID="header_hidden_15" style="display: block;">
- Show the snippet from t/builtins/strings/ucfirst.t (line 7 ~ line 12, 6 lines) -
</div>
</a>
<div ID="hide_15" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /ucfirst/&gt;

is ucfirst(&quot;hello world&quot;), &quot;Hello world&quot;, &quot;simple&quot;;
is ucfirst(&quot;&quot;),            &quot;&quot;,            &quot;empty string&quot;;
is ucfirst(&quot;üüüü&quot;),        &quot;Üüüü&quot;,        &quot;umlaut&quot;;
is ucfirst(&quot;óóóó&quot;),        &quot;Óóóó&quot;,        &quot;accented chars&quot;;</pre>
</div>


<p>Performs a Unicode &#34;titlecase&#34; operation on the first character of the string.</p>

<dt><a name="capitalize"
>capitalize</a></dt>

<dd>
<a name="msg_55"></a>
<a href="?hide_quotes=no#msg_55" onclick="return tog_quote(55);">
<div ID="header_shown_55" style="display: none;">
- Hide the snippet from t/builtins/strings/capitalize.t (line 7 ~ line 27) -
</div>
<div ID="header_hidden_55" style="display: block;">
- Show the snippet from t/builtins/strings/capitalize.t (line 7 ~ line 27, 21 lines) -
</div>
</a>
<div ID="hide_55" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /capitalize/&gt;

is capitalize(&quot;&quot;),             &quot;&quot;,               &quot;capitalize('') works&quot;;
is capitalize(&quot;puGS Is cOOl!&quot;), &quot;Pugs Is Cool!&quot;, &quot;capitalize('...') works&quot;;
is &quot;puGS Is cOOl!&quot;.capitalize,  &quot;Pugs Is Cool!&quot;, &quot;'...'.capitalize works&quot;;

my $a = &quot;&quot;;
is capitalize($a),             &quot;&quot;,               &quot;capitalize empty string&quot;;
$a = &quot;puGS Is cOOl!&quot;;
is capitalize($a),             &quot;Pugs Is Cool!&quot;,  &quot;capitalize string works&quot;;
is $a,                         &quot;puGS Is cOOl!&quot;,  &quot;original srting not touched&quot;;
is $a.capitalize,              &quot;Pugs Is Cool!&quot;,  &quot;capitalize string works&quot;;
is $a,                         &quot;puGS Is cOOl!&quot;,  &quot;original srting not touched&quot;;
is &quot;ab cD Ef&quot;.capitalize,      &quot;Ab Cd Ef&quot;,       &quot;works on ordenary string&quot;;


$_ = &quot;puGS Is cOOl!&quot;;
is .capitalize, &quot;Pugs Is Cool!&quot;, 'capitalize() uses \$_ as default';

# Non-ASCII chars:
is capitalize(&quot;äöü abcä&quot;), &quot;Äöü Abcä&quot;, &quot;capitalize() works on non-ASCII chars&quot;;</pre>
</div>


<pre> our Str multi Str::capitalize ( Str $string )</pre>

<a name="msg_56"></a>
<a href="?hide_quotes=no#msg_56" onclick="return tog_quote(56);">
<div ID="header_shown_56" style="display: none;">
- Hide the snippet from t/builtins/strings/capitalize.t (line 7 ~ line 27) -
</div>
<div ID="header_hidden_56" style="display: block;">
- Show the snippet from t/builtins/strings/capitalize.t (line 7 ~ line 27, 21 lines) -
</div>
</a>
<div ID="hide_56" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /capitalize/&gt;

is capitalize(&quot;&quot;),             &quot;&quot;,               &quot;capitalize('') works&quot;;
is capitalize(&quot;puGS Is cOOl!&quot;), &quot;Pugs Is Cool!&quot;, &quot;capitalize('...') works&quot;;
is &quot;puGS Is cOOl!&quot;.capitalize,  &quot;Pugs Is Cool!&quot;, &quot;'...'.capitalize works&quot;;

my $a = &quot;&quot;;
is capitalize($a),             &quot;&quot;,               &quot;capitalize empty string&quot;;
$a = &quot;puGS Is cOOl!&quot;;
is capitalize($a),             &quot;Pugs Is Cool!&quot;,  &quot;capitalize string works&quot;;
is $a,                         &quot;puGS Is cOOl!&quot;,  &quot;original srting not touched&quot;;
is $a.capitalize,              &quot;Pugs Is Cool!&quot;,  &quot;capitalize string works&quot;;
is $a,                         &quot;puGS Is cOOl!&quot;,  &quot;original srting not touched&quot;;
is &quot;ab cD Ef&quot;.capitalize,      &quot;Ab Cd Ef&quot;,       &quot;works on ordenary string&quot;;


$_ = &quot;puGS Is cOOl!&quot;;
is .capitalize, &quot;Pugs Is Cool!&quot;, 'capitalize() uses \$_ as default';

# Non-ASCII chars:
is capitalize(&quot;äöü abcä&quot;), &quot;Äöü Abcä&quot;, &quot;capitalize() works on non-ASCII chars&quot;;</pre>
</div>


<p>Has the effect of first doing an <code>lc</code> on the entire string, then performing a <code>s:g/(\w+)/{ucfirst $1}/</code> on it.</p>

<a name="msg_48"></a>
<a href="?hide_quotes=no#msg_48" onclick="return tog_quote(48);">
<div ID="header_shown_48" style="display: none;">
- Hide the snippet from t/builtins/strings/lc.t (line 7 ~ line 24) -
</div>
<div ID="header_hidden_48" style="display: block;">
- Show the snippet from t/builtins/strings/lc.t (line 7 ~ line 24, 18 lines) -
</div>
</a>
<div ID="hide_48" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /lc/&gt;

is(lc(&quot;Hello World&quot;), &quot;hello world&quot;, &quot;simple lc test&quot;);
is(lc(&quot;&quot;), &quot;&quot;, &quot;empty string&quot;);
is(lc(&quot;ÅÄÖ&quot;), &quot;åäö&quot;, &quot;some finnish non-ascii chars&quot;);
is(lc(&quot;ÓÒÚÙ&quot;), &quot;óòúù&quot;, &quot;accented chars&quot;);

$_ = &quot;Hello World&quot;; 
my $x = .lc;
is($x, &quot;hello world&quot;, 'lc uses $_ as default');

{ # test invocant syntax for lc
    my $x = &quot;Hello World&quot;;
    is($x.lc, &quot;hello world&quot;, '$x.lc works');
    is(&quot;Hello World&quot;.lc, &quot;hello world&quot;, '&quot;Hello World&quot;.lc works');
}

is(&quot;ÁÉÍÖÜÓŰŐÚ&quot;.lc, &quot;áéíöüóűőú&quot;, &quot;.lc on Hungarian vowels&quot;);</pre>
</div>


<a name="msg_22"></a>
<a href="?hide_quotes=no#msg_22" onclick="return tog_quote(22);">
<div ID="header_shown_22" style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID="header_hidden_22" style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -
</div>
</a>
<div ID="hide_22" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /uc/&gt;

is(uc(&quot;Hello World&quot;), &quot;HELLO WORLD&quot;, &quot;simple&quot;);
is(uc(&quot;&quot;), &quot;&quot;, &quot;empty string&quot;); 
is(uc(&quot;åäö&quot;), &quot;ÅÄÖ&quot;, &quot;some finnish non-ascii chars&quot;);
is(uc(&quot;óòúù&quot;), &quot;ÓÒÚÙ&quot;, &quot;accented chars&quot;);

# given does not return proper value yet
$_ = &quot;Hello World&quot;;
my $x = .uc;
is $x, &quot;HELLO WORLD&quot;, 'uc uses the default $_';

{   
    my $x = &quot;Hello World&quot;;
    is $x.uc, &quot;HELLO WORLD&quot;, '$x.uc works';
    is &quot;Hello World&quot;.uc, &quot;HELLO WORLD&quot;, '&quot;Hello World&quot;.uc works';
}

# Bug: GERMAN SHARP S (&quot;ß&quot;) should uc() to &quot;SS&quot;, but it doesn't
# Compare with: perl -we 'use utf8; print uc &quot;ß&quot;'
is(uc(&quot;ß&quot;), &quot;SS&quot;, &quot;uc() of non-ascii chars may result in two chars&quot;);

is(&quot;áéíöüóűőú&quot;.uc, &quot;ÁÉÍÖÜÓŰŐÚ&quot;, &quot;.uc on Hungarian vowels&quot;);</pre>
</div>


<a name="msg_16"></a>
<a href="?hide_quotes=no#msg_16" onclick="return tog_quote(16);">
<div ID="header_shown_16" style="display: none;">
- Hide the snippet from t/builtins/strings/ucfirst.t (line 7 ~ line 12) -
</div>
<div ID="header_hidden_16" style="display: block;">
- Show the snippet from t/builtins/strings/ucfirst.t (line 7 ~ line 12, 6 lines) -
</div>
</a>
<div ID="hide_16" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /ucfirst/&gt;

is ucfirst(&quot;hello world&quot;), &quot;Hello world&quot;, &quot;simple&quot;;
is ucfirst(&quot;&quot;),            &quot;&quot;,            &quot;empty string&quot;;
is ucfirst(&quot;üüüü&quot;),        &quot;Üüüü&quot;,        &quot;umlaut&quot;;
is ucfirst(&quot;óóóó&quot;),        &quot;Óóóó&quot;,        &quot;accented chars&quot;;</pre>
</div>


<dt><a name="length"
>length</a></dt>

<dd>
<p>This word is banned in Perl 6. You must specify units.</p>

<dt><a name="index"
>index</a></dt>

<dd>
<pre> our StrPos multi Str::index( Str $string, Str $substring, StrPos $pos = 0 )</pre>

<a name="msg_27"></a>
<a href="?hide_quotes=no#msg_27" onclick="return tog_quote(27);">
<div ID="header_shown_27" style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID="header_hidden_27" style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -
</div>
</a>
<div ID="hide_27" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /substr/&gt;

{ # read only
    my $str = &quot;foobar&quot;;

    is(substr($str, 0, 1), &quot;f&quot;, &quot;first char&quot;);
    is(substr($str, -1), &quot;r&quot;, &quot;last char&quot;);
    is(substr($str, -4, 2), &quot;ob&quot;, &quot;counted from the end&quot;);
    is(substr($str, 1, 2), &quot;oo&quot;, &quot;arbitrary middle&quot;);
    is(substr($str, 3), &quot;bar&quot;, &quot;length omitted&quot;);
    is(substr($str, 3, 10), &quot;bar&quot;, &quot;length goes past end&quot;);
    is(substr($str, 20, 5), undef, &quot;substr outside of string&quot;);
    is(substr($str, -100, 10), undef, &quot;... on the negative side&quot;);

    is(substr($str, 0, -2), &quot;foob&quot;, &quot;from beginning, with negative length&quot;);
    is(substr($str, 2, -2), &quot;ob&quot;, &quot;in middle, with negative length&quot;);
    is(substr($str, 3, -3), &quot;&quot;, &quot;negative length - gives empty string&quot;);

    is($str, &quot;foobar&quot;, &quot;original string still not changed&quot;);
};

skip 4, &quot;more discussion needed&quot;;

=begin more-discussion-needed

{ # replacement
    my $str = &quot;foobar&quot;;

    substr($str, 2, 1, &quot;i&quot;);
    is($str, &quot;foibar&quot;, &quot;fourth arg to substr replaced part&quot;);

    substr($str, -1, 1, &quot;blah&quot;);
    is($str, &quot;foibablah&quot;, &quot;longer replacement expands string&quot;);

    substr($str, 1, 3, &quot;&quot;);
    is($str, &quot;fablah&quot;, &quot;shorter replacement shrunk it&quot;);

    substr($str, 1, -1, &quot;aye&quot;);
    is($str, &quot;fayeh&quot;, &quot;replacement with negative length&quot;);
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, &quot;gloop&quot;, '$r referent is eq to the substring');

    $$r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to reference modifies original&quot;, :todo);
    is($$r, &quot;boing&quot;, '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, &quot;ng&quot;, &quot;other ref to other lvalue&quot;, :todo);
    $$r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;, :todo);
    is($$o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo);
};

{ # as lvalue, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);
};

{ # as lvalue, using :=, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r := substr($str, 0, 5);
    is($r, &quot;gloop&quot;, 'bound $r is eq to the substring');

    $r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to bound var modifies original&quot;);
    is($r, &quot;boing&quot;, 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, &quot;ng&quot;, &quot;other bound var to other lvalue&quot;);
    $r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;);
    is($o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/&quot;Junctions&quot; /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr(&quot;camel&quot;, 0|1, 2&amp;3)', ((&quot;ca&quot;|&quot;am&quot;) &amp; (&quot;cam&quot;|&quot;ame&quot;)), &quot;junctive substr&quot;, :todo);
}


{ # misc
    my $str = &quot;hello foo and bar&quot;;
    is(substr($str, 6, 3), &quot;foo&quot;, &quot;substr&quot;);
    is($str.substr(6, 3), &quot;foo&quot;, &quot;.substr&quot;);
    is(substr(&quot;hello foo bar&quot;, 6, 3), &quot;foo&quot;, &quot;substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3), &quot;foo&quot;, &quot;.substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3).uc, &quot;FOO&quot;, &quot;.substr.uc on literal string&quot;);
    is(&quot;hello foo bar and baz&quot;.substr(6, 10).capitalize, &quot;Foo Bar An&quot;, &quot;.substr.capitalize on literal string&quot;);
    is(&quot;hello »« foo&quot;.substr(6, 2), &quot;»«&quot;, &quot;.substr on unicode string&quot;);
    is(&quot;שיעבוד כבר&quot;.substr(4, 4), &quot;וד כ&quot;, &quot;.substr on Hebrew text&quot;);
}</pre>
</div>


<p><code>index</code> searches for the first occurrence of <code>$substring</code> in <code>$string</code>, starting at <code>$pos</code>.</p>

<a name="msg_28"></a>
<a href="?hide_quotes=no#msg_28" onclick="return tog_quote(28);">
<div ID="header_shown_28" style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID="header_hidden_28" style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -
</div>
</a>
<div ID="hide_28" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /substr/&gt;

{ # read only
    my $str = &quot;foobar&quot;;

    is(substr($str, 0, 1), &quot;f&quot;, &quot;first char&quot;);
    is(substr($str, -1), &quot;r&quot;, &quot;last char&quot;);
    is(substr($str, -4, 2), &quot;ob&quot;, &quot;counted from the end&quot;);
    is(substr($str, 1, 2), &quot;oo&quot;, &quot;arbitrary middle&quot;);
    is(substr($str, 3), &quot;bar&quot;, &quot;length omitted&quot;);
    is(substr($str, 3, 10), &quot;bar&quot;, &quot;length goes past end&quot;);
    is(substr($str, 20, 5), undef, &quot;substr outside of string&quot;);
    is(substr($str, -100, 10), undef, &quot;... on the negative side&quot;);

    is(substr($str, 0, -2), &quot;foob&quot;, &quot;from beginning, with negative length&quot;);
    is(substr($str, 2, -2), &quot;ob&quot;, &quot;in middle, with negative length&quot;);
    is(substr($str, 3, -3), &quot;&quot;, &quot;negative length - gives empty string&quot;);

    is($str, &quot;foobar&quot;, &quot;original string still not changed&quot;);
};

skip 4, &quot;more discussion needed&quot;;

=begin more-discussion-needed

{ # replacement
    my $str = &quot;foobar&quot;;

    substr($str, 2, 1, &quot;i&quot;);
    is($str, &quot;foibar&quot;, &quot;fourth arg to substr replaced part&quot;);

    substr($str, -1, 1, &quot;blah&quot;);
    is($str, &quot;foibablah&quot;, &quot;longer replacement expands string&quot;);

    substr($str, 1, 3, &quot;&quot;);
    is($str, &quot;fablah&quot;, &quot;shorter replacement shrunk it&quot;);

    substr($str, 1, -1, &quot;aye&quot;);
    is($str, &quot;fayeh&quot;, &quot;replacement with negative length&quot;);
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, &quot;gloop&quot;, '$r referent is eq to the substring');

    $$r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to reference modifies original&quot;, :todo);
    is($$r, &quot;boing&quot;, '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, &quot;ng&quot;, &quot;other ref to other lvalue&quot;, :todo);
    $$r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;, :todo);
    is($$o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo);
};

{ # as lvalue, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);
};

{ # as lvalue, using :=, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r := substr($str, 0, 5);
    is($r, &quot;gloop&quot;, 'bound $r is eq to the substring');

    $r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to bound var modifies original&quot;);
    is($r, &quot;boing&quot;, 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, &quot;ng&quot;, &quot;other bound var to other lvalue&quot;);
    $r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;);
    is($o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/&quot;Junctions&quot; /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr(&quot;camel&quot;, 0|1, 2&amp;3)', ((&quot;ca&quot;|&quot;am&quot;) &amp; (&quot;cam&quot;|&quot;ame&quot;)), &quot;junctive substr&quot;, :todo);
}


{ # misc
    my $str = &quot;hello foo and bar&quot;;
    is(substr($str, 6, 3), &quot;foo&quot;, &quot;substr&quot;);
    is($str.substr(6, 3), &quot;foo&quot;, &quot;.substr&quot;);
    is(substr(&quot;hello foo bar&quot;, 6, 3), &quot;foo&quot;, &quot;substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3), &quot;foo&quot;, &quot;.substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3).uc, &quot;FOO&quot;, &quot;.substr.uc on literal string&quot;);
    is(&quot;hello foo bar and baz&quot;.substr(6, 10).capitalize, &quot;Foo Bar An&quot;, &quot;.substr.capitalize on literal string&quot;);
    is(&quot;hello »« foo&quot;.substr(6, 2), &quot;»«&quot;, &quot;.substr on unicode string&quot;);
    is(&quot;שיעבוד כבר&quot;.substr(4, 4), &quot;וד כ&quot;, &quot;.substr on Hebrew text&quot;);
}</pre>
</div>


<p>If the substring is found, then the position of the first character of the substring is returned. If the substring is not found, then undef is returned.</p>

<a name="msg_29"></a>
<a href="?hide_quotes=no#msg_29" onclick="return tog_quote(29);">
<div ID="header_shown_29" style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID="header_hidden_29" style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -
</div>
</a>
<div ID="hide_29" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /substr/&gt;

{ # read only
    my $str = &quot;foobar&quot;;

    is(substr($str, 0, 1), &quot;f&quot;, &quot;first char&quot;);
    is(substr($str, -1), &quot;r&quot;, &quot;last char&quot;);
    is(substr($str, -4, 2), &quot;ob&quot;, &quot;counted from the end&quot;);
    is(substr($str, 1, 2), &quot;oo&quot;, &quot;arbitrary middle&quot;);
    is(substr($str, 3), &quot;bar&quot;, &quot;length omitted&quot;);
    is(substr($str, 3, 10), &quot;bar&quot;, &quot;length goes past end&quot;);
    is(substr($str, 20, 5), undef, &quot;substr outside of string&quot;);
    is(substr($str, -100, 10), undef, &quot;... on the negative side&quot;);

    is(substr($str, 0, -2), &quot;foob&quot;, &quot;from beginning, with negative length&quot;);
    is(substr($str, 2, -2), &quot;ob&quot;, &quot;in middle, with negative length&quot;);
    is(substr($str, 3, -3), &quot;&quot;, &quot;negative length - gives empty string&quot;);

    is($str, &quot;foobar&quot;, &quot;original string still not changed&quot;);
};

skip 4, &quot;more discussion needed&quot;;

=begin more-discussion-needed

{ # replacement
    my $str = &quot;foobar&quot;;

    substr($str, 2, 1, &quot;i&quot;);
    is($str, &quot;foibar&quot;, &quot;fourth arg to substr replaced part&quot;);

    substr($str, -1, 1, &quot;blah&quot;);
    is($str, &quot;foibablah&quot;, &quot;longer replacement expands string&quot;);

    substr($str, 1, 3, &quot;&quot;);
    is($str, &quot;fablah&quot;, &quot;shorter replacement shrunk it&quot;);

    substr($str, 1, -1, &quot;aye&quot;);
    is($str, &quot;fayeh&quot;, &quot;replacement with negative length&quot;);
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, &quot;gloop&quot;, '$r referent is eq to the substring');

    $$r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to reference modifies original&quot;, :todo);
    is($$r, &quot;boing&quot;, '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, &quot;ng&quot;, &quot;other ref to other lvalue&quot;, :todo);
    $$r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;, :todo);
    is($$o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo);
};

{ # as lvalue, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);
};

{ # as lvalue, using :=, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r := substr($str, 0, 5);
    is($r, &quot;gloop&quot;, 'bound $r is eq to the substring');

    $r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to bound var modifies original&quot;);
    is($r, &quot;boing&quot;, 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, &quot;ng&quot;, &quot;other bound var to other lvalue&quot;);
    $r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;);
    is($o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/&quot;Junctions&quot; /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr(&quot;camel&quot;, 0|1, 2&amp;3)', ((&quot;ca&quot;|&quot;am&quot;) &amp; (&quot;cam&quot;|&quot;ame&quot;)), &quot;junctive substr&quot;, :todo);
}


{ # misc
    my $str = &quot;hello foo and bar&quot;;
    is(substr($str, 6, 3), &quot;foo&quot;, &quot;substr&quot;);
    is($str.substr(6, 3), &quot;foo&quot;, &quot;.substr&quot;);
    is(substr(&quot;hello foo bar&quot;, 6, 3), &quot;foo&quot;, &quot;substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3), &quot;foo&quot;, &quot;.substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3).uc, &quot;FOO&quot;, &quot;.substr.uc on literal string&quot;);
    is(&quot;hello foo bar and baz&quot;.substr(6, 10).capitalize, &quot;Foo Bar An&quot;, &quot;.substr.capitalize on literal string&quot;);
    is(&quot;hello »« foo&quot;.substr(6, 2), &quot;»«&quot;, &quot;.substr on unicode string&quot;);
    is(&quot;שיעבוד כבר&quot;.substr(4, 4), &quot;וד כ&quot;, &quot;.substr on Hebrew text&quot;);
}</pre>
</div>


<dt><a name="pack"
>pack</a></dt>

<dd>
<pre> our Str multi Str::pack( Str::Encoding $encoding,  Pair *@items )
 our Str multi Str::pack( Str::Encoding $encoding,  Str $template, *@items )
 our buf8 multi Str::pack( Pair *@items )
 our buf8 multi Str::pack( Str $template, *@items )</pre>

<p><code>pack</code> takes a list of pairs and formats the values according to the specification of the keys. Alternately, it takes a string <code>$template</code> and formats the rest of its arguments according to the specifications in the template string. The result is a sequence of bytes.</p>

<p>An optional <code>$encoding</code> can be used to specify the character encoding to use in interpreting the result as a <code>Str</code>, otherwise the return value will simply be a <code>buf</code> containing the bytes generated by the template(s) and value(s). Note that no guarantee is made in terms of the final, internal representation of the string, only that the generated sequence of bytes will be interpreted as a string in the given encoding, and a string containing those graphemes will be returned. If the sequence of bytes represents an invalid string according to <code>$encoding</code>, an exception is generated.</p>

<p>Templates are strings of the form:</p>

<pre>  grammar Str::PackTemplate {
   regex template  { [ &#60;group&#62; | &#60;specifier&#62; &#60;count&#62;? ]* }
   token group     { \( &#60;template&#62; \) }
   token specifier { &#60;[aAZbBhHcCsSiIlLnNvVqQjJfdFDpPuUwxX\@]&#62; \!? }
   token count     { \* |
             \[ [ \d+ | &#60;specifier&#62; ] \] |
             \d+ }
 }</pre>

<p>In the pairwise mode, each key must contain a single <code>&#60;group&#62;</code> or <code>&#60;specifier&#62;</code>, and the values must be either scalar arguments or arrays.</p>

<p>[ Note: Need more documentation and need to figure out what Perl 5 things no longer make sense. Does Perl 6 need any extra formatting</p>

<pre>        features? -ajs ]</pre>

<dt><a name="pos"
>pos
<dt><a name="quotemeta"
>quotemeta</a></dt>

<dd>
<a name="msg_39"></a>
<a href="?hide_quotes=no#msg_39" onclick="return tog_quote(39);">
<div ID="header_shown_39" style="display: none;">
- Hide the snippet from t/builtins/strings/quotemeta.t (line 27 ~ line 130) -
</div>
<div ID="header_hidden_39" style="display: block;">
- Show the snippet from t/builtins/strings/quotemeta.t (line 27 ~ line 130, 104 lines) -
</div>
</a>
<div ID="hide_39" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /quotemeta/&gt;

is(quotemeta(&quot;HeLLo World-72_1&quot;), &quot;HeLLo\\ World\\-72_1&quot;, &quot;simple lc test&quot;);
is(quotemeta(&quot;&quot;), &quot;&quot;, &quot;empty string&quot;);

$_ = &quot;HeLLo World-72_1&quot;; 
my $x = .quotemeta;
is($x, &quot;HeLLo\\ World\\-72_1&quot;, 'quotemeta uses $_ as default');

{ # test invocant syntax for quotemeta
    my $x = &quot;HeLLo World-72_1&quot;;
    is($x.quotemeta, &quot;HeLLo\\ World\\-72_1&quot;, '$x.quotemeta works');
    is(&quot;HeLLo World-72_1&quot;.quotemeta, &quot;HeLLo\\ World\\-72_1&quot;, '&quot;HeLLo World-72_1&quot;.quotemeta works');
}


if (%*Config&lt;ebcdic&gt; eq 'define') {
    $_ = (129 .. 233).map({ chr($_); }).join('');
    is($_.chars, 96, &quot;quotemeta starting string&quot;);
    
    # 105 characters - 52 letters = 53 backslashes
    # 105 characters + 53 backslashes = 158 characters
    $_ = quotemeta $_;
    is($_.chars, 158, &quot;quotemeta string&quot;);
    # 53 backslashed characters + 1 &quot;original&quot; backslash
    is($_.split('').grep({ $_ eq &quot;\x5c&quot; }).elems, 54, &quot;count backslashes&quot;);
}
else {
    $_ = (0 .. 255).map({ chr($_); }).join('');
    is($_.chars, 256, &quot;quotemeta starting string&quot;);
    
    # Original test in Perl 5.9.3:
    # 96 characters - 52 letters - 10 digits - 1 underscore = 33 backslashes
    # 96 characters + 33 backslashes = 129 characters
    # 
    # Then added remaining 32 + 128, all escaped:
    # 129 + (32 + 128) * 2 = 449
    #
    # Total backslashed chars are 33 + 32 + 128 = 193
    # Total backslashes are 1 + 193 = 194
    $_ = quotemeta $_;
    is($_.chars, 449, &quot;quotemeta string&quot;);
    # 33 backslashed characters + 1 &quot;original&quot; backslash
    is($_.split('').grep({ $_ eq &quot;\x5c&quot; }).elems, 194, &quot;count backslashes&quot;);
}

# Current quotemeta implementation mimics that for Perl 5, avoiding
# to escape Unicode characters beyond 256th
is(quotemeta(&quot;\x[263a]&quot;), &quot;\x[263a]&quot;, &quot;quotemeta Unicode&quot;);
is(quotemeta(&quot;\x[263a]&quot;).chars, 1, &quot;quotemeta Unicode length&quot;);

=begin from_perl5


plan tests =&gt; 22;

if ($Config{ebcdic} eq 'define') {
    $_ = join &quot;&quot;, map chr($_), 129..233;

    # 105 characters - 52 letters = 53 backslashes
    # 105 characters + 53 backslashes = 158 characters
    $_ = quotemeta $_;
    is(length($_), 158, &quot;quotemeta string&quot;);
    # 104 non-backslash characters
    is(tr/\\//cd, 104, &quot;tr count non-backslashed&quot;);
} else { # some ASCII descendant, then.
    $_ = join &quot;&quot;, map chr($_), 32..127;

    # 96 characters - 52 letters - 10 digits - 1 underscore = 33 backslashes
    # 96 characters + 33 backslashes = 129 characters
    $_ = quotemeta $_;
    is(length($_), 129, &quot;quotemeta string&quot;);
    # 95 non-backslash characters
    is(tr/\\//cd, 95, &quot;tr count non-backslashed&quot;);
}

is(length(quotemeta &quot;&quot;), 0, &quot;quotemeta empty string&quot;);

is(&quot;aA\UbB\LcC\EdD&quot;, &quot;aABBccdD&quot;, 'aA\UbB\LcC\EdD');
is(&quot;aA\LbB\UcC\EdD&quot;, &quot;aAbbCCdD&quot;, 'aA\LbB\UcC\EdD');
is(&quot;\L\upERL&quot;, &quot;Perl&quot;, '\L\upERL');
is(&quot;\u\LpERL&quot;, &quot;Perl&quot;, '\u\LpERL');
is(&quot;\U\lPerl&quot;, &quot;pERL&quot;, '\U\lPerl');
is(&quot;\l\UPerl&quot;, &quot;pERL&quot;, '\l\UPerl');
is(&quot;\u\LpE\Q#X#\ER\EL&quot;, &quot;Pe\\#x\\#rL&quot;, '\u\LpE\Q#X#\ER\EL');
is(&quot;\l\UPe\Q!x!\Er\El&quot;, &quot;pE\\!X\\!Rl&quot;, '\l\UPe\Q!x!\Er\El');
is(&quot;\Q\u\LpE.X.R\EL\E.&quot;, &quot;Pe\\.x\\.rL.&quot;, '\Q\u\LpE.X.R\EL\E.');
is(&quot;\Q\l\UPe*x*r\El\E*&quot;, &quot;pE\\*X\\*Rl*&quot;, '\Q\l\UPe*x*r\El\E*');
is(&quot;\U\lPerl\E\E\E\E&quot;, &quot;pERL&quot;, '\U\lPerl\E\E\E\E');
is(&quot;\l\UPerl\E\E\E\E&quot;, &quot;pERL&quot;, '\l\UPerl\E\E\E\E');

is(quotemeta(&quot;\x{263a}&quot;), &quot;\x{263a}&quot;, &quot;quotemeta Unicode&quot;);
is(length(quotemeta(&quot;\x{263a}&quot;)), 1, &quot;quotemeta Unicode length&quot;);

$a = &quot;foo|bar&quot;;
is(&quot;a\Q\Ec$a&quot;, &quot;acfoo|bar&quot;, '\Q\E');
is(&quot;a\L\Ec$a&quot;, &quot;acfoo|bar&quot;, '\L\E');
is(&quot;a\l\Ec$a&quot;, &quot;acfoo|bar&quot;, '\l\E');
is(&quot;a\U\Ec$a&quot;, &quot;acfoo|bar&quot;, '\U\E');
is(&quot;a\u\Ec$a&quot;, &quot;acfoo|bar&quot;, '\u\E');

=end from_perl5

=cut</pre>
</div>


<pre> our Str multi Str::quotemeta ( Str $string )</pre>

<a name="msg_40"></a>
<a href="?hide_quotes=no#msg_40" onclick="return tog_quote(40);">
<div ID="header_shown_40" style="display: none;">
- Hide the snippet from t/builtins/strings/quotemeta.t (line 27 ~ line 130) -
</div>
<div ID="header_hidden_40" style="display: block;">
- Show the snippet from t/builtins/strings/quotemeta.t (line 27 ~ line 130, 104 lines) -
</div>
</a>
<div ID="hide_40" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /quotemeta/&gt;

is(quotemeta(&quot;HeLLo World-72_1&quot;), &quot;HeLLo\\ World\\-72_1&quot;, &quot;simple lc test&quot;);
is(quotemeta(&quot;&quot;), &quot;&quot;, &quot;empty string&quot;);

$_ = &quot;HeLLo World-72_1&quot;; 
my $x = .quotemeta;
is($x, &quot;HeLLo\\ World\\-72_1&quot;, 'quotemeta uses $_ as default');

{ # test invocant syntax for quotemeta
    my $x = &quot;HeLLo World-72_1&quot;;
    is($x.quotemeta, &quot;HeLLo\\ World\\-72_1&quot;, '$x.quotemeta works');
    is(&quot;HeLLo World-72_1&quot;.quotemeta, &quot;HeLLo\\ World\\-72_1&quot;, '&quot;HeLLo World-72_1&quot;.quotemeta works');
}


if (%*Config&lt;ebcdic&gt; eq 'define') {
    $_ = (129 .. 233).map({ chr($_); }).join('');
    is($_.chars, 96, &quot;quotemeta starting string&quot;);
    
    # 105 characters - 52 letters = 53 backslashes
    # 105 characters + 53 backslashes = 158 characters
    $_ = quotemeta $_;
    is($_.chars, 158, &quot;quotemeta string&quot;);
    # 53 backslashed characters + 1 &quot;original&quot; backslash
    is($_.split('').grep({ $_ eq &quot;\x5c&quot; }).elems, 54, &quot;count backslashes&quot;);
}
else {
    $_ = (0 .. 255).map({ chr($_); }).join('');
    is($_.chars, 256, &quot;quotemeta starting string&quot;);
    
    # Original test in Perl 5.9.3:
    # 96 characters - 52 letters - 10 digits - 1 underscore = 33 backslashes
    # 96 characters + 33 backslashes = 129 characters
    # 
    # Then added remaining 32 + 128, all escaped:
    # 129 + (32 + 128) * 2 = 449
    #
    # Total backslashed chars are 33 + 32 + 128 = 193
    # Total backslashes are 1 + 193 = 194
    $_ = quotemeta $_;
    is($_.chars, 449, &quot;quotemeta string&quot;);
    # 33 backslashed characters + 1 &quot;original&quot; backslash
    is($_.split('').grep({ $_ eq &quot;\x5c&quot; }).elems, 194, &quot;count backslashes&quot;);
}

# Current quotemeta implementation mimics that for Perl 5, avoiding
# to escape Unicode characters beyond 256th
is(quotemeta(&quot;\x[263a]&quot;), &quot;\x[263a]&quot;, &quot;quotemeta Unicode&quot;);
is(quotemeta(&quot;\x[263a]&quot;).chars, 1, &quot;quotemeta Unicode length&quot;);

=begin from_perl5


plan tests =&gt; 22;

if ($Config{ebcdic} eq 'define') {
    $_ = join &quot;&quot;, map chr($_), 129..233;

    # 105 characters - 52 letters = 53 backslashes
    # 105 characters + 53 backslashes = 158 characters
    $_ = quotemeta $_;
    is(length($_), 158, &quot;quotemeta string&quot;);
    # 104 non-backslash characters
    is(tr/\\//cd, 104, &quot;tr count non-backslashed&quot;);
} else { # some ASCII descendant, then.
    $_ = join &quot;&quot;, map chr($_), 32..127;

    # 96 characters - 52 letters - 10 digits - 1 underscore = 33 backslashes
    # 96 characters + 33 backslashes = 129 characters
    $_ = quotemeta $_;
    is(length($_), 129, &quot;quotemeta string&quot;);
    # 95 non-backslash characters
    is(tr/\\//cd, 95, &quot;tr count non-backslashed&quot;);
}

is(length(quotemeta &quot;&quot;), 0, &quot;quotemeta empty string&quot;);

is(&quot;aA\UbB\LcC\EdD&quot;, &quot;aABBccdD&quot;, 'aA\UbB\LcC\EdD');
is(&quot;aA\LbB\UcC\EdD&quot;, &quot;aAbbCCdD&quot;, 'aA\LbB\UcC\EdD');
is(&quot;\L\upERL&quot;, &quot;Perl&quot;, '\L\upERL');
is(&quot;\u\LpERL&quot;, &quot;Perl&quot;, '\u\LpERL');
is(&quot;\U\lPerl&quot;, &quot;pERL&quot;, '\U\lPerl');
is(&quot;\l\UPerl&quot;, &quot;pERL&quot;, '\l\UPerl');
is(&quot;\u\LpE\Q#X#\ER\EL&quot;, &quot;Pe\\#x\\#rL&quot;, '\u\LpE\Q#X#\ER\EL');
is(&quot;\l\UPe\Q!x!\Er\El&quot;, &quot;pE\\!X\\!Rl&quot;, '\l\UPe\Q!x!\Er\El');
is(&quot;\Q\u\LpE.X.R\EL\E.&quot;, &quot;Pe\\.x\\.rL.&quot;, '\Q\u\LpE.X.R\EL\E.');
is(&quot;\Q\l\UPe*x*r\El\E*&quot;, &quot;pE\\*X\\*Rl*&quot;, '\Q\l\UPe*x*r\El\E*');
is(&quot;\U\lPerl\E\E\E\E&quot;, &quot;pERL&quot;, '\U\lPerl\E\E\E\E');
is(&quot;\l\UPerl\E\E\E\E&quot;, &quot;pERL&quot;, '\l\UPerl\E\E\E\E');

is(quotemeta(&quot;\x{263a}&quot;), &quot;\x{263a}&quot;, &quot;quotemeta Unicode&quot;);
is(length(quotemeta(&quot;\x{263a}&quot;)), 1, &quot;quotemeta Unicode length&quot;);

$a = &quot;foo|bar&quot;;
is(&quot;a\Q\Ec$a&quot;, &quot;acfoo|bar&quot;, '\Q\E');
is(&quot;a\L\Ec$a&quot;, &quot;acfoo|bar&quot;, '\L\E');
is(&quot;a\l\Ec$a&quot;, &quot;acfoo|bar&quot;, '\l\E');
is(&quot;a\U\Ec$a&quot;, &quot;acfoo|bar&quot;, '\U\E');
is(&quot;a\u\Ec$a&quot;, &quot;acfoo|bar&quot;, '\u\E');

=end from_perl5

=cut</pre>
</div>


<p>Returns the input string with all non-&#34;word&#34; characters back-slashed. That is, all characters not matching &#34;/[A-Za-z_0-9]/&#34; will be preceded by a backslash in the returned string, regardless of any locale settings.</p>

<dt><a name="rindex"
>rindex</a></dt>

<dd>
<pre> our StrPos multi Str::index( Str $string, Str $substring, StrPos $pos? )</pre>

<a name="msg_30"></a>
<a href="?hide_quotes=no#msg_30" onclick="return tog_quote(30);">
<div ID="header_shown_30" style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID="header_hidden_30" style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -
</div>
</a>
<div ID="hide_30" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /substr/&gt;

{ # read only
    my $str = &quot;foobar&quot;;

    is(substr($str, 0, 1), &quot;f&quot;, &quot;first char&quot;);
    is(substr($str, -1), &quot;r&quot;, &quot;last char&quot;);
    is(substr($str, -4, 2), &quot;ob&quot;, &quot;counted from the end&quot;);
    is(substr($str, 1, 2), &quot;oo&quot;, &quot;arbitrary middle&quot;);
    is(substr($str, 3), &quot;bar&quot;, &quot;length omitted&quot;);
    is(substr($str, 3, 10), &quot;bar&quot;, &quot;length goes past end&quot;);
    is(substr($str, 20, 5), undef, &quot;substr outside of string&quot;);
    is(substr($str, -100, 10), undef, &quot;... on the negative side&quot;);

    is(substr($str, 0, -2), &quot;foob&quot;, &quot;from beginning, with negative length&quot;);
    is(substr($str, 2, -2), &quot;ob&quot;, &quot;in middle, with negative length&quot;);
    is(substr($str, 3, -3), &quot;&quot;, &quot;negative length - gives empty string&quot;);

    is($str, &quot;foobar&quot;, &quot;original string still not changed&quot;);
};

skip 4, &quot;more discussion needed&quot;;

=begin more-discussion-needed

{ # replacement
    my $str = &quot;foobar&quot;;

    substr($str, 2, 1, &quot;i&quot;);
    is($str, &quot;foibar&quot;, &quot;fourth arg to substr replaced part&quot;);

    substr($str, -1, 1, &quot;blah&quot;);
    is($str, &quot;foibablah&quot;, &quot;longer replacement expands string&quot;);

    substr($str, 1, 3, &quot;&quot;);
    is($str, &quot;fablah&quot;, &quot;shorter replacement shrunk it&quot;);

    substr($str, 1, -1, &quot;aye&quot;);
    is($str, &quot;fayeh&quot;, &quot;replacement with negative length&quot;);
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, &quot;gloop&quot;, '$r referent is eq to the substring');

    $$r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to reference modifies original&quot;, :todo);
    is($$r, &quot;boing&quot;, '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, &quot;ng&quot;, &quot;other ref to other lvalue&quot;, :todo);
    $$r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;, :todo);
    is($$o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo);
};

{ # as lvalue, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);
};

{ # as lvalue, using :=, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r := substr($str, 0, 5);
    is($r, &quot;gloop&quot;, 'bound $r is eq to the substring');

    $r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to bound var modifies original&quot;);
    is($r, &quot;boing&quot;, 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, &quot;ng&quot;, &quot;other bound var to other lvalue&quot;);
    $r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;);
    is($o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/&quot;Junctions&quot; /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr(&quot;camel&quot;, 0|1, 2&amp;3)', ((&quot;ca&quot;|&quot;am&quot;) &amp; (&quot;cam&quot;|&quot;ame&quot;)), &quot;junctive substr&quot;, :todo);
}


{ # misc
    my $str = &quot;hello foo and bar&quot;;
    is(substr($str, 6, 3), &quot;foo&quot;, &quot;substr&quot;);
    is($str.substr(6, 3), &quot;foo&quot;, &quot;.substr&quot;);
    is(substr(&quot;hello foo bar&quot;, 6, 3), &quot;foo&quot;, &quot;substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3), &quot;foo&quot;, &quot;.substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3).uc, &quot;FOO&quot;, &quot;.substr.uc on literal string&quot;);
    is(&quot;hello foo bar and baz&quot;.substr(6, 10).capitalize, &quot;Foo Bar An&quot;, &quot;.substr.capitalize on literal string&quot;);
    is(&quot;hello »« foo&quot;.substr(6, 2), &quot;»«&quot;, &quot;.substr on unicode string&quot;);
    is(&quot;שיעבוד כבר&quot;.substr(4, 4), &quot;וד כ&quot;, &quot;.substr on Hebrew text&quot;);
}</pre>
</div>


<p>Returns the position of the last <code>$substring</code> in <code>$string</code>. If <code>$pos</code> is specified, then the search starts at that location in <code>$string</code>, and works backwards. See <code>index</code> for more detail.</p>

<a name="msg_31"></a>
<a href="?hide_quotes=no#msg_31" onclick="return tog_quote(31);">
<div ID="header_shown_31" style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID="header_hidden_31" style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -
</div>
</a>
<div ID="hide_31" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /substr/&gt;

{ # read only
    my $str = &quot;foobar&quot;;

    is(substr($str, 0, 1), &quot;f&quot;, &quot;first char&quot;);
    is(substr($str, -1), &quot;r&quot;, &quot;last char&quot;);
    is(substr($str, -4, 2), &quot;ob&quot;, &quot;counted from the end&quot;);
    is(substr($str, 1, 2), &quot;oo&quot;, &quot;arbitrary middle&quot;);
    is(substr($str, 3), &quot;bar&quot;, &quot;length omitted&quot;);
    is(substr($str, 3, 10), &quot;bar&quot;, &quot;length goes past end&quot;);
    is(substr($str, 20, 5), undef, &quot;substr outside of string&quot;);
    is(substr($str, -100, 10), undef, &quot;... on the negative side&quot;);

    is(substr($str, 0, -2), &quot;foob&quot;, &quot;from beginning, with negative length&quot;);
    is(substr($str, 2, -2), &quot;ob&quot;, &quot;in middle, with negative length&quot;);
    is(substr($str, 3, -3), &quot;&quot;, &quot;negative length - gives empty string&quot;);

    is($str, &quot;foobar&quot;, &quot;original string still not changed&quot;);
};

skip 4, &quot;more discussion needed&quot;;

=begin more-discussion-needed

{ # replacement
    my $str = &quot;foobar&quot;;

    substr($str, 2, 1, &quot;i&quot;);
    is($str, &quot;foibar&quot;, &quot;fourth arg to substr replaced part&quot;);

    substr($str, -1, 1, &quot;blah&quot;);
    is($str, &quot;foibablah&quot;, &quot;longer replacement expands string&quot;);

    substr($str, 1, 3, &quot;&quot;);
    is($str, &quot;fablah&quot;, &quot;shorter replacement shrunk it&quot;);

    substr($str, 1, -1, &quot;aye&quot;);
    is($str, &quot;fayeh&quot;, &quot;replacement with negative length&quot;);
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, &quot;gloop&quot;, '$r referent is eq to the substring');

    $$r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to reference modifies original&quot;, :todo);
    is($$r, &quot;boing&quot;, '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, &quot;ng&quot;, &quot;other ref to other lvalue&quot;, :todo);
    $$r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;, :todo);
    is($$o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo);
};

{ # as lvalue, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);
};

{ # as lvalue, using :=, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r := substr($str, 0, 5);
    is($r, &quot;gloop&quot;, 'bound $r is eq to the substring');

    $r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to bound var modifies original&quot;);
    is($r, &quot;boing&quot;, 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, &quot;ng&quot;, &quot;other bound var to other lvalue&quot;);
    $r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;);
    is($o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/&quot;Junctions&quot; /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr(&quot;camel&quot;, 0|1, 2&amp;3)', ((&quot;ca&quot;|&quot;am&quot;) &amp; (&quot;cam&quot;|&quot;ame&quot;)), &quot;junctive substr&quot;, :todo);
}


{ # misc
    my $str = &quot;hello foo and bar&quot;;
    is(substr($str, 6, 3), &quot;foo&quot;, &quot;substr&quot;);
    is($str.substr(6, 3), &quot;foo&quot;, &quot;.substr&quot;);
    is(substr(&quot;hello foo bar&quot;, 6, 3), &quot;foo&quot;, &quot;substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3), &quot;foo&quot;, &quot;.substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3).uc, &quot;FOO&quot;, &quot;.substr.uc on literal string&quot;);
    is(&quot;hello foo bar and baz&quot;.substr(6, 10).capitalize, &quot;Foo Bar An&quot;, &quot;.substr.capitalize on literal string&quot;);
    is(&quot;hello »« foo&quot;.substr(6, 2), &quot;»«&quot;, &quot;.substr on unicode string&quot;);
    is(&quot;שיעבוד כבר&quot;.substr(4, 4), &quot;וד כ&quot;, &quot;.substr on Hebrew text&quot;);
}</pre>
</div>


<dt><a name="split"
>split</a></dt>

<dd>
<pre> our List multi Str::split ( Str $delimiter ,  Str $input_, Int $limit = inf )
 our List multi Str::split ( Rule $delimiter = /\s+/,  Str $input, Int $limit = inf )
 our List multi Str::split ( Str $input ;  Str $delimiter          , Int $limit = inf )
 our List multi Str::split ( Str $input ; Rule $delimiter          , Int $limit = inf )</pre>

<p>String delimiters must not be treated as rules but as constants. The default is no longer &#39;&#160;&#39; since that would be interpreted as a constant. P5&#39;s <code>split(&#39;&#160;&#39;)</code> will translate to <code>.words</code> or some such. Null trailing fields are no longer trimmed by default. We might add some kind of :trim flag or introduce a trimlist function of some sort.</p>

<a name="msg_23"></a>
<a href="?hide_quotes=no#msg_23" onclick="return tog_quote(23);">
<div ID="header_shown_23" style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID="header_hidden_23" style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -
</div>
</a>
<div ID="hide_23" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /uc/&gt;

is(uc(&quot;Hello World&quot;), &quot;HELLO WORLD&quot;, &quot;simple&quot;);
is(uc(&quot;&quot;), &quot;&quot;, &quot;empty string&quot;); 
is(uc(&quot;åäö&quot;), &quot;ÅÄÖ&quot;, &quot;some finnish non-ascii chars&quot;);
is(uc(&quot;óòúù&quot;), &quot;ÓÒÚÙ&quot;, &quot;accented chars&quot;);

# given does not return proper value yet
$_ = &quot;Hello World&quot;;
my $x = .uc;
is $x, &quot;HELLO WORLD&quot;, 'uc uses the default $_';

{   
    my $x = &quot;Hello World&quot;;
    is $x.uc, &quot;HELLO WORLD&quot;, '$x.uc works';
    is &quot;Hello World&quot;.uc, &quot;HELLO WORLD&quot;, '&quot;Hello World&quot;.uc works';
}

# Bug: GERMAN SHARP S (&quot;ß&quot;) should uc() to &quot;SS&quot;, but it doesn't
# Compare with: perl -we 'use utf8; print uc &quot;ß&quot;'
is(uc(&quot;ß&quot;), &quot;SS&quot;, &quot;uc() of non-ascii chars may result in two chars&quot;);

is(&quot;áéíöüóűőú&quot;.uc, &quot;ÁÉÍÖÜÓŰŐÚ&quot;, &quot;.uc on Hungarian vowels&quot;);</pre>
</div>


<dt><a name="sprintf"
>sprintf</a></dt>

<dd>
<pre> our Str multi method Str::sprintf ( Str $format: *@args )
 our Str multi Str::sprintf ( Str $format, *@args )</pre>

<p>This function is mostly identical to the C library sprintf function.</p>

<p>The <code>$format</code> is scanned for <code>%</code> characters. Any <code>%</code> introduces a format token. Format tokens have the following grammar:</p>

<a name="msg_24"></a>
<a href="?hide_quotes=no#msg_24" onclick="return tog_quote(24);">
<div ID="header_shown_24" style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID="header_hidden_24" style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -
</div>
</a>
<div ID="hide_24" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /uc/&gt;

is(uc(&quot;Hello World&quot;), &quot;HELLO WORLD&quot;, &quot;simple&quot;);
is(uc(&quot;&quot;), &quot;&quot;, &quot;empty string&quot;); 
is(uc(&quot;åäö&quot;), &quot;ÅÄÖ&quot;, &quot;some finnish non-ascii chars&quot;);
is(uc(&quot;óòúù&quot;), &quot;ÓÒÚÙ&quot;, &quot;accented chars&quot;);

# given does not return proper value yet
$_ = &quot;Hello World&quot;;
my $x = .uc;
is $x, &quot;HELLO WORLD&quot;, 'uc uses the default $_';

{   
    my $x = &quot;Hello World&quot;;
    is $x.uc, &quot;HELLO WORLD&quot;, '$x.uc works';
    is &quot;Hello World&quot;.uc, &quot;HELLO WORLD&quot;, '&quot;Hello World&quot;.uc works';
}

# Bug: GERMAN SHARP S (&quot;ß&quot;) should uc() to &quot;SS&quot;, but it doesn't
# Compare with: perl -we 'use utf8; print uc &quot;ß&quot;'
is(uc(&quot;ß&quot;), &quot;SS&quot;, &quot;uc() of non-ascii chars may result in two chars&quot;);

is(&quot;áéíöüóűőú&quot;.uc, &quot;ÁÉÍÖÜÓŰŐÚ&quot;, &quot;.uc on Hungarian vowels&quot;);</pre>
</div>


<pre> grammar Str::SprintfFormat {
  regex format_token { \%: &#60;index&#62;? &#60;precision&#62;? &#60;modifier&#62;? &#60;directive&#62; }
  token index { \d+ \$ }
  token precision { &#60;flags&#62;? &#60;vector&#62;? &#60;precision_count&#62; }
  token flags { &#60;[\ +0\#\-]&#62;+ }
  token precision_count { [ &#60;[1-9]&#62;\d* | \* ]? [ \. [ \d* | \* ] ]? }
  token vector { \*? v }
  token modifier { ll | &#60;[lhVqL]&#62; }
  token directive { &#60;[\%csduoxefgXEGbpniDUOF]&#62; }
 }</pre>

<p>Directives guide the use (if any) of the arguments. When a directive (other than <code>%</code>) are used, they indicate how the next argument passed is to be formatted into the string.</p>

<p>The directives are:</p>

<pre> %   a literal percent sign
 c   a character with the given codepoint
 s   a string
 d   a signed integer, in decimal
 u   an unsigned integer, in decimal
 o   an unsigned integer, in octal
 x   an unsigned integer, in hexadecimal
 e   a floating-point number, in scientific notation
 f   a floating-point number, in fixed decimal notation
 g   a floating-point number, in %e or %f notation
 X   like x, but using upper-case letters
 E   like e, but using an upper-case &#34;E&#34;
 G   like g, but with an upper-case &#34;E&#34; (if applicable)
 b   an unsigned integer, in binary
 C   special: invokes the arg as code, see below</pre>

<p>Compatibility:</p>

<pre> i   a synonym for %d
 D   a synonym for %ld
 U   a synonym for %lu
 O   a synonym for %lo
 F   a synonym for %f</pre>

<p>Perl 5 compatibility:</p>

<pre> n   produces a runtime exception (see below)</pre>

<a name="msg_25"></a>
<a href="?hide_quotes=no#msg_25" onclick="return tog_quote(25);">
<div ID="header_shown_25" style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID="header_hidden_25" style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -
</div>
</a>
<div ID="hide_25" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /uc/&gt;

is(uc(&quot;Hello World&quot;), &quot;HELLO WORLD&quot;, &quot;simple&quot;);
is(uc(&quot;&quot;), &quot;&quot;, &quot;empty string&quot;); 
is(uc(&quot;åäö&quot;), &quot;ÅÄÖ&quot;, &quot;some finnish non-ascii chars&quot;);
is(uc(&quot;óòúù&quot;), &quot;ÓÒÚÙ&quot;, &quot;accented chars&quot;);

# given does not return proper value yet
$_ = &quot;Hello World&quot;;
my $x = .uc;
is $x, &quot;HELLO WORLD&quot;, 'uc uses the default $_';

{   
    my $x = &quot;Hello World&quot;;
    is $x.uc, &quot;HELLO WORLD&quot;, '$x.uc works';
    is &quot;Hello World&quot;.uc, &quot;HELLO WORLD&quot;, '&quot;Hello World&quot;.uc works';
}

# Bug: GERMAN SHARP S (&quot;ß&quot;) should uc() to &quot;SS&quot;, but it doesn't
# Compare with: perl -we 'use utf8; print uc &quot;ß&quot;'
is(uc(&quot;ß&quot;), &quot;SS&quot;, &quot;uc() of non-ascii chars may result in two chars&quot;);

is(&quot;áéíöüóűőú&quot;.uc, &quot;ÁÉÍÖÜÓŰŐÚ&quot;, &quot;.uc on Hungarian vowels&quot;);</pre>
</div>


<pre> p   produces a runtime exception</pre>

<a name="msg_26"></a>
<a href="?hide_quotes=no#msg_26" onclick="return tog_quote(26);">
<div ID="header_shown_26" style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID="header_hidden_26" style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -
</div>
</a>
<div ID="hide_26" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /uc/&gt;

is(uc(&quot;Hello World&quot;), &quot;HELLO WORLD&quot;, &quot;simple&quot;);
is(uc(&quot;&quot;), &quot;&quot;, &quot;empty string&quot;); 
is(uc(&quot;åäö&quot;), &quot;ÅÄÖ&quot;, &quot;some finnish non-ascii chars&quot;);
is(uc(&quot;óòúù&quot;), &quot;ÓÒÚÙ&quot;, &quot;accented chars&quot;);

# given does not return proper value yet
$_ = &quot;Hello World&quot;;
my $x = .uc;
is $x, &quot;HELLO WORLD&quot;, 'uc uses the default $_';

{   
    my $x = &quot;Hello World&quot;;
    is $x.uc, &quot;HELLO WORLD&quot;, '$x.uc works';
    is &quot;Hello World&quot;.uc, &quot;HELLO WORLD&quot;, '&quot;Hello World&quot;.uc works';
}

# Bug: GERMAN SHARP S (&quot;ß&quot;) should uc() to &quot;SS&quot;, but it doesn't
# Compare with: perl -we 'use utf8; print uc &quot;ß&quot;'
is(uc(&quot;ß&quot;), &quot;SS&quot;, &quot;uc() of non-ascii chars may result in two chars&quot;);

is(&quot;áéíöüóűőú&quot;.uc, &quot;ÁÉÍÖÜÓŰŐÚ&quot;, &quot;.uc on Hungarian vowels&quot;);</pre>
</div>


<p>The special format directive, <code>%C</code> invokes the target argument as code, passing it the result string that has been generated thus far and the argument array.</p>

<p>Here&#39;s an example of its use:</p>

<pre> sprintf &#34;%d%C is %d digits long&#34;,
    $num,
    sub($s,@args is rw) {@args[2]=$s.elems},
    0;</pre>

<p>The special directive, <code>%n</code> does not work in Perl 6 because of the difference in parameter passing conventions, but the example above simulates its effect using <code>%C</code>.</p>

<dt><a name="substr"
>substr</a></dt>

<dd>
<a name="msg_32"></a>
<a href="?hide_quotes=no#msg_32" onclick="return tog_quote(32);">
<div ID="header_shown_32" style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID="header_hidden_32" style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -
</div>
</a>
<div ID="hide_32" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /substr/&gt;

{ # read only
    my $str = &quot;foobar&quot;;

    is(substr($str, 0, 1), &quot;f&quot;, &quot;first char&quot;);
    is(substr($str, -1), &quot;r&quot;, &quot;last char&quot;);
    is(substr($str, -4, 2), &quot;ob&quot;, &quot;counted from the end&quot;);
    is(substr($str, 1, 2), &quot;oo&quot;, &quot;arbitrary middle&quot;);
    is(substr($str, 3), &quot;bar&quot;, &quot;length omitted&quot;);
    is(substr($str, 3, 10), &quot;bar&quot;, &quot;length goes past end&quot;);
    is(substr($str, 20, 5), undef, &quot;substr outside of string&quot;);
    is(substr($str, -100, 10), undef, &quot;... on the negative side&quot;);

    is(substr($str, 0, -2), &quot;foob&quot;, &quot;from beginning, with negative length&quot;);
    is(substr($str, 2, -2), &quot;ob&quot;, &quot;in middle, with negative length&quot;);
    is(substr($str, 3, -3), &quot;&quot;, &quot;negative length - gives empty string&quot;);

    is($str, &quot;foobar&quot;, &quot;original string still not changed&quot;);
};

skip 4, &quot;more discussion needed&quot;;

=begin more-discussion-needed

{ # replacement
    my $str = &quot;foobar&quot;;

    substr($str, 2, 1, &quot;i&quot;);
    is($str, &quot;foibar&quot;, &quot;fourth arg to substr replaced part&quot;);

    substr($str, -1, 1, &quot;blah&quot;);
    is($str, &quot;foibablah&quot;, &quot;longer replacement expands string&quot;);

    substr($str, 1, 3, &quot;&quot;);
    is($str, &quot;fablah&quot;, &quot;shorter replacement shrunk it&quot;);

    substr($str, 1, -1, &quot;aye&quot;);
    is($str, &quot;fayeh&quot;, &quot;replacement with negative length&quot;);
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, &quot;gloop&quot;, '$r referent is eq to the substring');

    $$r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to reference modifies original&quot;, :todo);
    is($$r, &quot;boing&quot;, '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, &quot;ng&quot;, &quot;other ref to other lvalue&quot;, :todo);
    $$r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;, :todo);
    is($$o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo);
};

{ # as lvalue, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);
};

{ # as lvalue, using :=, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r := substr($str, 0, 5);
    is($r, &quot;gloop&quot;, 'bound $r is eq to the substring');

    $r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to bound var modifies original&quot;);
    is($r, &quot;boing&quot;, 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, &quot;ng&quot;, &quot;other bound var to other lvalue&quot;);
    $r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;);
    is($o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/&quot;Junctions&quot; /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr(&quot;camel&quot;, 0|1, 2&amp;3)', ((&quot;ca&quot;|&quot;am&quot;) &amp; (&quot;cam&quot;|&quot;ame&quot;)), &quot;junctive substr&quot;, :todo);
}


{ # misc
    my $str = &quot;hello foo and bar&quot;;
    is(substr($str, 6, 3), &quot;foo&quot;, &quot;substr&quot;);
    is($str.substr(6, 3), &quot;foo&quot;, &quot;.substr&quot;);
    is(substr(&quot;hello foo bar&quot;, 6, 3), &quot;foo&quot;, &quot;substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3), &quot;foo&quot;, &quot;.substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3).uc, &quot;FOO&quot;, &quot;.substr.uc on literal string&quot;);
    is(&quot;hello foo bar and baz&quot;.substr(6, 10).capitalize, &quot;Foo Bar An&quot;, &quot;.substr.capitalize on literal string&quot;);
    is(&quot;hello »« foo&quot;.substr(6, 2), &quot;»«&quot;, &quot;.substr on unicode string&quot;);
    is(&quot;שיעבוד כבר&quot;.substr(4, 4), &quot;וד כ&quot;, &quot;.substr on Hebrew text&quot;);
}</pre>
</div>


<pre> our Str multi substr (Str $s, StrPos $start, StrLen $length?) is rw</pre>

<a name="msg_33"></a>
<a href="?hide_quotes=no#msg_33" onclick="return tog_quote(33);">
<div ID="header_shown_33" style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID="header_hidden_33" style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -
</div>
</a>
<div ID="hide_33" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /substr/&gt;

{ # read only
    my $str = &quot;foobar&quot;;

    is(substr($str, 0, 1), &quot;f&quot;, &quot;first char&quot;);
    is(substr($str, -1), &quot;r&quot;, &quot;last char&quot;);
    is(substr($str, -4, 2), &quot;ob&quot;, &quot;counted from the end&quot;);
    is(substr($str, 1, 2), &quot;oo&quot;, &quot;arbitrary middle&quot;);
    is(substr($str, 3), &quot;bar&quot;, &quot;length omitted&quot;);
    is(substr($str, 3, 10), &quot;bar&quot;, &quot;length goes past end&quot;);
    is(substr($str, 20, 5), undef, &quot;substr outside of string&quot;);
    is(substr($str, -100, 10), undef, &quot;... on the negative side&quot;);

    is(substr($str, 0, -2), &quot;foob&quot;, &quot;from beginning, with negative length&quot;);
    is(substr($str, 2, -2), &quot;ob&quot;, &quot;in middle, with negative length&quot;);
    is(substr($str, 3, -3), &quot;&quot;, &quot;negative length - gives empty string&quot;);

    is($str, &quot;foobar&quot;, &quot;original string still not changed&quot;);
};

skip 4, &quot;more discussion needed&quot;;

=begin more-discussion-needed

{ # replacement
    my $str = &quot;foobar&quot;;

    substr($str, 2, 1, &quot;i&quot;);
    is($str, &quot;foibar&quot;, &quot;fourth arg to substr replaced part&quot;);

    substr($str, -1, 1, &quot;blah&quot;);
    is($str, &quot;foibablah&quot;, &quot;longer replacement expands string&quot;);

    substr($str, 1, 3, &quot;&quot;);
    is($str, &quot;fablah&quot;, &quot;shorter replacement shrunk it&quot;);

    substr($str, 1, -1, &quot;aye&quot;);
    is($str, &quot;fayeh&quot;, &quot;replacement with negative length&quot;);
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, &quot;gloop&quot;, '$r referent is eq to the substring');

    $$r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to reference modifies original&quot;, :todo);
    is($$r, &quot;boing&quot;, '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, &quot;ng&quot;, &quot;other ref to other lvalue&quot;, :todo);
    $$r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;, :todo);
    is($$o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo);
};

{ # as lvalue, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);
};

{ # as lvalue, using :=, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r := substr($str, 0, 5);
    is($r, &quot;gloop&quot;, 'bound $r is eq to the substring');

    $r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to bound var modifies original&quot;);
    is($r, &quot;boing&quot;, 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, &quot;ng&quot;, &quot;other bound var to other lvalue&quot;);
    $r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;);
    is($o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/&quot;Junctions&quot; /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr(&quot;camel&quot;, 0|1, 2&amp;3)', ((&quot;ca&quot;|&quot;am&quot;) &amp; (&quot;cam&quot;|&quot;ame&quot;)), &quot;junctive substr&quot;, :todo);
}


{ # misc
    my $str = &quot;hello foo and bar&quot;;
    is(substr($str, 6, 3), &quot;foo&quot;, &quot;substr&quot;);
    is($str.substr(6, 3), &quot;foo&quot;, &quot;.substr&quot;);
    is(substr(&quot;hello foo bar&quot;, 6, 3), &quot;foo&quot;, &quot;substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3), &quot;foo&quot;, &quot;.substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3).uc, &quot;FOO&quot;, &quot;.substr.uc on literal string&quot;);
    is(&quot;hello foo bar and baz&quot;.substr(6, 10).capitalize, &quot;Foo Bar An&quot;, &quot;.substr.capitalize on literal string&quot;);
    is(&quot;hello »« foo&quot;.substr(6, 2), &quot;»«&quot;, &quot;.substr on unicode string&quot;);
    is(&quot;שיעבוד כבר&quot;.substr(4, 4), &quot;וד כ&quot;, &quot;.substr on Hebrew text&quot;);
}</pre>
</div>


<pre> our Str multi substr (Str $s, StrPos $start, StrPos $end?) is rw</pre>

<a name="msg_34"></a>
<a href="?hide_quotes=no#msg_34" onclick="return tog_quote(34);">
<div ID="header_shown_34" style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID="header_hidden_34" style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -
</div>
</a>
<div ID="hide_34" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /substr/&gt;

{ # read only
    my $str = &quot;foobar&quot;;

    is(substr($str, 0, 1), &quot;f&quot;, &quot;first char&quot;);
    is(substr($str, -1), &quot;r&quot;, &quot;last char&quot;);
    is(substr($str, -4, 2), &quot;ob&quot;, &quot;counted from the end&quot;);
    is(substr($str, 1, 2), &quot;oo&quot;, &quot;arbitrary middle&quot;);
    is(substr($str, 3), &quot;bar&quot;, &quot;length omitted&quot;);
    is(substr($str, 3, 10), &quot;bar&quot;, &quot;length goes past end&quot;);
    is(substr($str, 20, 5), undef, &quot;substr outside of string&quot;);
    is(substr($str, -100, 10), undef, &quot;... on the negative side&quot;);

    is(substr($str, 0, -2), &quot;foob&quot;, &quot;from beginning, with negative length&quot;);
    is(substr($str, 2, -2), &quot;ob&quot;, &quot;in middle, with negative length&quot;);
    is(substr($str, 3, -3), &quot;&quot;, &quot;negative length - gives empty string&quot;);

    is($str, &quot;foobar&quot;, &quot;original string still not changed&quot;);
};

skip 4, &quot;more discussion needed&quot;;

=begin more-discussion-needed

{ # replacement
    my $str = &quot;foobar&quot;;

    substr($str, 2, 1, &quot;i&quot;);
    is($str, &quot;foibar&quot;, &quot;fourth arg to substr replaced part&quot;);

    substr($str, -1, 1, &quot;blah&quot;);
    is($str, &quot;foibablah&quot;, &quot;longer replacement expands string&quot;);

    substr($str, 1, 3, &quot;&quot;);
    is($str, &quot;fablah&quot;, &quot;shorter replacement shrunk it&quot;);

    substr($str, 1, -1, &quot;aye&quot;);
    is($str, &quot;fayeh&quot;, &quot;replacement with negative length&quot;);
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, &quot;gloop&quot;, '$r referent is eq to the substring');

    $$r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to reference modifies original&quot;, :todo);
    is($$r, &quot;boing&quot;, '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, &quot;ng&quot;, &quot;other ref to other lvalue&quot;, :todo);
    $$r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;, :todo);
    is($$o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo);
};

{ # as lvalue, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);
};

{ # as lvalue, using :=, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r := substr($str, 0, 5);
    is($r, &quot;gloop&quot;, 'bound $r is eq to the substring');

    $r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to bound var modifies original&quot;);
    is($r, &quot;boing&quot;, 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, &quot;ng&quot;, &quot;other bound var to other lvalue&quot;);
    $r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;);
    is($o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/&quot;Junctions&quot; /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr(&quot;camel&quot;, 0|1, 2&amp;3)', ((&quot;ca&quot;|&quot;am&quot;) &amp; (&quot;cam&quot;|&quot;ame&quot;)), &quot;junctive substr&quot;, :todo);
}


{ # misc
    my $str = &quot;hello foo and bar&quot;;
    is(substr($str, 6, 3), &quot;foo&quot;, &quot;substr&quot;);
    is($str.substr(6, 3), &quot;foo&quot;, &quot;.substr&quot;);
    is(substr(&quot;hello foo bar&quot;, 6, 3), &quot;foo&quot;, &quot;substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3), &quot;foo&quot;, &quot;.substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3).uc, &quot;FOO&quot;, &quot;.substr.uc on literal string&quot;);
    is(&quot;hello foo bar and baz&quot;.substr(6, 10).capitalize, &quot;Foo Bar An&quot;, &quot;.substr.capitalize on literal string&quot;);
    is(&quot;hello »« foo&quot;.substr(6, 2), &quot;»«&quot;, &quot;.substr on unicode string&quot;);
    is(&quot;שיעבוד כבר&quot;.substr(4, 4), &quot;וד כ&quot;, &quot;.substr on Hebrew text&quot;);
}</pre>
</div>


<p><code>substr</code> returns part of an existing string. You control what part by passing a starting position and optionally either an end position or length. If you just pass two numbers, positionally, then they will be used as the start and length.</p>

<a name="msg_35"></a>
<a href="?hide_quotes=no#msg_35" onclick="return tog_quote(35);">
<div ID="header_shown_35" style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID="header_hidden_35" style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -
</div>
</a>
<div ID="hide_35" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /substr/&gt;

{ # read only
    my $str = &quot;foobar&quot;;

    is(substr($str, 0, 1), &quot;f&quot;, &quot;first char&quot;);
    is(substr($str, -1), &quot;r&quot;, &quot;last char&quot;);
    is(substr($str, -4, 2), &quot;ob&quot;, &quot;counted from the end&quot;);
    is(substr($str, 1, 2), &quot;oo&quot;, &quot;arbitrary middle&quot;);
    is(substr($str, 3), &quot;bar&quot;, &quot;length omitted&quot;);
    is(substr($str, 3, 10), &quot;bar&quot;, &quot;length goes past end&quot;);
    is(substr($str, 20, 5), undef, &quot;substr outside of string&quot;);
    is(substr($str, -100, 10), undef, &quot;... on the negative side&quot;);

    is(substr($str, 0, -2), &quot;foob&quot;, &quot;from beginning, with negative length&quot;);
    is(substr($str, 2, -2), &quot;ob&quot;, &quot;in middle, with negative length&quot;);
    is(substr($str, 3, -3), &quot;&quot;, &quot;negative length - gives empty string&quot;);

    is($str, &quot;foobar&quot;, &quot;original string still not changed&quot;);
};

skip 4, &quot;more discussion needed&quot;;

=begin more-discussion-needed

{ # replacement
    my $str = &quot;foobar&quot;;

    substr($str, 2, 1, &quot;i&quot;);
    is($str, &quot;foibar&quot;, &quot;fourth arg to substr replaced part&quot;);

    substr($str, -1, 1, &quot;blah&quot;);
    is($str, &quot;foibablah&quot;, &quot;longer replacement expands string&quot;);

    substr($str, 1, 3, &quot;&quot;);
    is($str, &quot;fablah&quot;, &quot;shorter replacement shrunk it&quot;);

    substr($str, 1, -1, &quot;aye&quot;);
    is($str, &quot;fayeh&quot;, &quot;replacement with negative length&quot;);
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, &quot;gloop&quot;, '$r referent is eq to the substring');

    $$r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to reference modifies original&quot;, :todo);
    is($$r, &quot;boing&quot;, '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, &quot;ng&quot;, &quot;other ref to other lvalue&quot;, :todo);
    $$r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;, :todo);
    is($$o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo);
};

{ # as lvalue, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);
};

{ # as lvalue, using :=, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r := substr($str, 0, 5);
    is($r, &quot;gloop&quot;, 'bound $r is eq to the substring');

    $r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to bound var modifies original&quot;);
    is($r, &quot;boing&quot;, 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, &quot;ng&quot;, &quot;other bound var to other lvalue&quot;);
    $r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;);
    is($o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/&quot;Junctions&quot; /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr(&quot;camel&quot;, 0|1, 2&amp;3)', ((&quot;ca&quot;|&quot;am&quot;) &amp; (&quot;cam&quot;|&quot;ame&quot;)), &quot;junctive substr&quot;, :todo);
}


{ # misc
    my $str = &quot;hello foo and bar&quot;;
    is(substr($str, 6, 3), &quot;foo&quot;, &quot;substr&quot;);
    is($str.substr(6, 3), &quot;foo&quot;, &quot;.substr&quot;);
    is(substr(&quot;hello foo bar&quot;, 6, 3), &quot;foo&quot;, &quot;substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3), &quot;foo&quot;, &quot;.substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3).uc, &quot;FOO&quot;, &quot;.substr.uc on literal string&quot;);
    is(&quot;hello foo bar and baz&quot;.substr(6, 10).capitalize, &quot;Foo Bar An&quot;, &quot;.substr.capitalize on literal string&quot;);
    is(&quot;hello »« foo&quot;.substr(6, 2), &quot;»«&quot;, &quot;.substr on unicode string&quot;);
    is(&quot;שיעבוד כבר&quot;.substr(4, 4), &quot;וד כ&quot;, &quot;.substr on Hebrew text&quot;);
}</pre>
</div>


<p>Here is an example of its use:</p>

<pre> $initials = substr($first_name,0,1) ~ substr($last_name,0,1);</pre>

<a name="msg_36"></a>
<a href="?hide_quotes=no#msg_36" onclick="return tog_quote(36);">
<div ID="header_shown_36" style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID="header_hidden_36" style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -
</div>
</a>
<div ID="hide_36" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /substr/&gt;

{ # read only
    my $str = &quot;foobar&quot;;

    is(substr($str, 0, 1), &quot;f&quot;, &quot;first char&quot;);
    is(substr($str, -1), &quot;r&quot;, &quot;last char&quot;);
    is(substr($str, -4, 2), &quot;ob&quot;, &quot;counted from the end&quot;);
    is(substr($str, 1, 2), &quot;oo&quot;, &quot;arbitrary middle&quot;);
    is(substr($str, 3), &quot;bar&quot;, &quot;length omitted&quot;);
    is(substr($str, 3, 10), &quot;bar&quot;, &quot;length goes past end&quot;);
    is(substr($str, 20, 5), undef, &quot;substr outside of string&quot;);
    is(substr($str, -100, 10), undef, &quot;... on the negative side&quot;);

    is(substr($str, 0, -2), &quot;foob&quot;, &quot;from beginning, with negative length&quot;);
    is(substr($str, 2, -2), &quot;ob&quot;, &quot;in middle, with negative length&quot;);
    is(substr($str, 3, -3), &quot;&quot;, &quot;negative length - gives empty string&quot;);

    is($str, &quot;foobar&quot;, &quot;original string still not changed&quot;);
};

skip 4, &quot;more discussion needed&quot;;

=begin more-discussion-needed

{ # replacement
    my $str = &quot;foobar&quot;;

    substr($str, 2, 1, &quot;i&quot;);
    is($str, &quot;foibar&quot;, &quot;fourth arg to substr replaced part&quot;);

    substr($str, -1, 1, &quot;blah&quot;);
    is($str, &quot;foibablah&quot;, &quot;longer replacement expands string&quot;);

    substr($str, 1, 3, &quot;&quot;);
    is($str, &quot;fablah&quot;, &quot;shorter replacement shrunk it&quot;);

    substr($str, 1, -1, &quot;aye&quot;);
    is($str, &quot;fayeh&quot;, &quot;replacement with negative length&quot;);
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, &quot;gloop&quot;, '$r referent is eq to the substring');

    $$r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to reference modifies original&quot;, :todo);
    is($$r, &quot;boing&quot;, '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, &quot;ng&quot;, &quot;other ref to other lvalue&quot;, :todo);
    $$r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;, :todo);
    is($$o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo);
};

{ # as lvalue, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);
};

{ # as lvalue, using :=, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r := substr($str, 0, 5);
    is($r, &quot;gloop&quot;, 'bound $r is eq to the substring');

    $r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to bound var modifies original&quot;);
    is($r, &quot;boing&quot;, 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, &quot;ng&quot;, &quot;other bound var to other lvalue&quot;);
    $r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;);
    is($o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/&quot;Junctions&quot; /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr(&quot;camel&quot;, 0|1, 2&amp;3)', ((&quot;ca&quot;|&quot;am&quot;) &amp; (&quot;cam&quot;|&quot;ame&quot;)), &quot;junctive substr&quot;, :todo);
}


{ # misc
    my $str = &quot;hello foo and bar&quot;;
    is(substr($str, 6, 3), &quot;foo&quot;, &quot;substr&quot;);
    is($str.substr(6, 3), &quot;foo&quot;, &quot;.substr&quot;);
    is(substr(&quot;hello foo bar&quot;, 6, 3), &quot;foo&quot;, &quot;substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3), &quot;foo&quot;, &quot;.substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3).uc, &quot;FOO&quot;, &quot;.substr.uc on literal string&quot;);
    is(&quot;hello foo bar and baz&quot;.substr(6, 10).capitalize, &quot;Foo Bar An&quot;, &quot;.substr.capitalize on literal string&quot;);
    is(&quot;hello »« foo&quot;.substr(6, 2), &quot;»«&quot;, &quot;.substr on unicode string&quot;);
    is(&quot;שיעבוד כבר&quot;.substr(4, 4), &quot;וד כ&quot;, &quot;.substr on Hebrew text&quot;);
}</pre>
</div>


<p>Optionally, you can use substr on the left hand side of an assignment like so:</p>

<a name="msg_37"></a>
<a href="?hide_quotes=no#msg_37" onclick="return tog_quote(37);">
<div ID="header_shown_37" style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID="header_hidden_37" style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -
</div>
</a>
<div ID="hide_37" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /substr/&gt;

{ # read only
    my $str = &quot;foobar&quot;;

    is(substr($str, 0, 1), &quot;f&quot;, &quot;first char&quot;);
    is(substr($str, -1), &quot;r&quot;, &quot;last char&quot;);
    is(substr($str, -4, 2), &quot;ob&quot;, &quot;counted from the end&quot;);
    is(substr($str, 1, 2), &quot;oo&quot;, &quot;arbitrary middle&quot;);
    is(substr($str, 3), &quot;bar&quot;, &quot;length omitted&quot;);
    is(substr($str, 3, 10), &quot;bar&quot;, &quot;length goes past end&quot;);
    is(substr($str, 20, 5), undef, &quot;substr outside of string&quot;);
    is(substr($str, -100, 10), undef, &quot;... on the negative side&quot;);

    is(substr($str, 0, -2), &quot;foob&quot;, &quot;from beginning, with negative length&quot;);
    is(substr($str, 2, -2), &quot;ob&quot;, &quot;in middle, with negative length&quot;);
    is(substr($str, 3, -3), &quot;&quot;, &quot;negative length - gives empty string&quot;);

    is($str, &quot;foobar&quot;, &quot;original string still not changed&quot;);
};

skip 4, &quot;more discussion needed&quot;;

=begin more-discussion-needed

{ # replacement
    my $str = &quot;foobar&quot;;

    substr($str, 2, 1, &quot;i&quot;);
    is($str, &quot;foibar&quot;, &quot;fourth arg to substr replaced part&quot;);

    substr($str, -1, 1, &quot;blah&quot;);
    is($str, &quot;foibablah&quot;, &quot;longer replacement expands string&quot;);

    substr($str, 1, 3, &quot;&quot;);
    is($str, &quot;fablah&quot;, &quot;shorter replacement shrunk it&quot;);

    substr($str, 1, -1, &quot;aye&quot;);
    is($str, &quot;fayeh&quot;, &quot;replacement with negative length&quot;);
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, &quot;gloop&quot;, '$r referent is eq to the substring');

    $$r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to reference modifies original&quot;, :todo);
    is($$r, &quot;boing&quot;, '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, &quot;ng&quot;, &quot;other ref to other lvalue&quot;, :todo);
    $$r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;, :todo);
    is($$o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo);
};

{ # as lvalue, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);
};

{ # as lvalue, using :=, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r := substr($str, 0, 5);
    is($r, &quot;gloop&quot;, 'bound $r is eq to the substring');

    $r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to bound var modifies original&quot;);
    is($r, &quot;boing&quot;, 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, &quot;ng&quot;, &quot;other bound var to other lvalue&quot;);
    $r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;);
    is($o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/&quot;Junctions&quot; /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr(&quot;camel&quot;, 0|1, 2&amp;3)', ((&quot;ca&quot;|&quot;am&quot;) &amp; (&quot;cam&quot;|&quot;ame&quot;)), &quot;junctive substr&quot;, :todo);
}


{ # misc
    my $str = &quot;hello foo and bar&quot;;
    is(substr($str, 6, 3), &quot;foo&quot;, &quot;substr&quot;);
    is($str.substr(6, 3), &quot;foo&quot;, &quot;.substr&quot;);
    is(substr(&quot;hello foo bar&quot;, 6, 3), &quot;foo&quot;, &quot;substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3), &quot;foo&quot;, &quot;.substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3).uc, &quot;FOO&quot;, &quot;.substr.uc on literal string&quot;);
    is(&quot;hello foo bar and baz&quot;.substr(6, 10).capitalize, &quot;Foo Bar An&quot;, &quot;.substr.capitalize on literal string&quot;);
    is(&quot;hello »« foo&quot;.substr(6, 2), &quot;»«&quot;, &quot;.substr on unicode string&quot;);
    is(&quot;שיעבוד כבר&quot;.substr(4, 4), &quot;וד כ&quot;, &quot;.substr on Hebrew text&quot;);
}</pre>
</div>


<pre> substr($string, 1, 5) = &#34;fred&#34;;</pre>

<a name="msg_38"></a>
<a href="?hide_quotes=no#msg_38" onclick="return tog_quote(38);">
<div ID="header_shown_38" style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID="header_hidden_38" style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -
</div>
</a>
<div ID="hide_38" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /substr/&gt;

{ # read only
    my $str = &quot;foobar&quot;;

    is(substr($str, 0, 1), &quot;f&quot;, &quot;first char&quot;);
    is(substr($str, -1), &quot;r&quot;, &quot;last char&quot;);
    is(substr($str, -4, 2), &quot;ob&quot;, &quot;counted from the end&quot;);
    is(substr($str, 1, 2), &quot;oo&quot;, &quot;arbitrary middle&quot;);
    is(substr($str, 3), &quot;bar&quot;, &quot;length omitted&quot;);
    is(substr($str, 3, 10), &quot;bar&quot;, &quot;length goes past end&quot;);
    is(substr($str, 20, 5), undef, &quot;substr outside of string&quot;);
    is(substr($str, -100, 10), undef, &quot;... on the negative side&quot;);

    is(substr($str, 0, -2), &quot;foob&quot;, &quot;from beginning, with negative length&quot;);
    is(substr($str, 2, -2), &quot;ob&quot;, &quot;in middle, with negative length&quot;);
    is(substr($str, 3, -3), &quot;&quot;, &quot;negative length - gives empty string&quot;);

    is($str, &quot;foobar&quot;, &quot;original string still not changed&quot;);
};

skip 4, &quot;more discussion needed&quot;;

=begin more-discussion-needed

{ # replacement
    my $str = &quot;foobar&quot;;

    substr($str, 2, 1, &quot;i&quot;);
    is($str, &quot;foibar&quot;, &quot;fourth arg to substr replaced part&quot;);

    substr($str, -1, 1, &quot;blah&quot;);
    is($str, &quot;foibablah&quot;, &quot;longer replacement expands string&quot;);

    substr($str, 1, 3, &quot;&quot;);
    is($str, &quot;fablah&quot;, &quot;shorter replacement shrunk it&quot;);

    substr($str, 1, -1, &quot;aye&quot;);
    is($str, &quot;fayeh&quot;, &quot;replacement with negative length&quot;);
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, &quot;gloop&quot;, '$r referent is eq to the substring');

    $$r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to reference modifies original&quot;, :todo);
    is($$r, &quot;boing&quot;, '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, &quot;ng&quot;, &quot;other ref to other lvalue&quot;, :todo);
    $$r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;, :todo);
    is($$o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo);
};

{ # as lvalue, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);
};

{ # as lvalue, using :=, should work
    my $str = &quot;gorch ding&quot;;

    substr($str, 0, 5) = &quot;gloop&quot;;
    is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

    my $r := substr($str, 0, 5);
    is($r, &quot;gloop&quot;, 'bound $r is eq to the substring');

    $r = &quot;boing&quot;;
    is($str, &quot;boing ding&quot;, &quot;assignment to bound var modifies original&quot;);
    is($r, &quot;boing&quot;, 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, &quot;ng&quot;, &quot;other bound var to other lvalue&quot;);
    $r = &quot;foo&quot;;
    is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;);
    is($o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/&quot;Junctions&quot; /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr(&quot;camel&quot;, 0|1, 2&amp;3)', ((&quot;ca&quot;|&quot;am&quot;) &amp; (&quot;cam&quot;|&quot;ame&quot;)), &quot;junctive substr&quot;, :todo);
}


{ # misc
    my $str = &quot;hello foo and bar&quot;;
    is(substr($str, 6, 3), &quot;foo&quot;, &quot;substr&quot;);
    is($str.substr(6, 3), &quot;foo&quot;, &quot;.substr&quot;);
    is(substr(&quot;hello foo bar&quot;, 6, 3), &quot;foo&quot;, &quot;substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3), &quot;foo&quot;, &quot;.substr on literal string&quot;);
    is(&quot;hello foo bar&quot;.substr(6, 3).uc, &quot;FOO&quot;, &quot;.substr.uc on literal string&quot;);
    is(&quot;hello foo bar and baz&quot;.substr(6, 10).capitalize, &quot;Foo Bar An&quot;, &quot;.substr.capitalize on literal string&quot;);
    is(&quot;hello »« foo&quot;.substr(6, 2), &quot;»«&quot;, &quot;.substr on unicode string&quot;);
    is(&quot;שיעבוד כבר&quot;.substr(4, 4), &quot;וד כ&quot;, &quot;.substr on Hebrew text&quot;);
}</pre>
</div>


<p>If the replacement string is longer or shorter than the matched sub-string, then the original string will be dynamically resized.</p>

<p>[ Note: Is the word &#34;length&#34; a problem, here, given Perl 6&#39;s general desire to stop using length with respect to strings? -ajs ]</p>

<dt><a name="unpack"
>unpack
<dt><a name="vec"
>vec</a></dt>

<dd>
<p>Should replace vec with declared arrays of bit, uint2, uint4, etc.</p>

<dt><a name="words"
>words</a></dt>

<dd>
<pre> our List multi Str::words ( Rule $matcher = /\S+/,  Str $input, Int $limit = inf )
 our List multi Str::words ( Str $input ; Rule $matcher = /\S+/, Int $limit = inf )</pre>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Control::Basic"
>Control::Basic</a></h2>

<dl>
<dt><a name="caller"
>caller</a></dt>

<dd>
<p>TODO</p>

<dt><a name="eval"
>eval</a></dt>

<dd>
<pre> multi Control::Basic::eval ( Str $code, Grammar :$lang = CALLER::&#60;$?PARSER&#62;)</pre>

<p>Execute <code>$code</code> as if it were code written in <code>$lang</code>. The default is the language in effect at the exact location of the eval call.</p>

<p>Returns whatever <code>$code</code> returns, or undef on error.</p>

<dt><a name="evalfile"
>evalfile</a></dt>

<dd>
<pre> multi Control::Basic::evalfile (Str $filename ; Grammar :$lang = Perl6)</pre>

<p>Behaves like, and replaces Perl 5 <code>do EXPR</code>, with optional <code>$lang</code> support.</p>

<dt><a name="exit"
>exit</a></dt>

<dd>
<pre> multi Control::Basic::exit ( Int $status = 0)</pre>

<p>Stops all program execution, and returns <code>$status</code> to the calling environment.</p>

<dt><a name="nothing"
>nothing</a></dt>

<dd>
<a name="msg_69"></a>
<a href="?hide_quotes=no#msg_69" onclick="return tog_quote(69);">
<div ID="header_shown_69" style="display: none;">
- Hide the snippet from t/builtins/control_flow/nothing.t (line 11 ~ line 21) -
</div>
<div ID="header_hidden_69" style="display: block;">
- Show the snippet from t/builtins/control_flow/nothing.t (line 11 ~ line 21, 11 lines) -
</div>
</a>
<div ID="hide_69" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Control::Basic&quot; /nothing/&gt;

plan 2;

lives_ok { nothing }, &quot;nothing() works&quot;;

# Probably the most commonly used form:
my $var;
nothing while $var++ &lt; 3;
# We're still here, so pass().
pass &quot;nothing() works in while&quot;;</pre>
</div>


<pre> multi Control::Basic::nothing ()</pre>

<a name="msg_70"></a>
<a href="?hide_quotes=no#msg_70" onclick="return tog_quote(70);">
<div ID="header_shown_70" style="display: none;">
- Hide the snippet from t/builtins/control_flow/nothing.t (line 11 ~ line 21) -
</div>
<div ID="header_hidden_70" style="display: block;">
- Show the snippet from t/builtins/control_flow/nothing.t (line 11 ~ line 21, 11 lines) -
</div>
</a>
<div ID="hide_70" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Control::Basic&quot; /nothing/&gt;

plan 2;

lives_ok { nothing }, &quot;nothing() works&quot;;

# Probably the most commonly used form:
my $var;
nothing while $var++ &lt; 3;
# We're still here, so pass().
pass &quot;nothing() works in while&quot;;</pre>
</div>


<p>No operation. Literally does nothing.</p>

<a name="msg_71"></a>
<a href="?hide_quotes=no#msg_71" onclick="return tog_quote(71);">
<div ID="header_shown_71" style="display: none;">
- Hide the snippet from t/builtins/control_flow/nothing.t (line 11 ~ line 21) -
</div>
<div ID="header_hidden_71" style="display: block;">
- Show the snippet from t/builtins/control_flow/nothing.t (line 11 ~ line 21, 11 lines) -
</div>
</a>
<div ID="hide_71" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Control::Basic&quot; /nothing/&gt;

plan 2;

lives_ok { nothing }, &quot;nothing() works&quot;;

# Probably the most commonly used form:
my $var;
nothing while $var++ &lt; 3;
# We're still here, so pass().
pass &quot;nothing() works in while&quot;;</pre>
</div>


<dt><a name="sleep"
>sleep</a></dt>

<dd>
<pre> our Num multi Control::Basic::sleep ( Num $for = Inf )</pre>

<p>Attempt to sleep for up to <code>$for</code> seconds. Implementations are obligated to support sub-second resolutions if that is at all possible.</p>

<p>This is exactly the same as:</p>

<pre> $$.sleep($for)</pre>

<p>See <code>Synopsis 17: Concurrency</code> for more details.</p>

<dt><a name="want"
>want</a></dt>

<dd>
<p>TODO</p>

<dt><a name="word"
>word</a></dt>

<dd>
<p><code>word</code> is almost exactly the same as <code>macro</code>, only defines macros which take no arguments. For example:</p>

<pre> word foo { &#34;&#39;foo&#39;.say&#34; }
 foo;</pre>

<p>[ Refs: Message-ID: &#60;20050614164447.GA14958@wall.org&#62;</p>

<pre>    Date: Tue, 14 Jun 2005 09:44:47 -0700  (12:44 EDT)
    From: Larry Wall &#60;larry@wall.org&#62;
    To: perl6-language@perl.org
]</pre>

<dt><a name="die"
>die
<dt><a name="fail"
>fail</a></dt>

<dd>
<p><b>TODO</b>: Research the exception handling system.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Conversions"
>Conversions</a></h2>

<dl>
<dt><a name="bless"
>bless</a></dt>

<dd>
<pre> our Object multi method Class::bless( Object::RepCandidate $candidate )
 our Object multi method Class::bless( *%args )</pre>

<p><code>bless</code> is only available as a method which can be called on a class object like so:</p>

<pre> $object = $class.bless(k1 =&#62; $v1, k2 =&#62; $v2, ...);</pre>

<p>A newly created object, based on either the <code>$candidate</code> representation or a newly created representation (initialized with the <code>%args</code> that are passed in) when the second form is used.</p>

<p>It automatically calls all appropriate BUILD routines by calling the BUILDALL routine for the current class, which initializes the object in least-derived to most-derived order. See <a href="http://search.cpan.org/perldoc?S12#Objects" class="podlinkpod"
>&#34;Objects&#34; in S12</a> for more detailed information on object creation.</p>

<a name="msg_1"></a>
<a href="?hide_quotes=no#msg_1" onclick="return tog_quote(1);">
<div ID="header_shown_1" style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 136) -
</div>
<div ID="header_hidden_1" style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 136, 126 lines) -
</div>
</a>
<div ID="hide_1" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Conversions&quot; /ord/&gt;
# L&lt;S29/&quot;Conversions&quot; /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  &quot; &quot;,    32,
  &quot;!&quot;,    33,
  &quot;\&quot;&quot;,   34,
  &quot;#&quot;,    35,
  &quot;$&quot;,    36,
  &quot;%&quot;,    37,
  &quot;&amp;&quot;,    38,
  &quot;\'&quot;,   39,
  &quot;(&quot;,    40,
  &quot;)&quot;,    41,
  &quot;*&quot;,    42,
  &quot;+&quot;,    43,
  &quot;,&quot;,    44,
  &quot;-&quot;,    45,
  &quot;.&quot;,    46,
  &quot;/&quot;,    47,
  &quot;0&quot;,    48,
  &quot;1&quot;,    49,
  &quot;2&quot;,    50,
  &quot;3&quot;,    51,
  &quot;4&quot;,    52,
  &quot;5&quot;,    53,
  &quot;6&quot;,    54,
  &quot;7&quot;,    55,
  &quot;8&quot;,    56,
  &quot;9&quot;,    57,
  &quot;:&quot;,    58,
  &quot;;&quot;,    59,
  &quot;&lt;&quot;,    60,
  &quot;=&quot;,    61,
  &quot;&gt;&quot;,    62,
  &quot;?&quot;,    63,
  &quot;@&quot;,    64,
  &quot;A&quot;,    65,
  &quot;B&quot;,    66,
  &quot;C&quot;,    67,
  &quot;D&quot;,    68,
  &quot;E&quot;,    69,
  &quot;F&quot;,    70,
  &quot;G&quot;,    71,
  &quot;H&quot;,    72,
  &quot;I&quot;,    73,
  &quot;J&quot;,    74,
  &quot;K&quot;,    75,
  &quot;L&quot;,    76,
  &quot;M&quot;,    77,
  &quot;N&quot;,    78,
  &quot;O&quot;,    79,
  &quot;P&quot;,    80,
  &quot;Q&quot;,    81,
  &quot;R&quot;,    82,
  &quot;S&quot;,    83,
  &quot;T&quot;,    84,
  &quot;U&quot;,    85,
  &quot;V&quot;,    86,
  &quot;W&quot;,    87,
  &quot;X&quot;,    88,
  &quot;Y&quot;,    89,
  &quot;Z&quot;,    90,
  &quot;[&quot;,    91,
  &quot;\\&quot;,   92,
  &quot;]&quot;,    93,
  &quot;^&quot;,    94,
  &quot;_&quot;,    95,
  &quot;`&quot;,    96,
  &quot;a&quot;,    97,
  &quot;b&quot;,    98,
  &quot;c&quot;,    99,
  &quot;d&quot;,    100,
  &quot;e&quot;,    101,
  &quot;f&quot;,    102,
  &quot;g&quot;,    103,
  &quot;h&quot;,    104,
  &quot;i&quot;,    105,
  &quot;j&quot;,    106,
  &quot;k&quot;,    107,
  &quot;l&quot;,    108,
  &quot;m&quot;,    109,
  &quot;n&quot;,    110,
  &quot;o&quot;,    111,
  &quot;p&quot;,    112,
  &quot;q&quot;,    113,
  &quot;r&quot;,    114,
  &quot;s&quot;,    115,
  &quot;t&quot;,    116,
  &quot;u&quot;,    117,
  &quot;v&quot;,    118,
  &quot;w&quot;,    119,
  &quot;x&quot;,    120,
  &quot;y&quot;,    121,
  &quot;z&quot;,    122,
  &quot;|&quot;,    124,
  &quot;}&quot;,    125,
  &quot;~&quot;,    126,

  # Unicode tests
  &quot;ä&quot;,    228,
  &quot;€&quot;,    8364,
  &quot;»&quot;,    187,
  &quot;«&quot;,    171,

  # Special chars
  &quot;\o00&quot;, 0,
  &quot;\o01&quot;, 1,
  &quot;\o03&quot;, 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = &quot;\\{$code}{$code &gt;= 32 ?? &quot; == '{$char}'&quot; !! &quot;&quot;}&quot;;
  is ord($char), $code, &quot;ord() works for $descr&quot;;
  is chr($code), $char, &quot;chr() works for $descr&quot;;
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, &quot;ord(chr($code)) is $code&quot;;
}</pre>
</div>


<dt><a name="chr"
>chr</a></dt>

<dd>
<a name="msg_7"></a>
<a href="?hide_quotes=no#msg_7" onclick="return tog_quote(7);">
<div ID="header_shown_7" style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136) -
</div>
<div ID="header_hidden_7" style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136, 125 lines) -
</div>
</a>
<div ID="hide_7" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Conversions&quot; /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  &quot; &quot;,    32,
  &quot;!&quot;,    33,
  &quot;\&quot;&quot;,   34,
  &quot;#&quot;,    35,
  &quot;$&quot;,    36,
  &quot;%&quot;,    37,
  &quot;&amp;&quot;,    38,
  &quot;\'&quot;,   39,
  &quot;(&quot;,    40,
  &quot;)&quot;,    41,
  &quot;*&quot;,    42,
  &quot;+&quot;,    43,
  &quot;,&quot;,    44,
  &quot;-&quot;,    45,
  &quot;.&quot;,    46,
  &quot;/&quot;,    47,
  &quot;0&quot;,    48,
  &quot;1&quot;,    49,
  &quot;2&quot;,    50,
  &quot;3&quot;,    51,
  &quot;4&quot;,    52,
  &quot;5&quot;,    53,
  &quot;6&quot;,    54,
  &quot;7&quot;,    55,
  &quot;8&quot;,    56,
  &quot;9&quot;,    57,
  &quot;:&quot;,    58,
  &quot;;&quot;,    59,
  &quot;&lt;&quot;,    60,
  &quot;=&quot;,    61,
  &quot;&gt;&quot;,    62,
  &quot;?&quot;,    63,
  &quot;@&quot;,    64,
  &quot;A&quot;,    65,
  &quot;B&quot;,    66,
  &quot;C&quot;,    67,
  &quot;D&quot;,    68,
  &quot;E&quot;,    69,
  &quot;F&quot;,    70,
  &quot;G&quot;,    71,
  &quot;H&quot;,    72,
  &quot;I&quot;,    73,
  &quot;J&quot;,    74,
  &quot;K&quot;,    75,
  &quot;L&quot;,    76,
  &quot;M&quot;,    77,
  &quot;N&quot;,    78,
  &quot;O&quot;,    79,
  &quot;P&quot;,    80,
  &quot;Q&quot;,    81,
  &quot;R&quot;,    82,
  &quot;S&quot;,    83,
  &quot;T&quot;,    84,
  &quot;U&quot;,    85,
  &quot;V&quot;,    86,
  &quot;W&quot;,    87,
  &quot;X&quot;,    88,
  &quot;Y&quot;,    89,
  &quot;Z&quot;,    90,
  &quot;[&quot;,    91,
  &quot;\\&quot;,   92,
  &quot;]&quot;,    93,
  &quot;^&quot;,    94,
  &quot;_&quot;,    95,
  &quot;`&quot;,    96,
  &quot;a&quot;,    97,
  &quot;b&quot;,    98,
  &quot;c&quot;,    99,
  &quot;d&quot;,    100,
  &quot;e&quot;,    101,
  &quot;f&quot;,    102,
  &quot;g&quot;,    103,
  &quot;h&quot;,    104,
  &quot;i&quot;,    105,
  &quot;j&quot;,    106,
  &quot;k&quot;,    107,
  &quot;l&quot;,    108,
  &quot;m&quot;,    109,
  &quot;n&quot;,    110,
  &quot;o&quot;,    111,
  &quot;p&quot;,    112,
  &quot;q&quot;,    113,
  &quot;r&quot;,    114,
  &quot;s&quot;,    115,
  &quot;t&quot;,    116,
  &quot;u&quot;,    117,
  &quot;v&quot;,    118,
  &quot;w&quot;,    119,
  &quot;x&quot;,    120,
  &quot;y&quot;,    121,
  &quot;z&quot;,    122,
  &quot;|&quot;,    124,
  &quot;}&quot;,    125,
  &quot;~&quot;,    126,

  # Unicode tests
  &quot;ä&quot;,    228,
  &quot;€&quot;,    8364,
  &quot;»&quot;,    187,
  &quot;«&quot;,    171,

  # Special chars
  &quot;\o00&quot;, 0,
  &quot;\o01&quot;, 1,
  &quot;\o03&quot;, 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = &quot;\\{$code}{$code &gt;= 32 ?? &quot; == '{$char}'&quot; !! &quot;&quot;}&quot;;
  is ord($char), $code, &quot;ord() works for $descr&quot;;
  is chr($code), $char, &quot;chr() works for $descr&quot;;
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, &quot;ord(chr($code)) is $code&quot;;
}</pre>
</div>


<dt><a name="ord"
>ord</a></dt>

<dd>
<a name="msg_2"></a>
<a href="?hide_quotes=no#msg_2" onclick="return tog_quote(2);">
<div ID="header_shown_2" style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 136) -
</div>
<div ID="header_hidden_2" style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 136, 126 lines) -
</div>
</a>
<div ID="hide_2" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Conversions&quot; /ord/&gt;
# L&lt;S29/&quot;Conversions&quot; /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  &quot; &quot;,    32,
  &quot;!&quot;,    33,
  &quot;\&quot;&quot;,   34,
  &quot;#&quot;,    35,
  &quot;$&quot;,    36,
  &quot;%&quot;,    37,
  &quot;&amp;&quot;,    38,
  &quot;\'&quot;,   39,
  &quot;(&quot;,    40,
  &quot;)&quot;,    41,
  &quot;*&quot;,    42,
  &quot;+&quot;,    43,
  &quot;,&quot;,    44,
  &quot;-&quot;,    45,
  &quot;.&quot;,    46,
  &quot;/&quot;,    47,
  &quot;0&quot;,    48,
  &quot;1&quot;,    49,
  &quot;2&quot;,    50,
  &quot;3&quot;,    51,
  &quot;4&quot;,    52,
  &quot;5&quot;,    53,
  &quot;6&quot;,    54,
  &quot;7&quot;,    55,
  &quot;8&quot;,    56,
  &quot;9&quot;,    57,
  &quot;:&quot;,    58,
  &quot;;&quot;,    59,
  &quot;&lt;&quot;,    60,
  &quot;=&quot;,    61,
  &quot;&gt;&quot;,    62,
  &quot;?&quot;,    63,
  &quot;@&quot;,    64,
  &quot;A&quot;,    65,
  &quot;B&quot;,    66,
  &quot;C&quot;,    67,
  &quot;D&quot;,    68,
  &quot;E&quot;,    69,
  &quot;F&quot;,    70,
  &quot;G&quot;,    71,
  &quot;H&quot;,    72,
  &quot;I&quot;,    73,
  &quot;J&quot;,    74,
  &quot;K&quot;,    75,
  &quot;L&quot;,    76,
  &quot;M&quot;,    77,
  &quot;N&quot;,    78,
  &quot;O&quot;,    79,
  &quot;P&quot;,    80,
  &quot;Q&quot;,    81,
  &quot;R&quot;,    82,
  &quot;S&quot;,    83,
  &quot;T&quot;,    84,
  &quot;U&quot;,    85,
  &quot;V&quot;,    86,
  &quot;W&quot;,    87,
  &quot;X&quot;,    88,
  &quot;Y&quot;,    89,
  &quot;Z&quot;,    90,
  &quot;[&quot;,    91,
  &quot;\\&quot;,   92,
  &quot;]&quot;,    93,
  &quot;^&quot;,    94,
  &quot;_&quot;,    95,
  &quot;`&quot;,    96,
  &quot;a&quot;,    97,
  &quot;b&quot;,    98,
  &quot;c&quot;,    99,
  &quot;d&quot;,    100,
  &quot;e&quot;,    101,
  &quot;f&quot;,    102,
  &quot;g&quot;,    103,
  &quot;h&quot;,    104,
  &quot;i&quot;,    105,
  &quot;j&quot;,    106,
  &quot;k&quot;,    107,
  &quot;l&quot;,    108,
  &quot;m&quot;,    109,
  &quot;n&quot;,    110,
  &quot;o&quot;,    111,
  &quot;p&quot;,    112,
  &quot;q&quot;,    113,
  &quot;r&quot;,    114,
  &quot;s&quot;,    115,
  &quot;t&quot;,    116,
  &quot;u&quot;,    117,
  &quot;v&quot;,    118,
  &quot;w&quot;,    119,
  &quot;x&quot;,    120,
  &quot;y&quot;,    121,
  &quot;z&quot;,    122,
  &quot;|&quot;,    124,
  &quot;}&quot;,    125,
  &quot;~&quot;,    126,

  # Unicode tests
  &quot;ä&quot;,    228,
  &quot;€&quot;,    8364,
  &quot;»&quot;,    187,
  &quot;«&quot;,    171,

  # Special chars
  &quot;\o00&quot;, 0,
  &quot;\o01&quot;, 1,
  &quot;\o03&quot;, 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = &quot;\\{$code}{$code &gt;= 32 ?? &quot; == '{$char}'&quot; !! &quot;&quot;}&quot;;
  is ord($char), $code, &quot;ord() works for $descr&quot;;
  is chr($code), $char, &quot;chr() works for $descr&quot;;
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, &quot;ord(chr($code)) is $code&quot;;
}</pre>
</div>


<pre> our Uni multi Str::chr( Uni $codepoint )</pre>

<a name="msg_8"></a>
<a href="?hide_quotes=no#msg_8" onclick="return tog_quote(8);">
<div ID="header_shown_8" style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136) -
</div>
<div ID="header_hidden_8" style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136, 125 lines) -
</div>
</a>
<div ID="hide_8" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Conversions&quot; /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  &quot; &quot;,    32,
  &quot;!&quot;,    33,
  &quot;\&quot;&quot;,   34,
  &quot;#&quot;,    35,
  &quot;$&quot;,    36,
  &quot;%&quot;,    37,
  &quot;&amp;&quot;,    38,
  &quot;\'&quot;,   39,
  &quot;(&quot;,    40,
  &quot;)&quot;,    41,
  &quot;*&quot;,    42,
  &quot;+&quot;,    43,
  &quot;,&quot;,    44,
  &quot;-&quot;,    45,
  &quot;.&quot;,    46,
  &quot;/&quot;,    47,
  &quot;0&quot;,    48,
  &quot;1&quot;,    49,
  &quot;2&quot;,    50,
  &quot;3&quot;,    51,
  &quot;4&quot;,    52,
  &quot;5&quot;,    53,
  &quot;6&quot;,    54,
  &quot;7&quot;,    55,
  &quot;8&quot;,    56,
  &quot;9&quot;,    57,
  &quot;:&quot;,    58,
  &quot;;&quot;,    59,
  &quot;&lt;&quot;,    60,
  &quot;=&quot;,    61,
  &quot;&gt;&quot;,    62,
  &quot;?&quot;,    63,
  &quot;@&quot;,    64,
  &quot;A&quot;,    65,
  &quot;B&quot;,    66,
  &quot;C&quot;,    67,
  &quot;D&quot;,    68,
  &quot;E&quot;,    69,
  &quot;F&quot;,    70,
  &quot;G&quot;,    71,
  &quot;H&quot;,    72,
  &quot;I&quot;,    73,
  &quot;J&quot;,    74,
  &quot;K&quot;,    75,
  &quot;L&quot;,    76,
  &quot;M&quot;,    77,
  &quot;N&quot;,    78,
  &quot;O&quot;,    79,
  &quot;P&quot;,    80,
  &quot;Q&quot;,    81,
  &quot;R&quot;,    82,
  &quot;S&quot;,    83,
  &quot;T&quot;,    84,
  &quot;U&quot;,    85,
  &quot;V&quot;,    86,
  &quot;W&quot;,    87,
  &quot;X&quot;,    88,
  &quot;Y&quot;,    89,
  &quot;Z&quot;,    90,
  &quot;[&quot;,    91,
  &quot;\\&quot;,   92,
  &quot;]&quot;,    93,
  &quot;^&quot;,    94,
  &quot;_&quot;,    95,
  &quot;`&quot;,    96,
  &quot;a&quot;,    97,
  &quot;b&quot;,    98,
  &quot;c&quot;,    99,
  &quot;d&quot;,    100,
  &quot;e&quot;,    101,
  &quot;f&quot;,    102,
  &quot;g&quot;,    103,
  &quot;h&quot;,    104,
  &quot;i&quot;,    105,
  &quot;j&quot;,    106,
  &quot;k&quot;,    107,
  &quot;l&quot;,    108,
  &quot;m&quot;,    109,
  &quot;n&quot;,    110,
  &quot;o&quot;,    111,
  &quot;p&quot;,    112,
  &quot;q&quot;,    113,
  &quot;r&quot;,    114,
  &quot;s&quot;,    115,
  &quot;t&quot;,    116,
  &quot;u&quot;,    117,
  &quot;v&quot;,    118,
  &quot;w&quot;,    119,
  &quot;x&quot;,    120,
  &quot;y&quot;,    121,
  &quot;z&quot;,    122,
  &quot;|&quot;,    124,
  &quot;}&quot;,    125,
  &quot;~&quot;,    126,

  # Unicode tests
  &quot;ä&quot;,    228,
  &quot;€&quot;,    8364,
  &quot;»&quot;,    187,
  &quot;«&quot;,    171,

  # Special chars
  &quot;\o00&quot;, 0,
  &quot;\o01&quot;, 1,
  &quot;\o03&quot;, 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = &quot;\\{$code}{$code &gt;= 32 ?? &quot; == '{$char}'&quot; !! &quot;&quot;}&quot;;
  is ord($char), $code, &quot;ord() works for $descr&quot;;
  is chr($code), $char, &quot;chr() works for $descr&quot;;
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, &quot;ord(chr($code)) is $code&quot;;
}</pre>
</div>


<pre> our Uni multi Str::ord( Uni $character )</pre>

<a name="msg_3"></a>
<a href="?hide_quotes=no#msg_3" onclick="return tog_quote(3);">
<div ID="header_shown_3" style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 136) -
</div>
<div ID="header_hidden_3" style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 136, 126 lines) -
</div>
</a>
<div ID="hide_3" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Conversions&quot; /ord/&gt;
# L&lt;S29/&quot;Conversions&quot; /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  &quot; &quot;,    32,
  &quot;!&quot;,    33,
  &quot;\&quot;&quot;,   34,
  &quot;#&quot;,    35,
  &quot;$&quot;,    36,
  &quot;%&quot;,    37,
  &quot;&amp;&quot;,    38,
  &quot;\'&quot;,   39,
  &quot;(&quot;,    40,
  &quot;)&quot;,    41,
  &quot;*&quot;,    42,
  &quot;+&quot;,    43,
  &quot;,&quot;,    44,
  &quot;-&quot;,    45,
  &quot;.&quot;,    46,
  &quot;/&quot;,    47,
  &quot;0&quot;,    48,
  &quot;1&quot;,    49,
  &quot;2&quot;,    50,
  &quot;3&quot;,    51,
  &quot;4&quot;,    52,
  &quot;5&quot;,    53,
  &quot;6&quot;,    54,
  &quot;7&quot;,    55,
  &quot;8&quot;,    56,
  &quot;9&quot;,    57,
  &quot;:&quot;,    58,
  &quot;;&quot;,    59,
  &quot;&lt;&quot;,    60,
  &quot;=&quot;,    61,
  &quot;&gt;&quot;,    62,
  &quot;?&quot;,    63,
  &quot;@&quot;,    64,
  &quot;A&quot;,    65,
  &quot;B&quot;,    66,
  &quot;C&quot;,    67,
  &quot;D&quot;,    68,
  &quot;E&quot;,    69,
  &quot;F&quot;,    70,
  &quot;G&quot;,    71,
  &quot;H&quot;,    72,
  &quot;I&quot;,    73,
  &quot;J&quot;,    74,
  &quot;K&quot;,    75,
  &quot;L&quot;,    76,
  &quot;M&quot;,    77,
  &quot;N&quot;,    78,
  &quot;O&quot;,    79,
  &quot;P&quot;,    80,
  &quot;Q&quot;,    81,
  &quot;R&quot;,    82,
  &quot;S&quot;,    83,
  &quot;T&quot;,    84,
  &quot;U&quot;,    85,
  &quot;V&quot;,    86,
  &quot;W&quot;,    87,
  &quot;X&quot;,    88,
  &quot;Y&quot;,    89,
  &quot;Z&quot;,    90,
  &quot;[&quot;,    91,
  &quot;\\&quot;,   92,
  &quot;]&quot;,    93,
  &quot;^&quot;,    94,
  &quot;_&quot;,    95,
  &quot;`&quot;,    96,
  &quot;a&quot;,    97,
  &quot;b&quot;,    98,
  &quot;c&quot;,    99,
  &quot;d&quot;,    100,
  &quot;e&quot;,    101,
  &quot;f&quot;,    102,
  &quot;g&quot;,    103,
  &quot;h&quot;,    104,
  &quot;i&quot;,    105,
  &quot;j&quot;,    106,
  &quot;k&quot;,    107,
  &quot;l&quot;,    108,
  &quot;m&quot;,    109,
  &quot;n&quot;,    110,
  &quot;o&quot;,    111,
  &quot;p&quot;,    112,
  &quot;q&quot;,    113,
  &quot;r&quot;,    114,
  &quot;s&quot;,    115,
  &quot;t&quot;,    116,
  &quot;u&quot;,    117,
  &quot;v&quot;,    118,
  &quot;w&quot;,    119,
  &quot;x&quot;,    120,
  &quot;y&quot;,    121,
  &quot;z&quot;,    122,
  &quot;|&quot;,    124,
  &quot;}&quot;,    125,
  &quot;~&quot;,    126,

  # Unicode tests
  &quot;ä&quot;,    228,
  &quot;€&quot;,    8364,
  &quot;»&quot;,    187,
  &quot;«&quot;,    171,

  # Special chars
  &quot;\o00&quot;, 0,
  &quot;\o01&quot;, 1,
  &quot;\o03&quot;, 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = &quot;\\{$code}{$code &gt;= 32 ?? &quot; == '{$char}'&quot; !! &quot;&quot;}&quot;;
  is ord($char), $code, &quot;ord() works for $descr&quot;;
  is chr($code), $char, &quot;chr() works for $descr&quot;;
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, &quot;ord(chr($code)) is $code&quot;;
}</pre>
</div>


<pre> multi Str::ord( Str $string )</pre>

<a name="msg_4"></a>
<a href="?hide_quotes=no#msg_4" onclick="return tog_quote(4);">
<div ID="header_shown_4" style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 136) -
</div>
<div ID="header_hidden_4" style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 136, 126 lines) -
</div>
</a>
<div ID="hide_4" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Conversions&quot; /ord/&gt;
# L&lt;S29/&quot;Conversions&quot; /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  &quot; &quot;,    32,
  &quot;!&quot;,    33,
  &quot;\&quot;&quot;,   34,
  &quot;#&quot;,    35,
  &quot;$&quot;,    36,
  &quot;%&quot;,    37,
  &quot;&amp;&quot;,    38,
  &quot;\'&quot;,   39,
  &quot;(&quot;,    40,
  &quot;)&quot;,    41,
  &quot;*&quot;,    42,
  &quot;+&quot;,    43,
  &quot;,&quot;,    44,
  &quot;-&quot;,    45,
  &quot;.&quot;,    46,
  &quot;/&quot;,    47,
  &quot;0&quot;,    48,
  &quot;1&quot;,    49,
  &quot;2&quot;,    50,
  &quot;3&quot;,    51,
  &quot;4&quot;,    52,
  &quot;5&quot;,    53,
  &quot;6&quot;,    54,
  &quot;7&quot;,    55,
  &quot;8&quot;,    56,
  &quot;9&quot;,    57,
  &quot;:&quot;,    58,
  &quot;;&quot;,    59,
  &quot;&lt;&quot;,    60,
  &quot;=&quot;,    61,
  &quot;&gt;&quot;,    62,
  &quot;?&quot;,    63,
  &quot;@&quot;,    64,
  &quot;A&quot;,    65,
  &quot;B&quot;,    66,
  &quot;C&quot;,    67,
  &quot;D&quot;,    68,
  &quot;E&quot;,    69,
  &quot;F&quot;,    70,
  &quot;G&quot;,    71,
  &quot;H&quot;,    72,
  &quot;I&quot;,    73,
  &quot;J&quot;,    74,
  &quot;K&quot;,    75,
  &quot;L&quot;,    76,
  &quot;M&quot;,    77,
  &quot;N&quot;,    78,
  &quot;O&quot;,    79,
  &quot;P&quot;,    80,
  &quot;Q&quot;,    81,
  &quot;R&quot;,    82,
  &quot;S&quot;,    83,
  &quot;T&quot;,    84,
  &quot;U&quot;,    85,
  &quot;V&quot;,    86,
  &quot;W&quot;,    87,
  &quot;X&quot;,    88,
  &quot;Y&quot;,    89,
  &quot;Z&quot;,    90,
  &quot;[&quot;,    91,
  &quot;\\&quot;,   92,
  &quot;]&quot;,    93,
  &quot;^&quot;,    94,
  &quot;_&quot;,    95,
  &quot;`&quot;,    96,
  &quot;a&quot;,    97,
  &quot;b&quot;,    98,
  &quot;c&quot;,    99,
  &quot;d&quot;,    100,
  &quot;e&quot;,    101,
  &quot;f&quot;,    102,
  &quot;g&quot;,    103,
  &quot;h&quot;,    104,
  &quot;i&quot;,    105,
  &quot;j&quot;,    106,
  &quot;k&quot;,    107,
  &quot;l&quot;,    108,
  &quot;m&quot;,    109,
  &quot;n&quot;,    110,
  &quot;o&quot;,    111,
  &quot;p&quot;,    112,
  &quot;q&quot;,    113,
  &quot;r&quot;,    114,
  &quot;s&quot;,    115,
  &quot;t&quot;,    116,
  &quot;u&quot;,    117,
  &quot;v&quot;,    118,
  &quot;w&quot;,    119,
  &quot;x&quot;,    120,
  &quot;y&quot;,    121,
  &quot;z&quot;,    122,
  &quot;|&quot;,    124,
  &quot;}&quot;,    125,
  &quot;~&quot;,    126,

  # Unicode tests
  &quot;ä&quot;,    228,
  &quot;€&quot;,    8364,
  &quot;»&quot;,    187,
  &quot;«&quot;,    171,

  # Special chars
  &quot;\o00&quot;, 0,
  &quot;\o01&quot;, 1,
  &quot;\o03&quot;, 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = &quot;\\{$code}{$code &gt;= 32 ?? &quot; == '{$char}'&quot; !! &quot;&quot;}&quot;;
  is ord($char), $code, &quot;ord() works for $descr&quot;;
  is chr($code), $char, &quot;chr() works for $descr&quot;;
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, &quot;ord(chr($code)) is $code&quot;;
}</pre>
</div>


<p>These functions are available for purposes of backward compatibility. <code>chr</code> takes a <code>Uni</code> and returns the exact same value with no change. This is because, in Perl 6, a Uni is both an integer codepoint when numified and a single character when stringified. Thus, chr is just:</p>

<a name="msg_9"></a>
<a href="?hide_quotes=no#msg_9" onclick="return tog_quote(9);">
<div ID="header_shown_9" style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136) -
</div>
<div ID="header_hidden_9" style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136, 125 lines) -
</div>
</a>
<div ID="hide_9" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Conversions&quot; /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  &quot; &quot;,    32,
  &quot;!&quot;,    33,
  &quot;\&quot;&quot;,   34,
  &quot;#&quot;,    35,
  &quot;$&quot;,    36,
  &quot;%&quot;,    37,
  &quot;&amp;&quot;,    38,
  &quot;\'&quot;,   39,
  &quot;(&quot;,    40,
  &quot;)&quot;,    41,
  &quot;*&quot;,    42,
  &quot;+&quot;,    43,
  &quot;,&quot;,    44,
  &quot;-&quot;,    45,
  &quot;.&quot;,    46,
  &quot;/&quot;,    47,
  &quot;0&quot;,    48,
  &quot;1&quot;,    49,
  &quot;2&quot;,    50,
  &quot;3&quot;,    51,
  &quot;4&quot;,    52,
  &quot;5&quot;,    53,
  &quot;6&quot;,    54,
  &quot;7&quot;,    55,
  &quot;8&quot;,    56,
  &quot;9&quot;,    57,
  &quot;:&quot;,    58,
  &quot;;&quot;,    59,
  &quot;&lt;&quot;,    60,
  &quot;=&quot;,    61,
  &quot;&gt;&quot;,    62,
  &quot;?&quot;,    63,
  &quot;@&quot;,    64,
  &quot;A&quot;,    65,
  &quot;B&quot;,    66,
  &quot;C&quot;,    67,
  &quot;D&quot;,    68,
  &quot;E&quot;,    69,
  &quot;F&quot;,    70,
  &quot;G&quot;,    71,
  &quot;H&quot;,    72,
  &quot;I&quot;,    73,
  &quot;J&quot;,    74,
  &quot;K&quot;,    75,
  &quot;L&quot;,    76,
  &quot;M&quot;,    77,
  &quot;N&quot;,    78,
  &quot;O&quot;,    79,
  &quot;P&quot;,    80,
  &quot;Q&quot;,    81,
  &quot;R&quot;,    82,
  &quot;S&quot;,    83,
  &quot;T&quot;,    84,
  &quot;U&quot;,    85,
  &quot;V&quot;,    86,
  &quot;W&quot;,    87,
  &quot;X&quot;,    88,
  &quot;Y&quot;,    89,
  &quot;Z&quot;,    90,
  &quot;[&quot;,    91,
  &quot;\\&quot;,   92,
  &quot;]&quot;,    93,
  &quot;^&quot;,    94,
  &quot;_&quot;,    95,
  &quot;`&quot;,    96,
  &quot;a&quot;,    97,
  &quot;b&quot;,    98,
  &quot;c&quot;,    99,
  &quot;d&quot;,    100,
  &quot;e&quot;,    101,
  &quot;f&quot;,    102,
  &quot;g&quot;,    103,
  &quot;h&quot;,    104,
  &quot;i&quot;,    105,
  &quot;j&quot;,    106,
  &quot;k&quot;,    107,
  &quot;l&quot;,    108,
  &quot;m&quot;,    109,
  &quot;n&quot;,    110,
  &quot;o&quot;,    111,
  &quot;p&quot;,    112,
  &quot;q&quot;,    113,
  &quot;r&quot;,    114,
  &quot;s&quot;,    115,
  &quot;t&quot;,    116,
  &quot;u&quot;,    117,
  &quot;v&quot;,    118,
  &quot;w&quot;,    119,
  &quot;x&quot;,    120,
  &quot;y&quot;,    121,
  &quot;z&quot;,    122,
  &quot;|&quot;,    124,
  &quot;}&quot;,    125,
  &quot;~&quot;,    126,

  # Unicode tests
  &quot;ä&quot;,    228,
  &quot;€&quot;,    8364,
  &quot;»&quot;,    187,
  &quot;«&quot;,    171,

  # Special chars
  &quot;\o00&quot;, 0,
  &quot;\o01&quot;, 1,
  &quot;\o03&quot;, 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = &quot;\\{$code}{$code &gt;= 32 ?? &quot; == '{$char}'&quot; !! &quot;&quot;}&quot;;
  is ord($char), $code, &quot;ord() works for $descr&quot;;
  is chr($code), $char, &quot;chr() works for $descr&quot;;
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, &quot;ord(chr($code)) is $code&quot;;
}</pre>
</div>


<pre> our Uni multi Str::chr( Uni $codepoint) { $codepoint; }</pre>

<a name="msg_10"></a>
<a href="?hide_quotes=no#msg_10" onclick="return tog_quote(10);">
<div ID="header_shown_10" style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136) -
</div>
<div ID="header_hidden_10" style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136, 125 lines) -
</div>
</a>
<div ID="hide_10" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Conversions&quot; /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  &quot; &quot;,    32,
  &quot;!&quot;,    33,
  &quot;\&quot;&quot;,   34,
  &quot;#&quot;,    35,
  &quot;$&quot;,    36,
  &quot;%&quot;,    37,
  &quot;&amp;&quot;,    38,
  &quot;\'&quot;,   39,
  &quot;(&quot;,    40,
  &quot;)&quot;,    41,
  &quot;*&quot;,    42,
  &quot;+&quot;,    43,
  &quot;,&quot;,    44,
  &quot;-&quot;,    45,
  &quot;.&quot;,    46,
  &quot;/&quot;,    47,
  &quot;0&quot;,    48,
  &quot;1&quot;,    49,
  &quot;2&quot;,    50,
  &quot;3&quot;,    51,
  &quot;4&quot;,    52,
  &quot;5&quot;,    53,
  &quot;6&quot;,    54,
  &quot;7&quot;,    55,
  &quot;8&quot;,    56,
  &quot;9&quot;,    57,
  &quot;:&quot;,    58,
  &quot;;&quot;,    59,
  &quot;&lt;&quot;,    60,
  &quot;=&quot;,    61,
  &quot;&gt;&quot;,    62,
  &quot;?&quot;,    63,
  &quot;@&quot;,    64,
  &quot;A&quot;,    65,
  &quot;B&quot;,    66,
  &quot;C&quot;,    67,
  &quot;D&quot;,    68,
  &quot;E&quot;,    69,
  &quot;F&quot;,    70,
  &quot;G&quot;,    71,
  &quot;H&quot;,    72,
  &quot;I&quot;,    73,
  &quot;J&quot;,    74,
  &quot;K&quot;,    75,
  &quot;L&quot;,    76,
  &quot;M&quot;,    77,
  &quot;N&quot;,    78,
  &quot;O&quot;,    79,
  &quot;P&quot;,    80,
  &quot;Q&quot;,    81,
  &quot;R&quot;,    82,
  &quot;S&quot;,    83,
  &quot;T&quot;,    84,
  &quot;U&quot;,    85,
  &quot;V&quot;,    86,
  &quot;W&quot;,    87,
  &quot;X&quot;,    88,
  &quot;Y&quot;,    89,
  &quot;Z&quot;,    90,
  &quot;[&quot;,    91,
  &quot;\\&quot;,   92,
  &quot;]&quot;,    93,
  &quot;^&quot;,    94,
  &quot;_&quot;,    95,
  &quot;`&quot;,    96,
  &quot;a&quot;,    97,
  &quot;b&quot;,    98,
  &quot;c&quot;,    99,
  &quot;d&quot;,    100,
  &quot;e&quot;,    101,
  &quot;f&quot;,    102,
  &quot;g&quot;,    103,
  &quot;h&quot;,    104,
  &quot;i&quot;,    105,
  &quot;j&quot;,    106,
  &quot;k&quot;,    107,
  &quot;l&quot;,    108,
  &quot;m&quot;,    109,
  &quot;n&quot;,    110,
  &quot;o&quot;,    111,
  &quot;p&quot;,    112,
  &quot;q&quot;,    113,
  &quot;r&quot;,    114,
  &quot;s&quot;,    115,
  &quot;t&quot;,    116,
  &quot;u&quot;,    117,
  &quot;v&quot;,    118,
  &quot;w&quot;,    119,
  &quot;x&quot;,    120,
  &quot;y&quot;,    121,
  &quot;z&quot;,    122,
  &quot;|&quot;,    124,
  &quot;}&quot;,    125,
  &quot;~&quot;,    126,

  # Unicode tests
  &quot;ä&quot;,    228,
  &quot;€&quot;,    8364,
  &quot;»&quot;,    187,
  &quot;«&quot;,    171,

  # Special chars
  &quot;\o00&quot;, 0,
  &quot;\o01&quot;, 1,
  &quot;\o03&quot;, 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = &quot;\\{$code}{$code &gt;= 32 ?? &quot; == '{$char}'&quot; !! &quot;&quot;}&quot;;
  is ord($char), $code, &quot;ord() works for $descr&quot;;
  is chr($code), $char, &quot;chr() works for $descr&quot;;
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, &quot;ord(chr($code)) is $code&quot;;
}</pre>
</div>


<p><code>ord</code> is almost the same, but it also has a form that takes a string. In a scalar context, the return value is the <code>Uni</code> representing the first codepoint in the string. In a list context, the return value is the list of <code>Uni</code>s representing the entire string.</p>

<a name="msg_5"></a>
<a href="?hide_quotes=no#msg_5" onclick="return tog_quote(5);">
<div ID="header_shown_5" style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 136) -
</div>
<div ID="header_hidden_5" style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 136, 126 lines) -
</div>
</a>
<div ID="hide_5" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Conversions&quot; /ord/&gt;
# L&lt;S29/&quot;Conversions&quot; /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  &quot; &quot;,    32,
  &quot;!&quot;,    33,
  &quot;\&quot;&quot;,   34,
  &quot;#&quot;,    35,
  &quot;$&quot;,    36,
  &quot;%&quot;,    37,
  &quot;&amp;&quot;,    38,
  &quot;\'&quot;,   39,
  &quot;(&quot;,    40,
  &quot;)&quot;,    41,
  &quot;*&quot;,    42,
  &quot;+&quot;,    43,
  &quot;,&quot;,    44,
  &quot;-&quot;,    45,
  &quot;.&quot;,    46,
  &quot;/&quot;,    47,
  &quot;0&quot;,    48,
  &quot;1&quot;,    49,
  &quot;2&quot;,    50,
  &quot;3&quot;,    51,
  &quot;4&quot;,    52,
  &quot;5&quot;,    53,
  &quot;6&quot;,    54,
  &quot;7&quot;,    55,
  &quot;8&quot;,    56,
  &quot;9&quot;,    57,
  &quot;:&quot;,    58,
  &quot;;&quot;,    59,
  &quot;&lt;&quot;,    60,
  &quot;=&quot;,    61,
  &quot;&gt;&quot;,    62,
  &quot;?&quot;,    63,
  &quot;@&quot;,    64,
  &quot;A&quot;,    65,
  &quot;B&quot;,    66,
  &quot;C&quot;,    67,
  &quot;D&quot;,    68,
  &quot;E&quot;,    69,
  &quot;F&quot;,    70,
  &quot;G&quot;,    71,
  &quot;H&quot;,    72,
  &quot;I&quot;,    73,
  &quot;J&quot;,    74,
  &quot;K&quot;,    75,
  &quot;L&quot;,    76,
  &quot;M&quot;,    77,
  &quot;N&quot;,    78,
  &quot;O&quot;,    79,
  &quot;P&quot;,    80,
  &quot;Q&quot;,    81,
  &quot;R&quot;,    82,
  &quot;S&quot;,    83,
  &quot;T&quot;,    84,
  &quot;U&quot;,    85,
  &quot;V&quot;,    86,
  &quot;W&quot;,    87,
  &quot;X&quot;,    88,
  &quot;Y&quot;,    89,
  &quot;Z&quot;,    90,
  &quot;[&quot;,    91,
  &quot;\\&quot;,   92,
  &quot;]&quot;,    93,
  &quot;^&quot;,    94,
  &quot;_&quot;,    95,
  &quot;`&quot;,    96,
  &quot;a&quot;,    97,
  &quot;b&quot;,    98,
  &quot;c&quot;,    99,
  &quot;d&quot;,    100,
  &quot;e&quot;,    101,
  &quot;f&quot;,    102,
  &quot;g&quot;,    103,
  &quot;h&quot;,    104,
  &quot;i&quot;,    105,
  &quot;j&quot;,    106,
  &quot;k&quot;,    107,
  &quot;l&quot;,    108,
  &quot;m&quot;,    109,
  &quot;n&quot;,    110,
  &quot;o&quot;,    111,
  &quot;p&quot;,    112,
  &quot;q&quot;,    113,
  &quot;r&quot;,    114,
  &quot;s&quot;,    115,
  &quot;t&quot;,    116,
  &quot;u&quot;,    117,
  &quot;v&quot;,    118,
  &quot;w&quot;,    119,
  &quot;x&quot;,    120,
  &quot;y&quot;,    121,
  &quot;z&quot;,    122,
  &quot;|&quot;,    124,
  &quot;}&quot;,    125,
  &quot;~&quot;,    126,

  # Unicode tests
  &quot;ä&quot;,    228,
  &quot;€&quot;,    8364,
  &quot;»&quot;,    187,
  &quot;«&quot;,    171,

  # Special chars
  &quot;\o00&quot;, 0,
  &quot;\o01&quot;, 1,
  &quot;\o03&quot;, 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = &quot;\\{$code}{$code &gt;= 32 ?? &quot; == '{$char}'&quot; !! &quot;&quot;}&quot;;
  is ord($char), $code, &quot;ord() works for $descr&quot;;
  is chr($code), $char, &quot;chr() works for $descr&quot;;
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, &quot;ord(chr($code)) is $code&quot;;
}</pre>
</div>


<p>An integer can be passed to <code>chr</code>, but it will automatically be upgraded to a Uni (by interpreting it as a Unicode codepoint).</p>

<a name="msg_11"></a>
<a href="?hide_quotes=no#msg_11" onclick="return tog_quote(11);">
<div ID="header_shown_11" style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136) -
</div>
<div ID="header_hidden_11" style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136, 125 lines) -
</div>
</a>
<div ID="hide_11" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Conversions&quot; /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  &quot; &quot;,    32,
  &quot;!&quot;,    33,
  &quot;\&quot;&quot;,   34,
  &quot;#&quot;,    35,
  &quot;$&quot;,    36,
  &quot;%&quot;,    37,
  &quot;&amp;&quot;,    38,
  &quot;\'&quot;,   39,
  &quot;(&quot;,    40,
  &quot;)&quot;,    41,
  &quot;*&quot;,    42,
  &quot;+&quot;,    43,
  &quot;,&quot;,    44,
  &quot;-&quot;,    45,
  &quot;.&quot;,    46,
  &quot;/&quot;,    47,
  &quot;0&quot;,    48,
  &quot;1&quot;,    49,
  &quot;2&quot;,    50,
  &quot;3&quot;,    51,
  &quot;4&quot;,    52,
  &quot;5&quot;,    53,
  &quot;6&quot;,    54,
  &quot;7&quot;,    55,
  &quot;8&quot;,    56,
  &quot;9&quot;,    57,
  &quot;:&quot;,    58,
  &quot;;&quot;,    59,
  &quot;&lt;&quot;,    60,
  &quot;=&quot;,    61,
  &quot;&gt;&quot;,    62,
  &quot;?&quot;,    63,
  &quot;@&quot;,    64,
  &quot;A&quot;,    65,
  &quot;B&quot;,    66,
  &quot;C&quot;,    67,
  &quot;D&quot;,    68,
  &quot;E&quot;,    69,
  &quot;F&quot;,    70,
  &quot;G&quot;,    71,
  &quot;H&quot;,    72,
  &quot;I&quot;,    73,
  &quot;J&quot;,    74,
  &quot;K&quot;,    75,
  &quot;L&quot;,    76,
  &quot;M&quot;,    77,
  &quot;N&quot;,    78,
  &quot;O&quot;,    79,
  &quot;P&quot;,    80,
  &quot;Q&quot;,    81,
  &quot;R&quot;,    82,
  &quot;S&quot;,    83,
  &quot;T&quot;,    84,
  &quot;U&quot;,    85,
  &quot;V&quot;,    86,
  &quot;W&quot;,    87,
  &quot;X&quot;,    88,
  &quot;Y&quot;,    89,
  &quot;Z&quot;,    90,
  &quot;[&quot;,    91,
  &quot;\\&quot;,   92,
  &quot;]&quot;,    93,
  &quot;^&quot;,    94,
  &quot;_&quot;,    95,
  &quot;`&quot;,    96,
  &quot;a&quot;,    97,
  &quot;b&quot;,    98,
  &quot;c&quot;,    99,
  &quot;d&quot;,    100,
  &quot;e&quot;,    101,
  &quot;f&quot;,    102,
  &quot;g&quot;,    103,
  &quot;h&quot;,    104,
  &quot;i&quot;,    105,
  &quot;j&quot;,    106,
  &quot;k&quot;,    107,
  &quot;l&quot;,    108,
  &quot;m&quot;,    109,
  &quot;n&quot;,    110,
  &quot;o&quot;,    111,
  &quot;p&quot;,    112,
  &quot;q&quot;,    113,
  &quot;r&quot;,    114,
  &quot;s&quot;,    115,
  &quot;t&quot;,    116,
  &quot;u&quot;,    117,
  &quot;v&quot;,    118,
  &quot;w&quot;,    119,
  &quot;x&quot;,    120,
  &quot;y&quot;,    121,
  &quot;z&quot;,    122,
  &quot;|&quot;,    124,
  &quot;}&quot;,    125,
  &quot;~&quot;,    126,

  # Unicode tests
  &quot;ä&quot;,    228,
  &quot;€&quot;,    8364,
  &quot;»&quot;,    187,
  &quot;«&quot;,    171,

  # Special chars
  &quot;\o00&quot;, 0,
  &quot;\o01&quot;, 1,
  &quot;\o03&quot;, 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = &quot;\\{$code}{$code &gt;= 32 ?? &quot; == '{$char}'&quot; !! &quot;&quot;}&quot;;
  is ord($char), $code, &quot;ord() works for $descr&quot;;
  is chr($code), $char, &quot;chr() works for $descr&quot;;
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, &quot;ord(chr($code)) is $code&quot;;
}</pre>
</div>


<p>Be aware that the stringification of certain <code>Uni</code>s will fail because they have no stand-alone stringified interpretation. Similarly, the creation of a <code>Uni</code> from an integer might fail due to the integer being out of range. If that happens, an undefined <code>Uni</code> is always returned. Similarly, <code>chr(undef)</code> or <code>ord(undef)</code> will force the reutrn of an undefined <code>Uni</code>.</p>

<a name="msg_12"></a>
<a href="?hide_quotes=no#msg_12" onclick="return tog_quote(12);">
<div ID="header_shown_12" style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136) -
</div>
<div ID="header_hidden_12" style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136, 125 lines) -
</div>
</a>
<div ID="hide_12" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Conversions&quot; /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  &quot; &quot;,    32,
  &quot;!&quot;,    33,
  &quot;\&quot;&quot;,   34,
  &quot;#&quot;,    35,
  &quot;$&quot;,    36,
  &quot;%&quot;,    37,
  &quot;&amp;&quot;,    38,
  &quot;\'&quot;,   39,
  &quot;(&quot;,    40,
  &quot;)&quot;,    41,
  &quot;*&quot;,    42,
  &quot;+&quot;,    43,
  &quot;,&quot;,    44,
  &quot;-&quot;,    45,
  &quot;.&quot;,    46,
  &quot;/&quot;,    47,
  &quot;0&quot;,    48,
  &quot;1&quot;,    49,
  &quot;2&quot;,    50,
  &quot;3&quot;,    51,
  &quot;4&quot;,    52,
  &quot;5&quot;,    53,
  &quot;6&quot;,    54,
  &quot;7&quot;,    55,
  &quot;8&quot;,    56,
  &quot;9&quot;,    57,
  &quot;:&quot;,    58,
  &quot;;&quot;,    59,
  &quot;&lt;&quot;,    60,
  &quot;=&quot;,    61,
  &quot;&gt;&quot;,    62,
  &quot;?&quot;,    63,
  &quot;@&quot;,    64,
  &quot;A&quot;,    65,
  &quot;B&quot;,    66,
  &quot;C&quot;,    67,
  &quot;D&quot;,    68,
  &quot;E&quot;,    69,
  &quot;F&quot;,    70,
  &quot;G&quot;,    71,
  &quot;H&quot;,    72,
  &quot;I&quot;,    73,
  &quot;J&quot;,    74,
  &quot;K&quot;,    75,
  &quot;L&quot;,    76,
  &quot;M&quot;,    77,
  &quot;N&quot;,    78,
  &quot;O&quot;,    79,
  &quot;P&quot;,    80,
  &quot;Q&quot;,    81,
  &quot;R&quot;,    82,
  &quot;S&quot;,    83,
  &quot;T&quot;,    84,
  &quot;U&quot;,    85,
  &quot;V&quot;,    86,
  &quot;W&quot;,    87,
  &quot;X&quot;,    88,
  &quot;Y&quot;,    89,
  &quot;Z&quot;,    90,
  &quot;[&quot;,    91,
  &quot;\\&quot;,   92,
  &quot;]&quot;,    93,
  &quot;^&quot;,    94,
  &quot;_&quot;,    95,
  &quot;`&quot;,    96,
  &quot;a&quot;,    97,
  &quot;b&quot;,    98,
  &quot;c&quot;,    99,
  &quot;d&quot;,    100,
  &quot;e&quot;,    101,
  &quot;f&quot;,    102,
  &quot;g&quot;,    103,
  &quot;h&quot;,    104,
  &quot;i&quot;,    105,
  &quot;j&quot;,    106,
  &quot;k&quot;,    107,
  &quot;l&quot;,    108,
  &quot;m&quot;,    109,
  &quot;n&quot;,    110,
  &quot;o&quot;,    111,
  &quot;p&quot;,    112,
  &quot;q&quot;,    113,
  &quot;r&quot;,    114,
  &quot;s&quot;,    115,
  &quot;t&quot;,    116,
  &quot;u&quot;,    117,
  &quot;v&quot;,    118,
  &quot;w&quot;,    119,
  &quot;x&quot;,    120,
  &quot;y&quot;,    121,
  &quot;z&quot;,    122,
  &quot;|&quot;,    124,
  &quot;}&quot;,    125,
  &quot;~&quot;,    126,

  # Unicode tests
  &quot;ä&quot;,    228,
  &quot;€&quot;,    8364,
  &quot;»&quot;,    187,
  &quot;«&quot;,    171,

  # Special chars
  &quot;\o00&quot;, 0,
  &quot;\o01&quot;, 1,
  &quot;\o03&quot;, 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = &quot;\\{$code}{$code &gt;= 32 ?? &quot; == '{$char}'&quot; !! &quot;&quot;}&quot;;
  is ord($char), $code, &quot;ord() works for $descr&quot;;
  is chr($code), $char, &quot;chr() works for $descr&quot;;
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, &quot;ord(chr($code)) is $code&quot;;
}</pre>
</div>


<a name="msg_6"></a>
<a href="?hide_quotes=no#msg_6" onclick="return tog_quote(6);">
<div ID="header_shown_6" style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 136) -
</div>
<div ID="header_hidden_6" style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 136, 126 lines) -
</div>
</a>
<div ID="hide_6" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Conversions&quot; /ord/&gt;
# L&lt;S29/&quot;Conversions&quot; /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  &quot; &quot;,    32,
  &quot;!&quot;,    33,
  &quot;\&quot;&quot;,   34,
  &quot;#&quot;,    35,
  &quot;$&quot;,    36,
  &quot;%&quot;,    37,
  &quot;&amp;&quot;,    38,
  &quot;\'&quot;,   39,
  &quot;(&quot;,    40,
  &quot;)&quot;,    41,
  &quot;*&quot;,    42,
  &quot;+&quot;,    43,
  &quot;,&quot;,    44,
  &quot;-&quot;,    45,
  &quot;.&quot;,    46,
  &quot;/&quot;,    47,
  &quot;0&quot;,    48,
  &quot;1&quot;,    49,
  &quot;2&quot;,    50,
  &quot;3&quot;,    51,
  &quot;4&quot;,    52,
  &quot;5&quot;,    53,
  &quot;6&quot;,    54,
  &quot;7&quot;,    55,
  &quot;8&quot;,    56,
  &quot;9&quot;,    57,
  &quot;:&quot;,    58,
  &quot;;&quot;,    59,
  &quot;&lt;&quot;,    60,
  &quot;=&quot;,    61,
  &quot;&gt;&quot;,    62,
  &quot;?&quot;,    63,
  &quot;@&quot;,    64,
  &quot;A&quot;,    65,
  &quot;B&quot;,    66,
  &quot;C&quot;,    67,
  &quot;D&quot;,    68,
  &quot;E&quot;,    69,
  &quot;F&quot;,    70,
  &quot;G&quot;,    71,
  &quot;H&quot;,    72,
  &quot;I&quot;,    73,
  &quot;J&quot;,    74,
  &quot;K&quot;,    75,
  &quot;L&quot;,    76,
  &quot;M&quot;,    77,
  &quot;N&quot;,    78,
  &quot;O&quot;,    79,
  &quot;P&quot;,    80,
  &quot;Q&quot;,    81,
  &quot;R&quot;,    82,
  &quot;S&quot;,    83,
  &quot;T&quot;,    84,
  &quot;U&quot;,    85,
  &quot;V&quot;,    86,
  &quot;W&quot;,    87,
  &quot;X&quot;,    88,
  &quot;Y&quot;,    89,
  &quot;Z&quot;,    90,
  &quot;[&quot;,    91,
  &quot;\\&quot;,   92,
  &quot;]&quot;,    93,
  &quot;^&quot;,    94,
  &quot;_&quot;,    95,
  &quot;`&quot;,    96,
  &quot;a&quot;,    97,
  &quot;b&quot;,    98,
  &quot;c&quot;,    99,
  &quot;d&quot;,    100,
  &quot;e&quot;,    101,
  &quot;f&quot;,    102,
  &quot;g&quot;,    103,
  &quot;h&quot;,    104,
  &quot;i&quot;,    105,
  &quot;j&quot;,    106,
  &quot;k&quot;,    107,
  &quot;l&quot;,    108,
  &quot;m&quot;,    109,
  &quot;n&quot;,    110,
  &quot;o&quot;,    111,
  &quot;p&quot;,    112,
  &quot;q&quot;,    113,
  &quot;r&quot;,    114,
  &quot;s&quot;,    115,
  &quot;t&quot;,    116,
  &quot;u&quot;,    117,
  &quot;v&quot;,    118,
  &quot;w&quot;,    119,
  &quot;x&quot;,    120,
  &quot;y&quot;,    121,
  &quot;z&quot;,    122,
  &quot;|&quot;,    124,
  &quot;}&quot;,    125,
  &quot;~&quot;,    126,

  # Unicode tests
  &quot;ä&quot;,    228,
  &quot;€&quot;,    8364,
  &quot;»&quot;,    187,
  &quot;«&quot;,    171,

  # Special chars
  &quot;\o00&quot;, 0,
  &quot;\o01&quot;, 1,
  &quot;\o03&quot;, 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = &quot;\\{$code}{$code &gt;= 32 ?? &quot; == '{$char}'&quot; !! &quot;&quot;}&quot;;
  is ord($char), $code, &quot;ord() works for $descr&quot;;
  is chr($code), $char, &quot;chr() works for $descr&quot;;
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, &quot;ord(chr($code)) is $code&quot;;
}</pre>
</div>


<dt><a name="list"
>list</a></dt>

<dd>
<pre> our List multi Conversions::List::list ( *@list )</pre>

<p>Forces List Context on it&#39;s arguments, and returns them.</p>

<dt><a name="item"
>item</a></dt>

<dd>
<pre> our Item multi Conversions::Item::item ( $item )</pre>

<p>Forces generic Item context on its argument, and returns it.</p>

<dt><a name=":16,_:8,_:2,_:10"
>:16, :8, :2, :10</a></dt>

<dd>
<pre> our Num multi prefix:&#60;:16&#62; ( Str $hexstr )
 our Num multi prefix:&#60;:8&#62; ( Str $octstr )
 our Num multi prefix:&#60;:2&#62; ( Str $binstr )
 our Num multi prefix:&#60;:10&#62; ( Str $decstr )
 etc.</pre>

<p>Interprets string as a number, with a default hexadecimal/octal/binary/decimal radix. Any radix prefix (0b, 0d, 0x, 0o) mentioned inside the string will override this operator (this statement is true: 10 == :8(&#34;0d10&#34;)), except 0b and 0d will be interpreted as hex digits by :16 (<code>hex(&#34;0d10&#34;) == :16 &#34;0d10&#34;</code>). <code>fail</code>s on failure.</p>

<p>These aren&#39;t really functions, syntactically, but adverbial forms that just happen to allow a parenthesize argument. But more typically you&#39;ll see</p>

<pre>    :4&#60;222&#62;
    :16&#60;deadbeef&#62;</pre>

<p>and such.</p>

<p>Replaces Perl 5 <code>hex</code> and <code>oct</code>.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Time"
>Time</a></h2>

<dl>
<dt><a name="gmtime"
>gmtime</a></dt>

<dd>
<pre> our Time multi Time::gmtime ( Time $time? )
 our Time multi method Time::gmtime ( Time $time: )</pre>

<p>Identical to:</p>

<pre> Time::localtime(:$time,:tz&#60;GMT&#62;)</pre>

<dt><a name="localtime"
>localtime</a></dt>

<dd>
<pre> our Time multi Time::localtime ( Time $time?, Time::Zone $tz? )
 our Time multi method Time::localtime ( Time $time: Time::Zone $tz? )</pre>

<p>Returns a time object whose default timezone is <code>$tz</code> (or the system&#39;s default timezone if none is provided).</p>

<p>If used as a function, and no time is provided, the current time is used.</p>

<p>Note that no matter what, <code>$time</code>&#39;s concept of &#34;its timezone&#34; is discarded in favor of something new.</p>

<dt><a name="time"
>time</a></dt>

<dd>
<pre> our Time multi Time::time()</pre>

<p>Returns a <code>Time</code> object. There are a number of uses for this object, all of which can be found in the documentation for <code>Time</code>.</p>

<p>There is, by default, no timezone associated with this Time object, so whatever default the system has will take over if timezone-specific data is accessed.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="OS"
>OS</a></h2>

<dl>
<dt><a name="getpw"
>getpw</a></dt>

<dd>
<pre> our OS::PW multi OS::getpw()
 our OS::PW multi OS::getpw( Int $uid )
 our OS::PW multi OS::getpw( Str $name )

 our OS::PW multi method OS::PWEnt::getpw( OS::PWEnt $pw: )
 our OS::PW multi method OS::PWEnt::getpw( OS::PWEnt $pw: Int $uid )
 our OS::PW multi method OS::PWEnt::getpw( OS::PWEnt $pw: Str $name )</pre>

<p>The <code>getpw</code> function operates on system login information, returning data about users in the form of an <code>OS::PW</code> object (&#34;PW&#34; refers to the historical <code>getpw*</code> functions that are part of the POSIX standard, and stands for &#34;password&#34;).</p>

<p>When given no parameters, the &#34;next&#34; user entry is returned (<code>undef</code> is returned when the list of users has been exhausted).</p>

<p>When <code>$uid</code> is provided, a user with the given UID is found and returned. <code>undef</code> is returned if no matching entry is found.</p>

<p>When <code>$name</code> is provided, a user with the matching name is found and returned. <code>undef</code> is returned if no matching entry is found.</p>

<p>The return value is an object that represents the system-specific information about the user. When numified, this object returns the UID of the user. When stringified, this object returns the username.</p>

<p>Therefore, the typical convention of:</p>

<pre>  my Int $uid = getpw(~$name);</pre>

<p>and</p>

<pre>  my Str $name = getpw(+$uid);</pre>

<p>Will work as expected.</p>

<p>See the documentation for the <code>OS::PW</code> and <code>OS::PWEnt</code> classes for more information and the equivalent of the Perl 5 setpwent / endpwent functions.</p>

<p>WARNING: Even when used as a method on an <code>OS::PWEnt</code> object, there may be system-specific, global state associated with the implementation of these routines.</p>

<p>[Note: TODO setpgrp setpriority times -ajs ]</p>

<dt><a name="chroot"
>chroot</a></dt>

<dd>
<pre> our Bool multi OS::chroot ( Str $path = CALLER::&#60;$_&#62; )</pre>

<p>On POSIX systems, changes the context of the current process such that the &#34;root&#34; directory becomes <code>$path</code> and all rooted paths (those that begin with a leading path separator) are relative to that path. For security reasons, many operating systems limit this functionality to the superuser. The return value will be true on success.</p>

<dt><a name="getlogin"
>getlogin</a></dt>

<dd>
<pre> our Str multi OS::getlogin ()</pre>

<p>Returns the username of the account running the program. This may not be as secure as using <code>getpwuid</code> on some platforms.</p>

<dt><a name="kill"
>kill</a></dt>

<dd>
<pre> our Bool multi OS::kill ( OS::Signal $signal, Bool :$group, *@pids )
 our Bool multi method Conc::Proc::kill ( Conc::Proc $pid: OS::Signal $signal?, Bool :$group )</pre>

<p>Sends the given <code>$signal</code> to the process(es) given and returns a boolean value indicating success (true) if all of the processes existed and were sent the signal and failure (false) if any of the processes did not exist or the signal could not be delivered to them.</p>

<p>The <code>$signal</code> can be initialized from an integer signal number or a string. Common signals are:</p>

<pre> KILL - stop the process, do not allow it to exit gracefully
 TERM - stop the process, allow it to exit gracefully
 HUP  - Hangup, often used as a request to re-run from scratch
 STOP - Pause execution
 CONT - Continue after a STOP</pre>

<p>Consult your operating system documentation for the full list of signal names and numbers. For compatibility, a signal name may be prefixed with &#34;SIG&#34;.</p>

<p>The method form may omit the signal. In this case, the default signal is <code>&#39;TERM&#39;</code>.</p>

<p>If the <code>:group</code> named parameter is passed, <code>kill</code> will attempt to send the signal to a process <i>group</i> rather than a single process. This functionality is platform-specific.</p>

<p>The special signal <code>0</code> can be sent which does not actually deliver a signal at all, and is used to determine if processes are still running:</p>

<pre>  say &#34;Still running&#34; if $proc.kill(0);</pre>

<dt><a name="run"
>run</a></dt>

<dd>
<pre> our Conc::Proc::Status multi OS::run ( ; Str $command )
 our Conc::Proc::Status multi OS::run ( ; Str $path, *@args )
 our Conc::Proc::Status multi OS::run ( Str @path_and_args )

 our Conc::Proc multi OS::run ( ; Str $command, Bool :$bg! )
 our Conc::Proc multi OS::run ( ; Str $path, Bool :$bg!, *@args )
 our Conc::Proc multi OS::run ( Str @path_and_args, Bool :$bg! )</pre>

<p><code>run</code> executes an external program, and returns control to the caller once the program has exited.</p>

<p>The default form expects a single string argument which contains the full command-line. This command-line will be scanned for special characters that the operating system&#39;s shell might interpret such as <code>;</code> or embedded quotes. If any are found, the command will be run through a sub-shell in an operating system specific fashion (on POSIX systems, this means <code>sh -c</code>).</p>

<p>If called like this:</p>

<pre> run( :path&#60;&#39;/some/path&#39;&#62;, &#39;arg1&#39;, &#39;arg2&#39;, ... )</pre>

<p>or with a single array (containing both the path and arguments), then the path given is executed directly with no shell interpretation.</p>

<p>The return value is the exit status of the program, and can be evaluated in the following contexts:</p>

<pre> Bool - True = success; False = failure
 Int  - Exit status (per the .exit method)</pre>

<p>See <code>wait</code> for more detail on how the <code>Conc::Proc::Status</code> object is used.</p>

<p>On failure to execute, an undefined value is returned.</p>

<p>If the <code>:bg</code> named parameter is passed, the program will be executed in the background, and the run command will return as soon as the child process is created. This means that the object returned is actually a <code>Conc::Proc</code>, which represents the created process.</p>

<p>[ Note: should the :bg form take rw filehandles or is that over-overloading the functionality of run? Should run be the new open with</p>

<pre>        respect to executing external code? -ajs ]</pre>

<p>[ Note: system() should be renamed to sys() or sh() or run() or some such to avoid P5-induced boolean inversion confusion, plus Huffmanize it a little better. I&#39;m thinking run() might be best for MMD reasons. --law</p>

<p>Note: exec should also be renamed to something clearer and &#34;final&#34; and huffmanly longer. I&#39;m thinking runinstead(). And maybe the function behind qq:x should be rungather() rather than readpipe(). -law ]</p>

<dt><a name="runinstead"
>runinstead</a></dt>

<dd>
<pre> multi OS::runinstead ( ; Str $path, *@args )
 multi OS::runinstead ( ; Str $command )</pre>

<p>Identical to <code>run</code> except that it never returns. The executed program replaces the currently running program in memory.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Concurrency"
>Concurrency</a></h2>

<p>There are higher-level models of concurrency management in Perl (see <a href="http://search.cpan.org/perldoc?S17#Concurrency" class="podlinkpod"
>&#34;Concurrency&#34; in S17</a>). These functions are simply the lowest level tools</p>

<dl>
<dt><a name="fork"
>fork</a></dt>

<dd>
<pre> our Conc::Proc sub Conc::Processes::fork()</pre>

<p>Creates a copy of the current process. Both processes return from <code>fork</code>. The original process returns the <i>child</i> process as a <code>Conc::Proc</code> object. The newly created process returns the <i>parent</i> process as a <code>Conc::Proc</code> object. As with any Conc::Proc object, the child process object numifies to the process ID (OS dependent integer). However, the parent process object numifies to <code>0</code> so that the child and parent can distinguish each other.</p>

<p>Typical usage would be:</p>

<pre> if !defined(my $pid = fork) {
   die &#34;Error calling fork: $!&#34;;
 } elsif $pid == 0 {
   say &#34;I am the new child!&#34;;
   exit 0;
 } else {
   say &#34;I am the parent of {+$pid}&#34;;
   wait();
 }</pre>

<dt><a name="wait"
>wait</a></dt>

<dd>
<pre> our Conc::Proc::Status multi method Conc::Processes::wait( Conc::Proc $process: *%options )

 our Conc::Proc::Status multi Conc::Processes::wait ( Conc::Proc $process = -1, *%options )</pre>

<p>Waits for a child process to terminate and returns the status object for the child. This status object will numify to the process ID of the child that exited.</p>

<p>Important Conc::Proc::Status methods:</p>

<pre> .exit - Numeric exit value
 .pid - Process ID
 .signal - Signal number if any, otherwise 0</pre>

<p>For historical reasons there is a <code>.status</code> method which is equal to:</p>

<pre> ($status.exit +&#60; 8) +| $status.signal</pre>

<p>If <code>$process</code> is supplied, then wait will only return when the given process has exited. Either a full <code>Conc::Proc</code> object can be passed, or just a numeric process ID. A <code>-1</code> explicitly indicates that wait should return immediately if any child process exits.</p>

<p>When called in this way, the returned <code>Conc::Proc::Status</code> object will have a <code>.pid</code> of <code>-1</code> (which is also what it numifies to) if there was no such process to wait for.</p>

<p>The named options include:</p>

<dl>
<dt><a name="blocking"
>blocking</a></dt>

<dd>
<p>Defaults to true. If set to false, this forces wait to return immediately.</p>

<dt><a name="WNOHANG"
>WNOHANG</a></dt>

<dd>
<p>Exists for historical compatibility. <code>WNOHANG =</code> 1&#62; is identical to <code>blocking =</code> False&#62;.</p>
</dd>
</dl>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Obsolete"
>Obsolete</a></h2>

<dl>
<dt><a name="dbmopen,_dbmclose"
>dbmopen, dbmclose</a></dt>

<dd>
<pre> use DB_File;</pre>

<dt><a name="dump"
>dump</a></dt>

<dd>
<p>Dumped.</p>

<dt><a name="format,_formline,_write"
>format, formline, write</a></dt>

<dd>
<p>See Exegesis 7.</p>

<dt><a name="/[msg|sem|shm].*/"
>/[msg|sem|shm].*/</a></dt>

<dd>
<pre> use IPC::SysV;</pre>

<dt><a name="local"
>local</a></dt>

<dd>
<p>Replaced by <code>temp</code> which, unlike <code>local</code>, defaults to not changing the value.</p>

<dt><a name="lock"
>lock</a></dt>

<dd>
<p>See <a href="http://search.cpan.org/perldoc?S17#Concurrency" class="podlinkpod"
>&#34;Concurrency&#34; in S17</a>. <code>lock</code> has been replaced by <code>is atomic</code>.</p>

<dt><a name="ref"
>ref</a></dt>

<dd>
<p>There is no ref() any more, since it was almost always used to get the type name in Perl 5. If you really want the type name, you can use <code>$var.meta.name</code> or <code>$var.^name</code>. If you really want P5 ref semantics, use <code>Perl5::p5ref</code>.</p>

<p>But if you&#39;re just wanting to test against a type, you&#39;re likely better off performing an <code>isa</code> or <code>does</code> or <code>can</code>, or just <code>$var ~~ TYPE</code>.</p>

<dt><a name="reset"
>reset</a></dt>

<dd>
<p>Was there a <i>good</i> use for this?</p>

<dt><a name="prototype"
>prototype</a></dt>

<dd>
<pre> &#38;func.meta.signature;
 &#38;func.^signature;</pre>

<dt><a name="study"
>study</a></dt>

<dd>
<p>Algorithm was too Anglo-centric. Could be brought back if generalized somehow.</p>

<dt><a name="waitpid"
>waitpid</a></dt>

<dd>
<p><code>wait</code> can now be called with or without an optional process/pid.</p>

<dt><a name="%"
>%</a></dt>

<dd>
<pre> $num1 % $num2</pre>

<p>Does a floating point modulus operation, i.e. 5.5 % 1 == 0.5 and 5 % 2.5 == 0.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Pending_Apocalypse"
>Pending Apocalypse</a></h2>

<p>The following functions are classified by Apocalypse/Synopsis numbers.</p>

<dl>
<dt><a name="A/S14:_Tied_Variables"
>A/S14: Tied Variables</a></dt>

<dd>
<p>tie tied untie (now implemented as container classes? my $foo is ....? is tie the meta operation on the container type for &#39;rebless&#39; - macro tie ( $var, $class, *@args ) { CODE { variable($var).meta.rebless( $class, *@args ) } } )</p>

<p>These are replaced by container types. The compiler is free to assume that any lexical variable is never going to change its container type unless some representation is made to that effect in the declaration. Note: P5&#39;s tied() is roughly replaced by P6&#39;s variable().</p>

<dt><a name="A/S16:_IPC_/_IO_/_Signals"
>A/S16: IPC / IO / Signals</a></dt>

<dd>
<p>-X accept alarm bind binmode chown close closedir connect eof fcntl fileno flock getc getpeername /[get|set][host|net|proto|serv|sock].*/ glob ioctl link listen lstat mkdir open opendir pipe print printf read readdir readline readlink readpipe recv rename rewinddir rmdir seek seekdir select(both) send setsockopt shutdown slurp socket socketpair stat symlink syscall sysopen sysread sysseek syswrite tell telldir truncate umask unlink utime warn</p>

<dt><a name="A/S??:_OS_Interaction"
>A/S??: OS Interaction</a></dt>

<dd>
<p>chroot crypt getlogin /[get|set][pw|gr].*/ kill setpgrp setpriority times</p>

<p>... These are probably going to be part of POSIX, automatically imported to GLOBAL <b>if</b> the platform is the right one</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Unfile