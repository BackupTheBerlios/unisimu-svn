<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<meta HTTP-EQUIV="content-type" CONTENT="text/html; charset=UTF-8">
<head>
<title>Title</title>
<link rel="stylesheet" href="http://dev.perl.org/css/perl.css" type="text/css" />
<link rev="made" href="mailto:" />
<script language="javascript1.2"><!--
var agt = navigator.userAgent.toLowerCase();

var is_opera = (agt.indexOf("opera") != -1);
var is_ie = (agt.indexOf("msie") != -1) && document.all && !is_opera;
var is_ie5 = (agt.indexOf("msie 5") != -1) && document.all;

function tog() {
  // tog: toggle the visibility of html elements (arguments[1..]) from none to
  // arguments[0].  Return what should be returned in a javascript onevent().
  display = arguments[0];
  for( var i=1; i<arguments.length; i++ ) {    
    var x = document.getElementById(arguments[i]);
    if (!x) continue;
    if (x.style.display == "none" || x.style.display == "") {
      x.style.display = display;
    } else {
      x.style.display = "none";
    }
  } 

  var e = is_ie ? window.event : this;
  if (e) {
    if (is_ie) {
      e.cancelBubble = true;
      e.returnValue = false;
      return false;
    } else {
      return false;
    }
  }
}

function tog_quote( idnum ) {
  return tog( 'block', 'header_shown_' + idnum, 'header_hidden_' + idnum,
	   'hide_' + idnum );
}

//--></script>
</head>

<body>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" valign="middle">
<big><strong><span class="block">&nbsp;Title</span></strong></big>
</td></tr>
</table>

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#Title">Title</a></li>
	<li><a href="#Version">Version</a></li>
	<li><a href="#Notes">Notes</a></li>
	<ul>

		<li><a href="#Operators20vs2e20Functions">Operators vs. Functions</a></li>
	</ul>

	<li><a href="#Type20Declarations">Type Declarations</a></li>
	<li><a href="#Function20Packages">Function Packages</a></li>
	<ul>

		<li><a href="#Math3a3aBasic">Math::Basic</a></li>
		<li><a href="#Math3a3aTrig">Math::Trig</a></li>
		<li><a href="#Scalar">Scalar</a></li>
		<li><a href="#Container">Container</a></li>
		<li><a href="#Array">Array</a></li>
		<li><a href="#List">List</a></li>
		<li><a href="#Hash">Hash</a></li>
		<li><a href="#Str">Str</a></li>
		<li><a href="#Control3a3aBasic">Control::Basic</a></li>
		<li><a href="#Conversions">Conversions</a></li>
		<li><a href="#Time">Time</a></li>
		<li><a href="#OS">OS</a></li>
		<li><a href="#Concurrency">Concurrency</a></li>
		<li><a href="#Obsolete">Obsolete</a></li>
		<li><a href="#Pending20Apocalypse">Pending Apocalypse</a></li>
	</ul>

	<li><a href="#Additions">Additions</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Title">Title</a></h1>
<pre>
 Synopsis 29 - Builtin Functions</pre>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Version">Version</a></h1>
<pre>
 Author:        Rod Adams &lt;rod@rodadams.net&gt;
 Maintainer:    Larry Wall &lt;larry@wall.org&gt;
 Contributions: Aaron Sherman &lt;ajs@ajs.com&gt;
 Date:          12 Mar 2005
 Last Modified: 08 Jul 2006
 Version:       4</pre>
<p>This document attempts to document the list of builtin functions in Perl 6.
It assumes familiarity with Perl 5 and prior synopses.</p>
<p>The document is now the official S29.  It's still here in the pugs
repository temporarily to allow easy access to pugs implementors,
but eventually it will be copied over to svn.perl.org.  Despite its
being ``official'', feel free to hack on it as long as it's in the pugs
space.  -law</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Notes">Notes</a></h1>
<p>In Perl 6, all builtin functions belong to a named package. Not all
functions are guaranteed to be imported into the global package
<code>::*</code>. In addition, the list of functions imported into <code>::*</code> will be
subject to change with each release of Perl. Authors wishing to
``Future Proof'' their code should either specifically import the
functions they will be using, or always refer to the functions by their
full name.</p>
<p>After 6.0.0 comes out, global aliases will not be removed lightly,
and will never be removed at all without having gone through a
deprecation cycle of at least a year.  In any event, you can specify
that you want the interface for a particular version of Perl, and
that can be emulated by later versions of Perl to the extent that
security updates allow.</p>
<p>Where code is given here, it is intended to define semantics, not to
dictate implementation.</p>
<p>
</p>
<h2><a name="Operators20vs2e20Functions">Operators vs. Functions</a></h2>
<p>There is no particular difference between an operator and a function,
but for the sake of documentation, only functions declared without
specifying a grammatical category or with a category of <code>term:</code>
(see <a href="#synopsis2023a20bits20and20pieces">Synopsis 2: Bits and Pieces</a>) will be described as ``functions'',
and everything else as ``operators'' which are outside of the scope
of this document.</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Type20Declarations">Type Declarations</a></h1>
<p>The following type declarations are assumed:</p>
<dl>
<dt><strong><a name="item_AnyChar">AnyChar</a></strong><br />
</dt>
<dd>
The root class of all ``character'' types, regardless of level.
</dd>
<dd>
<p>This is a subtype of <code>Str</code>, limited to a length of 1 at it's highest
supported Unicode level.</p>
</dd>
<dd>
<p>The type name <code>Char</code> is aliased to the maximum supported Unicode level
in the current lexical scope (where ``current'' is taken to mean the
eventual lexical scope for generic code (roles and macros), not the
scope in which the generic code is defined).  In other words, use <code>Char</code>
when you don't care which level you're writing for.</p>
</dd>
<dd>
<p>Subclasses (things that are <code>isa AnyChar</code>):</p>
</dd>
<dl>
<dt><strong><a name="item_Ling">LinguaChar or Ling (language-defined characters)</a></strong><br />
</dt>
<dt><strong><a name="item_Graf">GraphemeChar or Graf (language-independent graphemes)</a></strong><br />
</dt>
<dt><strong><a name="item_Uni">CodePoint or Uni (Unicode codepoints)</a></strong><br />
</dt>
<dt><strong><a name="item_Byte">Byte</a></strong><br />
</dt>
<dd>
Yes, Byte is both a string and a number.
</dd>
<p></p></dl>
<dt><strong><a name="item_MatchTest">MatchTest</a></strong><br />
</dt>
<dd>
<pre>
 subset MatchTest of Item | Junction;</pre>
</dd>
<dd>
<p>Used to supply a test to match against. Assume <code>~~</code> will be used against it.</p>
</dd>
</dl>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Function20Packages">Function Packages</a></h1>
<p>
</p>
<h2><a name="Math3a3aBasic">Math::Basic</a></h2>
<p><strong>API document</strong>: <a href="./Math/Basic.html">the Math::Basic manpage</a></p>
<p><code>Math::Basic</code> provides a number of constants in addition to the basic
mathematical functions. To get these constants, you must request
them:</p>
<pre>
 use Math::Basic :constants;</pre>
<p>or use the full name, e.g. <code>Math::Basic::pi</code>.</p>
<dl>
<dt><strong><a name="item_abs">abs</a></strong><br />
</dt>
<dd>
<pre>
 our Num multi Math::Basic::abs ( Num $x )</pre>
</dd>
<dd>
<p>Absolute Value.</p>
</dd>
<dt><strong><a name="item_floor">floor</a></strong><br />
</dt>
<dd>
<pre>
 our Int multi Math::Basic::floor ( Num $x )</pre>
</dd>
<dd>
<p>Returns the highest integer not greater than $x.</p>
</dd>
<dt><strong><a name="item_ceiling">ceiling</a></strong><br />
</dt>
<dd>
<pre>
 our Int multi Math::Basic::ceiling ( Num $x )
 our Int multi Math::Basic::ceil ( Num $x )</pre>
</dd>
<dd>
<p>Returns the lowest integer not less than $x.</p>
</dd>
<dt><strong><a name="item_round">round</a></strong><br />
</dt>
<dd>
<pre>
 our Int multi Math::Basic::round ( Num $x )</pre>
</dd>
<dd>
<p>Returns the nearest integer to $x.  The algorithm is floor($x + 0.5).
(Other rounding algorithms will be given extended names beginning with ``round''.)</p>
</dd>
<dt><strong><a name="item_truncate">truncate</a></strong><br />
</dt>
<dd>
<pre>
 our Int multi Math::Basic::truncate ( Num $x )
 our Int multi Math::Basic::int ( Num $x )</pre>
</dd>
<dd>
<p>Returns the closest integer to $x whose absolute value is not greater
than the absolute value of $x.  (In other words, just chuck any
fractional part.)  This is the default rounding function used by an
<code>int()</code> cast, for historic reasons.  But see Int constructor above
for a rounded version.</p>
</dd>
<dt><strong><a name="item_exp">exp</a></strong><br />
</dt>
<dd>
<pre>
 our Num multi Math::Basic::exp ( Num $exponent, Num :$base = Num::e )</pre>
</dd>
<dd>
<p>Performs similar to <code>$base ** $exponent</code>. <code>$base</code> defaults to the
constant <em>e</em>.</p>
</dd>
<dt><strong><a name="item_log">log</a></strong><br />
</dt>
<dd>
<pre>
 our Num multi Math::Basic::log ( Num $x, Num :$base )</pre>
</dd>
<dd>
<p>Logarithm of base <code>$base</code>, default Natural. Calling with <code>$x == 0</code> is an
error.</p>
</dd>
<dt><strong><a name="item_log10">log10</a></strong><br />
</dt>
<dd>
<pre>
 our Num multi Math::Basic::log10 (Num $x);</pre>
</dd>
<dd>
<p>A base <code>10</code> logarithm, othewise identical to <a href="#item_log"><code>log</code></a>.</p>
</dd>
<dt><strong><a name="item_rand">rand</a></strong><br />
</dt>
<a name="msg_108"></a>
<a href="?hide_quotes=no#msg_108" onclick="return tog_quote(108);">
<div ID=header_shown_108 style="display: none;">
- Hide the snippet from t/builtins/math/rand.t (line 13 ~ line 21) -
</div>
<div ID=header_hidden_108 style="display: block;">
- Show the snippet from t/builtins/math/rand.t (line 13 ~ line 21, 9 lines) -</div>
</a>
<div ID=hide_108 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Math::Basic" /rand/&gt;

ok(rand() &gt;= 0, 'rand() returns numbers greater than or equal to 0');
ok(rand() &lt; 1, 'rand() returns numbers less than 1');

for 1 .. 10 {
  ok rand(10) &gt;=  0, "rand(10) always returns numbers greater than or equal to 0 ($_)";
  ok rand(10)  &lt; 10, "rand(10) always returns numbers less than 10 ($_)";
}</pre>
</div><pre>
 our Num multi Math::Basic::rand ( Num $x = 1 )</pre>
<a name="msg_109"></a>
<a href="?hide_quotes=no#msg_109" onclick="return tog_quote(109);">
<div ID=header_shown_109 style="display: none;">
- Hide the snippet from t/builtins/math/rand.t (line 13 ~ line 21) -
</div>
<div ID=header_hidden_109 style="display: block;">
- Show the snippet from t/builtins/math/rand.t (line 13 ~ line 21, 9 lines) -</div>
</a>
<div ID=hide_109 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Math::Basic" /rand/&gt;

ok(rand() &gt;= 0, 'rand() returns numbers greater than or equal to 0');
ok(rand() &lt; 1, 'rand() returns numbers less than 1');

for 1 .. 10 {
  ok rand(10) &gt;=  0, "rand(10) always returns numbers greater than or equal to 0 ($_)";
  ok rand(10)  &lt; 10, "rand(10) always returns numbers less than 10 ($_)";
}</pre>
</div><p>Pseudo random number in range <code>0 ..^ $x</code>.  That is, <code>0</code> is theoretically possible,
while <code>$x</code> is not.</p>
<a name="msg_110"></a>
<a href="?hide_quotes=no#msg_110" onclick="return tog_quote(110);">
<div ID=header_shown_110 style="display: none;">
- Hide the snippet from t/builtins/math/rand.t (line 13 ~ line 21) -
</div>
<div ID=header_hidden_110 style="display: block;">
- Show the snippet from t/builtins/math/rand.t (line 13 ~ line 21, 9 lines) -</div>
</a>
<div ID=hide_110 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Math::Basic" /rand/&gt;

ok(rand() &gt;= 0, 'rand() returns numbers greater than or equal to 0');
ok(rand() &lt; 1, 'rand() returns numbers less than 1');

for 1 .. 10 {
  ok rand(10) &gt;=  0, "rand(10) always returns numbers greater than or equal to 0 ($_)";
  ok rand(10)  &lt; 10, "rand(10) always returns numbers less than 10 ($_)";
}</pre>
</div><dt><strong><a name="item_sign">sign</a></strong><br />
</dt>
<dd>
<pre>
 our Int multi Math::Basic::sign ( Num $x )</pre>
</dd>
<dd>
<p>Returns 1 when <code>$x</code> is greater than 0, -1 when it is less than 0, 0 when it
is equal to 0, or undefined when the value passed is undefined.</p>
</dd>
<dt><strong><a name="item_srand">srand</a></strong><br />
</dt>
<a name="msg_111"></a>
<a href="?hide_quotes=no#msg_111" onclick="return tog_quote(111);">
<div ID=header_shown_111 style="display: none;">
- Hide the snippet from t/builtins/math/rand.t (line 13 ~ line 21) -
</div>
<div ID=header_hidden_111 style="display: block;">
- Show the snippet from t/builtins/math/rand.t (line 13 ~ line 21, 9 lines) -</div>
</a>
<div ID=hide_111 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Math::Basic" /rand/&gt;

ok(rand() &gt;= 0, 'rand() returns numbers greater than or equal to 0');
ok(rand() &lt; 1, 'rand() returns numbers less than 1');

for 1 .. 10 {
  ok rand(10) &gt;=  0, "rand(10) always returns numbers greater than or equal to 0 ($_)";
  ok rand(10)  &lt; 10, "rand(10) always returns numbers less than 10 ($_)";
}</pre>
</div><pre>
 multi Math::Basic::srand ( Num $seed = default_seed_algorithm())</pre>
<a name="msg_112"></a>
<a href="?hide_quotes=no#msg_112" onclick="return tog_quote(112);">
<div ID=header_shown_112 style="display: none;">
- Hide the snippet from t/builtins/math/rand.t (line 13 ~ line 21) -
</div>
<div ID=header_hidden_112 style="display: block;">
- Show the snippet from t/builtins/math/rand.t (line 13 ~ line 21, 9 lines) -</div>
</a>
<div ID=hide_112 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Math::Basic" /rand/&gt;

ok(rand() &gt;= 0, 'rand() returns numbers greater than or equal to 0');
ok(rand() &lt; 1, 'rand() returns numbers less than 1');

for 1 .. 10 {
  ok rand(10) &gt;=  0, "rand(10) always returns numbers greater than or equal to 0 ($_)";
  ok rand(10)  &lt; 10, "rand(10) always returns numbers less than 10 ($_)";
}</pre>
</div><p>Seed the generator <a href="#item_rand"><code>rand</code></a> uses. <code>$seed</code> defaults to some combination
of various platform dependent characteristics to yield a non-deterministic seed.
Note that you get one <a href="#item_srand"><code>srand()</code></a> for free when you start a Perl program, so
you <em>must</em> call <a href="#item_srand"><code>srand()</code></a> yourself if you wish to specify a deterministic seed
(or if you wish to be differently nondeterministic).</p>
<a name="msg_113"></a>
<a href="?hide_quotes=no#msg_113" onclick="return tog_quote(113);">
<div ID=header_shown_113 style="display: none;">
- Hide the snippet from t/builtins/math/rand.t (line 13 ~ line 21) -
</div>
<div ID=header_hidden_113 style="display: block;">
- Show the snippet from t/builtins/math/rand.t (line 13 ~ line 21, 9 lines) -</div>
</a>
<div ID=hide_113 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Math::Basic" /rand/&gt;

ok(rand() &gt;= 0, 'rand() returns numbers greater than or equal to 0');
ok(rand() &lt; 1, 'rand() returns numbers less than 1');

for 1 .. 10 {
  ok rand(10) &gt;=  0, "rand(10) always returns numbers greater than or equal to 0 ($_)";
  ok rand(10)  &lt; 10, "rand(10) always returns numbers less than 10 ($_)";
}</pre>
</div><dt><strong><a name="item_sqrt">sqrt</a></strong><br />
</dt>
<dd>
<pre>
 our Num multi Math::Basic::sqrt ( Num $x )</pre>
</dd>
<dd>
<p>Returns the square root of the parameter.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="Math3a3aTrig">Math::Trig</a></h2>
<a name="msg_20"></a>
<a href="?hide_quotes=no#msg_20" onclick="return tog_quote(20);">
<div ID=header_shown_20 style="display: none;">
- Hide the snippet from t/builtins/math/trig.t (line 61 ~ line 102) -
</div>
<div ID=header_hidden_20 style="display: block;">
- Show the snippet from t/builtins/math/trig.t (line 61 ~ line 102, 42 lines) -</div>
</a>
<div ID=hide_20 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Math::Trig"&gt;
# -- sin, cos, tan
# sin
ok(approx(sin(0/4*$PI), 0));
ok(approx(sin(1/4*$PI), 1/2*sqrt(2)));
ok(approx(sin(2/4*$PI), 1));
ok(approx(sin(3/4*$PI), 1/2*sqrt(2)));
ok(approx(sin(4/4*$PI), 0));
ok(approx(sin(5/4*$PI), -1/2*sqrt(2)));
ok(approx(sin(6/4*$PI), -1));
ok(approx(sin(7/4*$PI), -1/2*sqrt(2)));
ok(approx(sin(8/4*$PI), 0));

# cos
ok(approx(cos(0/4*$PI), 1));
ok(approx(cos(1/4*$PI), 1/2*sqrt(2)));
ok(approx(cos(2/4*$PI), 0));
ok(approx(cos(3/4*$PI), -1/2*sqrt(2)));
ok(approx(cos(4/4*$PI), -1));
ok(approx(cos(5/4*$PI), -1/2*sqrt(2)));
ok(approx(cos(6/4*$PI), 0));
ok(approx(cos(7/4*$PI), 1/2*sqrt(2)));
ok(approx(cos(8/4*$PI), 1));

# tan
ok(approx(tan(0/4*$PI), 0));
ok(approx(tan(1/4*$PI), 1));
ok(approx(tan(3/4*$PI), -1));
ok(approx(tan(4/4*$PI), 0));
ok(approx(tan(5/4*$PI), 1));
ok(approx(tan(7/4*$PI), -1));
ok(approx(tan(8/4*$PI), 0));

# asin
ok(approx(try {asin(0)},            0));
ok(approx(try {asin(1/2*sqrt(2))},  1/4*$PI), :todo&lt;feature&gt;);
ok(approx(try {asin(1)},            2/4*$PI), :todo&lt;feature&gt;);

# acos
ok(approx(try {acos(0)},            2/4*$PI), :todo&lt;feature&gt;);
ok(approx(try {acos(1/2*sqrt(2))},  1/4*$PI), :todo&lt;feature&gt;);
ok(approx(try {acos(1)},            0/4*$PI));</pre>
</div><dl>
<dt><strong><a name="item_Standard_Trig_Functions"><em>Standard Trig Functions</em></a></strong><br />
</dt>
<dd>
<pre>
 our Num multi Num::func ( Num  $x, $base = 'radians' )
 our Num multi Math::Trig::func ( Num $x, $base = 'radians' )</pre>
</dd>
<dd>
<p>where <em>func</em> is one of:
sin, cos, tan, asin, acos, atan, sec, cosec, cotan, asec, acosec,
acotan, sinh, cosh, tanh, asinh, acosh, atanh, sech, cosech, cotanh,
asech, acosech, acotanh.</p>
</dd>
<dd>
<p>Performs the various trigonometric functions.</p>
</dd>
<dd>
<p>Option <code>$base</code> is used to declare how you measure your angles.
Given the value of an arc representing a single full revolution.</p>
</dd>
<dd>
<pre>
 $base          Result
 ----           -------
 /:i ^r/        Radians  (2*pi)
 /:i ^d/        Degrees  (360)
 /:i ^g/        Gradians (400)
 Num            Units of 1 revolution.</pre>
</dd>
<dd>
<p>Note that module currying can be used within a lexical scope to specify
a consistent base so you don't have to supply it with every call:</p>
</dd>
<dd>
<pre>
 my module Trig ::= Math::Trig.assuming(:base&lt;degrees&gt;);</pre>
</dd>
<dd>
<p>This overrides the default of ``radians''.</p>
</dd>
<dt><strong><a name="item_atan2">atan2</a></strong><br />
</dt>
<dd>
<pre>
 our Num multi Math::Trig::atan2 ( Num $y, Num $x = 1, Num $base )</pre>
</dd>
<dd>
<p>This second form of <code>atan</code> computes the arctangent of $y/$x, and takes
the quadrant into account. Otherwise behaves as other trigonometric functions.</p>
</dd>
<dd>
<p>[Note: changed atan back to atan2, or the default $x = 1 will confuse MMD.
The other alternative would be to remove the default. --law]</p>
</dd>
</dl>
<p>
</p>
<h2><a name="Scalar">Scalar</a></h2>
<dl>
<dt><strong><a name="item_defined">defined</a></strong><br />
</dt>
<dd>
<pre>
  our Bool multi Scalar::defined ( Any $thing )
  our Bool multi Scalar::defined ( Any $thing, ::role )
  our Bool multi method Scalar::defined ( Scalar $thing: )
  our Bool multi method Scalar::defined ( Scalar $thing: ::role )</pre>
</dd>
<dd>
<p><a href="#item_defined"><code>defined</code></a> returns true if the parameter has a value and that value is
not the undefined value (per <a href="#item_undef"><code>undef</code></a>), otherwise false is returned.</p>
</dd>
<dd>
<p>Same as Perl 5, only takes extra optional argument to ask if value is defined
with respect to a particular role:</p>
</dd>
<dd>
<pre>
    $x.defined(SomeRole);</pre>
</dd>
<dd>
<p>A value may be defined according to one role and undefined according to another.
Without the extra argument, defaults to the definition of defined supplied by
the type of the object.</p>
</dd>
<dt><strong><a name="item_undefine">undefine</a></strong><br />
</dt>
<dd>
<pre>
  our multi Any::undefine( Any $thing )
  our multi method Any::undefine ( Any $thing: )</pre>
</dd>
<dd>
<p>Takes any variable as a parameter and attempts to ``remove'' its
definition. For simple scalar variables this means assigning
the undefined value to the variable. For objects, this is equivalent
to invoking their undefine method. For arrays, hashes and other
complex data, this might require emptying the structures associated
with the object.</p>
</dd>
<dd>
<p>In all cases, calling <a href="#item_undefine"><code>undefine</code></a> on a variable
should place the object in the same state as if it was just
declared.</p>
</dd>
<dt><strong><a name="item_undef">undef</a></strong><br />
</dt>
<dd>
<pre>
  constant Scalar Scalar::undef</pre>
</dd>
<dd>
<p>Returns the undefined scalar object. <a href="#item_undef"><code>undef</code></a> has no value at
all, but for historical compatibility, it will numify to <code>0</code>
and stringify to the empty string, potentially generating a
warning in doing so. There are two ways to determine if a
value equal to undef: the <a href="#item_defined"><code>defined</code></a> function (or method) can
be called or the <code>//</code> (or <code>err</code>) operator can be used.</p>
</dd>
<dd>
<p><a href="#item_undef"><code>undef</code></a> is also considered to be false in a boolean context.
Such a conversion does not generate a warning.</p>
</dd>
<dd>
<p>Perl 5's unary <a href="#item_undef"><code>undef</code></a> function is renamed <a href="#item_undefine"><code>undefine</code></a> to avoid
confusion with the value <a href="#item_undef"><code>undef</code></a> (which is always 0-ary now).</p>
</dd>
</dl>
<p>
</p>
<h2><a name="Container">Container</a></h2>
<dl>
<dt><strong><a name="item_cat">cat</a></strong><br />
</dt>
<dd>
<pre>
 our Lazy multi Container::cat( *@@list );</pre>
</dd>
<dd>
<p><a href="#item_cat"><code>cat</code></a> reads arrays serially rather than in parallel as <a href="#item_each"><code>each</code></a> does. It
returns all of the elements of the containers that were passed to it
like so:</p>
</dd>
<dd>
<pre>
 cat(@a;@b;@c);</pre>
</dd>
<dd>
<p>Typically, you could just write <code>(@a,@b,@c)</code>, but sometimes
it's nice to be explicit about that:</p>
</dd>
<dd>
<pre>
 @foo := [[1,2,3],[4,5,6]]; say cat([;] @foo); # 1,2,3,4,5,6</pre>
</dd>
<dt><strong><a name="item_each">each</a></strong><br />
</dt>
<dd>
<pre>
 our Lazy multi Container::each( Bool :$shortest, Bool :$finite, *@@list )</pre>
</dd>
<dd>
<p>Unlike Perl 5's each, <a href="#item_each"><code>each</code></a> is a general method that traverses any
composite container in a type-specific manner. <a href="#item_each"><code>each</code></a> is like <a href="#item_zip"><code>zip</code></a>,
but does not create tuples as return values. An example of its
use is:</p>
</dd>
<dd>
<pre>
 for each(:parity, =&lt;&gt;; 1..*) -&gt; ($line, $lineno) {
   say &quot;$lineno: $line&quot;;
 }</pre>
</dd>
<dd>
<p>The optional <code>:shortest</code> named parameter causes <a href="#item_each"><code>each</code></a> to stop
processing its input lists as soon as <em>any</em> of them is exhausted.
This modifier can also be used on individual containers, causing
<a href="#item_each"><code>each</code></a> to stop when <em>that</em> parameter is empty.</p>
</dd>
<dd>
<p>The optional <code>:finite</code> named parameter causes <a href="#item_each"><code>each</code></a> to stop
processing its input lists as long as only those which are known
at run-time to represent infinite ranges are left.</p>
</dd>
<dd>
<p>For P5-like traversal, see <code>Hash::kv</code> or <code>Hash::pairs</code> instead,
and put into <code>for</code> instead of <code>while</code>.  Perhaps there is a
<code>Perl5::p5each</code> emulation.</p>
</dd>
<dt><strong><a name="item_roundrobin">roundrobin</a></strong><br />
</dt>
<dd>
<pre>
 our Lazy multi Container::roundrobin( Bool :$shortest, Bool :$finite, *@@list )</pre>
</dd>
<dd>
<p><a href="#item_roundrobin"><code>roundrobin</code></a> is very similar to <a href="#item_each"><code>each</code></a>, and in fact</p>
</dd>
<dd>
<pre>
 roundrobin( :shortest, @a; @b; @c );</pre>
</dd>
<dd>
<p>and</p>
</dd>
<dd>
<pre>
 each( :shortest, @a; @b; @c );</pre>
</dd>
<dd>
<p>Are exactly the same. The difference is that, by default <a href="#item_roundrobin"><code>roundrobin</code></a> will
not return <a href="#item_undef"><code>undef</code></a> as a ``spacer'' for an array that has been emptied. Thus:</p>
</dd>
<dd>
<pre>
 my @a = 1;
 my @b = 1..2;
 my @c = 1..3;
 for roundrobin( @a; @b; @c ) -&gt; $x { ... }</pre>
</dd>
<dd>
<p>will get the following values for <code>$x</code>: <code>1, 1, 1, 2, 2, 3</code></p>
</dd>
<dd>
<p><a href="#item_each"><code>each</code></a> would get: <code>1, 1, 1, 2, 2, undef, 3, undef, undef</code></p>
</dd>
<dt><strong><a name="item_zip">zip</a></strong><br />
</dt>
<dd>
<pre>
 our Iterator multi Container::zip ( Bool :$shortest, Bool :$finite, *@@list )
 our Iterator multi infix:Container::¥ ( Bool :$shortest, Bool :$finite, *@@list )
 our Iterator multi infix:Container::Y ( Bool :$shortest, Bool :$finite, *@@list )</pre>
</dd>
<dd>
<p>zip takes any number of arrays and returns one tuple for every index.
This is easier to read in an example:</p>
</dd>
<dd>
<pre>
 for zip(@a;@b;@c) -&gt; [$nth_a,$nth_b,$nth_c] {
   ...
 }</pre>
</dd>
<dd>
<p>mnemonic: the input arrays are ``zipped'' up like a zipper.</p>
</dd>
<dd>
<p>The optional <code>:shortest</code> named parameter causes <a href="#item_zip"><code>zip</code></a> to stop
processing its input lists as soon as <em>any</em> of them is exhausted.
This modifier can also be used on individual containers, causing
<a href="#item_zip"><code>zip</code></a> to stop when <em>that</em> parameter is empty.</p>
</dd>
<dd>
<p>The optional <code>:finite</code> named parameter causes <a href="#item_zip"><code>zip</code></a> to stop
processing its input lists as long as only those which are known
at run-time to represent infinite ranges are left.</p>
</dd>
<dd>
<p><code>¥</code> (and its ASCII equivalent, <code>Y</code>) is an infix equivalent for zip:</p>
</dd>
<dd>
<pre>
 for @a ¥ @b ¥ @c -&gt; [$a,$b,$c] {...}</pre>
</dd>
</dl>
<p>
</p>
<h2><a name="Array">Array</a></h2>
<dl>
<dt><strong><a name="item_delete">delete</a></strong><br />
</dt>
<dd>
<pre>
 our List multi method Array::delete (@array : *@indices )</pre>
</dd>
<dd>
<p>Sets elements specified by <code>@indices</code> in the invocant to a
non-existent state, as if they never had a value. Deleted elements at
the end of an Array shorten the length of the Array, unless doing so
would violate an <code>is shape()</code> definition.</p>
</dd>
<dd>
<p><code>@indices</code> is interpreted the same way as subscripting is in terms of
slices and multidimensionality. See Synopsis 9 for details.</p>
</dd>
<dd>
<p>Returns the <code>value(s)</code> previously held in deleted locations.</p>
</dd>
<dd>
<p>An unary form is expected. See <code>Hash::delete</code>.</p>
</dd>
<dt><strong><a name="item_exists">exists</a></strong><br />
</dt>
<dd>
<pre>
 our Bool multi method Array::exists (@array : Int *@indices )</pre>
</dd>
<dd>
<p>True if the specified Array element has been assigned to. This
is not the same as being defined.</p>
</dd>
<dd>
<p>Supplying a different number of indices than invocant has dimensions is
an error.</p>
</dd>
<dd>
<p>An unary form is expected. See <code>Hash::delete</code>.</p>
</dd>
<dt><strong><a name="item_pop">pop</a></strong><br />
</dt>
<dd>
<pre>
 our Scalar multi Array::pop ( @array is rw )
 our Scalar multi method Array::pop ( @array: )</pre>
</dd>
<dd>
<p>Remove the last element of <code>@array</code> and return it.</p>
</dd>
<dt><strong><a name="item_push">push</a></strong><br />
</dt>
<dd>
<pre>
 our Int multi Array::push ( @array is rw, *@values )
 our Int multi method Array::push ( @array: *@values )</pre>
</dd>
<dd>
<p>Add to the end of <code>@array</code>, all of the subsequent arguments.</p>
</dd>
<dt><strong><a name="item_shift">shift</a></strong><br />
</dt>
<dd>
<pre>
 our Scalar multi Array::shift ( @array is rw  )
 our Scalar multi method Array::shift ( @array:  )</pre>
</dd>
<dd>
<p>Remove the first element from <code>@array</code> and return it.</p>
</dd>
<dt><strong><a name="item_splice">splice</a></strong><br />
</dt>
<dd>
<pre>
 our List multi Array::splice( @array is rw, Int $offset = 0, Int $size?, *@values )</pre>
</dd>
<dd>
<p><a href="#item_splice"><code>splice</code></a> fills many niches in array-management, but its fundamental behavior
is to remove zero or more elements from an array and replace them with a
new (and potentially empty) list. This operation can shorten or lengthen
the target array.</p>
</dd>
<dd>
<p><code>$offset</code> is the index of the array element to start with. It defaults
to <code>0</code>.</p>
</dd>
<dd>
<p><code>$size</code> is the number of elements to remove from <code>@array</code>. It defaults
to removing the rest of the array from <code>$offset</code> on.</p>
</dd>
<dd>
<p>The slurpy list of values (if any) is then inserted at <code>$offset</code>.</p>
</dd>
<dd>
<p>Calling splice with a traditional parameter list, you must define <code>$offset</code>
and <code>$size</code> if you wish to pass a replacement list of values. To avoid
having to pass these otherwise optional parameters, use the piping operator(s):</p>
</dd>
<dd>
<pre>
 splice(@array,10) &lt;== 1..*;</pre>
</dd>
<dd>
<p>which replaces <code>@array[10]</code> and all subsequent elements with an infinite
series starting at <code>1</code>.</p>
</dd>
<dd>
<p>This behaves similarly to Perl 5's <a href="#item_splice"><code>splice</code></a>.</p>
</dd>
<dd>
<p>If <code>@array</code> is multidimensional, <a href="#item_splice"><code>splice</code></a> operates only on the first
dimension, and works with Array References.</p>
</dd>
<dt><strong><a name="item_unshift">unshift</a></strong><br />
</dt>
<dd>
<pre>
 our Int multi Array::unshift ( @array is rw, *@values )
 our Int multi method Array::unshift ( @array: *@values )</pre>
</dd>
<dd>
<p><a href="#item_unshift"><code>unshift</code></a> adds the values onto the start of the <code>@array</code>.</p>
</dd>
<dt><strong><a name="item_keys">keys</a></strong><br />
</dt>
<dt><strong><a name="item_kv">kv</a></strong><br />
</dt>
<dt><strong><a name="item_pairs">pairs</a></strong><br />
</dt>
<dt><strong><a name="item_values">values</a></strong><br />
</dt>
<dd>
<pre>
 multi Int|List Array::keys ( @array ; MatchTest *@indextests )
 multi Int|List Array::kv ( @array ; MatchTest *@indextests )
 multi Int|(List of Pair) Array::pairs  (@array ; MatchTest *@indextests )
 multi Int|List Array::values ( @array ; MatchTest *@indextests )</pre>
</dd>
<dd>
<p>(XXX these signatures are wrong. -luqui)</p>
</dd>
<dd>
<p>Iterates the elements of <code>@array</code>, in order.</p>
</dd>
<dd>
<p>If <code>@indextests</code> are provided, only elements whose indices match
<code>$index ~~ any(@indextests)</code> are iterated.</p>
</dd>
<dd>
<p>What is returned at each element of the iteration varies with function.
<a href="#item_values"><code>values</code></a> returns the value of the associated element; <a href="#item_kv"><code>kv</code></a> returns 
a 2 element list in (index, value) order, <a href="#item_pairs"><code>pairs</code></a> a <a href="#item_Pair"><code>Pair(index, value)</code></a>.</p>
</dd>
<dd>
<p><code>@array</code> is considered single dimensional. If it is in fact multi-dimensional,
the values returned will be array references to the sub array.</p>
</dd>
<dd>
<p>In Scalar context, they all return the count of elements that would have
been iterated.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="List">List</a></h2>
<dl>
<dt><strong><a name="item_grep">grep</a></strong><br />
</dt>
<dd>
<pre>
 our Lazy multi Array::grep ( @values, Code *&amp;test )
 our Lazy multi Array::grep ( @values, MatchTest $test )
 our Lazy multi List::grep ( MatchTest $test, *@values )</pre>
</dd>
<dd>
<p><a href="#item_grep"><code>grep</code></a> takes a list or array of values and returns a lazily evaluated
list comprised of all of the values from the original list for which
the <code>$test</code> smart-matches as true.</p>
</dd>
<dd>
<p>Here is an example of its use:</p>
</dd>
<dd>
<pre>
 @friends = grep { .is_friend } @coworkers;</pre>
</dd>
<dd>
<p>This takes the array <code>@coworkers</code>, checks every element to see
which ones return true for the <code>.is_friend</code> method, and returns
the resulting list to store into <code>@friends</code>.</p>
</dd>
<dt><strong><a name="item_join">join</a></strong><br />
</dt>
<dd>
<pre>
 our Str multi Array::join ( @values, Str $separator? )
 our Str multi List::join ( Str $separator?, *@values )</pre>
</dd>
<dd>
<p><a href="#item_join"><code>join</code></a> returns a single string comprised of all of the elements
of <code>@values</code>, separated by <code>$separator</code>. The separator defaults
to a single space.</p>
</dd>
<dd>
<p>Given an empty list, <a href="#item_join"><code>join</code></a> returns the empty string.</p>
</dd>
<dt><strong><a name="item_map">map</a></strong><br />
</dt>
<dd>
<pre>
 our Lazy multi Array::map ( @values, Code *&amp;expression )
 our Lazy multi List::map ( Code $expression?, *@values )</pre>
</dd>
<dd>
<p><a href="#item_map"><code>map</code></a> returns a lazily evaluated list which is comprised of
the return value of the expression, evaluated once for every
one of the <code>@values</code> that are passed in.</p>
</dd>
<dd>
<p>Here is an example of its use:</p>
</dd>
<dd>
<pre>
 @addresses = map { %addresses_by_name&lt;$_&gt; } @names;</pre>
</dd>
<dd>
<p>Here we take an array of names, and look each name up in
<code>%addresses_by_name</code> in order to build the corresponding
list of addresses.</p>
</dd>
<dd>
<p>If the expression returns no values or multiple values, then the
resulting list may not be the same length as the number of values
that were passed. For example:</p>
</dd>
<dd>
<pre>
 @factors = map { prime_factors($_) } @composites;</pre>
</dd>
<dt><strong><a name="item_reduce">reduce</a></strong><br />
</dt>
<dd>
<pre>
 our Scalar multi Array::reduce ( @values ; Code *&amp;expression )
 our Scalar multi List::reduce ( Code $expression ; *@values )
   my $res;
   for @values -&gt; $cur {
     FIRST {$res = $cur; next;}
     $res = &amp;$expression($res, $cur);
   }
   $res;
 }</pre>
</dd>
<dt><strong><a name="item_reverse">reverse</a></strong><br />
</dt>
<dd>
<pre>
 our Hash multi Hash::reverse ( %hash ) {
   (my %result){%hash.values} = %hash.keys;
   %result;
 }</pre>
</dd>
<dd>
<pre>
 multi Lazy Array::reverse ( @values )
 multi Lazy List::reverse ( *@values ) {
    gather {
        1 while take pop @values;
    }
 }</pre>
</dd>
<dd>
<pre>
 multi Str Str::reverse ( $str ) {
    split('', $str).reverse.join
 )</pre>
</dd>
<dt><strong><a name="item_sort">sort</a></strong><br />
</dt>
<dd>
<pre>
 subset KeyExtractor of Code(Any --&gt; Any);
 subset Comparator   of Code(Any, Any --&gt; Int );
 subset SortCriterion of KeyExtractor | Comparator | Pair(KeyExtractor, Comparator);</pre>
</dd>
<dd>
<pre>
 our Array multi Array::sort( @values is rw, *&amp;by, Bit $inplace? )
 our Array multi Array::sort( @values is rw, SortCriterion @by, Bit $inplace? )
 our Array multi Array::sort( @values is rw, SortCriterion $by = &amp;infix:&lt;cmp&gt;, Bit $inplace? )</pre>
</dd>
<dd>
<pre>
 our List multi List::sort( SortCriterion @by,  *@values )
 our List multi List::sort( SortCriterion $by = &amp;infix:&lt;cmp&gt;, *@values )</pre>
</dd>
<dd>
<p>Returns <code>@values</code> sorted, using criteria <code>$by</code> or <code>@by</code> for
comparisons. <code>@by</code> differs from <code>$by</code> in that each criteria is
applied, in order, until a non-zero (tie) result is achieved.</p>
</dd>
<dd>
<p>Criterion can take a few different forms:</p>
</dd>
<dl>
<dt><strong><a name="item_Comparator">Comparator</a></strong><br />
</dt>
<dd>
A closure with arity of 2, which returns negative/zero/positive,
signaling the first argument should be before/tied with/after the
second in the final ordering of the List. aka ``The Perl 5 way''
</dd>
<p></p>
<dt><strong><a name="item_KeyExtractor">KeyExtractor</a></strong><br />
</dt>
<dd>
A closure with arity of 1, which returns the ``key'' by which to sort. If
the closure returns a Num, <code>&lt;=&gt;</code> is used for comparison,
otherwise <code>cmp</code>.
</dd>
<p></p>
<dt><strong><a name="item_Pair">Pair(KeyExtractor, Comparator)</a></strong><br />
</dt>
<dd>
A combination of the two methods above, for when one wishes to take
advantage of the internal caching of keys that is expected to happen,
but wishes to compare them with something other than <code>&lt;=&gt;</code> or
<code>cmp</code>.
</dd>
<p></p></dl>
<p>Any Criterion may receive either or both of the traits <code>is descending</code>
and <code>is insensitive</code> to reverse the order of sort, or the adjust the
case sensitivity of <code>cmp</code> as a Comparator.</p>
<p>If all criteria are exhausted when comparing two elements, sort should
return them in the same relative order they had in <code>@values</code>.</p>
<p>If <code>$inplace</code> is specified, the array is sorted in place.</p>
<p>See <a href="http://www.nntp.perl.org/group/perl.perl6.language/16578">http://www.nntp.perl.org/group/perl.perl6.language/16578</a> for more
details and examples.</p>
</dl>
<p>
</p>
<h2><a name="Hash">Hash</a></h2>
<dl>
<dt><strong>delete</strong><br />
</dt>
<dd>
<pre>
 our List  multi method Hash::delete ( *@keys )
 our Scalar multi method Hash::delete ( $key ) is default</pre>
</dd>
<dd>
<p>Deletes the elements specified by <code>$key</code> or <code>$keys</code> from the invocant.
returns the <code>value(s)</code> that were associated to those keys.</p>
</dd>
<dl>
<dt><strong><a name="item_Unary_Form">Unary Form</a></strong><br />
</dt>
<dd>
Implementations should create a suitable macro, or otherwise support the
unary form <code>delete %hash{$key}</code> in all its forms. Below are some
example translations. This list is <em>not</em> exhaustive.
</dd>
<dd>
<pre>
 delete %hash{$key}                %hash.delete{$key}
 delete %hash&lt;key&gt;                 %hash.delete{'key'}
 delete %hash&lt;key1&gt;{@keys}         %hash&lt;key1&gt;.delete{@keys}</pre>
</dd>
<p></p></dl>
<dt><strong>exists</strong><br />
</dt>
<dd>
<pre>
 our Bool multi method Hash::exists ( $key )</pre>
</dd>
<dd>
<p>True if invocant has an element whose key matches <code>$key</code>, false
otherwise.</p>
</dd>
<dd>
<p>A unary form is expected. See Hash::delete.</p>
</dd>
<dd>
<p>See also Code::exists to determine if a function has been declared.
(Use <a href="#item_defined"><code>defined()</code></a> to determine whether the function body is defined.
A body of ... counts as undefined.)</p>
</dd>
<dt><strong>keys</strong><br />
</dt>
<dt><strong>kv</strong><br />
</dt>
<dt><strong>pairs</strong><br />
</dt>
<dt><strong>values</strong><br />
</dt>
<dd>
<pre>
 multi Int|List Hash::keys ( %hash ; MatchTest *@keytests )
 multi Int|List Hash::kv ( %hash ; MatchTest *@keytests )
 multi Int|(List of Pair) Hash::pairs  (%hash ; MatchTest *@keytests )
 multi Int|List Hash::values ( %hash ; MatchTest *@keytests )</pre>
</dd>
<dd>
<p>Iterates the elements of <code>%hash</code> in no apparent order, but the order
will be the same between successive calls to these functions, as long as
<code>%hash</code> doesn't change.</p>
</dd>
<dd>
<p>If <code>@keytests</code> are provided, only elements whose keys evaluate
<code>$key ~~ any(@keytests)</code> as true are iterated.</p>
</dd>
<dd>
<p>What is returned at each element of the iteration varies with function.
<a href="#item_keys"><code>keys</code></a> only returns the key; <a href="#item_values"><code>values</code></a> the value; <a href="#item_kv"><code>kv</code></a> returns both as
a 2 element list in (key, value) order, <a href="#item_pairs"><code>pairs</code></a> a <a href="#item_Pair"><code>Pair(key, value)</code></a>.</p>
</dd>
<dd>
<p>Note that <code>kv %hash</code> returns the same as <a href="#item_zip"><code>zip(keys %hash; values %hash)</code></a></p>
</dd>
<dd>
<p>In Scalar context, they all return the count of elements that would have
been iterated.</p>
</dd>
<dd>
<p>The lvalue form of <a href="#item_keys"><code>keys</code></a> is not longer supported. Use the <code>.buckets</code>
property instead.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="Str">Str</a></h2>
<p>General notes about strings:</p>
<p>A Str can exist at several Unicode levels at once. Which level you
interact with typically depends on what your current lexical context has
declared the ``working Unicode level to be''. Default is GChar.</p>
<p>[Q: Default can't be LChar because we don't go into ``language'' mode unless there's
a specific language declaration saying either exactly what language
we're going into, or what environmental parameter to pay attention to
to select our language.  So I believe the default should be GChar. -law]</p>
<p>Attempting to use a string at a level higher it can support is handled
without warning. The current highest supported level of the string
is simply mapped Char for Char to the new higher level. However,
attempting to stuff something of a higher level a lower-level string
is an error (for example, attempting to store Kanji in a Byte string).
And explicit conversion function must be used to tell it how you want it
encoded.</p>
<p>Attempting to use a string at a level lower than what it supports is not
allowed.</p>
<p>If a function takes a <code>Str</code> and returns a <code>Str</code>, the returned <code>Str</code>
will support the same levels as the input, unless specified otherwise.</p>
<dl>
<dt><strong><a name="item_p5chop">p5chop</a></strong><br />
</dt>
<dd>
<pre>
 our Char multi P5emul::Str::p5chop ( Str  $string is rw )
 our Char multi P5emul::Str::p5chop ( Str *@strings = ($+_) is rw )</pre>
</dd>
<dd>
<p>Trims the last character from <code>$string</code>, and returns it. Called with a
list, it chops each item in turn, and returns the last character
chopped.</p>
</dd>
<dt><strong><a name="item_chop">chop</a></strong><br />
</dt>
<dd>
<pre>
 our Str method Str::chop ( Str  $string: )</pre>
</dd>
<dd>
<p>Returns string with one Char removed from the end.</p>
</dd>
<dt><strong><a name="item_p5chomp">p5chomp</a></strong><br />
</dt>
<a name="msg_29"></a>
<a href="?hide_quotes=no#msg_29" onclick="return tog_quote(29);">
<div ID=header_shown_29 style="display: none;">
- Hide the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116) -
</div>
<div ID=header_hidden_29 style="display: block;">
- Show the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116, 104 lines) -</div>
</a>
<div ID=hide_29 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /chomp/&gt;
# Also see L&lt;"http://use.perl.org/~autrijus/journal/25351"&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.

{
    my $foo = "foo\n";
    chomp($foo);
    is($foo, "foo\n", 'our variable was not yet chomped');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n\n";
    $foo .= chomp;
    is($foo, "foo\n", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\nbar\n";
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n ";
    $foo .= chomp;
    is($foo, "foo\n ", 'our variable is chomped with no effect');
}

{
    my $foo = "foo\n";
    my $chomped_foo = try { chomp($foo).newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo\n", 'and our variable was not chomped');
}

{
    my $foo = "foo\n";
    $foo .= chomp;
    my $chomped_foo = try { $foo.newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo", 'and our variable was chomped');
}

{
    my $foo = "foo\n\n";
    my $chomped = $foo.chomp;
    is($foo, "foo\n\n", ".chomp has no effect on the original string");
    is($chomped, "foo\n", ".chomp returns correctly chomped value");
    
    # $chomped.chomp.newline

    $chomped = $chomped.chomp;
    is($chomped, "foo", ".chomp returns correctly chomped value again");
}

# chomp in list context
{
    is_deeply(chomp(()), [], "chomp on empty list");
    is_deeply(chomp(("abc\n")), ("abc"), "one element list");
    is_deeply(chomp(("abc\n", "bcd\n")), ("abc", "bcd"), "two element list");
    is_deeply(("abc\n", "bcd\n").chomp, ("abc", "bcd"), "two element list");
}
{
    my @foo = ();
    my @bar = chomp @foo;
    is_deeply(@bar, @foo, "chomp empty array");
}
{
    my @foo = ("abc\n");
    my @bar = chomp @foo;
    my @baz = ("abc");
    is_deeply(@bar, @baz, "chomp array with one element");
}
{
    my @foo = ("abc\n", "bcd\n");
    my @bar = chomp @foo;
    my @baz = ("abc", "bcd");
    is_deeply(@bar, @baz, "chomp array with 2 elements");


    @bar = @foo.chomp;
    is_deeply(@bar, @baz, "chomp array with 2 elements");

    my @morgo = ("abc\n\n", "bcd\n\n");
    my @hapci = chomp @morgo;
    is_deeply(@hapci, @foo, "chomp array with 2 elements with duplicate newlines");

    my @szundi = @morgo.chomp;
    is_deeply(@szundi, @foo, "chomp array with 2 elements with duplicate newlines");
}

</pre>
</div><a name="msg_63"></a>
<a href="?hide_quotes=no#msg_63" onclick="return tog_quote(63);">
<div ID=header_shown_63 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_63 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_63 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><a name="msg_21"></a>
<a href="?hide_quotes=no#msg_21" onclick="return tog_quote(21);">
<div ID=header_shown_21 style="display: none;">
- Hide the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37) -
</div>
<div ID=header_hidden_21 style="display: block;">
- Show the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37, 25 lines) -</div>
</a>
<div ID=hide_21 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /chomp/&gt;
# Also see L&lt;"http://use.perl.org/~autrijus/journal/25351"&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.
# Since currently the behaviour with regards to arrays is not defined, I'm
# assuming the correct behaviour is an extension of the behaviour for
# a single string.

{
    my @foo = ("foo\n","bar\n","baz\n");
    chomp(@foo);
    is(@foo[0], "foo\n", '1st element was not yet chomped');
    is(@foo[1], "bar\n", '2nd element was not yet chomped');
    is(@foo[2], "baz\n", '3rd element was not yet chomped');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element chomped correctly');
    is(@foo[1], 'bar', '2nd element chomped correctly');
    is(@foo[2], 'baz', '3rd element chomped correctly');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element is chomped again with no effect');
    is(@foo[1], 'bar', '2nd element is chomped again with no effect');
    is(@foo[2], 'baz', '3rd element is chomped again with no effect');
}
</pre>
</div><a name="msg_64"></a>
<a href="?hide_quotes=no#msg_64" onclick="return tog_quote(64);">
<div ID=header_shown_64 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_64 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_64 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><a name="msg_30"></a>
<a href="?hide_quotes=no#msg_30" onclick="return tog_quote(30);">
<div ID=header_shown_30 style="display: none;">
- Hide the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116) -
</div>
<div ID=header_hidden_30 style="display: block;">
- Show the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116, 104 lines) -</div>
</a>
<div ID=hide_30 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /chomp/&gt;
# Also see L&lt;"http://use.perl.org/~autrijus/journal/25351"&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.

{
    my $foo = "foo\n";
    chomp($foo);
    is($foo, "foo\n", 'our variable was not yet chomped');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n\n";
    $foo .= chomp;
    is($foo, "foo\n", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\nbar\n";
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n ";
    $foo .= chomp;
    is($foo, "foo\n ", 'our variable is chomped with no effect');
}

{
    my $foo = "foo\n";
    my $chomped_foo = try { chomp($foo).newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo\n", 'and our variable was not chomped');
}

{
    my $foo = "foo\n";
    $foo .= chomp;
    my $chomped_foo = try { $foo.newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo", 'and our variable was chomped');
}

{
    my $foo = "foo\n\n";
    my $chomped = $foo.chomp;
    is($foo, "foo\n\n", ".chomp has no effect on the original string");
    is($chomped, "foo\n", ".chomp returns correctly chomped value");
    
    # $chomped.chomp.newline

    $chomped = $chomped.chomp;
    is($chomped, "foo", ".chomp returns correctly chomped value again");
}

# chomp in list context
{
    is_deeply(chomp(()), [], "chomp on empty list");
    is_deeply(chomp(("abc\n")), ("abc"), "one element list");
    is_deeply(chomp(("abc\n", "bcd\n")), ("abc", "bcd"), "two element list");
    is_deeply(("abc\n", "bcd\n").chomp, ("abc", "bcd"), "two element list");
}
{
    my @foo = ();
    my @bar = chomp @foo;
    is_deeply(@bar, @foo, "chomp empty array");
}
{
    my @foo = ("abc\n");
    my @bar = chomp @foo;
    my @baz = ("abc");
    is_deeply(@bar, @baz, "chomp array with one element");
}
{
    my @foo = ("abc\n", "bcd\n");
    my @bar = chomp @foo;
    my @baz = ("abc", "bcd");
    is_deeply(@bar, @baz, "chomp array with 2 elements");


    @bar = @foo.chomp;
    is_deeply(@bar, @baz, "chomp array with 2 elements");

    my @morgo = ("abc\n\n", "bcd\n\n");
    my @hapci = chomp @morgo;
    is_deeply(@hapci, @foo, "chomp array with 2 elements with duplicate newlines");

    my @szundi = @morgo.chomp;
    is_deeply(@szundi, @foo, "chomp array with 2 elements with duplicate newlines");
}

</pre>
</div><a name="msg_65"></a>
<a href="?hide_quotes=no#msg_65" onclick="return tog_quote(65);">
<div ID=header_shown_65 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_65 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_65 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><pre>
 our Int multi P5emul::Str::p5chomp ( Str  $string is rw )</pre>
<a name="msg_31"></a>
<a href="?hide_quotes=no#msg_31" onclick="return tog_quote(31);">
<div ID=header_shown_31 style="display: none;">
- Hide the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116) -
</div>
<div ID=header_hidden_31 style="display: block;">
- Show the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116, 104 lines) -</div>
</a>
<div ID=hide_31 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /chomp/&gt;
# Also see L&lt;"http://use.perl.org/~autrijus/journal/25351"&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.

{
    my $foo = "foo\n";
    chomp($foo);
    is($foo, "foo\n", 'our variable was not yet chomped');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n\n";
    $foo .= chomp;
    is($foo, "foo\n", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\nbar\n";
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n ";
    $foo .= chomp;
    is($foo, "foo\n ", 'our variable is chomped with no effect');
}

{
    my $foo = "foo\n";
    my $chomped_foo = try { chomp($foo).newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo\n", 'and our variable was not chomped');
}

{
    my $foo = "foo\n";
    $foo .= chomp;
    my $chomped_foo = try { $foo.newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo", 'and our variable was chomped');
}

{
    my $foo = "foo\n\n";
    my $chomped = $foo.chomp;
    is($foo, "foo\n\n", ".chomp has no effect on the original string");
    is($chomped, "foo\n", ".chomp returns correctly chomped value");
    
    # $chomped.chomp.newline

    $chomped = $chomped.chomp;
    is($chomped, "foo", ".chomp returns correctly chomped value again");
}

# chomp in list context
{
    is_deeply(chomp(()), [], "chomp on empty list");
    is_deeply(chomp(("abc\n")), ("abc"), "one element list");
    is_deeply(chomp(("abc\n", "bcd\n")), ("abc", "bcd"), "two element list");
    is_deeply(("abc\n", "bcd\n").chomp, ("abc", "bcd"), "two element list");
}
{
    my @foo = ();
    my @bar = chomp @foo;
    is_deeply(@bar, @foo, "chomp empty array");
}
{
    my @foo = ("abc\n");
    my @bar = chomp @foo;
    my @baz = ("abc");
    is_deeply(@bar, @baz, "chomp array with one element");
}
{
    my @foo = ("abc\n", "bcd\n");
    my @bar = chomp @foo;
    my @baz = ("abc", "bcd");
    is_deeply(@bar, @baz, "chomp array with 2 elements");


    @bar = @foo.chomp;
    is_deeply(@bar, @baz, "chomp array with 2 elements");

    my @morgo = ("abc\n\n", "bcd\n\n");
    my @hapci = chomp @morgo;
    is_deeply(@hapci, @foo, "chomp array with 2 elements with duplicate newlines");

    my @szundi = @morgo.chomp;
    is_deeply(@szundi, @foo, "chomp array with 2 elements with duplicate newlines");
}

</pre>
</div><a name="msg_66"></a>
<a href="?hide_quotes=no#msg_66" onclick="return tog_quote(66);">
<div ID=header_shown_66 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_66 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_66 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><a name="msg_22"></a>
<a href="?hide_quotes=no#msg_22" onclick="return tog_quote(22);">
<div ID=header_shown_22 style="display: none;">
- Hide the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37) -
</div>
<div ID=header_hidden_22 style="display: block;">
- Show the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37, 25 lines) -</div>
</a>
<div ID=hide_22 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /chomp/&gt;
# Also see L&lt;"http://use.perl.org/~autrijus/journal/25351"&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.
# Since currently the behaviour with regards to arrays is not defined, I'm
# assuming the correct behaviour is an extension of the behaviour for
# a single string.

{
    my @foo = ("foo\n","bar\n","baz\n");
    chomp(@foo);
    is(@foo[0], "foo\n", '1st element was not yet chomped');
    is(@foo[1], "bar\n", '2nd element was not yet chomped');
    is(@foo[2], "baz\n", '3rd element was not yet chomped');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element chomped correctly');
    is(@foo[1], 'bar', '2nd element chomped correctly');
    is(@foo[2], 'baz', '3rd element chomped correctly');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element is chomped again with no effect');
    is(@foo[1], 'bar', '2nd element is chomped again with no effect');
    is(@foo[2], 'baz', '3rd element is chomped again with no effect');
}
</pre>
</div><a name="msg_67"></a>
<a href="?hide_quotes=no#msg_67" onclick="return tog_quote(67);">
<div ID=header_shown_67 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_67 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_67 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><a name="msg_32"></a>
<a href="?hide_quotes=no#msg_32" onclick="return tog_quote(32);">
<div ID=header_shown_32 style="display: none;">
- Hide the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116) -
</div>
<div ID=header_hidden_32 style="display: block;">
- Show the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116, 104 lines) -</div>
</a>
<div ID=hide_32 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /chomp/&gt;
# Also see L&lt;"http://use.perl.org/~autrijus/journal/25351"&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.

{
    my $foo = "foo\n";
    chomp($foo);
    is($foo, "foo\n", 'our variable was not yet chomped');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n\n";
    $foo .= chomp;
    is($foo, "foo\n", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\nbar\n";
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n ";
    $foo .= chomp;
    is($foo, "foo\n ", 'our variable is chomped with no effect');
}

{
    my $foo = "foo\n";
    my $chomped_foo = try { chomp($foo).newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo\n", 'and our variable was not chomped');
}

{
    my $foo = "foo\n";
    $foo .= chomp;
    my $chomped_foo = try { $foo.newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo", 'and our variable was chomped');
}

{
    my $foo = "foo\n\n";
    my $chomped = $foo.chomp;
    is($foo, "foo\n\n", ".chomp has no effect on the original string");
    is($chomped, "foo\n", ".chomp returns correctly chomped value");
    
    # $chomped.chomp.newline

    $chomped = $chomped.chomp;
    is($chomped, "foo", ".chomp returns correctly chomped value again");
}

# chomp in list context
{
    is_deeply(chomp(()), [], "chomp on empty list");
    is_deeply(chomp(("abc\n")), ("abc"), "one element list");
    is_deeply(chomp(("abc\n", "bcd\n")), ("abc", "bcd"), "two element list");
    is_deeply(("abc\n", "bcd\n").chomp, ("abc", "bcd"), "two element list");
}
{
    my @foo = ();
    my @bar = chomp @foo;
    is_deeply(@bar, @foo, "chomp empty array");
}
{
    my @foo = ("abc\n");
    my @bar = chomp @foo;
    my @baz = ("abc");
    is_deeply(@bar, @baz, "chomp array with one element");
}
{
    my @foo = ("abc\n", "bcd\n");
    my @bar = chomp @foo;
    my @baz = ("abc", "bcd");
    is_deeply(@bar, @baz, "chomp array with 2 elements");


    @bar = @foo.chomp;
    is_deeply(@bar, @baz, "chomp array with 2 elements");

    my @morgo = ("abc\n\n", "bcd\n\n");
    my @hapci = chomp @morgo;
    is_deeply(@hapci, @foo, "chomp array with 2 elements with duplicate newlines");

    my @szundi = @morgo.chomp;
    is_deeply(@szundi, @foo, "chomp array with 2 elements with duplicate newlines");
}

</pre>
</div><a name="msg_68"></a>
<a href="?hide_quotes=no#msg_68" onclick="return tog_quote(68);">
<div ID=header_shown_68 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_68 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_68 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><pre>
 our Int multi P5emul::Str::p5chomp ( Str *@strings = ($+_) is rw )</pre>
<a name="msg_33"></a>
<a href="?hide_quotes=no#msg_33" onclick="return tog_quote(33);">
<div ID=header_shown_33 style="display: none;">
- Hide the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116) -
</div>
<div ID=header_hidden_33 style="display: block;">
- Show the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116, 104 lines) -</div>
</a>
<div ID=hide_33 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /chomp/&gt;
# Also see L&lt;"http://use.perl.org/~autrijus/journal/25351"&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.

{
    my $foo = "foo\n";
    chomp($foo);
    is($foo, "foo\n", 'our variable was not yet chomped');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n\n";
    $foo .= chomp;
    is($foo, "foo\n", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\nbar\n";
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n ";
    $foo .= chomp;
    is($foo, "foo\n ", 'our variable is chomped with no effect');
}

{
    my $foo = "foo\n";
    my $chomped_foo = try { chomp($foo).newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo\n", 'and our variable was not chomped');
}

{
    my $foo = "foo\n";
    $foo .= chomp;
    my $chomped_foo = try { $foo.newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo", 'and our variable was chomped');
}

{
    my $foo = "foo\n\n";
    my $chomped = $foo.chomp;
    is($foo, "foo\n\n", ".chomp has no effect on the original string");
    is($chomped, "foo\n", ".chomp returns correctly chomped value");
    
    # $chomped.chomp.newline

    $chomped = $chomped.chomp;
    is($chomped, "foo", ".chomp returns correctly chomped value again");
}

# chomp in list context
{
    is_deeply(chomp(()), [], "chomp on empty list");
    is_deeply(chomp(("abc\n")), ("abc"), "one element list");
    is_deeply(chomp(("abc\n", "bcd\n")), ("abc", "bcd"), "two element list");
    is_deeply(("abc\n", "bcd\n").chomp, ("abc", "bcd"), "two element list");
}
{
    my @foo = ();
    my @bar = chomp @foo;
    is_deeply(@bar, @foo, "chomp empty array");
}
{
    my @foo = ("abc\n");
    my @bar = chomp @foo;
    my @baz = ("abc");
    is_deeply(@bar, @baz, "chomp array with one element");
}
{
    my @foo = ("abc\n", "bcd\n");
    my @bar = chomp @foo;
    my @baz = ("abc", "bcd");
    is_deeply(@bar, @baz, "chomp array with 2 elements");


    @bar = @foo.chomp;
    is_deeply(@bar, @baz, "chomp array with 2 elements");

    my @morgo = ("abc\n\n", "bcd\n\n");
    my @hapci = chomp @morgo;
    is_deeply(@hapci, @foo, "chomp array with 2 elements with duplicate newlines");

    my @szundi = @morgo.chomp;
    is_deeply(@szundi, @foo, "chomp array with 2 elements with duplicate newlines");
}

</pre>
</div><a name="msg_69"></a>
<a href="?hide_quotes=no#msg_69" onclick="return tog_quote(69);">
<div ID=header_shown_69 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_69 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_69 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><a name="msg_23"></a>
<a href="?hide_quotes=no#msg_23" onclick="return tog_quote(23);">
<div ID=header_shown_23 style="display: none;">
- Hide the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37) -
</div>
<div ID=header_hidden_23 style="display: block;">
- Show the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37, 25 lines) -</div>
</a>
<div ID=hide_23 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /chomp/&gt;
# Also see L&lt;"http://use.perl.org/~autrijus/journal/25351"&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.
# Since currently the behaviour with regards to arrays is not defined, I'm
# assuming the correct behaviour is an extension of the behaviour for
# a single string.

{
    my @foo = ("foo\n","bar\n","baz\n");
    chomp(@foo);
    is(@foo[0], "foo\n", '1st element was not yet chomped');
    is(@foo[1], "bar\n", '2nd element was not yet chomped');
    is(@foo[2], "baz\n", '3rd element was not yet chomped');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element chomped correctly');
    is(@foo[1], 'bar', '2nd element chomped correctly');
    is(@foo[2], 'baz', '3rd element chomped correctly');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element is chomped again with no effect');
    is(@foo[1], 'bar', '2nd element is chomped again with no effect');
    is(@foo[2], 'baz', '3rd element is chomped again with no effect');
}
</pre>
</div><a name="msg_70"></a>
<a href="?hide_quotes=no#msg_70" onclick="return tog_quote(70);">
<div ID=header_shown_70 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_70 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_70 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><a name="msg_34"></a>
<a href="?hide_quotes=no#msg_34" onclick="return tog_quote(34);">
<div ID=header_shown_34 style="display: none;">
- Hide the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116) -
</div>
<div ID=header_hidden_34 style="display: block;">
- Show the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116, 104 lines) -</div>
</a>
<div ID=hide_34 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /chomp/&gt;
# Also see L&lt;"http://use.perl.org/~autrijus/journal/25351"&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.

{
    my $foo = "foo\n";
    chomp($foo);
    is($foo, "foo\n", 'our variable was not yet chomped');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n\n";
    $foo .= chomp;
    is($foo, "foo\n", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\nbar\n";
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n ";
    $foo .= chomp;
    is($foo, "foo\n ", 'our variable is chomped with no effect');
}

{
    my $foo = "foo\n";
    my $chomped_foo = try { chomp($foo).newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo\n", 'and our variable was not chomped');
}

{
    my $foo = "foo\n";
    $foo .= chomp;
    my $chomped_foo = try { $foo.newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo", 'and our variable was chomped');
}

{
    my $foo = "foo\n\n";
    my $chomped = $foo.chomp;
    is($foo, "foo\n\n", ".chomp has no effect on the original string");
    is($chomped, "foo\n", ".chomp returns correctly chomped value");
    
    # $chomped.chomp.newline

    $chomped = $chomped.chomp;
    is($chomped, "foo", ".chomp returns correctly chomped value again");
}

# chomp in list context
{
    is_deeply(chomp(()), [], "chomp on empty list");
    is_deeply(chomp(("abc\n")), ("abc"), "one element list");
    is_deeply(chomp(("abc\n", "bcd\n")), ("abc", "bcd"), "two element list");
    is_deeply(("abc\n", "bcd\n").chomp, ("abc", "bcd"), "two element list");
}
{
    my @foo = ();
    my @bar = chomp @foo;
    is_deeply(@bar, @foo, "chomp empty array");
}
{
    my @foo = ("abc\n");
    my @bar = chomp @foo;
    my @baz = ("abc");
    is_deeply(@bar, @baz, "chomp array with one element");
}
{
    my @foo = ("abc\n", "bcd\n");
    my @bar = chomp @foo;
    my @baz = ("abc", "bcd");
    is_deeply(@bar, @baz, "chomp array with 2 elements");


    @bar = @foo.chomp;
    is_deeply(@bar, @baz, "chomp array with 2 elements");

    my @morgo = ("abc\n\n", "bcd\n\n");
    my @hapci = chomp @morgo;
    is_deeply(@hapci, @foo, "chomp array with 2 elements with duplicate newlines");

    my @szundi = @morgo.chomp;
    is_deeply(@szundi, @foo, "chomp array with 2 elements with duplicate newlines");
}

</pre>
</div><a name="msg_71"></a>
<a href="?hide_quotes=no#msg_71" onclick="return tog_quote(71);">
<div ID=header_shown_71 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_71 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_71 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><p>Related to <a href="#item_p5chop"><code>p5chop</code></a>, only removes trailing chars that match <code>/\n/</code>. In
either case, it returns the number of chars removed.</p>
<dt><strong><a name="item_chomp">chomp</a></strong><br />
</dt>
<a name="msg_35"></a>
<a href="?hide_quotes=no#msg_35" onclick="return tog_quote(35);">
<div ID=header_shown_35 style="display: none;">
- Hide the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116) -
</div>
<div ID=header_hidden_35 style="display: block;">
- Show the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116, 104 lines) -</div>
</a>
<div ID=hide_35 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /chomp/&gt;
# Also see L&lt;"http://use.perl.org/~autrijus/journal/25351"&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.

{
    my $foo = "foo\n";
    chomp($foo);
    is($foo, "foo\n", 'our variable was not yet chomped');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n\n";
    $foo .= chomp;
    is($foo, "foo\n", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\nbar\n";
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n ";
    $foo .= chomp;
    is($foo, "foo\n ", 'our variable is chomped with no effect');
}

{
    my $foo = "foo\n";
    my $chomped_foo = try { chomp($foo).newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo\n", 'and our variable was not chomped');
}

{
    my $foo = "foo\n";
    $foo .= chomp;
    my $chomped_foo = try { $foo.newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo", 'and our variable was chomped');
}

{
    my $foo = "foo\n\n";
    my $chomped = $foo.chomp;
    is($foo, "foo\n\n", ".chomp has no effect on the original string");
    is($chomped, "foo\n", ".chomp returns correctly chomped value");
    
    # $chomped.chomp.newline

    $chomped = $chomped.chomp;
    is($chomped, "foo", ".chomp returns correctly chomped value again");
}

# chomp in list context
{
    is_deeply(chomp(()), [], "chomp on empty list");
    is_deeply(chomp(("abc\n")), ("abc"), "one element list");
    is_deeply(chomp(("abc\n", "bcd\n")), ("abc", "bcd"), "two element list");
    is_deeply(("abc\n", "bcd\n").chomp, ("abc", "bcd"), "two element list");
}
{
    my @foo = ();
    my @bar = chomp @foo;
    is_deeply(@bar, @foo, "chomp empty array");
}
{
    my @foo = ("abc\n");
    my @bar = chomp @foo;
    my @baz = ("abc");
    is_deeply(@bar, @baz, "chomp array with one element");
}
{
    my @foo = ("abc\n", "bcd\n");
    my @bar = chomp @foo;
    my @baz = ("abc", "bcd");
    is_deeply(@bar, @baz, "chomp array with 2 elements");


    @bar = @foo.chomp;
    is_deeply(@bar, @baz, "chomp array with 2 elements");

    my @morgo = ("abc\n\n", "bcd\n\n");
    my @hapci = chomp @morgo;
    is_deeply(@hapci, @foo, "chomp array with 2 elements with duplicate newlines");

    my @szundi = @morgo.chomp;
    is_deeply(@szundi, @foo, "chomp array with 2 elements with duplicate newlines");
}

</pre>
</div><a name="msg_72"></a>
<a href="?hide_quotes=no#msg_72" onclick="return tog_quote(72);">
<div ID=header_shown_72 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_72 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_72 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><a name="msg_24"></a>
<a href="?hide_quotes=no#msg_24" onclick="return tog_quote(24);">
<div ID=header_shown_24 style="display: none;">
- Hide the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37) -
</div>
<div ID=header_hidden_24 style="display: block;">
- Show the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37, 25 lines) -</div>
</a>
<div ID=hide_24 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /chomp/&gt;
# Also see L&lt;"http://use.perl.org/~autrijus/journal/25351"&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.
# Since currently the behaviour with regards to arrays is not defined, I'm
# assuming the correct behaviour is an extension of the behaviour for
# a single string.

{
    my @foo = ("foo\n","bar\n","baz\n");
    chomp(@foo);
    is(@foo[0], "foo\n", '1st element was not yet chomped');
    is(@foo[1], "bar\n", '2nd element was not yet chomped');
    is(@foo[2], "baz\n", '3rd element was not yet chomped');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element chomped correctly');
    is(@foo[1], 'bar', '2nd element chomped correctly');
    is(@foo[2], 'baz', '3rd element chomped correctly');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element is chomped again with no effect');
    is(@foo[1], 'bar', '2nd element is chomped again with no effect');
    is(@foo[2], 'baz', '3rd element is chomped again with no effect');
}
</pre>
</div><a name="msg_73"></a>
<a href="?hide_quotes=no#msg_73" onclick="return tog_quote(73);">
<div ID=header_shown_73 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_73 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_73 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><a name="msg_36"></a>
<a href="?hide_quotes=no#msg_36" onclick="return tog_quote(36);">
<div ID=header_shown_36 style="display: none;">
- Hide the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116) -
</div>
<div ID=header_hidden_36 style="display: block;">
- Show the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116, 104 lines) -</div>
</a>
<div ID=hide_36 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /chomp/&gt;
# Also see L&lt;"http://use.perl.org/~autrijus/journal/25351"&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.

{
    my $foo = "foo\n";
    chomp($foo);
    is($foo, "foo\n", 'our variable was not yet chomped');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n\n";
    $foo .= chomp;
    is($foo, "foo\n", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\nbar\n";
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n ";
    $foo .= chomp;
    is($foo, "foo\n ", 'our variable is chomped with no effect');
}

{
    my $foo = "foo\n";
    my $chomped_foo = try { chomp($foo).newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo\n", 'and our variable was not chomped');
}

{
    my $foo = "foo\n";
    $foo .= chomp;
    my $chomped_foo = try { $foo.newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo", 'and our variable was chomped');
}

{
    my $foo = "foo\n\n";
    my $chomped = $foo.chomp;
    is($foo, "foo\n\n", ".chomp has no effect on the original string");
    is($chomped, "foo\n", ".chomp returns correctly chomped value");
    
    # $chomped.chomp.newline

    $chomped = $chomped.chomp;
    is($chomped, "foo", ".chomp returns correctly chomped value again");
}

# chomp in list context
{
    is_deeply(chomp(()), [], "chomp on empty list");
    is_deeply(chomp(("abc\n")), ("abc"), "one element list");
    is_deeply(chomp(("abc\n", "bcd\n")), ("abc", "bcd"), "two element list");
    is_deeply(("abc\n", "bcd\n").chomp, ("abc", "bcd"), "two element list");
}
{
    my @foo = ();
    my @bar = chomp @foo;
    is_deeply(@bar, @foo, "chomp empty array");
}
{
    my @foo = ("abc\n");
    my @bar = chomp @foo;
    my @baz = ("abc");
    is_deeply(@bar, @baz, "chomp array with one element");
}
{
    my @foo = ("abc\n", "bcd\n");
    my @bar = chomp @foo;
    my @baz = ("abc", "bcd");
    is_deeply(@bar, @baz, "chomp array with 2 elements");


    @bar = @foo.chomp;
    is_deeply(@bar, @baz, "chomp array with 2 elements");

    my @morgo = ("abc\n\n", "bcd\n\n");
    my @hapci = chomp @morgo;
    is_deeply(@hapci, @foo, "chomp array with 2 elements with duplicate newlines");

    my @szundi = @morgo.chomp;
    is_deeply(@szundi, @foo, "chomp array with 2 elements with duplicate newlines");
}

</pre>
</div><a name="msg_74"></a>
<a href="?hide_quotes=no#msg_74" onclick="return tog_quote(74);">
<div ID=header_shown_74 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_74 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_74 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><pre>
 our Str method Str::chomp ( Str $string: )</pre>
<a name="msg_37"></a>
<a href="?hide_quotes=no#msg_37" onclick="return tog_quote(37);">
<div ID=header_shown_37 style="display: none;">
- Hide the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116) -
</div>
<div ID=header_hidden_37 style="display: block;">
- Show the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116, 104 lines) -</div>
</a>
<div ID=hide_37 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /chomp/&gt;
# Also see L&lt;"http://use.perl.org/~autrijus/journal/25351"&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.

{
    my $foo = "foo\n";
    chomp($foo);
    is($foo, "foo\n", 'our variable was not yet chomped');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n\n";
    $foo .= chomp;
    is($foo, "foo\n", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\nbar\n";
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n ";
    $foo .= chomp;
    is($foo, "foo\n ", 'our variable is chomped with no effect');
}

{
    my $foo = "foo\n";
    my $chomped_foo = try { chomp($foo).newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo\n", 'and our variable was not chomped');
}

{
    my $foo = "foo\n";
    $foo .= chomp;
    my $chomped_foo = try { $foo.newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo", 'and our variable was chomped');
}

{
    my $foo = "foo\n\n";
    my $chomped = $foo.chomp;
    is($foo, "foo\n\n", ".chomp has no effect on the original string");
    is($chomped, "foo\n", ".chomp returns correctly chomped value");
    
    # $chomped.chomp.newline

    $chomped = $chomped.chomp;
    is($chomped, "foo", ".chomp returns correctly chomped value again");
}

# chomp in list context
{
    is_deeply(chomp(()), [], "chomp on empty list");
    is_deeply(chomp(("abc\n")), ("abc"), "one element list");
    is_deeply(chomp(("abc\n", "bcd\n")), ("abc", "bcd"), "two element list");
    is_deeply(("abc\n", "bcd\n").chomp, ("abc", "bcd"), "two element list");
}
{
    my @foo = ();
    my @bar = chomp @foo;
    is_deeply(@bar, @foo, "chomp empty array");
}
{
    my @foo = ("abc\n");
    my @bar = chomp @foo;
    my @baz = ("abc");
    is_deeply(@bar, @baz, "chomp array with one element");
}
{
    my @foo = ("abc\n", "bcd\n");
    my @bar = chomp @foo;
    my @baz = ("abc", "bcd");
    is_deeply(@bar, @baz, "chomp array with 2 elements");


    @bar = @foo.chomp;
    is_deeply(@bar, @baz, "chomp array with 2 elements");

    my @morgo = ("abc\n\n", "bcd\n\n");
    my @hapci = chomp @morgo;
    is_deeply(@hapci, @foo, "chomp array with 2 elements with duplicate newlines");

    my @szundi = @morgo.chomp;
    is_deeply(@szundi, @foo, "chomp array with 2 elements with duplicate newlines");
}

</pre>
</div><a name="msg_75"></a>
<a href="?hide_quotes=no#msg_75" onclick="return tog_quote(75);">
<div ID=header_shown_75 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_75 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_75 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><a name="msg_25"></a>
<a href="?hide_quotes=no#msg_25" onclick="return tog_quote(25);">
<div ID=header_shown_25 style="display: none;">
- Hide the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37) -
</div>
<div ID=header_hidden_25 style="display: block;">
- Show the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37, 25 lines) -</div>
</a>
<div ID=hide_25 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /chomp/&gt;
# Also see L&lt;"http://use.perl.org/~autrijus/journal/25351"&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.
# Since currently the behaviour with regards to arrays is not defined, I'm
# assuming the correct behaviour is an extension of the behaviour for
# a single string.

{
    my @foo = ("foo\n","bar\n","baz\n");
    chomp(@foo);
    is(@foo[0], "foo\n", '1st element was not yet chomped');
    is(@foo[1], "bar\n", '2nd element was not yet chomped');
    is(@foo[2], "baz\n", '3rd element was not yet chomped');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element chomped correctly');
    is(@foo[1], 'bar', '2nd element chomped correctly');
    is(@foo[2], 'baz', '3rd element chomped correctly');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element is chomped again with no effect');
    is(@foo[1], 'bar', '2nd element is chomped again with no effect');
    is(@foo[2], 'baz', '3rd element is chomped again with no effect');
}
</pre>
</div><a name="msg_76"></a>
<a href="?hide_quotes=no#msg_76" onclick="return tog_quote(76);">
<div ID=header_shown_76 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_76 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_76 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><a name="msg_38"></a>
<a href="?hide_quotes=no#msg_38" onclick="return tog_quote(38);">
<div ID=header_shown_38 style="display: none;">
- Hide the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116) -
</div>
<div ID=header_hidden_38 style="display: block;">
- Show the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116, 104 lines) -</div>
</a>
<div ID=hide_38 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /chomp/&gt;
# Also see L&lt;"http://use.perl.org/~autrijus/journal/25351"&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.

{
    my $foo = "foo\n";
    chomp($foo);
    is($foo, "foo\n", 'our variable was not yet chomped');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n\n";
    $foo .= chomp;
    is($foo, "foo\n", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\nbar\n";
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n ";
    $foo .= chomp;
    is($foo, "foo\n ", 'our variable is chomped with no effect');
}

{
    my $foo = "foo\n";
    my $chomped_foo = try { chomp($foo).newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo\n", 'and our variable was not chomped');
}

{
    my $foo = "foo\n";
    $foo .= chomp;
    my $chomped_foo = try { $foo.newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo", 'and our variable was chomped');
}

{
    my $foo = "foo\n\n";
    my $chomped = $foo.chomp;
    is($foo, "foo\n\n", ".chomp has no effect on the original string");
    is($chomped, "foo\n", ".chomp returns correctly chomped value");
    
    # $chomped.chomp.newline

    $chomped = $chomped.chomp;
    is($chomped, "foo", ".chomp returns correctly chomped value again");
}

# chomp in list context
{
    is_deeply(chomp(()), [], "chomp on empty list");
    is_deeply(chomp(("abc\n")), ("abc"), "one element list");
    is_deeply(chomp(("abc\n", "bcd\n")), ("abc", "bcd"), "two element list");
    is_deeply(("abc\n", "bcd\n").chomp, ("abc", "bcd"), "two element list");
}
{
    my @foo = ();
    my @bar = chomp @foo;
    is_deeply(@bar, @foo, "chomp empty array");
}
{
    my @foo = ("abc\n");
    my @bar = chomp @foo;
    my @baz = ("abc");
    is_deeply(@bar, @baz, "chomp array with one element");
}
{
    my @foo = ("abc\n", "bcd\n");
    my @bar = chomp @foo;
    my @baz = ("abc", "bcd");
    is_deeply(@bar, @baz, "chomp array with 2 elements");


    @bar = @foo.chomp;
    is_deeply(@bar, @baz, "chomp array with 2 elements");

    my @morgo = ("abc\n\n", "bcd\n\n");
    my @hapci = chomp @morgo;
    is_deeply(@hapci, @foo, "chomp array with 2 elements with duplicate newlines");

    my @szundi = @morgo.chomp;
    is_deeply(@szundi, @foo, "chomp array with 2 elements with duplicate newlines");
}

</pre>
</div><a name="msg_77"></a>
<a href="?hide_quotes=no#msg_77" onclick="return tog_quote(77);">
<div ID=header_shown_77 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_77 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_77 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><p>Returns string with newline removed from the end.  An arbitrary
terminator can be removed if the input filehandle has marked the
string for where the ``newline'' begins.  (Presumably this is stored
as a property of the string.)  Otherwise a standard newline is removed.</p>
<p>Note: Most users should just let their I/O handles autochomp instead.
(Autochomping is the default.)</p>
<a name="msg_39"></a>
<a href="?hide_quotes=no#msg_39" onclick="return tog_quote(39);">
<div ID=header_shown_39 style="display: none;">
- Hide the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116) -
</div>
<div ID=header_hidden_39 style="display: block;">
- Show the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116, 104 lines) -</div>
</a>
<div ID=hide_39 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /chomp/&gt;
# Also see L&lt;"http://use.perl.org/~autrijus/journal/25351"&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.

{
    my $foo = "foo\n";
    chomp($foo);
    is($foo, "foo\n", 'our variable was not yet chomped');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n\n";
    $foo .= chomp;
    is($foo, "foo\n", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\nbar\n";
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n ";
    $foo .= chomp;
    is($foo, "foo\n ", 'our variable is chomped with no effect');
}

{
    my $foo = "foo\n";
    my $chomped_foo = try { chomp($foo).newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo\n", 'and our variable was not chomped');
}

{
    my $foo = "foo\n";
    $foo .= chomp;
    my $chomped_foo = try { $foo.newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo", 'and our variable was chomped');
}

{
    my $foo = "foo\n\n";
    my $chomped = $foo.chomp;
    is($foo, "foo\n\n", ".chomp has no effect on the original string");
    is($chomped, "foo\n", ".chomp returns correctly chomped value");
    
    # $chomped.chomp.newline

    $chomped = $chomped.chomp;
    is($chomped, "foo", ".chomp returns correctly chomped value again");
}

# chomp in list context
{
    is_deeply(chomp(()), [], "chomp on empty list");
    is_deeply(chomp(("abc\n")), ("abc"), "one element list");
    is_deeply(chomp(("abc\n", "bcd\n")), ("abc", "bcd"), "two element list");
    is_deeply(("abc\n", "bcd\n").chomp, ("abc", "bcd"), "two element list");
}
{
    my @foo = ();
    my @bar = chomp @foo;
    is_deeply(@bar, @foo, "chomp empty array");
}
{
    my @foo = ("abc\n");
    my @bar = chomp @foo;
    my @baz = ("abc");
    is_deeply(@bar, @baz, "chomp array with one element");
}
{
    my @foo = ("abc\n", "bcd\n");
    my @bar = chomp @foo;
    my @baz = ("abc", "bcd");
    is_deeply(@bar, @baz, "chomp array with 2 elements");


    @bar = @foo.chomp;
    is_deeply(@bar, @baz, "chomp array with 2 elements");

    my @morgo = ("abc\n\n", "bcd\n\n");
    my @hapci = chomp @morgo;
    is_deeply(@hapci, @foo, "chomp array with 2 elements with duplicate newlines");

    my @szundi = @morgo.chomp;
    is_deeply(@szundi, @foo, "chomp array with 2 elements with duplicate newlines");
}

</pre>
</div><a name="msg_78"></a>
<a href="?hide_quotes=no#msg_78" onclick="return tog_quote(78);">
<div ID=header_shown_78 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_78 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_78 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><a name="msg_26"></a>
<a href="?hide_quotes=no#msg_26" onclick="return tog_quote(26);">
<div ID=header_shown_26 style="display: none;">
- Hide the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37) -
</div>
<div ID=header_hidden_26 style="display: block;">
- Show the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37, 25 lines) -</div>
</a>
<div ID=hide_26 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /chomp/&gt;
# Also see L&lt;"http://use.perl.org/~autrijus/journal/25351"&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.
# Since currently the behaviour with regards to arrays is not defined, I'm
# assuming the correct behaviour is an extension of the behaviour for
# a single string.

{
    my @foo = ("foo\n","bar\n","baz\n");
    chomp(@foo);
    is(@foo[0], "foo\n", '1st element was not yet chomped');
    is(@foo[1], "bar\n", '2nd element was not yet chomped');
    is(@foo[2], "baz\n", '3rd element was not yet chomped');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element chomped correctly');
    is(@foo[1], 'bar', '2nd element chomped correctly');
    is(@foo[2], 'baz', '3rd element chomped correctly');
    @foo .= chomp;
    is(@foo[0], 'foo', '1st element is chomped again with no effect');
    is(@foo[1], 'bar', '2nd element is chomped again with no effect');
    is(@foo[2], 'baz', '3rd element is chomped again with no effect');
}
</pre>
</div><a name="msg_79"></a>
<a href="?hide_quotes=no#msg_79" onclick="return tog_quote(79);">
<div ID=header_shown_79 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_79 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_79 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><a name="msg_40"></a>
<a href="?hide_quotes=no#msg_40" onclick="return tog_quote(40);">
<div ID=header_shown_40 style="display: none;">
- Hide the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116) -
</div>
<div ID=header_hidden_40 style="display: block;">
- Show the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116, 104 lines) -</div>
</a>
<div ID=hide_40 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /chomp/&gt;
# Also see L&lt;"http://use.perl.org/~autrijus/journal/25351"&gt;
#   &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
#   which can be defined by the filehandle that obtains the default string at
#   the first place. To get destructive behaviour, use the .= form.

{
    my $foo = "foo\n";
    chomp($foo);
    is($foo, "foo\n", 'our variable was not yet chomped');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n\n";
    $foo .= chomp;
    is($foo, "foo\n", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again correctly');
    $foo .= chomp;
    is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\nbar\n";
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped correctly');
    $foo .= chomp;
    is($foo, "foo\nbar", 'our variable is chomped again with no effect');
}

{
    my $foo = "foo\n ";
    $foo .= chomp;
    is($foo, "foo\n ", 'our variable is chomped with no effect');
}

{
    my $foo = "foo\n";
    my $chomped_foo = try { chomp($foo).newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo\n", 'and our variable was not chomped');
}

{
    my $foo = "foo\n";
    $foo .= chomp;
    my $chomped_foo = try { $foo.newline };
    is($chomped_foo, "\n", 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
    is($foo, "foo", 'and our variable was chomped');
}

{
    my $foo = "foo\n\n";
    my $chomped = $foo.chomp;
    is($foo, "foo\n\n", ".chomp has no effect on the original string");
    is($chomped, "foo\n", ".chomp returns correctly chomped value");
    
    # $chomped.chomp.newline

    $chomped = $chomped.chomp;
    is($chomped, "foo", ".chomp returns correctly chomped value again");
}

# chomp in list context
{
    is_deeply(chomp(()), [], "chomp on empty list");
    is_deeply(chomp(("abc\n")), ("abc"), "one element list");
    is_deeply(chomp(("abc\n", "bcd\n")), ("abc", "bcd"), "two element list");
    is_deeply(("abc\n", "bcd\n").chomp, ("abc", "bcd"), "two element list");
}
{
    my @foo = ();
    my @bar = chomp @foo;
    is_deeply(@bar, @foo, "chomp empty array");
}
{
    my @foo = ("abc\n");
    my @bar = chomp @foo;
    my @baz = ("abc");
    is_deeply(@bar, @baz, "chomp array with one element");
}
{
    my @foo = ("abc\n", "bcd\n");
    my @bar = chomp @foo;
    my @baz = ("abc", "bcd");
    is_deeply(@bar, @baz, "chomp array with 2 elements");


    @bar = @foo.chomp;
    is_deeply(@bar, @baz, "chomp array with 2 elements");

    my @morgo = ("abc\n\n", "bcd\n\n");
    my @hapci = chomp @morgo;
    is_deeply(@hapci, @foo, "chomp array with 2 elements with duplicate newlines");

    my @szundi = @morgo.chomp;
    is_deeply(@szundi, @foo, "chomp array with 2 elements with duplicate newlines");
}

</pre>
</div><a name="msg_80"></a>
<a href="?hide_quotes=no#msg_80" onclick="return tog_quote(80);">
<div ID=header_shown_80 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_80 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_80 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><dt><strong><a name="item_crypt">crypt</a></strong><br />
</dt>
<dd>
<pre>
 our Str multi Str::crypt ( Str $plaintext, Str $salt )
 our Str multi method Str::crypt ( Str $plaintext: Str $salt )</pre>
</dd>
<dd>
<p>Encrypts the string using a one-way hash function. This yields a string
which cannot be ``decrypted''. This is used for verifying strings such
as passwords. The <code>$plaintext</code> is the text to be encrypted. The
<code>$salt</code> is a string which controls how the encryption is done. Typically,
this is a random string of two characters that matches the following pattern:</p>
</dd>
<a name="msg_81"></a>
<a href="?hide_quotes=no#msg_81" onclick="return tog_quote(81);">
<div ID=header_shown_81 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_81 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_81 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><pre>
 token Str::CryptBasicSalt { &lt;[./0-9A-Za-z]&gt; **{2} }</pre>
<p>There are other formats of salt as well, though their use is not universal.
Check your operating system's <strong>crypt</strong> function for more details. Often
these other functions are used when strings of length greater than eight
are to be used (the default crypt mode only recognizes the first eight
characters of the string as significant).</p>
<p>If you have a previously encrypted string and a plaintext password, you
can check to see of the password is correct like so:</p>
<pre>
 sub checkpw ( $encrypted, $plaintext ) {
   return crypt($plaintext, $encrypted) ~~ $encrypted;
 }</pre>
<p>This works because the first part of the encrypted form of the
password is the salt, so an encrypted text can be passed in place of
the salt (everything after the salt is ignored).</p>
<dt><strong><a name="item_lc">lc</a></strong><br />
</dt>
<a name="msg_41"></a>
<a href="?hide_quotes=no#msg_41" onclick="return tog_quote(41);">
<div ID=header_shown_41 style="display: none;">
- Hide the snippet from t/builtins/strings/lc.t (line 7 ~ line 24) -
</div>
<div ID=header_hidden_41 style="display: block;">
- Show the snippet from t/builtins/strings/lc.t (line 7 ~ line 24, 18 lines) -</div>
</a>
<div ID=hide_41 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /lc/&gt;

is(lc("Hello World"), "hello world", "simple lc test");
is(lc(""), "", "empty string");
is(lc("ÅÄÖ"), "åäö", "some finnish non-ascii chars");
is(lc("ÓÒÚÙ"), "óòúù", "accented chars");

$_ = "Hello World"; 
my $x = .lc;
is($x, "hello world", 'lc uses $_ as default');

{ # test invocant syntax for lc
    my $x = "Hello World";
    is($x.lc, "hello world", '$x.lc works');
    is("Hello World".lc, "hello world", '"Hello World".lc works');
}

is("ÁÉÍÖÜÓŰŐÚ".lc, "áéíöüóűőú", ".lc on Hungarian vowels");</pre>
</div><pre>
 our Str multi Str::lc ( Str $string )</pre>
<a name="msg_42"></a>
<a href="?hide_quotes=no#msg_42" onclick="return tog_quote(42);">
<div ID=header_shown_42 style="display: none;">
- Hide the snippet from t/builtins/strings/lc.t (line 7 ~ line 24) -
</div>
<div ID=header_hidden_42 style="display: block;">
- Show the snippet from t/builtins/strings/lc.t (line 7 ~ line 24, 18 lines) -</div>
</a>
<div ID=hide_42 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /lc/&gt;

is(lc("Hello World"), "hello world", "simple lc test");
is(lc(""), "", "empty string");
is(lc("ÅÄÖ"), "åäö", "some finnish non-ascii chars");
is(lc("ÓÒÚÙ"), "óòúù", "accented chars");

$_ = "Hello World"; 
my $x = .lc;
is($x, "hello world", 'lc uses $_ as default');

{ # test invocant syntax for lc
    my $x = "Hello World";
    is($x.lc, "hello world", '$x.lc works');
    is("Hello World".lc, "hello world", '"Hello World".lc works');
}

is("ÁÉÍÖÜÓŰŐÚ".lc, "áéíöüóűőú", ".lc on Hungarian vowels");</pre>
</div><p>Returns the input string after converting each character to its lowercase
form, if uppercase.</p>
<dt><strong><a name="item_lcfirst">lcfirst</a></strong><br />
</dt>
<a name="msg_47"></a>
<a href="?hide_quotes=no#msg_47" onclick="return tog_quote(47);">
<div ID=header_shown_47 style="display: none;">
- Hide the snippet from t/builtins/strings/lcfirst.t (line 7 ~ line 24) -
</div>
<div ID=header_hidden_47 style="display: block;">
- Show the snippet from t/builtins/strings/lcfirst.t (line 7 ~ line 24, 18 lines) -</div>
</a>
<div ID=hide_47 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /lcfirst/&gt;

is lcfirst("HELLO WORLD"), "hELLO WORLD", "simple";
is lcfirst(""),            "",            "empty string";
is lcfirst("ÜÜÜÜ"),        "üÜÜÜ",        "umlaut";
is lcfirst("ÓÓÓÓŃ"),       "óÓÓÓŃ",       "accented chars";

is "HELLO WORLD".lcfirst,  "hELLO WORLD", "simple.lcfirst";

my $str = "Some String";
is $str.lcfirst,    "some String",          "simple.lcfirst on scalar variable";
is "Other String".lcfirst,  "other String", ".lcfirst on  literal string";

$_ = "HELLO WORLD";
my $x = .lcfirst;
is $x, "hELLO WORLD", 'lcfirst uses $_ as default'

</pre>
</div><a name="msg_43"></a>
<a href="?hide_quotes=no#msg_43" onclick="return tog_quote(43);">
<div ID=header_shown_43 style="display: none;">
- Hide the snippet from t/builtins/strings/lc.t (line 7 ~ line 24) -
</div>
<div ID=header_hidden_43 style="display: block;">
- Show the snippet from t/builtins/strings/lc.t (line 7 ~ line 24, 18 lines) -</div>
</a>
<div ID=hide_43 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /lc/&gt;

is(lc("Hello World"), "hello world", "simple lc test");
is(lc(""), "", "empty string");
is(lc("ÅÄÖ"), "åäö", "some finnish non-ascii chars");
is(lc("ÓÒÚÙ"), "óòúù", "accented chars");

$_ = "Hello World"; 
my $x = .lc;
is($x, "hello world", 'lc uses $_ as default');

{ # test invocant syntax for lc
    my $x = "Hello World";
    is($x.lc, "hello world", '$x.lc works');
    is("Hello World".lc, "hello world", '"Hello World".lc works');
}

is("ÁÉÍÖÜÓŰŐÚ".lc, "áéíöüóűőú", ".lc on Hungarian vowels");</pre>
</div><pre>
 our Str multi Str::lcfirst ( Str $string )</pre>
<a name="msg_48"></a>
<a href="?hide_quotes=no#msg_48" onclick="return tog_quote(48);">
<div ID=header_shown_48 style="display: none;">
- Hide the snippet from t/builtins/strings/lcfirst.t (line 7 ~ line 24) -
</div>
<div ID=header_hidden_48 style="display: block;">
- Show the snippet from t/builtins/strings/lcfirst.t (line 7 ~ line 24, 18 lines) -</div>
</a>
<div ID=hide_48 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /lcfirst/&gt;

is lcfirst("HELLO WORLD"), "hELLO WORLD", "simple";
is lcfirst(""),            "",            "empty string";
is lcfirst("ÜÜÜÜ"),        "üÜÜÜ",        "umlaut";
is lcfirst("ÓÓÓÓŃ"),       "óÓÓÓŃ",       "accented chars";

is "HELLO WORLD".lcfirst,  "hELLO WORLD", "simple.lcfirst";

my $str = "Some String";
is $str.lcfirst,    "some String",          "simple.lcfirst on scalar variable";
is "Other String".lcfirst,  "other String", ".lcfirst on  literal string";

$_ = "HELLO WORLD";
my $x = .lcfirst;
is $x, "hELLO WORLD", 'lcfirst uses $_ as default'

</pre>
</div><a name="msg_44"></a>
<a href="?hide_quotes=no#msg_44" onclick="return tog_quote(44);">
<div ID=header_shown_44 style="display: none;">
- Hide the snippet from t/builtins/strings/lc.t (line 7 ~ line 24) -
</div>
<div ID=header_hidden_44 style="display: block;">
- Show the snippet from t/builtins/strings/lc.t (line 7 ~ line 24, 18 lines) -</div>
</a>
<div ID=hide_44 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /lc/&gt;

is(lc("Hello World"), "hello world", "simple lc test");
is(lc(""), "", "empty string");
is(lc("ÅÄÖ"), "åäö", "some finnish non-ascii chars");
is(lc("ÓÒÚÙ"), "óòúù", "accented chars");

$_ = "Hello World"; 
my $x = .lc;
is($x, "hello world", 'lc uses $_ as default');

{ # test invocant syntax for lc
    my $x = "Hello World";
    is($x.lc, "hello world", '$x.lc works');
    is("Hello World".lc, "hello world", '"Hello World".lc works');
}

is("ÁÉÍÖÜÓŰŐÚ".lc, "áéíöüóűőú", ".lc on Hungarian vowels");</pre>
</div><p>Like <a href="#item_lc"><code>lc</code></a>, but only affects the first character.</p>
<a name="msg_45"></a>
<a href="?hide_quotes=no#msg_45" onclick="return tog_quote(45);">
<div ID=header_shown_45 style="display: none;">
- Hide the snippet from t/builtins/strings/lc.t (line 7 ~ line 24) -
</div>
<div ID=header_hidden_45 style="display: block;">
- Show the snippet from t/builtins/strings/lc.t (line 7 ~ line 24, 18 lines) -</div>
</a>
<div ID=hide_45 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /lc/&gt;

is(lc("Hello World"), "hello world", "simple lc test");
is(lc(""), "", "empty string");
is(lc("ÅÄÖ"), "åäö", "some finnish non-ascii chars");
is(lc("ÓÒÚÙ"), "óòúù", "accented chars");

$_ = "Hello World"; 
my $x = .lc;
is($x, "hello world", 'lc uses $_ as default');

{ # test invocant syntax for lc
    my $x = "Hello World";
    is($x.lc, "hello world", '$x.lc works');
    is("Hello World".lc, "hello world", '"Hello World".lc works');
}

is("ÁÉÍÖÜÓŰŐÚ".lc, "áéíöüóűőú", ".lc on Hungarian vowels");</pre>
</div><dt><strong><a name="item_uc">uc</a></strong><br />
</dt>
<a name="msg_82"></a>
<a href="?hide_quotes=no#msg_82" onclick="return tog_quote(82);">
<div ID=header_shown_82 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_82 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_82 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><pre>
 our Str multi Str::uc ( Str $string )</pre>
<a name="msg_83"></a>
<a href="?hide_quotes=no#msg_83" onclick="return tog_quote(83);">
<div ID=header_shown_83 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_83 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_83 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><p>Returns the input string after converting each character to its uppercase
form, if lowercase. This is not a Unicode ``titlecase'' operation, but a
full ``uppercase''.</p>
<dt><strong><a name="item_ucfirst">ucfirst</a></strong><br />
</dt>
<a name="msg_105"></a>
<a href="?hide_quotes=no#msg_105" onclick="return tog_quote(105);">
<div ID=header_shown_105 style="display: none;">
- Hide the snippet from t/builtins/strings/ucfirst.t (line 7 ~ line 12) -
</div>
<div ID=header_hidden_105 style="display: block;">
- Show the snippet from t/builtins/strings/ucfirst.t (line 7 ~ line 12, 6 lines) -</div>
</a>
<div ID=hide_105 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /ucfirst/&gt;

is ucfirst("hello world"), "Hello world", "simple";
is ucfirst(""),            "",            "empty string";
is ucfirst("üüüü"),        "Üüüü",        "umlaut";
is ucfirst("óóóó"),        "Óóóó",        "accented chars";</pre>
</div><a name="msg_84"></a>
<a href="?hide_quotes=no#msg_84" onclick="return tog_quote(84);">
<div ID=header_shown_84 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_84 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_84 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><pre>
 our Str multi Str::ucfirst ( Str $string )</pre>
<a name="msg_106"></a>
<a href="?hide_quotes=no#msg_106" onclick="return tog_quote(106);">
<div ID=header_shown_106 style="display: none;">
- Hide the snippet from t/builtins/strings/ucfirst.t (line 7 ~ line 12) -
</div>
<div ID=header_hidden_106 style="display: block;">
- Show the snippet from t/builtins/strings/ucfirst.t (line 7 ~ line 12, 6 lines) -</div>
</a>
<div ID=hide_106 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /ucfirst/&gt;

is ucfirst("hello world"), "Hello world", "simple";
is ucfirst(""),            "",            "empty string";
is ucfirst("üüüü"),        "Üüüü",        "umlaut";
is ucfirst("óóóó"),        "Óóóó",        "accented chars";</pre>
</div><a name="msg_85"></a>
<a href="?hide_quotes=no#msg_85" onclick="return tog_quote(85);">
<div ID=header_shown_85 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_85 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_85 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><p>Performs a Unicode ``titlecase'' operation on the first character of the string.</p>
<dt><strong><a name="item_capitalize">capitalize</a></strong><br />
</dt>
<a name="msg_27"></a>
<a href="?hide_quotes=no#msg_27" onclick="return tog_quote(27);">
<div ID=header_shown_27 style="display: none;">
- Hide the snippet from t/builtins/strings/capitalize.t (line 7 ~ line 27) -
</div>
<div ID=header_hidden_27 style="display: block;">
- Show the snippet from t/builtins/strings/capitalize.t (line 7 ~ line 27, 21 lines) -</div>
</a>
<div ID=hide_27 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /capitalize/&gt;

is capitalize(""),             "",               "capitalize('') works";
is capitalize("puGS Is cOOl!"), "Pugs Is Cool!", "capitalize('...') works";
is "puGS Is cOOl!".capitalize,  "Pugs Is Cool!", "'...'.capitalize works";

my $a = "";
is capitalize($a),             "",               "capitalize empty string";
$a = "puGS Is cOOl!";
is capitalize($a),             "Pugs Is Cool!",  "capitalize string works";
is $a,                         "puGS Is cOOl!",  "original srting not touched";
is $a.capitalize,              "Pugs Is Cool!",  "capitalize string works";
is $a,                         "puGS Is cOOl!",  "original srting not touched";
is "ab cD Ef".capitalize,      "Ab Cd Ef",       "works on ordenary string";


$_ = "puGS Is cOOl!";
is .capitalize, "Pugs Is Cool!", 'capitalize() uses \$_ as default';

# Non-ASCII chars:
is capitalize("äöü abcä"), "Äöü Abcä", "capitalize() works on non-ASCII chars";</pre>
</div><a name="msg_86"></a>
<a href="?hide_quotes=no#msg_86" onclick="return tog_quote(86);">
<div ID=header_shown_86 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_86 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_86 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><pre>
 our Str multi Str::capitalize ( Str $string )</pre>
<a name="msg_28"></a>
<a href="?hide_quotes=no#msg_28" onclick="return tog_quote(28);">
<div ID=header_shown_28 style="display: none;">
- Hide the snippet from t/builtins/strings/capitalize.t (line 7 ~ line 27) -
</div>
<div ID=header_hidden_28 style="display: block;">
- Show the snippet from t/builtins/strings/capitalize.t (line 7 ~ line 27, 21 lines) -</div>
</a>
<div ID=hide_28 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /capitalize/&gt;

is capitalize(""),             "",               "capitalize('') works";
is capitalize("puGS Is cOOl!"), "Pugs Is Cool!", "capitalize('...') works";
is "puGS Is cOOl!".capitalize,  "Pugs Is Cool!", "'...'.capitalize works";

my $a = "";
is capitalize($a),             "",               "capitalize empty string";
$a = "puGS Is cOOl!";
is capitalize($a),             "Pugs Is Cool!",  "capitalize string works";
is $a,                         "puGS Is cOOl!",  "original srting not touched";
is $a.capitalize,              "Pugs Is Cool!",  "capitalize string works";
is $a,                         "puGS Is cOOl!",  "original srting not touched";
is "ab cD Ef".capitalize,      "Ab Cd Ef",       "works on ordenary string";


$_ = "puGS Is cOOl!";
is .capitalize, "Pugs Is Cool!", 'capitalize() uses \$_ as default';

# Non-ASCII chars:
is capitalize("äöü abcä"), "Äöü Abcä", "capitalize() works on non-ASCII chars";</pre>
</div><a name="msg_87"></a>
<a href="?hide_quotes=no#msg_87" onclick="return tog_quote(87);">
<div ID=header_shown_87 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_87 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_87 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><p>Has the effect of first doing an <a href="#item_lc"><code>lc</code></a> on the entire string, then performing a
<code>s:g/(\w+)/{ucfirst $1}/</code> on it.</p>
<a name="msg_107"></a>
<a href="?hide_quotes=no#msg_107" onclick="return tog_quote(107);">
<div ID=header_shown_107 style="display: none;">
- Hide the snippet from t/builtins/strings/ucfirst.t (line 7 ~ line 12) -
</div>
<div ID=header_hidden_107 style="display: block;">
- Show the snippet from t/builtins/strings/ucfirst.t (line 7 ~ line 12, 6 lines) -</div>
</a>
<div ID=hide_107 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /ucfirst/&gt;

is ucfirst("hello world"), "Hello world", "simple";
is ucfirst(""),            "",            "empty string";
is ucfirst("üüüü"),        "Üüüü",        "umlaut";
is ucfirst("óóóó"),        "Óóóó",        "accented chars";</pre>
</div><a name="msg_88"></a>
<a href="?hide_quotes=no#msg_88" onclick="return tog_quote(88);">
<div ID=header_shown_88 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_88 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_88 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><a name="msg_46"></a>
<a href="?hide_quotes=no#msg_46" onclick="return tog_quote(46);">
<div ID=header_shown_46 style="display: none;">
- Hide the snippet from t/builtins/strings/lc.t (line 7 ~ line 24) -
</div>
<div ID=header_hidden_46 style="display: block;">
- Show the snippet from t/builtins/strings/lc.t (line 7 ~ line 24, 18 lines) -</div>
</a>
<div ID=hide_46 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /lc/&gt;

is(lc("Hello World"), "hello world", "simple lc test");
is(lc(""), "", "empty string");
is(lc("ÅÄÖ"), "åäö", "some finnish non-ascii chars");
is(lc("ÓÒÚÙ"), "óòúù", "accented chars");

$_ = "Hello World"; 
my $x = .lc;
is($x, "hello world", 'lc uses $_ as default');

{ # test invocant syntax for lc
    my $x = "Hello World";
    is($x.lc, "hello world", '$x.lc works');
    is("Hello World".lc, "hello world", '"Hello World".lc works');
}

is("ÁÉÍÖÜÓŰŐÚ".lc, "áéíöüóűőú", ".lc on Hungarian vowels");</pre>
</div><dt><strong><a name="item_length">length</a></strong><br />
</dt>
<dd>
This word is banned in Perl 6.  You must specify units.
</dd>
<p></p>
<dt><strong><a name="item_index">index</a></strong><br />
</dt>
<dd>
<pre>
 our StrPos multi Str::index( Str $string, Str $substring, StrPos $pos = 0 )</pre>
</dd>
<a name="msg_51"></a>
<a href="?hide_quotes=no#msg_51" onclick="return tog_quote(51);">
<div ID=header_shown_51 style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID=header_hidden_51 style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -</div>
</a>
<div ID=hide_51 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /substr/&gt;

{ # read only
    my $str = "foobar";

    is(substr($str, 0, 1), "f", "first char");
    is(substr($str, -1), "r", "last char");
    is(substr($str, -4, 2), "ob", "counted from the end");
    is(substr($str, 1, 2), "oo", "arbitrary middle");
    is(substr($str, 3), "bar", "length omitted");
    is(substr($str, 3, 10), "bar", "length goes past end");
    is(substr($str, 20, 5), undef, "substr outside of string");
    is(substr($str, -100, 10), undef, "... on the negative side");

    is(substr($str, 0, -2), "foob", "from beginning, with negative length");
    is(substr($str, 2, -2), "ob", "in middle, with negative length");
    is(substr($str, 3, -3), "", "negative length - gives empty string");

    is($str, "foobar", "original string still not changed");
};

skip 4, "more discussion needed";

=begin more-discussion-needed

{ # replacement
    my $str = "foobar";

    substr($str, 2, 1, "i");
    is($str, "foibar", "fourth arg to substr replaced part");

    substr($str, -1, 1, "blah");
    is($str, "foibablah", "longer replacement expands string");

    substr($str, 1, 3, "");
    is($str, "fablah", "shorter replacement shrunk it");

    substr($str, 1, -1, "aye");
    is($str, "fayeh", "replacement with negative length");
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, "gloop", '$r referent is eq to the substring');

    $$r = "boing";
    is($str, "boing ding", "assignment to reference modifies original", :todo);
    is($$r, "boing", '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, "ng", "other ref to other lvalue", :todo);
    $$r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works", :todo);
    is($$o, " d", "other lvalue wiggled around", :todo);
};

{ # as lvalue, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");
};

{ # as lvalue, using :=, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r := substr($str, 0, 5);
    is($r, "gloop", 'bound $r is eq to the substring');

    $r = "boing";
    is($str, "boing ding", "assignment to bound var modifies original");
    is($r, "boing", 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, "ng", "other bound var to other lvalue");
    $r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works");
    is($o, " d", "other lvalue wiggled around", :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/"Junctions" /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr("camel", 0|1, 2&amp;3)', (("ca"|"am") &amp; ("cam"|"ame")), "junctive substr", :todo);
}


{ # misc
    my $str = "hello foo and bar";
    is(substr($str, 6, 3), "foo", "substr");
    is($str.substr(6, 3), "foo", ".substr");
    is(substr("hello foo bar", 6, 3), "foo", "substr on literal string");
    is("hello foo bar".substr(6, 3), "foo", ".substr on literal string");
    is("hello foo bar".substr(6, 3).uc, "FOO", ".substr.uc on literal string");
    is("hello foo bar and baz".substr(6, 10).capitalize, "Foo Bar An", ".substr.capitalize on literal string");
    is("hello »« foo".substr(6, 2), "»«", ".substr on unicode string");
    is("שיעבוד כבר".substr(4, 4), "וד כ", ".substr on Hebrew text");
}
</pre>
</div><a name="msg_89"></a>
<a href="?hide_quotes=no#msg_89" onclick="return tog_quote(89);">
<div ID=header_shown_89 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_89 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_89 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><p><a href="#item_index"><code>index</code></a> searches for the first occurrence of <code>$substring</code> in <code>$string</code>,
starting at <code>$pos</code>.</p>
<a name="msg_52"></a>
<a href="?hide_quotes=no#msg_52" onclick="return tog_quote(52);">
<div ID=header_shown_52 style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID=header_hidden_52 style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -</div>
</a>
<div ID=hide_52 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /substr/&gt;

{ # read only
    my $str = "foobar";

    is(substr($str, 0, 1), "f", "first char");
    is(substr($str, -1), "r", "last char");
    is(substr($str, -4, 2), "ob", "counted from the end");
    is(substr($str, 1, 2), "oo", "arbitrary middle");
    is(substr($str, 3), "bar", "length omitted");
    is(substr($str, 3, 10), "bar", "length goes past end");
    is(substr($str, 20, 5), undef, "substr outside of string");
    is(substr($str, -100, 10), undef, "... on the negative side");

    is(substr($str, 0, -2), "foob", "from beginning, with negative length");
    is(substr($str, 2, -2), "ob", "in middle, with negative length");
    is(substr($str, 3, -3), "", "negative length - gives empty string");

    is($str, "foobar", "original string still not changed");
};

skip 4, "more discussion needed";

=begin more-discussion-needed

{ # replacement
    my $str = "foobar";

    substr($str, 2, 1, "i");
    is($str, "foibar", "fourth arg to substr replaced part");

    substr($str, -1, 1, "blah");
    is($str, "foibablah", "longer replacement expands string");

    substr($str, 1, 3, "");
    is($str, "fablah", "shorter replacement shrunk it");

    substr($str, 1, -1, "aye");
    is($str, "fayeh", "replacement with negative length");
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, "gloop", '$r referent is eq to the substring');

    $$r = "boing";
    is($str, "boing ding", "assignment to reference modifies original", :todo);
    is($$r, "boing", '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, "ng", "other ref to other lvalue", :todo);
    $$r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works", :todo);
    is($$o, " d", "other lvalue wiggled around", :todo);
};

{ # as lvalue, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");
};

{ # as lvalue, using :=, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r := substr($str, 0, 5);
    is($r, "gloop", 'bound $r is eq to the substring');

    $r = "boing";
    is($str, "boing ding", "assignment to bound var modifies original");
    is($r, "boing", 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, "ng", "other bound var to other lvalue");
    $r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works");
    is($o, " d", "other lvalue wiggled around", :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/"Junctions" /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr("camel", 0|1, 2&amp;3)', (("ca"|"am") &amp; ("cam"|"ame")), "junctive substr", :todo);
}


{ # misc
    my $str = "hello foo and bar";
    is(substr($str, 6, 3), "foo", "substr");
    is($str.substr(6, 3), "foo", ".substr");
    is(substr("hello foo bar", 6, 3), "foo", "substr on literal string");
    is("hello foo bar".substr(6, 3), "foo", ".substr on literal string");
    is("hello foo bar".substr(6, 3).uc, "FOO", ".substr.uc on literal string");
    is("hello foo bar and baz".substr(6, 10).capitalize, "Foo Bar An", ".substr.capitalize on literal string");
    is("hello »« foo".substr(6, 2), "»«", ".substr on unicode string");
    is("שיעבוד כבר".substr(4, 4), "וד כ", ".substr on Hebrew text");
}
</pre>
</div><a name="msg_90"></a>
<a href="?hide_quotes=no#msg_90" onclick="return tog_quote(90);">
<div ID=header_shown_90 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_90 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_90 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><p>If the substring is found, then the position of the first character of
the substring is returned. If the substring is not found, then
undef is returned.</p>
<a name="msg_53"></a>
<a href="?hide_quotes=no#msg_53" onclick="return tog_quote(53);">
<div ID=header_shown_53 style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID=header_hidden_53 style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -</div>
</a>
<div ID=hide_53 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /substr/&gt;

{ # read only
    my $str = "foobar";

    is(substr($str, 0, 1), "f", "first char");
    is(substr($str, -1), "r", "last char");
    is(substr($str, -4, 2), "ob", "counted from the end");
    is(substr($str, 1, 2), "oo", "arbitrary middle");
    is(substr($str, 3), "bar", "length omitted");
    is(substr($str, 3, 10), "bar", "length goes past end");
    is(substr($str, 20, 5), undef, "substr outside of string");
    is(substr($str, -100, 10), undef, "... on the negative side");

    is(substr($str, 0, -2), "foob", "from beginning, with negative length");
    is(substr($str, 2, -2), "ob", "in middle, with negative length");
    is(substr($str, 3, -3), "", "negative length - gives empty string");

    is($str, "foobar", "original string still not changed");
};

skip 4, "more discussion needed";

=begin more-discussion-needed

{ # replacement
    my $str = "foobar";

    substr($str, 2, 1, "i");
    is($str, "foibar", "fourth arg to substr replaced part");

    substr($str, -1, 1, "blah");
    is($str, "foibablah", "longer replacement expands string");

    substr($str, 1, 3, "");
    is($str, "fablah", "shorter replacement shrunk it");

    substr($str, 1, -1, "aye");
    is($str, "fayeh", "replacement with negative length");
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, "gloop", '$r referent is eq to the substring');

    $$r = "boing";
    is($str, "boing ding", "assignment to reference modifies original", :todo);
    is($$r, "boing", '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, "ng", "other ref to other lvalue", :todo);
    $$r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works", :todo);
    is($$o, " d", "other lvalue wiggled around", :todo);
};

{ # as lvalue, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");
};

{ # as lvalue, using :=, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r := substr($str, 0, 5);
    is($r, "gloop", 'bound $r is eq to the substring');

    $r = "boing";
    is($str, "boing ding", "assignment to bound var modifies original");
    is($r, "boing", 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, "ng", "other bound var to other lvalue");
    $r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works");
    is($o, " d", "other lvalue wiggled around", :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/"Junctions" /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr("camel", 0|1, 2&amp;3)', (("ca"|"am") &amp; ("cam"|"ame")), "junctive substr", :todo);
}


{ # misc
    my $str = "hello foo and bar";
    is(substr($str, 6, 3), "foo", "substr");
    is($str.substr(6, 3), "foo", ".substr");
    is(substr("hello foo bar", 6, 3), "foo", "substr on literal string");
    is("hello foo bar".substr(6, 3), "foo", ".substr on literal string");
    is("hello foo bar".substr(6, 3).uc, "FOO", ".substr.uc on literal string");
    is("hello foo bar and baz".substr(6, 10).capitalize, "Foo Bar An", ".substr.capitalize on literal string");
    is("hello »« foo".substr(6, 2), "»«", ".substr on unicode string");
    is("שיעבוד כבר".substr(4, 4), "וד כ", ".substr on Hebrew text");
}
</pre>
</div><a name="msg_91"></a>
<a href="?hide_quotes=no#msg_91" onclick="return tog_quote(91);">
<div ID=header_shown_91 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_91 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_91 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><dt><strong><a name="item_pack">pack</a></strong><br />
</dt>
<dd>
<pre>
 our Str multi Str::pack( Str::Encoding $encoding,  Pair *@items )
 our Str multi Str::pack( Str::Encoding $encoding,  Str $template, *@items )
 our buf8 multi Str::pack( Pair *@items )
 our buf8 multi Str::pack( Str $template, *@items )</pre>
</dd>
<dd>
<p><a href="#item_pack"><code>pack</code></a> takes a list of pairs and formats the values according to
the specification of the keys. Alternately, it takes a string
<code>$template</code> and formats the rest of its arguments according to
the specifications in the template string. The result is a sequence
of bytes.</p>
</dd>
<dd>
<p>An optional <code>$encoding</code> can be used to specify the character
encoding to use in interpreting the result as a <code>Str</code>, otherwise the return
value will simply be a <code>buf</code> containing the bytes generated
by the <code>template(s)</code> and value(s). Note that no guarantee is made
in terms of the final, internal representation of the string, only
that the generated sequence of bytes will be interpreted as a
string in the given encoding, and a string containing those
graphemes will be returned. If the sequence of bytes represents
an invalid string according to <code>$encoding</code>, an exception is generated.</p>
</dd>
<dd>
<p>Templates are strings of the form:</p>
</dd>
<dd>
<pre>
  grammar Str::PackTemplate { 
   regex template  { [ &lt;group&gt; | &lt;specifier&gt; &lt;count&gt;? ]* }
   token group     { \( &lt;template&gt; \) }
   token specifier { &lt;[aAZbBhHcCsSiIlLnNvVqQjJfdFDpPuUwxX\@]&gt; \!? }
   token count     { \* |
                     \[ [ \d+ | &lt;specifier&gt; ] \] |
                     \d+ }
 }</pre>
</dd>
<dd>
<p>In the pairwise mode, each key must contain a single <code>&lt;group&gt;</code> or
<code>&lt;specifier&gt;</code>, and the values must be either scalar arguments or
arrays.</p>
</dd>
<dd>
<p>[ Note: Need more documentation and need to figure out what Perl 5 things
        no longer make sense. Does Perl 6 need any extra formatting</p>
</dd>
<dd>
<pre>
        features? -ajs ]</pre>
</dd>
<dt><strong><a name="item_pos">pos</a></strong><br />
</dt>
<dt><strong><a name="item_quotemeta">quotemeta</a></strong><br />
</dt>
<a name="msg_49"></a>
<a href="?hide_quotes=no#msg_49" onclick="return tog_quote(49);">
<div ID=header_shown_49 style="display: none;">
- Hide the snippet from t/builtins/strings/quotemeta.t (line 27 ~ line 130) -
</div>
<div ID=header_hidden_49 style="display: block;">
- Show the snippet from t/builtins/strings/quotemeta.t (line 27 ~ line 130, 104 lines) -</div>
</a>
<div ID=hide_49 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /quotemeta/&gt;

is(quotemeta("HeLLo World-72_1"), "HeLLo\\ World\\-72_1", "simple lc test");
is(quotemeta(""), "", "empty string");

$_ = "HeLLo World-72_1"; 
my $x = .quotemeta;
is($x, "HeLLo\\ World\\-72_1", 'quotemeta uses $_ as default');

{ # test invocant syntax for quotemeta
    my $x = "HeLLo World-72_1";
    is($x.quotemeta, "HeLLo\\ World\\-72_1", '$x.quotemeta works');
    is("HeLLo World-72_1".quotemeta, "HeLLo\\ World\\-72_1", '"HeLLo World-72_1".quotemeta works');
}


if (%*Config&lt;ebcdic&gt; eq 'define') {
    $_ = (129 .. 233).map({ chr($_); }).join('');
    is($_.chars, 96, "quotemeta starting string");
    
    # 105 characters - 52 letters = 53 backslashes
    # 105 characters + 53 backslashes = 158 characters
    $_ = quotemeta $_;
    is($_.chars, 158, "quotemeta string");
    # 53 backslashed characters + 1 "original" backslash
    is($_.split('').grep({ $_ eq "\x5c" }).elems, 54, "count backslashes");
}
else {
    $_ = (0 .. 255).map({ chr($_); }).join('');
    is($_.chars, 256, "quotemeta starting string");
    
    # Original test in Perl 5.9.3:
    # 96 characters - 52 letters - 10 digits - 1 underscore = 33 backslashes
    # 96 characters + 33 backslashes = 129 characters
    # 
    # Then added remaining 32 + 128, all escaped:
    # 129 + (32 + 128) * 2 = 449
    #
    # Total backslashed chars are 33 + 32 + 128 = 193
    # Total backslashes are 1 + 193 = 194
    $_ = quotemeta $_;
    is($_.chars, 449, "quotemeta string");
    # 33 backslashed characters + 1 "original" backslash
    is($_.split('').grep({ $_ eq "\x5c" }).elems, 194, "count backslashes");
}

# Current quotemeta implementation mimics that for Perl 5, avoiding
# to escape Unicode characters beyond 256th
is(quotemeta("\x[263a]"), "\x[263a]", "quotemeta Unicode");
is(quotemeta("\x[263a]").chars, 1, "quotemeta Unicode length");

=begin from_perl5


plan tests =&gt; 22;

if ($Config{ebcdic} eq 'define') {
    $_ = join "", map chr($_), 129..233;

    # 105 characters - 52 letters = 53 backslashes
    # 105 characters + 53 backslashes = 158 characters
    $_ = quotemeta $_;
    is(length($_), 158, "quotemeta string");
    # 104 non-backslash characters
    is(tr/\\//cd, 104, "tr count non-backslashed");
} else { # some ASCII descendant, then.
    $_ = join "", map chr($_), 32..127;

    # 96 characters - 52 letters - 10 digits - 1 underscore = 33 backslashes
    # 96 characters + 33 backslashes = 129 characters
    $_ = quotemeta $_;
    is(length($_), 129, "quotemeta string");
    # 95 non-backslash characters
    is(tr/\\//cd, 95, "tr count non-backslashed");
}

is(length(quotemeta ""), 0, "quotemeta empty string");

is("aA\UbB\LcC\EdD", "aABBccdD", 'aA\UbB\LcC\EdD');
is("aA\LbB\UcC\EdD", "aAbbCCdD", 'aA\LbB\UcC\EdD');
is("\L\upERL", "Perl", '\L\upERL');
is("\u\LpERL", "Perl", '\u\LpERL');
is("\U\lPerl", "pERL", '\U\lPerl');
is("\l\UPerl", "pERL", '\l\UPerl');
is("\u\LpE\Q#X#\ER\EL", "Pe\\#x\\#rL", '\u\LpE\Q#X#\ER\EL');
is("\l\UPe\Q!x!\Er\El", "pE\\!X\\!Rl", '\l\UPe\Q!x!\Er\El');
is("\Q\u\LpE.X.R\EL\E.", "Pe\\.x\\.rL.", '\Q\u\LpE.X.R\EL\E.');
is("\Q\l\UPe*x*r\El\E*", "pE\\*X\\*Rl*", '\Q\l\UPe*x*r\El\E*');
is("\U\lPerl\E\E\E\E", "pERL", '\U\lPerl\E\E\E\E');
is("\l\UPerl\E\E\E\E", "pERL", '\l\UPerl\E\E\E\E');

is(quotemeta("\x{263a}"), "\x{263a}", "quotemeta Unicode");
is(length(quotemeta("\x{263a}")), 1, "quotemeta Unicode length");

$a = "foo|bar";
is("a\Q\Ec$a", "acfoo|bar", '\Q\E');
is("a\L\Ec$a", "acfoo|bar", '\L\E');
is("a\l\Ec$a", "acfoo|bar", '\l\E');
is("a\U\Ec$a", "acfoo|bar", '\U\E');
is("a\u\Ec$a", "acfoo|bar", '\u\E');

=end from_perl5

=cut</pre>
</div><pre>
 our Str multi Str::quotemeta ( Str $string )</pre>
<a name="msg_50"></a>
<a href="?hide_quotes=no#msg_50" onclick="return tog_quote(50);">
<div ID=header_shown_50 style="display: none;">
- Hide the snippet from t/builtins/strings/quotemeta.t (line 27 ~ line 130) -
</div>
<div ID=header_hidden_50 style="display: block;">
- Show the snippet from t/builtins/strings/quotemeta.t (line 27 ~ line 130, 104 lines) -</div>
</a>
<div ID=hide_50 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /quotemeta/&gt;

is(quotemeta("HeLLo World-72_1"), "HeLLo\\ World\\-72_1", "simple lc test");
is(quotemeta(""), "", "empty string");

$_ = "HeLLo World-72_1"; 
my $x = .quotemeta;
is($x, "HeLLo\\ World\\-72_1", 'quotemeta uses $_ as default');

{ # test invocant syntax for quotemeta
    my $x = "HeLLo World-72_1";
    is($x.quotemeta, "HeLLo\\ World\\-72_1", '$x.quotemeta works');
    is("HeLLo World-72_1".quotemeta, "HeLLo\\ World\\-72_1", '"HeLLo World-72_1".quotemeta works');
}


if (%*Config&lt;ebcdic&gt; eq 'define') {
    $_ = (129 .. 233).map({ chr($_); }).join('');
    is($_.chars, 96, "quotemeta starting string");
    
    # 105 characters - 52 letters = 53 backslashes
    # 105 characters + 53 backslashes = 158 characters
    $_ = quotemeta $_;
    is($_.chars, 158, "quotemeta string");
    # 53 backslashed characters + 1 "original" backslash
    is($_.split('').grep({ $_ eq "\x5c" }).elems, 54, "count backslashes");
}
else {
    $_ = (0 .. 255).map({ chr($_); }).join('');
    is($_.chars, 256, "quotemeta starting string");
    
    # Original test in Perl 5.9.3:
    # 96 characters - 52 letters - 10 digits - 1 underscore = 33 backslashes
    # 96 characters + 33 backslashes = 129 characters
    # 
    # Then added remaining 32 + 128, all escaped:
    # 129 + (32 + 128) * 2 = 449
    #
    # Total backslashed chars are 33 + 32 + 128 = 193
    # Total backslashes are 1 + 193 = 194
    $_ = quotemeta $_;
    is($_.chars, 449, "quotemeta string");
    # 33 backslashed characters + 1 "original" backslash
    is($_.split('').grep({ $_ eq "\x5c" }).elems, 194, "count backslashes");
}

# Current quotemeta implementation mimics that for Perl 5, avoiding
# to escape Unicode characters beyond 256th
is(quotemeta("\x[263a]"), "\x[263a]", "quotemeta Unicode");
is(quotemeta("\x[263a]").chars, 1, "quotemeta Unicode length");

=begin from_perl5


plan tests =&gt; 22;

if ($Config{ebcdic} eq 'define') {
    $_ = join "", map chr($_), 129..233;

    # 105 characters - 52 letters = 53 backslashes
    # 105 characters + 53 backslashes = 158 characters
    $_ = quotemeta $_;
    is(length($_), 158, "quotemeta string");
    # 104 non-backslash characters
    is(tr/\\//cd, 104, "tr count non-backslashed");
} else { # some ASCII descendant, then.
    $_ = join "", map chr($_), 32..127;

    # 96 characters - 52 letters - 10 digits - 1 underscore = 33 backslashes
    # 96 characters + 33 backslashes = 129 characters
    $_ = quotemeta $_;
    is(length($_), 129, "quotemeta string");
    # 95 non-backslash characters
    is(tr/\\//cd, 95, "tr count non-backslashed");
}

is(length(quotemeta ""), 0, "quotemeta empty string");

is("aA\UbB\LcC\EdD", "aABBccdD", 'aA\UbB\LcC\EdD');
is("aA\LbB\UcC\EdD", "aAbbCCdD", 'aA\LbB\UcC\EdD');
is("\L\upERL", "Perl", '\L\upERL');
is("\u\LpERL", "Perl", '\u\LpERL');
is("\U\lPerl", "pERL", '\U\lPerl');
is("\l\UPerl", "pERL", '\l\UPerl');
is("\u\LpE\Q#X#\ER\EL", "Pe\\#x\\#rL", '\u\LpE\Q#X#\ER\EL');
is("\l\UPe\Q!x!\Er\El", "pE\\!X\\!Rl", '\l\UPe\Q!x!\Er\El');
is("\Q\u\LpE.X.R\EL\E.", "Pe\\.x\\.rL.", '\Q\u\LpE.X.R\EL\E.');
is("\Q\l\UPe*x*r\El\E*", "pE\\*X\\*Rl*", '\Q\l\UPe*x*r\El\E*');
is("\U\lPerl\E\E\E\E", "pERL", '\U\lPerl\E\E\E\E');
is("\l\UPerl\E\E\E\E", "pERL", '\l\UPerl\E\E\E\E');

is(quotemeta("\x{263a}"), "\x{263a}", "quotemeta Unicode");
is(length(quotemeta("\x{263a}")), 1, "quotemeta Unicode length");

$a = "foo|bar";
is("a\Q\Ec$a", "acfoo|bar", '\Q\E');
is("a\L\Ec$a", "acfoo|bar", '\L\E');
is("a\l\Ec$a", "acfoo|bar", '\l\E');
is("a\U\Ec$a", "acfoo|bar", '\U\E');
is("a\u\Ec$a", "acfoo|bar", '\u\E');

=end from_perl5

=cut</pre>
</div><p>Returns the input string with all non-``word'' characters back-slashed.
That is, all characters not matching ``/[A-Za-z_0-9]/'' will be preceded
by a backslash in the returned string, regardless of any locale settings.</p>
<dt><strong><a name="item_rindex">rindex</a></strong><br />
</dt>
<dd>
<pre>
 our StrPos multi Str::index( Str $string, Str $substring, StrPos $pos? )</pre>
</dd>
<a name="msg_54"></a>
<a href="?hide_quotes=no#msg_54" onclick="return tog_quote(54);">
<div ID=header_shown_54 style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID=header_hidden_54 style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -</div>
</a>
<div ID=hide_54 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /substr/&gt;

{ # read only
    my $str = "foobar";

    is(substr($str, 0, 1), "f", "first char");
    is(substr($str, -1), "r", "last char");
    is(substr($str, -4, 2), "ob", "counted from the end");
    is(substr($str, 1, 2), "oo", "arbitrary middle");
    is(substr($str, 3), "bar", "length omitted");
    is(substr($str, 3, 10), "bar", "length goes past end");
    is(substr($str, 20, 5), undef, "substr outside of string");
    is(substr($str, -100, 10), undef, "... on the negative side");

    is(substr($str, 0, -2), "foob", "from beginning, with negative length");
    is(substr($str, 2, -2), "ob", "in middle, with negative length");
    is(substr($str, 3, -3), "", "negative length - gives empty string");

    is($str, "foobar", "original string still not changed");
};

skip 4, "more discussion needed";

=begin more-discussion-needed

{ # replacement
    my $str = "foobar";

    substr($str, 2, 1, "i");
    is($str, "foibar", "fourth arg to substr replaced part");

    substr($str, -1, 1, "blah");
    is($str, "foibablah", "longer replacement expands string");

    substr($str, 1, 3, "");
    is($str, "fablah", "shorter replacement shrunk it");

    substr($str, 1, -1, "aye");
    is($str, "fayeh", "replacement with negative length");
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, "gloop", '$r referent is eq to the substring');

    $$r = "boing";
    is($str, "boing ding", "assignment to reference modifies original", :todo);
    is($$r, "boing", '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, "ng", "other ref to other lvalue", :todo);
    $$r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works", :todo);
    is($$o, " d", "other lvalue wiggled around", :todo);
};

{ # as lvalue, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");
};

{ # as lvalue, using :=, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r := substr($str, 0, 5);
    is($r, "gloop", 'bound $r is eq to the substring');

    $r = "boing";
    is($str, "boing ding", "assignment to bound var modifies original");
    is($r, "boing", 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, "ng", "other bound var to other lvalue");
    $r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works");
    is($o, " d", "other lvalue wiggled around", :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/"Junctions" /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr("camel", 0|1, 2&amp;3)', (("ca"|"am") &amp; ("cam"|"ame")), "junctive substr", :todo);
}


{ # misc
    my $str = "hello foo and bar";
    is(substr($str, 6, 3), "foo", "substr");
    is($str.substr(6, 3), "foo", ".substr");
    is(substr("hello foo bar", 6, 3), "foo", "substr on literal string");
    is("hello foo bar".substr(6, 3), "foo", ".substr on literal string");
    is("hello foo bar".substr(6, 3).uc, "FOO", ".substr.uc on literal string");
    is("hello foo bar and baz".substr(6, 10).capitalize, "Foo Bar An", ".substr.capitalize on literal string");
    is("hello »« foo".substr(6, 2), "»«", ".substr on unicode string");
    is("שיעבוד כבר".substr(4, 4), "וד כ", ".substr on Hebrew text");
}
</pre>
</div><a name="msg_92"></a>
<a href="?hide_quotes=no#msg_92" onclick="return tog_quote(92);">
<div ID=header_shown_92 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_92 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_92 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><p>Returns the position of the last <code>$substring</code> in <code>$string</code>. If <code>$pos</code>
is specified, then the search starts at that location in <code>$string</code>, and
works backwards. See <a href="#item_index"><code>index</code></a> for more detail.</p>
<a name="msg_55"></a>
<a href="?hide_quotes=no#msg_55" onclick="return tog_quote(55);">
<div ID=header_shown_55 style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID=header_hidden_55 style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -</div>
</a>
<div ID=hide_55 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /substr/&gt;

{ # read only
    my $str = "foobar";

    is(substr($str, 0, 1), "f", "first char");
    is(substr($str, -1), "r", "last char");
    is(substr($str, -4, 2), "ob", "counted from the end");
    is(substr($str, 1, 2), "oo", "arbitrary middle");
    is(substr($str, 3), "bar", "length omitted");
    is(substr($str, 3, 10), "bar", "length goes past end");
    is(substr($str, 20, 5), undef, "substr outside of string");
    is(substr($str, -100, 10), undef, "... on the negative side");

    is(substr($str, 0, -2), "foob", "from beginning, with negative length");
    is(substr($str, 2, -2), "ob", "in middle, with negative length");
    is(substr($str, 3, -3), "", "negative length - gives empty string");

    is($str, "foobar", "original string still not changed");
};

skip 4, "more discussion needed";

=begin more-discussion-needed

{ # replacement
    my $str = "foobar";

    substr($str, 2, 1, "i");
    is($str, "foibar", "fourth arg to substr replaced part");

    substr($str, -1, 1, "blah");
    is($str, "foibablah", "longer replacement expands string");

    substr($str, 1, 3, "");
    is($str, "fablah", "shorter replacement shrunk it");

    substr($str, 1, -1, "aye");
    is($str, "fayeh", "replacement with negative length");
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, "gloop", '$r referent is eq to the substring');

    $$r = "boing";
    is($str, "boing ding", "assignment to reference modifies original", :todo);
    is($$r, "boing", '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, "ng", "other ref to other lvalue", :todo);
    $$r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works", :todo);
    is($$o, " d", "other lvalue wiggled around", :todo);
};

{ # as lvalue, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");
};

{ # as lvalue, using :=, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r := substr($str, 0, 5);
    is($r, "gloop", 'bound $r is eq to the substring');

    $r = "boing";
    is($str, "boing ding", "assignment to bound var modifies original");
    is($r, "boing", 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, "ng", "other bound var to other lvalue");
    $r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works");
    is($o, " d", "other lvalue wiggled around", :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/"Junctions" /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr("camel", 0|1, 2&amp;3)', (("ca"|"am") &amp; ("cam"|"ame")), "junctive substr", :todo);
}


{ # misc
    my $str = "hello foo and bar";
    is(substr($str, 6, 3), "foo", "substr");
    is($str.substr(6, 3), "foo", ".substr");
    is(substr("hello foo bar", 6, 3), "foo", "substr on literal string");
    is("hello foo bar".substr(6, 3), "foo", ".substr on literal string");
    is("hello foo bar".substr(6, 3).uc, "FOO", ".substr.uc on literal string");
    is("hello foo bar and baz".substr(6, 10).capitalize, "Foo Bar An", ".substr.capitalize on literal string");
    is("hello »« foo".substr(6, 2), "»«", ".substr on unicode string");
    is("שיעבוד כבר".substr(4, 4), "וד כ", ".substr on Hebrew text");
}
</pre>
</div><a name="msg_93"></a>
<a href="?hide_quotes=no#msg_93" onclick="return tog_quote(93);">
<div ID=header_shown_93 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_93 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_93 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><dt><strong><a name="item_split">split</a></strong><br />
</dt>
<dd>
<pre>
 our List multi Str::split ( Str $delimiter ,  Str $input_, Int $limit = inf )
 our List multi Str::split ( Rule $delimiter = /\s+/,  Str $input, Int $limit = inf )
 our List multi Str::split ( Str $input ;  Str $delimiter          , Int $limit = inf )
 our List multi Str::split ( Str $input ; Rule $delimiter          , Int $limit = inf )</pre>
</dd>
<dd>
<p>String delimiters must not be treated as rules but as constants.  The
default is no longer '&nbsp;' since that would be interpreted as a constant.
P5's <a href="#item_split"><code>split(' ')</code></a> will translate to <code>.words</code> or some such.  Null trailing fields
are no longer trimmed by default.  We might add some kind of :trim flag or
introduce a trimlist function of some sort.</p>
</dd>
<a name="msg_94"></a>
<a href="?hide_quotes=no#msg_94" onclick="return tog_quote(94);">
<div ID=header_shown_94 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_94 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_94 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><dt><strong><a name="item_sprintf">sprintf</a></strong><br />
</dt>
<dd>
<pre>
 our Str multi method Str::sprintf ( Str $format: *@args )
 our Str multi Str::sprintf ( Str $format, *@args )</pre>
</dd>
<dd>
<p>This function is mostly identical to the C library sprintf function.</p>
</dd>
<dd>
<p>The <code>$format</code> is scanned for <a href="#item_2525"><code>%</code></a> characters. Any <a href="#item_2525"><code>%</code></a> introduces a
format token. Format tokens have the following grammar:</p>
</dd>
<a name="msg_95"></a>
<a href="?hide_quotes=no#msg_95" onclick="return tog_quote(95);">
<div ID=header_shown_95 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_95 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_95 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><pre>
 grammar Str::SprintfFormat {
  regex format_token { \%: &lt;index&gt;? &lt;precision&gt;? &lt;modifier&gt;? &lt;directive&gt; }
  token index { \d+ \$ }
  token precision { &lt;flags&gt;? &lt;vector&gt;? &lt;precision_count&gt; }
  token flags { &lt;[\ +0\#\-]&gt;+ }
  token precision_count { [ &lt;[1-9]&gt;\d* | \* ]? [ \. [ \d* | \* ] ]? }
  token vector { \*? v }
  token modifier { ll | &lt;[lhVqL]&gt; }
  token directive { &lt;[\%csduoxefgXEGbpniDUOF]&gt; }
 }</pre>
<p>Directives guide the use (if any) of the arguments. When a directive
(other than <a href="#item_2525"><code>%</code></a>) are used, they indicate how the next argument
passed is to be formatted into the string.</p>
<p>The directives are:</p>
<pre>
 %   a literal percent sign
 c   a character with the given codepoint
 s   a string
 d   a signed integer, in decimal
 u   an unsigned integer, in decimal
 o   an unsigned integer, in octal
 x   an unsigned integer, in hexadecimal
 e   a floating-point number, in scientific notation
 f   a floating-point number, in fixed decimal notation
 g   a floating-point number, in %e or %f notation
 X   like x, but using upper-case letters
 E   like e, but using an upper-case &quot;E&quot;
 G   like g, but with an upper-case &quot;E&quot; (if applicable)
 b   an unsigned integer, in binary
 C   special: invokes the arg as code, see below</pre>
<p>Compatibility:</p>
<pre>
 i   a synonym for %d
 D   a synonym for %ld
 U   a synonym for %lu
 O   a synonym for %lo
 F   a synonym for %f</pre>
<p>Perl 5 compatibility:</p>
<pre>
 n   produces a runtime exception (see below)</pre>
<a name="msg_96"></a>
<a href="?hide_quotes=no#msg_96" onclick="return tog_quote(96);">
<div ID=header_shown_96 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_96 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_96 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><pre>
 p   produces a runtime exception</pre>
<a name="msg_97"></a>
<a href="?hide_quotes=no#msg_97" onclick="return tog_quote(97);">
<div ID=header_shown_97 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_97 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_97 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><p>The special format directive, <code>%C</code> invokes the target argument as
code, passing it the result string that has been generated thus
far and the argument array.</p>
<p>Here's an example of its use:</p>
<pre>
 sprintf &quot;%d%C is %d digits long&quot;,
        $num,
        sub($s,@args is rw) {@args[2]=$s.elems},
        0;</pre>
<p>The special directive, <code>%n</code> does not work in Perl 6 because of the
difference in parameter passing conventions, but the example above
simulates its effect using <code>%C</code>.</p>
<dt><strong><a name="item_substr">substr</a></strong><br />
</dt>
<a name="msg_56"></a>
<a href="?hide_quotes=no#msg_56" onclick="return tog_quote(56);">
<div ID=header_shown_56 style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID=header_hidden_56 style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -</div>
</a>
<div ID=hide_56 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /substr/&gt;

{ # read only
    my $str = "foobar";

    is(substr($str, 0, 1), "f", "first char");
    is(substr($str, -1), "r", "last char");
    is(substr($str, -4, 2), "ob", "counted from the end");
    is(substr($str, 1, 2), "oo", "arbitrary middle");
    is(substr($str, 3), "bar", "length omitted");
    is(substr($str, 3, 10), "bar", "length goes past end");
    is(substr($str, 20, 5), undef, "substr outside of string");
    is(substr($str, -100, 10), undef, "... on the negative side");

    is(substr($str, 0, -2), "foob", "from beginning, with negative length");
    is(substr($str, 2, -2), "ob", "in middle, with negative length");
    is(substr($str, 3, -3), "", "negative length - gives empty string");

    is($str, "foobar", "original string still not changed");
};

skip 4, "more discussion needed";

=begin more-discussion-needed

{ # replacement
    my $str = "foobar";

    substr($str, 2, 1, "i");
    is($str, "foibar", "fourth arg to substr replaced part");

    substr($str, -1, 1, "blah");
    is($str, "foibablah", "longer replacement expands string");

    substr($str, 1, 3, "");
    is($str, "fablah", "shorter replacement shrunk it");

    substr($str, 1, -1, "aye");
    is($str, "fayeh", "replacement with negative length");
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, "gloop", '$r referent is eq to the substring');

    $$r = "boing";
    is($str, "boing ding", "assignment to reference modifies original", :todo);
    is($$r, "boing", '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, "ng", "other ref to other lvalue", :todo);
    $$r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works", :todo);
    is($$o, " d", "other lvalue wiggled around", :todo);
};

{ # as lvalue, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");
};

{ # as lvalue, using :=, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r := substr($str, 0, 5);
    is($r, "gloop", 'bound $r is eq to the substring');

    $r = "boing";
    is($str, "boing ding", "assignment to bound var modifies original");
    is($r, "boing", 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, "ng", "other bound var to other lvalue");
    $r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works");
    is($o, " d", "other lvalue wiggled around", :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/"Junctions" /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr("camel", 0|1, 2&amp;3)', (("ca"|"am") &amp; ("cam"|"ame")), "junctive substr", :todo);
}


{ # misc
    my $str = "hello foo and bar";
    is(substr($str, 6, 3), "foo", "substr");
    is($str.substr(6, 3), "foo", ".substr");
    is(substr("hello foo bar", 6, 3), "foo", "substr on literal string");
    is("hello foo bar".substr(6, 3), "foo", ".substr on literal string");
    is("hello foo bar".substr(6, 3).uc, "FOO", ".substr.uc on literal string");
    is("hello foo bar and baz".substr(6, 10).capitalize, "Foo Bar An", ".substr.capitalize on literal string");
    is("hello »« foo".substr(6, 2), "»«", ".substr on unicode string");
    is("שיעבוד כבר".substr(4, 4), "וד כ", ".substr on Hebrew text");
}
</pre>
</div><a name="msg_98"></a>
<a href="?hide_quotes=no#msg_98" onclick="return tog_quote(98);">
<div ID=header_shown_98 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_98 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_98 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><pre>
 our Str multi substr (Str $s, StrPos $start, StrLen $length?) is rw</pre>
<a name="msg_57"></a>
<a href="?hide_quotes=no#msg_57" onclick="return tog_quote(57);">
<div ID=header_shown_57 style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID=header_hidden_57 style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -</div>
</a>
<div ID=hide_57 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /substr/&gt;

{ # read only
    my $str = "foobar";

    is(substr($str, 0, 1), "f", "first char");
    is(substr($str, -1), "r", "last char");
    is(substr($str, -4, 2), "ob", "counted from the end");
    is(substr($str, 1, 2), "oo", "arbitrary middle");
    is(substr($str, 3), "bar", "length omitted");
    is(substr($str, 3, 10), "bar", "length goes past end");
    is(substr($str, 20, 5), undef, "substr outside of string");
    is(substr($str, -100, 10), undef, "... on the negative side");

    is(substr($str, 0, -2), "foob", "from beginning, with negative length");
    is(substr($str, 2, -2), "ob", "in middle, with negative length");
    is(substr($str, 3, -3), "", "negative length - gives empty string");

    is($str, "foobar", "original string still not changed");
};

skip 4, "more discussion needed";

=begin more-discussion-needed

{ # replacement
    my $str = "foobar";

    substr($str, 2, 1, "i");
    is($str, "foibar", "fourth arg to substr replaced part");

    substr($str, -1, 1, "blah");
    is($str, "foibablah", "longer replacement expands string");

    substr($str, 1, 3, "");
    is($str, "fablah", "shorter replacement shrunk it");

    substr($str, 1, -1, "aye");
    is($str, "fayeh", "replacement with negative length");
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, "gloop", '$r referent is eq to the substring');

    $$r = "boing";
    is($str, "boing ding", "assignment to reference modifies original", :todo);
    is($$r, "boing", '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, "ng", "other ref to other lvalue", :todo);
    $$r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works", :todo);
    is($$o, " d", "other lvalue wiggled around", :todo);
};

{ # as lvalue, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");
};

{ # as lvalue, using :=, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r := substr($str, 0, 5);
    is($r, "gloop", 'bound $r is eq to the substring');

    $r = "boing";
    is($str, "boing ding", "assignment to bound var modifies original");
    is($r, "boing", 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, "ng", "other bound var to other lvalue");
    $r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works");
    is($o, " d", "other lvalue wiggled around", :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/"Junctions" /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr("camel", 0|1, 2&amp;3)', (("ca"|"am") &amp; ("cam"|"ame")), "junctive substr", :todo);
}


{ # misc
    my $str = "hello foo and bar";
    is(substr($str, 6, 3), "foo", "substr");
    is($str.substr(6, 3), "foo", ".substr");
    is(substr("hello foo bar", 6, 3), "foo", "substr on literal string");
    is("hello foo bar".substr(6, 3), "foo", ".substr on literal string");
    is("hello foo bar".substr(6, 3).uc, "FOO", ".substr.uc on literal string");
    is("hello foo bar and baz".substr(6, 10).capitalize, "Foo Bar An", ".substr.capitalize on literal string");
    is("hello »« foo".substr(6, 2), "»«", ".substr on unicode string");
    is("שיעבוד כבר".substr(4, 4), "וד כ", ".substr on Hebrew text");
}
</pre>
</div><a name="msg_99"></a>
<a href="?hide_quotes=no#msg_99" onclick="return tog_quote(99);">
<div ID=header_shown_99 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_99 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_99 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><pre>
 our Str multi substr (Str $s, StrPos $start, StrPos $end?) is rw</pre>
<a name="msg_58"></a>
<a href="?hide_quotes=no#msg_58" onclick="return tog_quote(58);">
<div ID=header_shown_58 style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID=header_hidden_58 style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -</div>
</a>
<div ID=hide_58 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /substr/&gt;

{ # read only
    my $str = "foobar";

    is(substr($str, 0, 1), "f", "first char");
    is(substr($str, -1), "r", "last char");
    is(substr($str, -4, 2), "ob", "counted from the end");
    is(substr($str, 1, 2), "oo", "arbitrary middle");
    is(substr($str, 3), "bar", "length omitted");
    is(substr($str, 3, 10), "bar", "length goes past end");
    is(substr($str, 20, 5), undef, "substr outside of string");
    is(substr($str, -100, 10), undef, "... on the negative side");

    is(substr($str, 0, -2), "foob", "from beginning, with negative length");
    is(substr($str, 2, -2), "ob", "in middle, with negative length");
    is(substr($str, 3, -3), "", "negative length - gives empty string");

    is($str, "foobar", "original string still not changed");
};

skip 4, "more discussion needed";

=begin more-discussion-needed

{ # replacement
    my $str = "foobar";

    substr($str, 2, 1, "i");
    is($str, "foibar", "fourth arg to substr replaced part");

    substr($str, -1, 1, "blah");
    is($str, "foibablah", "longer replacement expands string");

    substr($str, 1, 3, "");
    is($str, "fablah", "shorter replacement shrunk it");

    substr($str, 1, -1, "aye");
    is($str, "fayeh", "replacement with negative length");
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, "gloop", '$r referent is eq to the substring');

    $$r = "boing";
    is($str, "boing ding", "assignment to reference modifies original", :todo);
    is($$r, "boing", '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, "ng", "other ref to other lvalue", :todo);
    $$r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works", :todo);
    is($$o, " d", "other lvalue wiggled around", :todo);
};

{ # as lvalue, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");
};

{ # as lvalue, using :=, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r := substr($str, 0, 5);
    is($r, "gloop", 'bound $r is eq to the substring');

    $r = "boing";
    is($str, "boing ding", "assignment to bound var modifies original");
    is($r, "boing", 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, "ng", "other bound var to other lvalue");
    $r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works");
    is($o, " d", "other lvalue wiggled around", :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/"Junctions" /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr("camel", 0|1, 2&amp;3)', (("ca"|"am") &amp; ("cam"|"ame")), "junctive substr", :todo);
}


{ # misc
    my $str = "hello foo and bar";
    is(substr($str, 6, 3), "foo", "substr");
    is($str.substr(6, 3), "foo", ".substr");
    is(substr("hello foo bar", 6, 3), "foo", "substr on literal string");
    is("hello foo bar".substr(6, 3), "foo", ".substr on literal string");
    is("hello foo bar".substr(6, 3).uc, "FOO", ".substr.uc on literal string");
    is("hello foo bar and baz".substr(6, 10).capitalize, "Foo Bar An", ".substr.capitalize on literal string");
    is("hello »« foo".substr(6, 2), "»«", ".substr on unicode string");
    is("שיעבוד כבר".substr(4, 4), "וד כ", ".substr on Hebrew text");
}
</pre>
</div><a name="msg_100"></a>
<a href="?hide_quotes=no#msg_100" onclick="return tog_quote(100);">
<div ID=header_shown_100 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_100 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_100 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><p><a href="#item_substr"><code>substr</code></a> returns part of an existing string. You control what part by
passing a starting position and optionally either an end position or length.
If you just pass two numbers, positionally, then they will be used
as the start and length.</p>
<a name="msg_59"></a>
<a href="?hide_quotes=no#msg_59" onclick="return tog_quote(59);">
<div ID=header_shown_59 style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID=header_hidden_59 style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -</div>
</a>
<div ID=hide_59 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /substr/&gt;

{ # read only
    my $str = "foobar";

    is(substr($str, 0, 1), "f", "first char");
    is(substr($str, -1), "r", "last char");
    is(substr($str, -4, 2), "ob", "counted from the end");
    is(substr($str, 1, 2), "oo", "arbitrary middle");
    is(substr($str, 3), "bar", "length omitted");
    is(substr($str, 3, 10), "bar", "length goes past end");
    is(substr($str, 20, 5), undef, "substr outside of string");
    is(substr($str, -100, 10), undef, "... on the negative side");

    is(substr($str, 0, -2), "foob", "from beginning, with negative length");
    is(substr($str, 2, -2), "ob", "in middle, with negative length");
    is(substr($str, 3, -3), "", "negative length - gives empty string");

    is($str, "foobar", "original string still not changed");
};

skip 4, "more discussion needed";

=begin more-discussion-needed

{ # replacement
    my $str = "foobar";

    substr($str, 2, 1, "i");
    is($str, "foibar", "fourth arg to substr replaced part");

    substr($str, -1, 1, "blah");
    is($str, "foibablah", "longer replacement expands string");

    substr($str, 1, 3, "");
    is($str, "fablah", "shorter replacement shrunk it");

    substr($str, 1, -1, "aye");
    is($str, "fayeh", "replacement with negative length");
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, "gloop", '$r referent is eq to the substring');

    $$r = "boing";
    is($str, "boing ding", "assignment to reference modifies original", :todo);
    is($$r, "boing", '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, "ng", "other ref to other lvalue", :todo);
    $$r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works", :todo);
    is($$o, " d", "other lvalue wiggled around", :todo);
};

{ # as lvalue, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");
};

{ # as lvalue, using :=, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r := substr($str, 0, 5);
    is($r, "gloop", 'bound $r is eq to the substring');

    $r = "boing";
    is($str, "boing ding", "assignment to bound var modifies original");
    is($r, "boing", 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, "ng", "other bound var to other lvalue");
    $r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works");
    is($o, " d", "other lvalue wiggled around", :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/"Junctions" /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr("camel", 0|1, 2&amp;3)', (("ca"|"am") &amp; ("cam"|"ame")), "junctive substr", :todo);
}


{ # misc
    my $str = "hello foo and bar";
    is(substr($str, 6, 3), "foo", "substr");
    is($str.substr(6, 3), "foo", ".substr");
    is(substr("hello foo bar", 6, 3), "foo", "substr on literal string");
    is("hello foo bar".substr(6, 3), "foo", ".substr on literal string");
    is("hello foo bar".substr(6, 3).uc, "FOO", ".substr.uc on literal string");
    is("hello foo bar and baz".substr(6, 10).capitalize, "Foo Bar An", ".substr.capitalize on literal string");
    is("hello »« foo".substr(6, 2), "»«", ".substr on unicode string");
    is("שיעבוד כבר".substr(4, 4), "וד כ", ".substr on Hebrew text");
}
</pre>
</div><a name="msg_101"></a>
<a href="?hide_quotes=no#msg_101" onclick="return tog_quote(101);">
<div ID=header_shown_101 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_101 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_101 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><p>Here is an example of its use:</p>
<pre>
 $initials = substr($first_name,0,1) ~ substr($last_name,0,1);</pre>
<a name="msg_60"></a>
<a href="?hide_quotes=no#msg_60" onclick="return tog_quote(60);">
<div ID=header_shown_60 style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID=header_hidden_60 style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -</div>
</a>
<div ID=hide_60 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /substr/&gt;

{ # read only
    my $str = "foobar";

    is(substr($str, 0, 1), "f", "first char");
    is(substr($str, -1), "r", "last char");
    is(substr($str, -4, 2), "ob", "counted from the end");
    is(substr($str, 1, 2), "oo", "arbitrary middle");
    is(substr($str, 3), "bar", "length omitted");
    is(substr($str, 3, 10), "bar", "length goes past end");
    is(substr($str, 20, 5), undef, "substr outside of string");
    is(substr($str, -100, 10), undef, "... on the negative side");

    is(substr($str, 0, -2), "foob", "from beginning, with negative length");
    is(substr($str, 2, -2), "ob", "in middle, with negative length");
    is(substr($str, 3, -3), "", "negative length - gives empty string");

    is($str, "foobar", "original string still not changed");
};

skip 4, "more discussion needed";

=begin more-discussion-needed

{ # replacement
    my $str = "foobar";

    substr($str, 2, 1, "i");
    is($str, "foibar", "fourth arg to substr replaced part");

    substr($str, -1, 1, "blah");
    is($str, "foibablah", "longer replacement expands string");

    substr($str, 1, 3, "");
    is($str, "fablah", "shorter replacement shrunk it");

    substr($str, 1, -1, "aye");
    is($str, "fayeh", "replacement with negative length");
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, "gloop", '$r referent is eq to the substring');

    $$r = "boing";
    is($str, "boing ding", "assignment to reference modifies original", :todo);
    is($$r, "boing", '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, "ng", "other ref to other lvalue", :todo);
    $$r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works", :todo);
    is($$o, " d", "other lvalue wiggled around", :todo);
};

{ # as lvalue, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");
};

{ # as lvalue, using :=, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r := substr($str, 0, 5);
    is($r, "gloop", 'bound $r is eq to the substring');

    $r = "boing";
    is($str, "boing ding", "assignment to bound var modifies original");
    is($r, "boing", 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, "ng", "other bound var to other lvalue");
    $r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works");
    is($o, " d", "other lvalue wiggled around", :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/"Junctions" /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr("camel", 0|1, 2&amp;3)', (("ca"|"am") &amp; ("cam"|"ame")), "junctive substr", :todo);
}


{ # misc
    my $str = "hello foo and bar";
    is(substr($str, 6, 3), "foo", "substr");
    is($str.substr(6, 3), "foo", ".substr");
    is(substr("hello foo bar", 6, 3), "foo", "substr on literal string");
    is("hello foo bar".substr(6, 3), "foo", ".substr on literal string");
    is("hello foo bar".substr(6, 3).uc, "FOO", ".substr.uc on literal string");
    is("hello foo bar and baz".substr(6, 10).capitalize, "Foo Bar An", ".substr.capitalize on literal string");
    is("hello »« foo".substr(6, 2), "»«", ".substr on unicode string");
    is("שיעבוד כבר".substr(4, 4), "וד כ", ".substr on Hebrew text");
}
</pre>
</div><a name="msg_102"></a>
<a href="?hide_quotes=no#msg_102" onclick="return tog_quote(102);">
<div ID=header_shown_102 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_102 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_102 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><p>Optionally, you can use substr on the left hand side of an assignment
like so:</p>
<a name="msg_61"></a>
<a href="?hide_quotes=no#msg_61" onclick="return tog_quote(61);">
<div ID=header_shown_61 style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID=header_hidden_61 style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -</div>
</a>
<div ID=hide_61 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /substr/&gt;

{ # read only
    my $str = "foobar";

    is(substr($str, 0, 1), "f", "first char");
    is(substr($str, -1), "r", "last char");
    is(substr($str, -4, 2), "ob", "counted from the end");
    is(substr($str, 1, 2), "oo", "arbitrary middle");
    is(substr($str, 3), "bar", "length omitted");
    is(substr($str, 3, 10), "bar", "length goes past end");
    is(substr($str, 20, 5), undef, "substr outside of string");
    is(substr($str, -100, 10), undef, "... on the negative side");

    is(substr($str, 0, -2), "foob", "from beginning, with negative length");
    is(substr($str, 2, -2), "ob", "in middle, with negative length");
    is(substr($str, 3, -3), "", "negative length - gives empty string");

    is($str, "foobar", "original string still not changed");
};

skip 4, "more discussion needed";

=begin more-discussion-needed

{ # replacement
    my $str = "foobar";

    substr($str, 2, 1, "i");
    is($str, "foibar", "fourth arg to substr replaced part");

    substr($str, -1, 1, "blah");
    is($str, "foibablah", "longer replacement expands string");

    substr($str, 1, 3, "");
    is($str, "fablah", "shorter replacement shrunk it");

    substr($str, 1, -1, "aye");
    is($str, "fayeh", "replacement with negative length");
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, "gloop", '$r referent is eq to the substring');

    $$r = "boing";
    is($str, "boing ding", "assignment to reference modifies original", :todo);
    is($$r, "boing", '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, "ng", "other ref to other lvalue", :todo);
    $$r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works", :todo);
    is($$o, " d", "other lvalue wiggled around", :todo);
};

{ # as lvalue, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");
};

{ # as lvalue, using :=, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r := substr($str, 0, 5);
    is($r, "gloop", 'bound $r is eq to the substring');

    $r = "boing";
    is($str, "boing ding", "assignment to bound var modifies original");
    is($r, "boing", 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, "ng", "other bound var to other lvalue");
    $r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works");
    is($o, " d", "other lvalue wiggled around", :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/"Junctions" /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr("camel", 0|1, 2&amp;3)', (("ca"|"am") &amp; ("cam"|"ame")), "junctive substr", :todo);
}


{ # misc
    my $str = "hello foo and bar";
    is(substr($str, 6, 3), "foo", "substr");
    is($str.substr(6, 3), "foo", ".substr");
    is(substr("hello foo bar", 6, 3), "foo", "substr on literal string");
    is("hello foo bar".substr(6, 3), "foo", ".substr on literal string");
    is("hello foo bar".substr(6, 3).uc, "FOO", ".substr.uc on literal string");
    is("hello foo bar and baz".substr(6, 10).capitalize, "Foo Bar An", ".substr.capitalize on literal string");
    is("hello »« foo".substr(6, 2), "»«", ".substr on unicode string");
    is("שיעבוד כבר".substr(4, 4), "וד כ", ".substr on Hebrew text");
}
</pre>
</div><a name="msg_103"></a>
<a href="?hide_quotes=no#msg_103" onclick="return tog_quote(103);">
<div ID=header_shown_103 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_103 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_103 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><pre>
 substr($string, 1, 5) = &quot;fred&quot;;</pre>
<a name="msg_62"></a>
<a href="?hide_quotes=no#msg_62" onclick="return tog_quote(62);">
<div ID=header_shown_62 style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID=header_hidden_62 style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125, 119 lines) -</div>
</a>
<div ID=hide_62 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /substr/&gt;

{ # read only
    my $str = "foobar";

    is(substr($str, 0, 1), "f", "first char");
    is(substr($str, -1), "r", "last char");
    is(substr($str, -4, 2), "ob", "counted from the end");
    is(substr($str, 1, 2), "oo", "arbitrary middle");
    is(substr($str, 3), "bar", "length omitted");
    is(substr($str, 3, 10), "bar", "length goes past end");
    is(substr($str, 20, 5), undef, "substr outside of string");
    is(substr($str, -100, 10), undef, "... on the negative side");

    is(substr($str, 0, -2), "foob", "from beginning, with negative length");
    is(substr($str, 2, -2), "ob", "in middle, with negative length");
    is(substr($str, 3, -3), "", "negative length - gives empty string");

    is($str, "foobar", "original string still not changed");
};

skip 4, "more discussion needed";

=begin more-discussion-needed

{ # replacement
    my $str = "foobar";

    substr($str, 2, 1, "i");
    is($str, "foibar", "fourth arg to substr replaced part");

    substr($str, -1, 1, "blah");
    is($str, "foibablah", "longer replacement expands string");

    substr($str, 1, 3, "");
    is($str, "fablah", "shorter replacement shrunk it");

    substr($str, 1, -1, "aye");
    is($str, "fayeh", "replacement with negative length");
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
#   my $substr = \substr($str, ...);
#   ...;
#   some_func $substr; # manipulates $substr
#   # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r = \substr($str, 0, 5);
    ok(~ref($r), '$r is a reference');
    is($$r, "gloop", '$r referent is eq to the substring');

    $$r = "boing";
    is($str, "boing ding", "assignment to reference modifies original", :todo);
    is($$r, "boing", '$r is consistent');

    my $o = \substr($str, 3, 2);
    is($$o, "ng", "other ref to other lvalue", :todo);
    $$r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works", :todo);
    is($$o, " d", "other lvalue wiggled around", :todo);
};

{ # as lvalue, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");
};

{ # as lvalue, using :=, should work
    my $str = "gorch ding";

    substr($str, 0, 5) = "gloop";
    is($str, "gloop ding", "lvalue assignment modified original string");

    my $r := substr($str, 0, 5);
    is($r, "gloop", 'bound $r is eq to the substring');

    $r = "boing";
    is($str, "boing ding", "assignment to bound var modifies original");
    is($r, "boing", 'bound $r is consistent', :todo&lt;bug&gt;);

    my $o := substr($str, 3, 2);
    is($o, "ng", "other bound var to other lvalue");
    $r = "foo";
    is($str, "foo ding", "lvalue ref size varies but still works");
    is($o, " d", "other lvalue wiggled around", :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/"Junctions" /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
#    eval_is('substr("camel", 0|1, 2&amp;3)', (("ca"|"am") &amp; ("cam"|"ame")), "junctive substr", :todo);
}


{ # misc
    my $str = "hello foo and bar";
    is(substr($str, 6, 3), "foo", "substr");
    is($str.substr(6, 3), "foo", ".substr");
    is(substr("hello foo bar", 6, 3), "foo", "substr on literal string");
    is("hello foo bar".substr(6, 3), "foo", ".substr on literal string");
    is("hello foo bar".substr(6, 3).uc, "FOO", ".substr.uc on literal string");
    is("hello foo bar and baz".substr(6, 10).capitalize, "Foo Bar An", ".substr.capitalize on literal string");
    is("hello »« foo".substr(6, 2), "»«", ".substr on unicode string");
    is("שיעבוד כבר".substr(4, 4), "וד כ", ".substr on Hebrew text");
}
</pre>
</div><a name="msg_104"></a>
<a href="?hide_quotes=no#msg_104" onclick="return tog_quote(104);">
<div ID=header_shown_104 style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID=header_hidden_104 style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30, 23 lines) -</div>
</a>
<div ID=hide_104 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Str" /uc/&gt;

is(uc("Hello World"), "HELLO WORLD", "simple");
is(uc(""), "", "empty string"); 
is(uc("åäö"), "ÅÄÖ", "some finnish non-ascii chars");
is(uc("óòúù"), "ÓÒÚÙ", "accented chars");

# given does not return proper value yet
$_ = "Hello World";
my $x = .uc;
is $x, "HELLO WORLD", 'uc uses the default $_';

{   
    my $x = "Hello World";
    is $x.uc, "HELLO WORLD", '$x.uc works';
    is "Hello World".uc, "HELLO WORLD", '"Hello World".uc works';
}

# Bug: GERMAN SHARP S ("ß") should uc() to "SS", but it doesn't
# Compare with: perl -we 'use utf8; print uc "ß"'
is(uc("ß"), "SS", "uc() of non-ascii chars may result in two chars");

is("áéíöüóűőú".uc, "ÁÉÍÖÜÓŰŐÚ", ".uc on Hungarian vowels");</pre>
</div><p>If the replacement string is longer or shorter than the matched sub-string,
then the original string will be dynamically resized.</p>
<p>[ Note: Is the word ``length'' a problem, here, given Perl 6's
        general desire to stop using length with respect to strings? -ajs ]</p>
<dt><strong><a name="item_unpack">unpack</a></strong><br />
</dt>
<dt><strong><a name="item_vec">vec</a></strong><br />
</dt>
<dd>
Should replace vec with declared arrays of bit, uint2, uint4, etc.
</dd>
<p></p>
<dt><strong><a name="item_words">words</a></strong><br />
</dt>
<dd>
<pre>
 our List multi Str::words ( Rule $matcher = /\S+/,  Str $input, Int $limit = inf )
 our List multi Str::words ( Str $input ; Rule $matcher = /\S+/, Int $limit = inf )</pre>
</dd>
</dl>
<p>
</p>
<h2><a name="Control3a3aBasic">Control::Basic</a></h2>
<dl>
<dt><strong><a name="item_caller">caller</a></strong><br />
</dt>
<dd>
TODO
</dd>
<p></p>
<dt><strong><a name="item_eval">eval</a></strong><br />
</dt>
<dd>
<pre>
 multi Control::Basic::eval ( Str $code, Grammar :$lang = CALLER::&lt;$?PARSER&gt;)</pre>
</dd>
<dd>
<p>Execute <code>$code</code> as if it were code written in <code>$lang</code>.  The default
is the language in effect at the exact location of the eval call.</p>
</dd>
<dd>
<p>Returns whatever <code>$code</code> returns, or undef on error.</p>
</dd>
<dt><strong><a name="item_evalfile">evalfile</a></strong><br />
</dt>
<dd>
<pre>
 multi Control::Basic::evalfile (Str $filename ; Grammar :$lang = Perl6)</pre>
</dd>
<dd>
<p>Behaves like, and replaces Perl 5 <code>do EXPR</code>, with optional <code>$lang</code>
support.</p>
</dd>
<dt><strong><a name="item_exit">exit</a></strong><br />
</dt>
<dd>
<pre>
 multi Control::Basic::exit ( Int $status = 0)</pre>
</dd>
<dd>
<p>Stops all program execution, and returns <code>$status</code> to the calling environment.</p>
</dd>
<dt><strong><a name="item_nothing">nothing</a></strong><br />
</dt>
<a name="msg_114"></a>
<a href="?hide_quotes=no#msg_114" onclick="return tog_quote(114);">
<div ID=header_shown_114 style="display: none;">
- Hide the snippet from t/builtins/control_flow/nothing.t (line 11 ~ line 21) -
</div>
<div ID=header_hidden_114 style="display: block;">
- Show the snippet from t/builtins/control_flow/nothing.t (line 11 ~ line 21, 11 lines) -</div>
</a>
<div ID=hide_114 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Control::Basic" /nothing/&gt;

plan 2;

lives_ok { nothing }, "nothing() works";

# Probably the most commonly used form:
my $var;
nothing while $var++ &lt; 3;
# We're still here, so pass().
pass "nothing() works in while";</pre>
</div><pre>
 multi Control::Basic::nothing ()</pre>
<a name="msg_115"></a>
<a href="?hide_quotes=no#msg_115" onclick="return tog_quote(115);">
<div ID=header_shown_115 style="display: none;">
- Hide the snippet from t/builtins/control_flow/nothing.t (line 11 ~ line 21) -
</div>
<div ID=header_hidden_115 style="display: block;">
- Show the snippet from t/builtins/control_flow/nothing.t (line 11 ~ line 21, 11 lines) -</div>
</a>
<div ID=hide_115 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Control::Basic" /nothing/&gt;

plan 2;

lives_ok { nothing }, "nothing() works";

# Probably the most commonly used form:
my $var;
nothing while $var++ &lt; 3;
# We're still here, so pass().
pass "nothing() works in while";</pre>
</div><p>No operation. Literally does nothing.</p>
<a name="msg_116"></a>
<a href="?hide_quotes=no#msg_116" onclick="return tog_quote(116);">
<div ID=header_shown_116 style="display: none;">
- Hide the snippet from t/builtins/control_flow/nothing.t (line 11 ~ line 21) -
</div>
<div ID=header_hidden_116 style="display: block;">
- Show the snippet from t/builtins/control_flow/nothing.t (line 11 ~ line 21, 11 lines) -</div>
</a>
<div ID=hide_116 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Control::Basic" /nothing/&gt;

plan 2;

lives_ok { nothing }, "nothing() works";

# Probably the most commonly used form:
my $var;
nothing while $var++ &lt; 3;
# We're still here, so pass().
pass "nothing() works in while";</pre>
</div><dt><strong><a name="item_sleep">sleep</a></strong><br />
</dt>
<dd>
<pre>
 our Num multi Control::Basic::sleep ( Num $for = Inf )</pre>
</dd>
<dd>
<p>Attempt to sleep for up to <code>$for</code> seconds. Implementations are obligated
to support sub-second resolutions if that is at all possible.</p>
</dd>
<dd>
<p>This is exactly the same as:</p>
</dd>
<dd>
<pre>
 $$.sleep($for)</pre>
</dd>
<dd>
<p>See <code>Synopsis 17: Concurrency</code> for more details.</p>
</dd>
<dt><strong><a name="item_want">want</a></strong><br />
</dt>
<dd>
TODO
</dd>
<p></p>
<dt><strong><a name="item_word">word</a></strong><br />
</dt>
<dd>
<a href="#item_word"><code>word</code></a> is almost exactly the same as <code>macro</code>, only defines macros which
take no arguments. For example:
</dd>
<dd>
<pre>
 word foo { &quot;'foo'.say&quot; }
 foo;</pre>
</dd>
<dd>
<p><table cellspacing="0" cellpadding="0"><tr><td>[ Refs:
<tr><td><td>Message-ID: &lt;<a href="mailto:20050614164447.GA14958@wall.org">20050614164447.GA14958@wall.org</a>&gt;</table></p>
</dd>
<dd>
<pre>
        Date: Tue, 14 Jun 2005 09:44:47 -0700  (12:44 EDT)
        From: Larry Wall &lt;larry@wall.org&gt;
        To: perl6-language@perl.org
]</pre>
</dd>
<p></p>
<dt><strong><a name="item_die">die</a></strong><br />
</dt>
<dt><strong><a name="item_fail">fail</a></strong><br />
</dt>
<dd>
<strong>TODO</strong>: Research the exception handling system.
</dd>
<p></p></dl>
<p>
</p>
<h2><a name="Conversions">Conversions</a></h2>
<dl>
<dt><strong><a name="item_bless">bless</a></strong><br />
</dt>
<dd>
<pre>
 our Object multi method Class::bless( Object::RepCandidate $candidate )
 our Object multi method Class::bless( *%args )</pre>
</dd>
<dd>
<p><a href="#item_bless"><code>bless</code></a> is only available as a method which can be called on a class
object like so:</p>
</dd>
<dd>
<pre>
 $object = $class.bless(k1 =&gt; $v1, k2 =&gt; $v2, ...);</pre>
</dd>
<dd>
<p>A newly created object, based on either the <code>$candidate</code> representation
or a newly created representation (initialized with the <code>%args</code> that
are passed in) when the second form is used.</p>
</dd>
<dd>
<p>It automatically calls all appropriate BUILD routines by calling the
BUILDALL routine for the current class, which initializes the object in
least-derived to most-derived order. See <a href="#synopsis20123a20objects">Synopsis 12: Objects</a>
for more detailed information on object creation.</p>
</dd>
<a name="msg_2"></a>
<a href="?hide_quotes=no#msg_2" onclick="return tog_quote(2);">
<div ID=header_shown_2 style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 11) -
</div>
<div ID=header_hidden_2 style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 11, 1 lines) -</div>
</a>
<div ID=hide_2 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Conversions" /ord/&gt;</pre>
</div><a name="msg_8"></a>
<a href="?hide_quotes=no#msg_8" onclick="return tog_quote(8);">
<div ID=header_shown_8 style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136) -
</div>
<div ID=header_hidden_8 style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136, 125 lines) -</div>
</a>
<div ID=hide_8 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Conversions" /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  " ",    32,
  "!",    33,
  "\"",   34,
  "#",    35,
  "$",    36,
  "%",    37,
  "&amp;",    38,
  "\'",   39,
  "(",    40,
  ")",    41,
  "*",    42,
  "+",    43,
  ",",    44,
  "-",    45,
  ".",    46,
  "/",    47,
  "0",    48,
  "1",    49,
  "2",    50,
  "3",    51,
  "4",    52,
  "5",    53,
  "6",    54,
  "7",    55,
  "8",    56,
  "9",    57,
  ":",    58,
  ";",    59,
  "&lt;",    60,
  "=",    61,
  "&gt;",    62,
  "?",    63,
  "@",    64,
  "A",    65,
  "B",    66,
  "C",    67,
  "D",    68,
  "E",    69,
  "F",    70,
  "G",    71,
  "H",    72,
  "I",    73,
  "J",    74,
  "K",    75,
  "L",    76,
  "M",    77,
  "N",    78,
  "O",    79,
  "P",    80,
  "Q",    81,
  "R",    82,
  "S",    83,
  "T",    84,
  "U",    85,
  "V",    86,
  "W",    87,
  "X",    88,
  "Y",    89,
  "Z",    90,
  "[",    91,
  "\\",   92,
  "]",    93,
  "^",    94,
  "_",    95,
  "`",    96,
  "a",    97,
  "b",    98,
  "c",    99,
  "d",    100,
  "e",    101,
  "f",    102,
  "g",    103,
  "h",    104,
  "i",    105,
  "j",    106,
  "k",    107,
  "l",    108,
  "m",    109,
  "n",    110,
  "o",    111,
  "p",    112,
  "q",    113,
  "r",    114,
  "s",    115,
  "t",    116,
  "u",    117,
  "v",    118,
  "w",    119,
  "x",    120,
  "y",    121,
  "z",    122,
  "|",    124,
  "}",    125,
  "~",    126,

  # Unicode tests
  "ä",    228,
  "€",    8364,
  "»",    187,
  "«",    171,

  # Special chars
  "\o00", 0,
  "\o01", 1,
  "\o03", 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = "\\{$code}{$code &gt;= 32 ?? " == '{$char}'" !! ""}";
  is ord($char), $code, "ord() works for $descr";
  is chr($code), $char, "chr() works for $descr";
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, "ord(chr($code)) is $code";
}

</pre>
</div><dt><strong><a name="item_chr">chr</a></strong><br />
</dt>
<a name="msg_9"></a>
<a href="?hide_quotes=no#msg_9" onclick="return tog_quote(9);">
<div ID=header_shown_9 style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136) -
</div>
<div ID=header_hidden_9 style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136, 125 lines) -</div>
</a>
<div ID=hide_9 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Conversions" /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  " ",    32,
  "!",    33,
  "\"",   34,
  "#",    35,
  "$",    36,
  "%",    37,
  "&amp;",    38,
  "\'",   39,
  "(",    40,
  ")",    41,
  "*",    42,
  "+",    43,
  ",",    44,
  "-",    45,
  ".",    46,
  "/",    47,
  "0",    48,
  "1",    49,
  "2",    50,
  "3",    51,
  "4",    52,
  "5",    53,
  "6",    54,
  "7",    55,
  "8",    56,
  "9",    57,
  ":",    58,
  ";",    59,
  "&lt;",    60,
  "=",    61,
  "&gt;",    62,
  "?",    63,
  "@",    64,
  "A",    65,
  "B",    66,
  "C",    67,
  "D",    68,
  "E",    69,
  "F",    70,
  "G",    71,
  "H",    72,
  "I",    73,
  "J",    74,
  "K",    75,
  "L",    76,
  "M",    77,
  "N",    78,
  "O",    79,
  "P",    80,
  "Q",    81,
  "R",    82,
  "S",    83,
  "T",    84,
  "U",    85,
  "V",    86,
  "W",    87,
  "X",    88,
  "Y",    89,
  "Z",    90,
  "[",    91,
  "\\",   92,
  "]",    93,
  "^",    94,
  "_",    95,
  "`",    96,
  "a",    97,
  "b",    98,
  "c",    99,
  "d",    100,
  "e",    101,
  "f",    102,
  "g",    103,
  "h",    104,
  "i",    105,
  "j",    106,
  "k",    107,
  "l",    108,
  "m",    109,
  "n",    110,
  "o",    111,
  "p",    112,
  "q",    113,
  "r",    114,
  "s",    115,
  "t",    116,
  "u",    117,
  "v",    118,
  "w",    119,
  "x",    120,
  "y",    121,
  "z",    122,
  "|",    124,
  "}",    125,
  "~",    126,

  # Unicode tests
  "ä",    228,
  "€",    8364,
  "»",    187,
  "«",    171,

  # Special chars
  "\o00", 0,
  "\o01", 1,
  "\o03", 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = "\\{$code}{$code &gt;= 32 ?? " == '{$char}'" !! ""}";
  is ord($char), $code, "ord() works for $descr";
  is chr($code), $char, "chr() works for $descr";
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, "ord(chr($code)) is $code";
}

</pre>
</div><dt><strong><a name="item_ord">ord</a></strong><br />
</dt>
<a name="msg_3"></a>
<a href="?hide_quotes=no#msg_3" onclick="return tog_quote(3);">
<div ID=header_shown_3 style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 11) -
</div>
<div ID=header_hidden_3 style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 11, 1 lines) -</div>
</a>
<div ID=hide_3 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Conversions" /ord/&gt;</pre>
</div><a name="msg_10"></a>
<a href="?hide_quotes=no#msg_10" onclick="return tog_quote(10);">
<div ID=header_shown_10 style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136) -
</div>
<div ID=header_hidden_10 style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136, 125 lines) -</div>
</a>
<div ID=hide_10 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Conversions" /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  " ",    32,
  "!",    33,
  "\"",   34,
  "#",    35,
  "$",    36,
  "%",    37,
  "&amp;",    38,
  "\'",   39,
  "(",    40,
  ")",    41,
  "*",    42,
  "+",    43,
  ",",    44,
  "-",    45,
  ".",    46,
  "/",    47,
  "0",    48,
  "1",    49,
  "2",    50,
  "3",    51,
  "4",    52,
  "5",    53,
  "6",    54,
  "7",    55,
  "8",    56,
  "9",    57,
  ":",    58,
  ";",    59,
  "&lt;",    60,
  "=",    61,
  "&gt;",    62,
  "?",    63,
  "@",    64,
  "A",    65,
  "B",    66,
  "C",    67,
  "D",    68,
  "E",    69,
  "F",    70,
  "G",    71,
  "H",    72,
  "I",    73,
  "J",    74,
  "K",    75,
  "L",    76,
  "M",    77,
  "N",    78,
  "O",    79,
  "P",    80,
  "Q",    81,
  "R",    82,
  "S",    83,
  "T",    84,
  "U",    85,
  "V",    86,
  "W",    87,
  "X",    88,
  "Y",    89,
  "Z",    90,
  "[",    91,
  "\\",   92,
  "]",    93,
  "^",    94,
  "_",    95,
  "`",    96,
  "a",    97,
  "b",    98,
  "c",    99,
  "d",    100,
  "e",    101,
  "f",    102,
  "g",    103,
  "h",    104,
  "i",    105,
  "j",    106,
  "k",    107,
  "l",    108,
  "m",    109,
  "n",    110,
  "o",    111,
  "p",    112,
  "q",    113,
  "r",    114,
  "s",    115,
  "t",    116,
  "u",    117,
  "v",    118,
  "w",    119,
  "x",    120,
  "y",    121,
  "z",    122,
  "|",    124,
  "}",    125,
  "~",    126,

  # Unicode tests
  "ä",    228,
  "€",    8364,
  "»",    187,
  "«",    171,

  # Special chars
  "\o00", 0,
  "\o01", 1,
  "\o03", 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = "\\{$code}{$code &gt;= 32 ?? " == '{$char}'" !! ""}";
  is ord($char), $code, "ord() works for $descr";
  is chr($code), $char, "chr() works for $descr";
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, "ord(chr($code)) is $code";
}

</pre>
</div><pre>
 our Uni multi Str::chr( Uni $codepoint )</pre>
<a name="msg_11"></a>
<a href="?hide_quotes=no#msg_11" onclick="return tog_quote(11);">
<div ID=header_shown_11 style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136) -
</div>
<div ID=header_hidden_11 style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136, 125 lines) -</div>
</a>
<div ID=hide_11 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Conversions" /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  " ",    32,
  "!",    33,
  "\"",   34,
  "#",    35,
  "$",    36,
  "%",    37,
  "&amp;",    38,
  "\'",   39,
  "(",    40,
  ")",    41,
  "*",    42,
  "+",    43,
  ",",    44,
  "-",    45,
  ".",    46,
  "/",    47,
  "0",    48,
  "1",    49,
  "2",    50,
  "3",    51,
  "4",    52,
  "5",    53,
  "6",    54,
  "7",    55,
  "8",    56,
  "9",    57,
  ":",    58,
  ";",    59,
  "&lt;",    60,
  "=",    61,
  "&gt;",    62,
  "?",    63,
  "@",    64,
  "A",    65,
  "B",    66,
  "C",    67,
  "D",    68,
  "E",    69,
  "F",    70,
  "G",    71,
  "H",    72,
  "I",    73,
  "J",    74,
  "K",    75,
  "L",    76,
  "M",    77,
  "N",    78,
  "O",    79,
  "P",    80,
  "Q",    81,
  "R",    82,
  "S",    83,
  "T",    84,
  "U",    85,
  "V",    86,
  "W",    87,
  "X",    88,
  "Y",    89,
  "Z",    90,
  "[",    91,
  "\\",   92,
  "]",    93,
  "^",    94,
  "_",    95,
  "`",    96,
  "a",    97,
  "b",    98,
  "c",    99,
  "d",    100,
  "e",    101,
  "f",    102,
  "g",    103,
  "h",    104,
  "i",    105,
  "j",    106,
  "k",    107,
  "l",    108,
  "m",    109,
  "n",    110,
  "o",    111,
  "p",    112,
  "q",    113,
  "r",    114,
  "s",    115,
  "t",    116,
  "u",    117,
  "v",    118,
  "w",    119,
  "x",    120,
  "y",    121,
  "z",    122,
  "|",    124,
  "}",    125,
  "~",    126,

  # Unicode tests
  "ä",    228,
  "€",    8364,
  "»",    187,
  "«",    171,

  # Special chars
  "\o00", 0,
  "\o01", 1,
  "\o03", 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = "\\{$code}{$code &gt;= 32 ?? " == '{$char}'" !! ""}";
  is ord($char), $code, "ord() works for $descr";
  is chr($code), $char, "chr() works for $descr";
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, "ord(chr($code)) is $code";
}

</pre>
</div><pre>
 our Uni multi Str::ord( Uni $character )</pre>
<a name="msg_4"></a>
<a href="?hide_quotes=no#msg_4" onclick="return tog_quote(4);">
<div ID=header_shown_4 style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 11) -
</div>
<div ID=header_hidden_4 style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 11, 1 lines) -</div>
</a>
<div ID=hide_4 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Conversions" /ord/&gt;</pre>
</div><a name="msg_12"></a>
<a href="?hide_quotes=no#msg_12" onclick="return tog_quote(12);">
<div ID=header_shown_12 style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136) -
</div>
<div ID=header_hidden_12 style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136, 125 lines) -</div>
</a>
<div ID=hide_12 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Conversions" /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  " ",    32,
  "!",    33,
  "\"",   34,
  "#",    35,
  "$",    36,
  "%",    37,
  "&amp;",    38,
  "\'",   39,
  "(",    40,
  ")",    41,
  "*",    42,
  "+",    43,
  ",",    44,
  "-",    45,
  ".",    46,
  "/",    47,
  "0",    48,
  "1",    49,
  "2",    50,
  "3",    51,
  "4",    52,
  "5",    53,
  "6",    54,
  "7",    55,
  "8",    56,
  "9",    57,
  ":",    58,
  ";",    59,
  "&lt;",    60,
  "=",    61,
  "&gt;",    62,
  "?",    63,
  "@",    64,
  "A",    65,
  "B",    66,
  "C",    67,
  "D",    68,
  "E",    69,
  "F",    70,
  "G",    71,
  "H",    72,
  "I",    73,
  "J",    74,
  "K",    75,
  "L",    76,
  "M",    77,
  "N",    78,
  "O",    79,
  "P",    80,
  "Q",    81,
  "R",    82,
  "S",    83,
  "T",    84,
  "U",    85,
  "V",    86,
  "W",    87,
  "X",    88,
  "Y",    89,
  "Z",    90,
  "[",    91,
  "\\",   92,
  "]",    93,
  "^",    94,
  "_",    95,
  "`",    96,
  "a",    97,
  "b",    98,
  "c",    99,
  "d",    100,
  "e",    101,
  "f",    102,
  "g",    103,
  "h",    104,
  "i",    105,
  "j",    106,
  "k",    107,
  "l",    108,
  "m",    109,
  "n",    110,
  "o",    111,
  "p",    112,
  "q",    113,
  "r",    114,
  "s",    115,
  "t",    116,
  "u",    117,
  "v",    118,
  "w",    119,
  "x",    120,
  "y",    121,
  "z",    122,
  "|",    124,
  "}",    125,
  "~",    126,

  # Unicode tests
  "ä",    228,
  "€",    8364,
  "»",    187,
  "«",    171,

  # Special chars
  "\o00", 0,
  "\o01", 1,
  "\o03", 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = "\\{$code}{$code &gt;= 32 ?? " == '{$char}'" !! ""}";
  is ord($char), $code, "ord() works for $descr";
  is chr($code), $char, "chr() works for $descr";
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, "ord(chr($code)) is $code";
}

</pre>
</div><pre>
 multi Str::ord( Str $string )</pre>
<a name="msg_5"></a>
<a href="?hide_quotes=no#msg_5" onclick="return tog_quote(5);">
<div ID=header_shown_5 style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 11) -
</div>
<div ID=header_hidden_5 style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 11, 1 lines) -</div>
</a>
<div ID=hide_5 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Conversions" /ord/&gt;</pre>
</div><a name="msg_13"></a>
<a href="?hide_quotes=no#msg_13" onclick="return tog_quote(13);">
<div ID=header_shown_13 style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136) -
</div>
<div ID=header_hidden_13 style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136, 125 lines) -</div>
</a>
<div ID=hide_13 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Conversions" /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  " ",    32,
  "!",    33,
  "\"",   34,
  "#",    35,
  "$",    36,
  "%",    37,
  "&amp;",    38,
  "\'",   39,
  "(",    40,
  ")",    41,
  "*",    42,
  "+",    43,
  ",",    44,
  "-",    45,
  ".",    46,
  "/",    47,
  "0",    48,
  "1",    49,
  "2",    50,
  "3",    51,
  "4",    52,
  "5",    53,
  "6",    54,
  "7",    55,
  "8",    56,
  "9",    57,
  ":",    58,
  ";",    59,
  "&lt;",    60,
  "=",    61,
  "&gt;",    62,
  "?",    63,
  "@",    64,
  "A",    65,
  "B",    66,
  "C",    67,
  "D",    68,
  "E",    69,
  "F",    70,
  "G",    71,
  "H",    72,
  "I",    73,
  "J",    74,
  "K",    75,
  "L",    76,
  "M",    77,
  "N",    78,
  "O",    79,
  "P",    80,
  "Q",    81,
  "R",    82,
  "S",    83,
  "T",    84,
  "U",    85,
  "V",    86,
  "W",    87,
  "X",    88,
  "Y",    89,
  "Z",    90,
  "[",    91,
  "\\",   92,
  "]",    93,
  "^",    94,
  "_",    95,
  "`",    96,
  "a",    97,
  "b",    98,
  "c",    99,
  "d",    100,
  "e",    101,
  "f",    102,
  "g",    103,
  "h",    104,
  "i",    105,
  "j",    106,
  "k",    107,
  "l",    108,
  "m",    109,
  "n",    110,
  "o",    111,
  "p",    112,
  "q",    113,
  "r",    114,
  "s",    115,
  "t",    116,
  "u",    117,
  "v",    118,
  "w",    119,
  "x",    120,
  "y",    121,
  "z",    122,
  "|",    124,
  "}",    125,
  "~",    126,

  # Unicode tests
  "ä",    228,
  "€",    8364,
  "»",    187,
  "«",    171,

  # Special chars
  "\o00", 0,
  "\o01", 1,
  "\o03", 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = "\\{$code}{$code &gt;= 32 ?? " == '{$char}'" !! ""}";
  is ord($char), $code, "ord() works for $descr";
  is chr($code), $char, "chr() works for $descr";
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, "ord(chr($code)) is $code";
}

</pre>
</div><p>These functions are available for purposes of backward compatibility.
<a href="#item_chr"><code>chr</code></a> takes a <a href="#item_Uni"><code>Uni</code></a> and returns the exact same value with no change.
This is because, in Perl 6, a Uni is both an integer codepoint when
numified and a single character when stringified. Thus, chr is just:</p>
<a name="msg_14"></a>
<a href="?hide_quotes=no#msg_14" onclick="return tog_quote(14);">
<div ID=header_shown_14 style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136) -
</div>
<div ID=header_hidden_14 style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136, 125 lines) -</div>
</a>
<div ID=hide_14 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Conversions" /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  " ",    32,
  "!",    33,
  "\"",   34,
  "#",    35,
  "$",    36,
  "%",    37,
  "&amp;",    38,
  "\'",   39,
  "(",    40,
  ")",    41,
  "*",    42,
  "+",    43,
  ",",    44,
  "-",    45,
  ".",    46,
  "/",    47,
  "0",    48,
  "1",    49,
  "2",    50,
  "3",    51,
  "4",    52,
  "5",    53,
  "6",    54,
  "7",    55,
  "8",    56,
  "9",    57,
  ":",    58,
  ";",    59,
  "&lt;",    60,
  "=",    61,
  "&gt;",    62,
  "?",    63,
  "@",    64,
  "A",    65,
  "B",    66,
  "C",    67,
  "D",    68,
  "E",    69,
  "F",    70,
  "G",    71,
  "H",    72,
  "I",    73,
  "J",    74,
  "K",    75,
  "L",    76,
  "M",    77,
  "N",    78,
  "O",    79,
  "P",    80,
  "Q",    81,
  "R",    82,
  "S",    83,
  "T",    84,
  "U",    85,
  "V",    86,
  "W",    87,
  "X",    88,
  "Y",    89,
  "Z",    90,
  "[",    91,
  "\\",   92,
  "]",    93,
  "^",    94,
  "_",    95,
  "`",    96,
  "a",    97,
  "b",    98,
  "c",    99,
  "d",    100,
  "e",    101,
  "f",    102,
  "g",    103,
  "h",    104,
  "i",    105,
  "j",    106,
  "k",    107,
  "l",    108,
  "m",    109,
  "n",    110,
  "o",    111,
  "p",    112,
  "q",    113,
  "r",    114,
  "s",    115,
  "t",    116,
  "u",    117,
  "v",    118,
  "w",    119,
  "x",    120,
  "y",    121,
  "z",    122,
  "|",    124,
  "}",    125,
  "~",    126,

  # Unicode tests
  "ä",    228,
  "€",    8364,
  "»",    187,
  "«",    171,

  # Special chars
  "\o00", 0,
  "\o01", 1,
  "\o03", 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = "\\{$code}{$code &gt;= 32 ?? " == '{$char}'" !! ""}";
  is ord($char), $code, "ord() works for $descr";
  is chr($code), $char, "chr() works for $descr";
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, "ord(chr($code)) is $code";
}

</pre>
</div><pre>
 our Uni multi Str::chr( Uni $codepoint) { $codepoint; }</pre>
<a name="msg_15"></a>
<a href="?hide_quotes=no#msg_15" onclick="return tog_quote(15);">
<div ID=header_shown_15 style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136) -
</div>
<div ID=header_hidden_15 style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136, 125 lines) -</div>
</a>
<div ID=hide_15 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Conversions" /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  " ",    32,
  "!",    33,
  "\"",   34,
  "#",    35,
  "$",    36,
  "%",    37,
  "&amp;",    38,
  "\'",   39,
  "(",    40,
  ")",    41,
  "*",    42,
  "+",    43,
  ",",    44,
  "-",    45,
  ".",    46,
  "/",    47,
  "0",    48,
  "1",    49,
  "2",    50,
  "3",    51,
  "4",    52,
  "5",    53,
  "6",    54,
  "7",    55,
  "8",    56,
  "9",    57,
  ":",    58,
  ";",    59,
  "&lt;",    60,
  "=",    61,
  "&gt;",    62,
  "?",    63,
  "@",    64,
  "A",    65,
  "B",    66,
  "C",    67,
  "D",    68,
  "E",    69,
  "F",    70,
  "G",    71,
  "H",    72,
  "I",    73,
  "J",    74,
  "K",    75,
  "L",    76,
  "M",    77,
  "N",    78,
  "O",    79,
  "P",    80,
  "Q",    81,
  "R",    82,
  "S",    83,
  "T",    84,
  "U",    85,
  "V",    86,
  "W",    87,
  "X",    88,
  "Y",    89,
  "Z",    90,
  "[",    91,
  "\\",   92,
  "]",    93,
  "^",    94,
  "_",    95,
  "`",    96,
  "a",    97,
  "b",    98,
  "c",    99,
  "d",    100,
  "e",    101,
  "f",    102,
  "g",    103,
  "h",    104,
  "i",    105,
  "j",    106,
  "k",    107,
  "l",    108,
  "m",    109,
  "n",    110,
  "o",    111,
  "p",    112,
  "q",    113,
  "r",    114,
  "s",    115,
  "t",    116,
  "u",    117,
  "v",    118,
  "w",    119,
  "x",    120,
  "y",    121,
  "z",    122,
  "|",    124,
  "}",    125,
  "~",    126,

  # Unicode tests
  "ä",    228,
  "€",    8364,
  "»",    187,
  "«",    171,

  # Special chars
  "\o00", 0,
  "\o01", 1,
  "\o03", 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = "\\{$code}{$code &gt;= 32 ?? " == '{$char}'" !! ""}";
  is ord($char), $code, "ord() works for $descr";
  is chr($code), $char, "chr() works for $descr";
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, "ord(chr($code)) is $code";
}

</pre>
</div><p><a href="#item_ord"><code>ord</code></a> is almost the same, but it also has a form that takes a string.
In a scalar context, the return value is the <a href="#item_Uni"><code>Uni</code></a> representing
the first codepoint in the string. In a list context, the return
value is the list of <a href="#item_Uni"><code>Uni</code></a>s representing the entire string.</p>
<a name="msg_6"></a>
<a href="?hide_quotes=no#msg_6" onclick="return tog_quote(6);">
<div ID=header_shown_6 style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 11) -
</div>
<div ID=header_hidden_6 style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 11, 1 lines) -</div>
</a>
<div ID=hide_6 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Conversions" /ord/&gt;</pre>
</div><a name="msg_16"></a>
<a href="?hide_quotes=no#msg_16" onclick="return tog_quote(16);">
<div ID=header_shown_16 style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136) -
</div>
<div ID=header_hidden_16 style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136, 125 lines) -</div>
</a>
<div ID=hide_16 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Conversions" /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  " ",    32,
  "!",    33,
  "\"",   34,
  "#",    35,
  "$",    36,
  "%",    37,
  "&amp;",    38,
  "\'",   39,
  "(",    40,
  ")",    41,
  "*",    42,
  "+",    43,
  ",",    44,
  "-",    45,
  ".",    46,
  "/",    47,
  "0",    48,
  "1",    49,
  "2",    50,
  "3",    51,
  "4",    52,
  "5",    53,
  "6",    54,
  "7",    55,
  "8",    56,
  "9",    57,
  ":",    58,
  ";",    59,
  "&lt;",    60,
  "=",    61,
  "&gt;",    62,
  "?",    63,
  "@",    64,
  "A",    65,
  "B",    66,
  "C",    67,
  "D",    68,
  "E",    69,
  "F",    70,
  "G",    71,
  "H",    72,
  "I",    73,
  "J",    74,
  "K",    75,
  "L",    76,
  "M",    77,
  "N",    78,
  "O",    79,
  "P",    80,
  "Q",    81,
  "R",    82,
  "S",    83,
  "T",    84,
  "U",    85,
  "V",    86,
  "W",    87,
  "X",    88,
  "Y",    89,
  "Z",    90,
  "[",    91,
  "\\",   92,
  "]",    93,
  "^",    94,
  "_",    95,
  "`",    96,
  "a",    97,
  "b",    98,
  "c",    99,
  "d",    100,
  "e",    101,
  "f",    102,
  "g",    103,
  "h",    104,
  "i",    105,
  "j",    106,
  "k",    107,
  "l",    108,
  "m",    109,
  "n",    110,
  "o",    111,
  "p",    112,
  "q",    113,
  "r",    114,
  "s",    115,
  "t",    116,
  "u",    117,
  "v",    118,
  "w",    119,
  "x",    120,
  "y",    121,
  "z",    122,
  "|",    124,
  "}",    125,
  "~",    126,

  # Unicode tests
  "ä",    228,
  "€",    8364,
  "»",    187,
  "«",    171,

  # Special chars
  "\o00", 0,
  "\o01", 1,
  "\o03", 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = "\\{$code}{$code &gt;= 32 ?? " == '{$char}'" !! ""}";
  is ord($char), $code, "ord() works for $descr";
  is chr($code), $char, "chr() works for $descr";
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, "ord(chr($code)) is $code";
}

</pre>
</div><p>An integer can be passed to <a href="#item_chr"><code>chr</code></a>, but it will automatically
be upgraded to a Uni (by interpreting it as a Unicode codepoint).</p>
<a name="msg_17"></a>
<a href="?hide_quotes=no#msg_17" onclick="return tog_quote(17);">
<div ID=header_shown_17 style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136) -
</div>
<div ID=header_hidden_17 style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136, 125 lines) -</div>
</a>
<div ID=hide_17 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Conversions" /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  " ",    32,
  "!",    33,
  "\"",   34,
  "#",    35,
  "$",    36,
  "%",    37,
  "&amp;",    38,
  "\'",   39,
  "(",    40,
  ")",    41,
  "*",    42,
  "+",    43,
  ",",    44,
  "-",    45,
  ".",    46,
  "/",    47,
  "0",    48,
  "1",    49,
  "2",    50,
  "3",    51,
  "4",    52,
  "5",    53,
  "6",    54,
  "7",    55,
  "8",    56,
  "9",    57,
  ":",    58,
  ";",    59,
  "&lt;",    60,
  "=",    61,
  "&gt;",    62,
  "?",    63,
  "@",    64,
  "A",    65,
  "B",    66,
  "C",    67,
  "D",    68,
  "E",    69,
  "F",    70,
  "G",    71,
  "H",    72,
  "I",    73,
  "J",    74,
  "K",    75,
  "L",    76,
  "M",    77,
  "N",    78,
  "O",    79,
  "P",    80,
  "Q",    81,
  "R",    82,
  "S",    83,
  "T",    84,
  "U",    85,
  "V",    86,
  "W",    87,
  "X",    88,
  "Y",    89,
  "Z",    90,
  "[",    91,
  "\\",   92,
  "]",    93,
  "^",    94,
  "_",    95,
  "`",    96,
  "a",    97,
  "b",    98,
  "c",    99,
  "d",    100,
  "e",    101,
  "f",    102,
  "g",    103,
  "h",    104,
  "i",    105,
  "j",    106,
  "k",    107,
  "l",    108,
  "m",    109,
  "n",    110,
  "o",    111,
  "p",    112,
  "q",    113,
  "r",    114,
  "s",    115,
  "t",    116,
  "u",    117,
  "v",    118,
  "w",    119,
  "x",    120,
  "y",    121,
  "z",    122,
  "|",    124,
  "}",    125,
  "~",    126,

  # Unicode tests
  "ä",    228,
  "€",    8364,
  "»",    187,
  "«",    171,

  # Special chars
  "\o00", 0,
  "\o01", 1,
  "\o03", 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = "\\{$code}{$code &gt;= 32 ?? " == '{$char}'" !! ""}";
  is ord($char), $code, "ord() works for $descr";
  is chr($code), $char, "chr() works for $descr";
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, "ord(chr($code)) is $code";
}

</pre>
</div><p>Be aware that the stringification of certain <a href="#item_Uni"><code>Uni</code></a>s will
fail because they have no stand-alone stringified interpretation.
Similarly, the creation of a <a href="#item_Uni"><code>Uni</code></a> from an integer might fail
due to the integer being out of range. If that
happens, an undefined <a href="#item_Uni"><code>Uni</code></a> is always returned. Similarly,
<a href="#item_chr"><code>chr(undef)</code></a> or <a href="#item_ord"><code>ord(undef)</code></a> will force the reutrn of an
undefined <a href="#item_Uni"><code>Uni</code></a>.</p>
<a name="msg_18"></a>
<a href="?hide_quotes=no#msg_18" onclick="return tog_quote(18);">
<div ID=header_shown_18 style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136) -
</div>
<div ID=header_hidden_18 style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136, 125 lines) -</div>
</a>
<div ID=hide_18 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Conversions" /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  " ",    32,
  "!",    33,
  "\"",   34,
  "#",    35,
  "$",    36,
  "%",    37,
  "&amp;",    38,
  "\'",   39,
  "(",    40,
  ")",    41,
  "*",    42,
  "+",    43,
  ",",    44,
  "-",    45,
  ".",    46,
  "/",    47,
  "0",    48,
  "1",    49,
  "2",    50,
  "3",    51,
  "4",    52,
  "5",    53,
  "6",    54,
  "7",    55,
  "8",    56,
  "9",    57,
  ":",    58,
  ";",    59,
  "&lt;",    60,
  "=",    61,
  "&gt;",    62,
  "?",    63,
  "@",    64,
  "A",    65,
  "B",    66,
  "C",    67,
  "D",    68,
  "E",    69,
  "F",    70,
  "G",    71,
  "H",    72,
  "I",    73,
  "J",    74,
  "K",    75,
  "L",    76,
  "M",    77,
  "N",    78,
  "O",    79,
  "P",    80,
  "Q",    81,
  "R",    82,
  "S",    83,
  "T",    84,
  "U",    85,
  "V",    86,
  "W",    87,
  "X",    88,
  "Y",    89,
  "Z",    90,
  "[",    91,
  "\\",   92,
  "]",    93,
  "^",    94,
  "_",    95,
  "`",    96,
  "a",    97,
  "b",    98,
  "c",    99,
  "d",    100,
  "e",    101,
  "f",    102,
  "g",    103,
  "h",    104,
  "i",    105,
  "j",    106,
  "k",    107,
  "l",    108,
  "m",    109,
  "n",    110,
  "o",    111,
  "p",    112,
  "q",    113,
  "r",    114,
  "s",    115,
  "t",    116,
  "u",    117,
  "v",    118,
  "w",    119,
  "x",    120,
  "y",    121,
  "z",    122,
  "|",    124,
  "}",    125,
  "~",    126,

  # Unicode tests
  "ä",    228,
  "€",    8364,
  "»",    187,
  "«",    171,

  # Special chars
  "\o00", 0,
  "\o01", 1,
  "\o03", 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = "\\{$code}{$code &gt;= 32 ?? " == '{$char}'" !! ""}";
  is ord($char), $code, "ord() works for $descr";
  is chr($code), $char, "chr() works for $descr";
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, "ord(chr($code)) is $code";
}

</pre>
</div><a name="msg_7"></a>
<a href="?hide_quotes=no#msg_7" onclick="return tog_quote(7);">
<div ID=header_shown_7 style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 11) -
</div>
<div ID=header_hidden_7 style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 11, 1 lines) -</div>
</a>
<div ID=hide_7 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Conversions" /ord/&gt;</pre>
</div><a name="msg_19"></a>
<a href="?hide_quotes=no#msg_19" onclick="return tog_quote(19);">
<div ID=header_shown_19 style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136) -
</div>
<div ID=header_hidden_19 style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136, 125 lines) -</div>
</a>
<div ID=hide_19 style="display:none; border:1px solid">
<pre>
# L&lt;S29/"Conversions" /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
  " ",    32,
  "!",    33,
  "\"",   34,
  "#",    35,
  "$",    36,
  "%",    37,
  "&amp;",    38,
  "\'",   39,
  "(",    40,
  ")",    41,
  "*",    42,
  "+",    43,
  ",",    44,
  "-",    45,
  ".",    46,
  "/",    47,
  "0",    48,
  "1",    49,
  "2",    50,
  "3",    51,
  "4",    52,
  "5",    53,
  "6",    54,
  "7",    55,
  "8",    56,
  "9",    57,
  ":",    58,
  ";",    59,
  "&lt;",    60,
  "=",    61,
  "&gt;",    62,
  "?",    63,
  "@",    64,
  "A",    65,
  "B",    66,
  "C",    67,
  "D",    68,
  "E",    69,
  "F",    70,
  "G",    71,
  "H",    72,
  "I",    73,
  "J",    74,
  "K",    75,
  "L",    76,
  "M",    77,
  "N",    78,
  "O",    79,
  "P",    80,
  "Q",    81,
  "R",    82,
  "S",    83,
  "T",    84,
  "U",    85,
  "V",    86,
  "W",    87,
  "X",    88,
  "Y",    89,
  "Z",    90,
  "[",    91,
  "\\",   92,
  "]",    93,
  "^",    94,
  "_",    95,
  "`",    96,
  "a",    97,
  "b",    98,
  "c",    99,
  "d",    100,
  "e",    101,
  "f",    102,
  "g",    103,
  "h",    104,
  "i",    105,
  "j",    106,
  "k",    107,
  "l",    108,
  "m",    109,
  "n",    110,
  "o",    111,
  "p",    112,
  "q",    113,
  "r",    114,
  "s",    115,
  "t",    116,
  "u",    117,
  "v",    118,
  "w",    119,
  "x",    120,
  "y",    121,
  "z",    122,
  "|",    124,
  "}",    125,
  "~",    126,

  # Unicode tests
  "ä",    228,
  "€",    8364,
  "»",    187,
  "«",    171,

  # Special chars
  "\o00", 0,
  "\o01", 1,
  "\o03", 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
  my $descr = "\\{$code}{$code &gt;= 32 ?? " == '{$char}'" !! ""}";
  is ord($char), $code, "ord() works for $descr";
  is chr($code), $char, "chr() works for $descr";
}

for 0..31 -&gt; $code {
  my $char = chr($code);
  is ord($char), $code, "ord(chr($code)) is $code";
}

</pre>
</div><dt><strong><a name="item_list">list</a></strong><br />
</dt>
<dd>
<pre>
 our List multi Conversions::List::list ( *@list )</pre>
</dd>
<dd>
<p>Forces List Context on it's arguments, and returns them.</p>
</dd>
<dt><strong><a name="item_item">item</a></strong><br />
</dt>
<dd>
<pre>
 our Item multi Conversions::Item::item ( $item )</pre>
</dd>
<dd>
<p>Forces generic Item context on its argument, and returns it.</p>
</dd>
<dt><strong><a name="item_253A16252C_253A8252C_253A2252C_253A10">:16, :8, :2, :10</a></strong><br />
</dt>
<dd>
<pre>
 our Num multi prefix:&lt;:16&gt; ( Str $hexstr )
 our Num multi prefix:&lt;:8&gt; ( Str $octstr )
 our Num multi prefix:&lt;:2&gt; ( Str $binstr )
 our Num multi prefix:&lt;:10&gt; ( Str $decstr )
 etc.</pre>
</dd>
<dd>
<p>Interprets string as a number, with a default
hexadecimal/octal/binary/decimal radix. Any radix prefix (0b, 0d, 0x, 0o)
mentioned inside the string will override this operator (this statement is true: 10 == :8(``0d10'')), except 0b and 0d will be interpreted
as hex digits by :16 (<code>hex(&quot;0d10&quot;) == :16 &quot;0d10&quot;</code>).  <a href="#item_fail"><code>fail</code></a>s on failure.</p>
</dd>
<dd>
<p>These aren't really functions, syntactically, but adverbial forms that
just happen to allow a parenthesize argument.  But more typically you'll
see</p>
</dd>
<dd>
<pre>
    :4&lt;222&gt;
    :16&lt;deadbeef&gt;</pre>
</dd>
<dd>
<p>and such.</p>
</dd>
<dd>
<p>Replaces Perl 5 <code>hex</code> and <code>oct</code>.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="Time">Time</a></h2>
<dl>
<dt><strong><a name="item_gmtime">gmtime</a></strong><br />
</dt>
<dd>
<pre>
 our Time multi Time::gmtime ( Time $time? )
 our Time multi method Time::gmtime ( Time $time: )</pre>
</dd>
<dd>
<p>Identical to:</p>
</dd>
<dd>
<pre>
 Time::localtime(:$time,:tz&lt;GMT&gt;)</pre>
</dd>
<dt><strong><a name="item_localtime">localtime</a></strong><br />
</dt>
<dd>
<pre>
 our Time multi Time::localtime ( Time $time?, Time::Zone $tz? )
 our Time multi method Time::localtime ( Time $time: Time::Zone $tz? )</pre>
</dd>
<dd>
<p>Returns a time object whose default timezone is <code>$tz</code> (or the system's
default timezone if none is provided).</p>
</dd>
<dd>
<p>If used as a function, and no time is provided, the current time is used.</p>
</dd>
<dd>
<p>Note that no matter what, <code>$time</code>'s concept of ``its timezone'' is discarded
in favor of something new.</p>
</dd>
<dt><strong><a name="item_time">time</a></strong><br />
</dt>
<dd>
<pre>
 our Time multi Time::time()</pre>
</dd>
<dd>
<p>Returns a <code>Time</code> object. There are a number of uses for this
object, all of which can be found in the documentation for <code>Time</code>.</p>
</dd>
<dd>
<p>There is, by default, no timezone associated with this Time object, so
whatever default the system has will take over if timezone-specific
data is accessed.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="OS">OS</a></h2>
<dl>
<dt><strong><a name="item_getpw">getpw</a></strong><br />
</dt>
<dd>
<pre>
 our OS::PW multi OS::getpw()
 our OS::PW multi OS::getpw( Int $uid )
 our OS::PW multi OS::getpw( Str $name )</pre>
</dd>
<dd>
<pre>
 our OS::PW multi method OS::PWEnt::getpw( OS::PWEnt $pw: )
 our OS::PW multi method OS::PWEnt::getpw( OS::PWEnt $pw: Int $uid )
 our OS::PW multi method OS::PWEnt::getpw( OS::PWEnt $pw: Str $name )</pre>
</dd>
<dd>
<p>The <a href="#item_getpw"><code>getpw</code></a> function operates on system login information, returning
data about users in the form of an <code>OS::PW</code> object (``PW'' refers
to the historical <code>getpw*</code> functions that are part of the POSIX
standard, and stands for ``password'').</p>
</dd>
<dd>
<p>When given no parameters, the ``next'' user entry is returned (<a href="#item_undef"><code>undef</code></a> is
returned when the list of users has been exhausted).</p>
</dd>
<dd>
<p>When <code>$uid</code> is provided, a user with the given UID is found and returned.
<a href="#item_undef"><code>undef</code></a> is returned if no matching entry is found.</p>
</dd>
<dd>
<p>When <code>$name</code> is provided, a user with the matching name is found and
returned. <a href="#item_undef"><code>undef</code></a> is returned if no matching entry is found.</p>
</dd>
<dd>
<p>The return value is an object that represents the system-specific
information about the user. When numified, this object returns the
UID of the user. When stringified, this object returns the username.</p>
</dd>
<dd>
<p>Therefore, the typical convention of:</p>
</dd>
<dd>
<pre>
  my Int $uid = getpw(~$name);</pre>
</dd>
<dd>
<p>and</p>
</dd>
<dd>
<pre>
  my Str $name = getpw(+$uid);</pre>
</dd>
<dd>
<p>Will work as expected.</p>
</dd>
<dd>
<p>See the documentation for the <code>OS::PW</code> and <code>OS::PWEnt</code> classes for more
information and the equivalent of the Perl 5 setpwent / endpwent functions.</p>
</dd>
<dd>
<p>WARNING: Even when used as a method on an <code>OS::PWEnt</code> object, there
may be system-specific, global state associated with the implementation
of these routines.</p>
</dd>
<dd>
<p>[Note: TODO setpgrp setpriority times -ajs ]</p>
</dd>
<dt><strong><a name="item_chroot">chroot</a></strong><br />
</dt>
<dd>
<pre>
 our Bool multi OS::chroot ( Str $path = CALLER::&lt;$_&gt; )</pre>
</dd>
<dd>
<p>On POSIX systems, changes the context of the current process such
that the ``root'' directory becomes <code>$path</code> and all rooted paths
(those that begin with a leading path separator) are relative to
that path. For security reasons, many operating systems limit
this functionality to the superuser. The return value will be
true on success.</p>
</dd>
<dt><strong><a name="item_getlogin">getlogin</a></strong><br />
</dt>
<dd>
<pre>
 our Str multi OS::getlogin ()</pre>
</dd>
<dd>
<p>Returns the username of the account running the program. This may
not be as secure as using <code>getpwuid</code> on some platforms.</p>
</dd>
<dt><strong><a name="item_kill">kill</a></strong><br />
</dt>
<dd>
<pre>
 our Bool multi OS::kill ( OS::Signal $signal, Bool :$group, *@pids )
 our Bool multi method Conc::Proc::kill ( Conc::Proc $pid: OS::Signal $signal?, Bool :$group )</pre>
</dd>
<dd>
<p>Sends the given <code>$signal</code> to the <code>process(es)</code> given and returns a boolean
value indicating success (true) if all of the processes existed and were
sent the signal and failure (false) if any of the processes did not exist
or the signal could not be delivered to them.</p>
</dd>
<dd>
<p>The <code>$signal</code> can be initialized from an integer signal number or a
string. Common signals are:</p>
</dd>
<dd>
<pre>
 KILL - stop the process, do not allow it to exit gracefully
 TERM - stop the process, allow it to exit gracefully
 HUP  - Hangup, often used as a request to re-run from scratch
 STOP - Pause execution
 CONT - Continue after a STOP</pre>
</dd>
<dd>
<p>Consult your operating system documentation for the full list
of signal names and numbers. For compatibility, a signal name
may be prefixed with ``SIG''.</p>
</dd>
<dd>
<p>The method form may omit the signal. In this case, the default signal is
<code>'TERM'</code>.</p>
</dd>
<dd>
<p>If the <code>:group</code> named parameter is passed, <a href="#item_kill"><code>kill</code></a> will attempt to
send the signal to a process <em>group</em> rather than a single process.
This functionality is platform-specific.</p>
</dd>
<dd>
<p>The special signal <code>0</code> can be sent which does not actually deliver a
signal at all, and is used to determine if processes are still running:</p>
</dd>
<dd>
<pre>
  say &quot;Still running&quot; if $proc.kill(0);</pre>
</dd>
<dt><strong><a name="item_run">run</a></strong><br />
</dt>
<dd>
<pre>
 our Conc::Proc::Status multi OS::run ( ; Str $command )
 our Conc::Proc::Status multi OS::run ( ; Str $path, *@args )
 our Conc::Proc::Status multi OS::run ( Str @path_and_args )</pre>
</dd>
<dd>
<pre>
 our Conc::Proc multi OS::run ( ; Str $command, Bool :$bg! )
 our Conc::Proc multi OS::run ( ; Str $path, Bool :$bg!, *@args )
 our Conc::Proc multi OS::run ( Str @path_and_args, Bool :$bg! )</pre>
</dd>
<dd>
<p><a href="#item_run"><code>run</code></a> executes an external program, and returns control to the caller
once the program has exited.</p>
</dd>
<dd>
<p>The default form expects a single string argument which contains the
full command-line. This command-line will be scanned for special
characters that the operating system's shell might interpret such as
<code>;</code> or embedded quotes. If any are found, the command will be run
through a sub-shell in an operating system specific fashion (on
POSIX systems, this means <code>sh -c</code>).</p>
</dd>
<dd>
<p>If called like this:</p>
</dd>
<dd>
<pre>
 run( :path&lt;'/some/path'&gt;, 'arg1', 'arg2', ... )</pre>
</dd>
<dd>
<p>or with a single array (containing both the path and arguments), then the
path given is executed directly with no shell interpretation.</p>
</dd>
<dd>
<p>The return value is the exit status
of the program, and can be evaluated in the following contexts:</p>
</dd>
<dd>
<pre>
 Bool - True = success; False = failure
 Int  - Exit status (per the .exit method)</pre>
</dd>
<dd>
<p>See <a href="#item_wait"><code>wait</code></a> for more detail on how the <code>Conc::Proc::Status</code> object
is used.</p>
</dd>
<dd>
<p>On failure to execute, an undefined value is returned.</p>
</dd>
<dd>
<p>If the <code>:bg</code> named parameter is passed, the program will be executed
in the background, and the run command will return as soon as the
child process is created. This means that the object returned is
actually a <code>Conc::Proc</code>, which represents the created process.</p>
</dd>
<dd>
<p>[ Note: should the :bg form take rw filehandles or is that over-overloading
        the functionality of run? Should run be the new open with</p>
</dd>
<dd>
<pre>
        respect to executing external code? -ajs ]</pre>
</dd>
<dd>
<p>[ Note: <code>system()</code> should be renamed to <code>sys()</code> or <code>sh()</code> or <a href="#item_run"><code>run()</code></a> or
some such to avoid P5-induced boolean inversion confusion, plus
Huffmanize it a little better.  I'm thinking <a href="#item_run"><code>run()</code></a> might be best
for MMD reasons. --law</p>
</dd>
<dd>
<p>Note: exec should also be renamed to something clearer and ``final''
and huffmanly longer.  I'm thinking runinstead().  And maybe the
function behind qq:x should be <code>rungather()</code> rather than readpipe().  -law
]</p>
</dd>
<dt><strong><a name="item_runinstead">runinstead</a></strong><br />
</dt>
<dd>
<pre>
 multi OS::runinstead ( ; Str $path, *@args )
 multi OS::runinstead ( ; Str $command )</pre>
</dd>
<dd>
<p>Identical to <a href="#item_run"><code>run</code></a> except that it never returns. The executed program
replaces the currently running program in memory.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="Concurrency">Concurrency</a></h2>
<p>There are higher-level models of concurrency management in Perl (see
<a href="#synopsis20173a20concurrency">Synopsis 17: Concurrency</a>). These functions are simply the lowest level
tools</p>
<dl>
<dt><strong><a name="item_fork">fork</a></strong><br />
</dt>
<dd>
<pre>
 our Conc::Proc sub Conc::Processes::fork()</pre>
</dd>
<dd>
<p>Creates a copy of the current process. Both processes return from
<a href="#item_fork"><code>fork</code></a>. The original process returns
the <em>child</em> process as a <code>Conc::Proc</code> object. The newly created process
returns the <em>parent</em> process as a <code>Conc::Proc</code> object. As with
any Conc::Proc object, the child process object numifies to the
process ID (OS dependent integer). However, the parent process object
numifies to <code>0</code> so that the child and parent can distinguish each other.</p>
</dd>
<dd>
<p>Typical usage would be:</p>
</dd>
<dd>
<pre>
 if !defined(my $pid = fork) {
   die &quot;Error calling fork: $!&quot;;
 } elsif $pid == 0 {
   say &quot;I am the new child!&quot;;
   exit 0;
 } else {
   say &quot;I am the parent of {+$pid}&quot;;
   wait();
 }</pre>
</dd>
<dt><strong><a name="item_wait">wait</a></strong><br />
</dt>
<dd>
<pre>
 our Conc::Proc::Status multi method Conc::Processes::wait( Conc::Proc $process: *%options )</pre>
</dd>
<dd>
<pre>
 our Conc::Proc::Status multi Conc::Processes::wait ( Conc::Proc $process = -1, *%options )</pre>
</dd>
<dd>
<p>Waits for a child process to terminate and returns the status
object for the child.  This status object will numify to the process
ID of the child that exited.</p>
</dd>
<dd>
<p>Important Conc::Proc::Status methods:</p>
</dd>
<dd>
<pre>
 .exit - Numeric exit value
 .pid - Process ID
 .signal - Signal number if any, otherwise 0</pre>
</dd>
<dd>
<p>For historical reasons there is a <code>.status</code> method which is equal to:</p>
</dd>
<dd>
<pre>
 ($status.exit +&lt; 8) +| $status.signal</pre>
</dd>
<dd>
<p>If <code>$process</code> is supplied, then wait will only return when the given process
has exited. Either a full <code>Conc::Proc</code> object can be passed, or just a
numeric process ID. A <code>-1</code> explicitly indicates that wait should return
immediately if any child process exits.</p>
</dd>
<dd>
<p>When called in this way, the returned <code>Conc::Proc::Status</code> object
will have a <code>.pid</code> of <code>-1</code> (which is also what it numifies to) if
there was no such process to wait for.</p>
</dd>
<dd>
<p>The named options include:</p>
</dd>
<dl>
<dt><strong><a name="item_blocking">blocking</a></strong><br />
</dt>
<dd>
Defaults to true. If set to false, this forces wait to return immediately.
</dd>
<p></p>
<dt><strong><a name="item_WNOHANG">WNOHANG</a></strong><br />
</dt>
<dd>
Exists for historical compatibility. <code>WNOHANG =</code> 1&gt; is identical to
<code>blocking =</code> False&gt;.
</dd>
<p></p></dl>
</dl>
<p>
</p>
<h2><a name="Obsolete">Obsolete</a></h2>
<dl>
<dt><strong><a name="item_dbmopen252C_dbmclose">dbmopen, dbmclose</a></strong><br />
</dt>
<dd>
<pre>
 use DB_File;</pre>
</dd>
<dt><strong><a name="item_dump">dump</a></strong><br />
</dt>
<dd>
Dumped.
</dd>
<p></p>
<dt><strong><a name="item_format252C_formline252C_write">format, formline, write</a></strong><br />
</dt>
<dd>
See Exegesis 7.
</dd>
<p></p>
<dt><strong><a name="item_252F255Bmsg257Csem257Cshm255D252E252A252F">/[msg|sem|shm].*/</a></strong><br />
</dt>
<dd>
<pre>
 use IPC::SysV;</pre>
</dd>
<dt><strong><a name="item_local">local</a></strong><br />
</dt>
<dd>
Replaced by <code>temp</code> which, unlike <a href="#item_local"><code>local</code></a>, defaults to not changing the value.
</dd>
<p></p>
<dt><strong><a name="item_lock">lock</a></strong><br />
</dt>
<dd>
See <a href="#synopsis20173a20concurrency">Synopsis 17: Concurrency</a>. <a href="#item_lock"><code>lock</code></a> has been replaced by
<code>is atomic</code>.
</dd>
<p></p>
<dt><strong><a name="item_ref">ref</a></strong><br />
</dt>
<dd>
There is no <a href="#item_ref"><code>ref()</code></a> any more, since it was almost always used to get
the type name in Perl 5.  If you really want the type name, you can
use <code>$var.meta.name</code> or <code>$var.^name</code>.  If you really want P5 ref
semantics, use <code>Perl5::p5ref</code>.
</dd>
<dd>
<p>But if you're just wanting to test against a type, you're likely better off
performing an <code>isa</code> or <code>does</code> or <code>can</code>, or just <code>$var ~~ TYPE</code>.</p>
</dd>
<p></p>
<dt><strong><a name="item_reset">reset</a></strong><br />
</dt>
<dd>
Was there a <em>good</em> use for this?
</dd>
<p></p>
<dt><strong><a name="item_prototype">prototype</a></strong><br />
</dt>
<dd>
<pre>
 &amp;func.meta.signature;
 &amp;func.^signature;</pre>
</dd>
<dt><strong><a name="item_study">study</a></strong><br />
</dt>
<dd>
Algorithm was too Anglo-centric.  Could be brought back if generalized somehow.
</dd>
<p></p>
<dt><strong><a name="item_waitpid">waitpid</a></strong><br />
</dt>
<dd>
<a href="#item_wait"><code>wait</code></a> can now be called with or without an optional process/pid.
</dd>
<p></p></dl>
<dl>
<dt><strong><a name="item_2525">%</a></strong><br />
</dt>
<dd>
<pre>
 $num1 % $num2</pre>
</dd>
<dd>
<p>Does a floating point modulus operation, i.e. 5.5 % 1 == 0.5 and 5 % 2.5 == 0.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="Pending20Apocalypse">Pending Apocalypse</a></h2>
<p>The following functions are classified by Apocalypse/Synopsis numbers.</p>
<dl>
<dt><strong><a name="item_A252FS14253A_Tied_Variables">A/S14: Tied Variables</a></strong><br />
</dt>
<dd>
tie tied untie (now implemented as container classes? my $foo is ....? is tie the meta operation on the container type for 'rebless' - macro tie ( $var, $class, *@args ) { CODE { variable($var).meta.rebless( $class, *@args ) } } )
</dd>
<dd>
<p>These are replaced by container types.  The compiler is free to assume
that any lexical variable is never going to change its container type
unless some representation is made to that effect in the declaration.
Note: P5's <code>tied()</code> is roughly replaced by P6's variable().</p>
</dd>
<p></p>
<dt><strong><a name="item_A252FS16253A_IPC_252F_IO_252F_Signals">A/S16: IPC / IO / Signals</a></strong><br />
</dt>
<dd>
-X accept alarm bind binmode chown close closedir connect eof fcntl
fileno flock getc getpeername
/[get|set][host|net|proto|serv|sock].*/ glob ioctl link listen 
lstat mkdir open opendir pipe print printf read readdir readline
readlink readpipe recv rename rewinddir rmdir seek seekdir <code>select(both)</code>
send setsockopt shutdown slurp socket socketpair stat symlink
syscall sysopen sysread sysseek syswrite tell telldir truncate umask
unlink utime warn
</dd>
<p></p>
<dt><strong><a name="item_A252FS253F253F253A_OS_Interaction">A/S??: OS Interaction</a></strong><br />
</dt>
<dd>
chroot crypt getlogin /[get|set][pw|gr].*/ kill setpgrp setpriority
times
</dd>
<dd>
<p>... These are probably going to be part of POSIX, automatically imported to GLOBAL <strong>if</strong> the platform is the right one</p>
</dd>
<p></p></dl>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Additions">Additions</a></h1>
<p>Please post errors and feedback to perl6-language.  If you are making
a general laundry list, please separate messages by topic.</p>
<p><a href="#__index__"><small>Back to Top</small></a></p>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" valign="middle">
<big><strong><span class="block">&nbsp;Title</span></strong></big>
</td></tr>
</table>

</body>

</html>
