<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
           "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>S05</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="http://dev.perl.org/css/perl.css">

<script type="text/javascript">
var agt = navigator.userAgent.toLowerCase();

var is_opera = (agt.indexOf("opera") != -1);
var is_ie = (agt.indexOf("msie") != -1) && document.all && !is_opera;
var is_ie5 = (agt.indexOf("msie 5") != -1) && document.all;

function tog() {
  // tog: toggle the visibility of html elements (arguments[1..]) from none to
  // arguments[0].  Return what should be returned in a javascript onevent().
  display = arguments[0];
  for( var i=1; i<arguments.length; i++ ) {
    var x = document.getElementById(arguments[i]);
    if (!x) continue;
    if (x.style.display == "none" || x.style.display == "") {
      x.style.display = display;
    } else {
      x.style.display = "none";
    }
  }

  var e = is_ie ? window.event : this;
  if (e) {
    if (is_ie) {
      e.cancelBubble = true;
      e.returnValue = false;
      return false;
    } else {
      return false;
    }
  }
}

function tog_quote( idnum ) {
  return tog( 'block', 'header_shown_' + idnum, 'header_hidden_' + idnum,
       'hide_' + idnum );
}

</script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.03,
  using Pod::Simple::PullParser v2.02,
  under Perl v5.008007 at Wed Aug 23 14:43:20 2006 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#New_match_result_and_capture_variables'>New match result and capture variables</a>
  <li class='indexItem indexItem1'><a href='#Unchanged_syntactic_features'>Unchanged syntactic features</a>
  <li class='indexItem indexItem1'><a href='#Modifiers'>Modifiers</a>
  <li class='indexItem indexItem1'><a href='#Changed_metacharacters'>Changed metacharacters</a>
  <li class='indexItem indexItem1'><a href='#New_metacharacters'>New metacharacters</a>
  <li class='indexItem indexItem1'><a href='#Bracket_rationalization'>Bracket rationalization</a>
  <li class='indexItem indexItem1'><a href='#Variable_(non-)interpolation'>Variable (non-)interpolation</a>
  <li class='indexItem indexItem1'><a href='#Extensible_metasyntax_(%3C...%3E)'>Extensible metasyntax (&#60;...&#62;)</a>
  <li class='indexItem indexItem1'><a href='#Backslash_reform'>Backslash reform</a>
  <li class='indexItem indexItem1'><a href='#Regexes_really_are_regexes_now'>Regexes really are regexes now</a>
  <li class='indexItem indexItem1'><a href='#Backtracking_control'>Backtracking control</a>
  <li class='indexItem indexItem1'><a href='#Named_Regexes'>Named Regexes</a>
  <li class='indexItem indexItem1'><a href='#Nothing_is_illegal'>Nothing is illegal</a>
  <li class='indexItem indexItem1'><a href='#Return_values_from_matches'>Return values from matches</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Match_objects'>Match objects</a>
    <li class='indexItem indexItem2'><a href='#Subpattern_captures'>Subpattern captures</a>
    <li class='indexItem indexItem2'><a href='#Accessing_captured_subpatterns'>Accessing captured subpatterns</a>
    <li class='indexItem indexItem2'><a href='#Nested_subpattern_captures'>Nested subpattern captures</a>
    <li class='indexItem indexItem2'><a href='#Quantified_subpattern_captures'>Quantified subpattern captures</a>
    <li class='indexItem indexItem2'><a href='#Indirectly_quantified_subpattern_captures'>Indirectly quantified subpattern captures</a>
    <li class='indexItem indexItem2'><a href='#Subpattern_numbering'>Subpattern numbering</a>
    <li class='indexItem indexItem2'><a href='#Subrule_captures'>Subrule captures</a>
    <li class='indexItem indexItem2'><a href='#Accessing_captured_subrules'>Accessing captured subrules</a>
    <li class='indexItem indexItem2'><a href='#Repeated_captures_of_the_same_subrule'>Repeated captures of the same subrule</a>
    <li class='indexItem indexItem2'><a href='#Aliasing'>Aliasing</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Named_scalar_aliasing_to_subpatterns'>Named scalar aliasing to subpatterns</a>
      <li class='indexItem indexItem3'><a href='#Named_scalar_aliases_applied_to_non-capturing_brackets'>Named scalar aliases applied to non-capturing brackets</a>
      <li class='indexItem indexItem3'><a href='#Named_scalar_aliasing_to_subrules'>Named scalar aliasing to subrules</a>
      <li class='indexItem indexItem3'><a href='#Numbered_scalar_aliasing'>Numbered scalar aliasing</a>
      <li class='indexItem indexItem3'><a href='#Scalar_aliases_applied_to_quantified_constructs'>Scalar aliases applied to quantified constructs</a>
      <li class='indexItem indexItem3'><a href='#Array_aliasing'>Array aliasing</a>
      <li class='indexItem indexItem3'><a href='#Hash_aliasing'>Hash aliasing</a>
      <li class='indexItem indexItem3'><a href='#External_aliasing'>External aliasing</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Capturing_from_repeated_matches'>Capturing from repeated matches</a>
    <li class='indexItem indexItem2'><a href='#%3Akeepall'>:keepall</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Grammars'>Grammars</a>
  <li class='indexItem indexItem1'><a href='#Syntactic_categories'>Syntactic categories</a>
  <li class='indexItem indexItem1'><a href='#Pragmas'>Pragmas</a>
  <li class='indexItem indexItem1'><a href='#Transliteration'>Transliteration</a>
  <li class='indexItem indexItem1'><a href='#Positional_matching%2C_fixed_width_types'>Positional matching, fixed width types</a>
  <li class='indexItem indexItem1'><a href='#Matching_against_non-strings'>Matching against non-strings</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 5: Regexes and Rules</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<p>Damian Conway &#60;damian@conway.org&#62; and Allison Randal &#60;al@shadowed.net&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre>   Maintainer: Patrick Michaud &#60;pmichaud@pobox.com&#62; and
               Larry Wall &#60;larry@wall.org&#62;
   Date: 24 Jun 2002
   Last Modified: 21 Aug 2006
   Number: 5
   Version: 33</pre>

<p>This document summarizes Apocalypse 5, which is about the new regex syntax. We now try to call them <i>regex</i> rather than &#34;regular expressions&#34; because they haven&#39;t been regular expressions for a long time, and we think the popular term &#34;regex&#34; is in the process of becoming a technical term with a precise meaning of: &#34;something you do pattern matching with, kinda like a regular expression&#34;.</p>

<p>In any case, when referring to recursive patterns within a grammar, the terms <i>rule</i> and <i>token</i> are generally preferred.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="New_match_result_and_capture_variables"
>New match result and capture variables</a></h1>

<p>The underlying match result object is now available as the <code>$/</code> variable, which is implicitly lexically scoped. All access to the current (or most recent) match is through this variable, even when it doesn&#39;t look like it. The individual capture variables (such as <code>$0</code>, <code>$1</code>, etc.) are just elements of <code>$/</code>.</p>

<p>By the way, unlike in Perl 5, the numbered capture variables now start at <code>$0</code> instead of <code>$1</code>. See below.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Unchanged_syntactic_features"
>Unchanged syntactic features</a></h1>

<p>The following regex features use the same syntax as in Perl 5:</p>

<ul>
<li>Capturing: (...)</li>

<li>Repetition quantifiers: *, +, and ?</li>

<li>Alternatives: |</li>

<li>Backslash escape: \</li>

<li>Minimal matching suffix: ??, *?, +?</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Modifiers"
>Modifiers</a></h1>

<ul>
<li>The extended syntax (<code>/x</code>) is no longer required...it&#39;s the default. (In fact, it&#39;s pretty much mandatory--the only way to get back to the old syntax is with the <code>:Perl5</code>/<code>:P5</code> modifier.)</li>

<li>There are no <code>/s</code> or <code>/m</code> modifiers (changes to the meta-characters replace them - see below).</li>

<li>There is no <code>/e</code> evaluation modifier on substitutions; instead use:
<pre>     s/pattern/{ doit() }/</pre>

<p>Instead of <code>/ee</code> say:</p>

<pre>     s/pattern/{ eval doit() }/</pre>
</li>

<li>Modifiers are now placed as adverbs at the <i>start</i> of a match/substitution:
<pre>     m:g:i/\s* (\w*) \s* ,?/;</pre>

<p>Every modifier must start with its own colon. The delimiter must be separated from the final modifier by whitespace if it would otherwise be taken as an argument to the preceding modifier (which is true for any bracketing character).</p>
</li>

<li>The single-character modifiers also have longer versions:
<pre>         :i        :ignorecase
         :g        :global</pre>
</li>

<li>The <code>:c</code> (or <code>:continue</code>) modifier causes the pattern to continue scanning from the string&#39;s current <code>.pos</code>:
<pre>     m:c/ pattern /        # start at end of
                           # previous match on $_</pre>

<p>Note that this does not automatically anchor the pattern to the starting location. (Use <code>:p</code> for that.) The pattern you supply to <code>split</code> has an implicit <code>:c</code> modifier.</p>

<p>The <code>:continue</code> modifier takes an optional argument of type <code>StrPos</code> which specifies the point at which to start scanning for a match. This should not be used unless you know what you&#39;re doing, or just happen to like hard-to-debug infinite loops.</p>
</li>

<li>The <code>:p</code> (or <code>:pos</code>) modifier causes the pattern to try to match only at the string&#39;s current <code>.pos</code>:
<pre>     m:p/ pattern /        # match at end of
                           # previous match on $_</pre>

<p>Since this is implicitly anchored to the position, it&#39;s suitable for building parsers and lexers. The pattern you supply to a Perl macro&#39;s <code>is parsed</code> trait has an implicit <code>:p</code> modifier.</p>

<p>Note that</p>

<pre>     m:c/pattern/</pre>

<p>is roughly equivalent to</p>

<pre>     m:p/.*? &#60;( pattern )&#62; /</pre>

<p>Also note that any regex called as a subrule is implicitly anchored to the current position anyway.</p>

<p>The <code>:pos</code> modifier takes an optional argument of type <code>StrPos</code> which specifies the point at which to attempt a match. This should not be used lightly. Put it in the category of a &#34;goto&#34;.</p>
</li>

<li>The new <code>:s</code> (<code>:sigspace</code>) modifier causes whitespace sequences to be considered &#34;significant&#34;; they are replaced by a whitespace matching rule, <code>&#60;?ws&#62;</code>. That is,
<pre>     m:s/ next cmd =   &#60;condition&#62;/</pre>

<p>is the same as:</p>

<pre>     m/ &#60;?ws&#62; next &#60;?ws&#62; cmd &#60;?ws&#62; = &#60;?ws&#62; &#60;condition&#62;/</pre>

<p>which is effectively the same as:</p>

<pre>     m/ \s* next \s+ cmd \s* = \s* &#60;condition&#62;/</pre>

<p>But in the case of</p>

<pre>     m:s {(a|\*) (b|\+)}</pre>

<p>or equivalently,</p>

<pre>     m { (a|\*) &#60;?ws&#62; (b|\+) }</pre>

<p><code>&#60;?ws&#62;</code> can&#39;t decide what to do until it sees the data. It still does the right thing. If not, define your own <code>&#60;?ws&#62;</code> and <code>:sigspace</code> will use that.</p>

<p>In general you don&#39;t need to use <code>:sigspace</code> within grammars because the parser rules automatically handle whitespace policy for you. In this context, whitespace often includes comments, depending on how the grammar chooses to define its whitespace rule. Although the default <code>&#60;?ws&#62;</code> subrule recognizes no comment construct, any grammar is free to override the rule. The <code>&#60;?ws&#62;</code> rule is not intended to mean the same thing everywhere.</p>

<p>It&#39;s also possible to pass an argument to <code>:sigspace</code> specifying a completely different subrule to apply. This can be any rule, it doesn&#39;t have to match whitespace. When discussing this modifier, it is important to distinguish the significant whitespace in the pattern from the &#34;whitespace&#34; being matched, so we&#39;ll call the pattern&#39;s whitespace <i>sigspace</i>, and generally reserve <i>whitespace</i> to indicate whatever <code>&#60;?ws&#62;</code> matches in the current grammar. The correspondence between sigspace and whitespace is primarily metaphorical, which is why the correspondence is both useful and (potentially) confusing.</p>

<p>The <code>:s</code> modifier is considered sufficiently important that match variants are defined for them:</p>

<pre>    ms/match some words/                        # same as m:sigspace
    ss/match some words/replace those words/    # same as s:sigspace</pre>

<p>Conjecture: This might become sufficiently idiomatic that <code>ms//</code> would be better as a &#34;stuttered&#34; <code>mm//</code> instead, much as <code>qq//</code> became idiomatic. It would also match <code>ss///</code> that way.</p>
</li>

<li>New modifiers specify Unicode level:
<pre>     m:bytes / .**{2} /       # match two bytes
     m:codes / .**{2} /       # match two codepoints
     m:graphs/ .**{2} /       # match two graphemes
     m:langs / .**{2} /       # match two language dependent chars</pre>

<p>There are corresponding pragmas to default to these levels.</p>
</li>

<li>The new <code>:Perl5</code> modifier allows Perl 5 regex syntax to be used instead:
<pre>     m:Perl5/(?mi)^[a-z]{1,2}(?=\s)/</pre>

<p>(It does not go so far as to allow you to put your modifiers at the end.)</p>
</li>

<li>Any integer modifier specifies a count. What kind of count is determined by the character that follows.</li>

<li>If followed by an <code>x</code>, it means repetition. Use <code>:x(4)</code> for the general form. So
<pre>     s:4x [ (&#60;?ident&#62;) = (\N+) $$] [$0 =&#62; $1];</pre>

<p>is the same as:</p>

<pre>     s:x(4) [ (&#60;?ident&#62;) = (\N+) $$] [$0 =&#62; $1];</pre>

<p>which is almost the same as:</p>

<pre>     $_.pos = 0;
     s:c [ (&#60;?ident&#62;) = (\N+) $$] [$0 =&#62; $1] for 1..4;</pre>

<p>except that the string is unchanged unless all four matches are found. However, ranges are allowed, so you can say <code>:x(1..4)</code> to change anywhere from one to four matches.</p>
</li>

<li>If the number is followed by an <code>st</code>, <code>nd</code>, <code>rd</code>, or <code>th</code>, it means find the <i>N</i>th occurrence. Use <code>:nth(3)</code> for the general form. So
<pre>     s:3rd/(\d+)/@data[$0]/;</pre>

<p>is the same as</p>

<pre>     s:nth(3)/(\d+)/@data[$0]/;</pre>

<p>which is the same as:</p>

<pre>     m/(\d+)/ &#38;&#38; m:c/(\d+)/ &#38;&#38; s:c/(\d+)/@data[$0]/;</pre>

<p>Lists and junctions are allowed: <code>:nth(1|2|3|5|8|13|21|34|55|89)</code>.</p>

<p>So are closures: <code>:nth{.is_fibonacci}</code></p>
</li>

<li>With the new <code>:ov</code> (<code>:overlap</code>) modifier, the current regex will match at all possible character positions (including overlapping) and return all matches in a list context, or a disjunction of matches in a scalar context. The first match at any position is returned.
<pre>     $str = &#34;abracadabra&#34;;

     if $str ~~ m:overlap/ a (.*) a / {
         @substrings = @@();    # bracadabr cadabr dabr br
     }</pre>
</li>

<li>With the new <code>:ex</code> (<code>:exhaustive</code>) modifier, the current regex will match every possible way (including overlapping) and return all matches in a list context, or a disjunction of matches in a scalar context.
<pre>     $str = &#34;abracadabra&#34;;

     if $str ~~ m:exhaustive/ a (.*) a / {
         say &#34;@()&#34;;    # br brac bracad bracadabr c cad cadabr d dabr br
     }</pre>

<p>Note that the <code>~~</code> above can return as soon as the first match is found, and the rest of the matches may be performed lazily by <code>@()</code>.</p>

<p>[Conjecture: the <code>:exhaustive</code> modifier should have an optional argument specifying how many seconds to run before giving up, since it&#39;s trivially easy to ask for the heat death of the universe to happen first.]</p>
</li>

<li>The new <code>:rw</code> modifier causes this regex to <i>claim</i> the current string for modification rather than assuming copy-on-write semantics. All the bindings in <code>$/</code> become lvalues into the string, such that if you modify, say, <code>$1</code>, the original string is modified in that location, and the positions of all the other fields modified accordingly (whatever that means). In the absence of this modifier (especially if it isn&#39;t implemented yet, or is never implemented), all pieces of <code>$/</code> are considered copy-on-write, if not read-only.</li>

<li>The new <code>:keepall</code> modifier causes this regex and all invoked subrules to remember everything, even if the rules themselves don&#39;t ask for their subrules to be remembered. This is for forcing a grammar that throws away whitespace and comments to keep them instead.</li>

<li>The new <code>:ratchet</code> modifier causes this regex to not backtrack by default. (Generally you do not use this modifier directly, since it&#39;s implied by <code>token</code> and <code>rule</code> declarations.) The effect of this modifier is to imply a <code>:</code> after every construct that could backtrack, including bare <code>*</code>, <code>+</code>, and <code>?</code> quantifiers, as well as alternations.</li>

<li>The new <code>:panic</code> modifier causes this regex and all invoked subrules to try to backtrack on any rules that would otherwise default to not backtracking because they have <code>:ratchet</code> set. Never panic unless you&#39;re desperate and want the pattern matcher to do a lot of unnecessary work. If you have an error in your grammar, it&#39;s almost certainly a bad idea to fix it by backtracking.</li>

<li>The <code>:i</code>, <code>:s</code>, <code>:Perl5</code>, and Unicode-level modifiers can be placed inside the regex (and are lexically scoped):
<pre>     m/:s alignment = [:i left|right|cent[er|re]] /</pre>
</li>

<li>User-defined modifiers will be possible:
<pre>         m:fuzzy/pattern/;</pre>
</li>

<li>User-defined modifiers can also take arguments:
<pre>         m:fuzzy(&#39;bare&#39;)/pattern/;</pre>
</li>

<li>To use parens or brackets for your delimiters you have to separate:
<pre>         m:fuzzy (pattern);</pre>

<p>or you&#39;ll end up with:</p>

<pre>         m:fuzzy(fuzzyargs); pattern ;</pre>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Changed_metacharacters"
>Changed metacharacters</a></h1>

<ul>
<li>A dot <code>.</code> now matches <i>any</i> character including newline. (The <code>/s</code> modifier is gone.)</li>

<li><code>^</code> and <code>$</code> now always match the start/end of a string, like the old <code>\A</code> and <code>\z</code>. (The <code>/m</code> modifier is gone.)</li>

<li>A <code>$</code> no longer matches an optional preceding <code>\n</code> so it&#39;s necessary to say <code>\n?$</code> if that&#39;s what you mean.</li>

<li><code>\n</code> now matches a logical (platform independent) newline not just <code>\x0a</code>.</li>

<li>The <code>\A</code>, <code>\Z</code>, and <code>\z</code> metacharacters are gone.</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="New_metacharacters"
>New metacharacters</a></h1>

<ul>
<li>Because <code>/x</code> is default:
<ul>
<li>An unescaped <code>#</code> now always introduces a comment. If followed by an opening bracket character (and if not in the first column), it introduces an embedded comment that terminates with the closing bracket. Otherwise the comment terminates at the newline.</li>

<li>Whitespace is now always metasyntactic, i.e. used only for layout and not matched literally (but see the <code>:sigspace</code> modifier described above).</li>
</ul>
</li>

<li><code>^^</code> and <code>$$</code> match line beginnings and endings. (The <code>/m</code> modifier is gone.) They are both zero-width assertions. <code>$$</code> matches before any <code>\n</code> (logical newline), and also at the end of the string if the final character was <i>not</i> a <code>\n</code>. <code>^^</code> always matches the beginning of the string and after any <code>\n</code> that is not the final character in the string.</li>

<li><code>.</code> matches an <i>anything</i>, while <code>\N</code> matches an <i>anything except newline</i>. (The <code>/s</code> modifier is gone.) In particular, <code>\N</code> matches neither carriage return nor line feed.</li>

<li>The new <code>&#38;</code> metacharacter separates conjunctive terms. The patterns on either side must match with the same beginning and end point. The operator is list associative like <code>|</code>, has higher precedence than <code>|</code>, and backtracking makes the right argument vary faster than the left.</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Bracket_rationalization"
>Bracket rationalization</a></h1>

<ul>
<li><code>(...)</code> still delimits a capturing group. However the ordering of these groups is hierarchical rather than linear. See <a href="#Nested_subpattern_captures" class="podlinkpod"
>&#34;Nested subpattern captures&#34;</a>.</li>

<li><code>[...]</code> is no longer a character class. It now delimits a non-capturing group.</li>

<li><code>{...}</code> is no longer a repetition quantifier. It now delimits an embedded closure.</li>

<li>You can call Perl code as part of a regex match by using a closure. Embedded code does not usually affect the match--it is only used for side-effects:
<pre>     / (\S+) { print &#34;string not blank\n&#34;; $text = $0; }
        \s+  { print &#34;but does contain whitespace\n&#34; }
     /</pre>
</li>

<li>It can affect the match if it calls <code>fail</code>:
<pre>     / (\d+) { $0 &#60; 256 or fail } /</pre>

<p>Closures are guaranteed to be called at the canonical time even if the optimizer could prove that something after them can&#39;t match. (Anything before is fair game, however.)</p>
</li>

<li>The repetition specifier is now <code>**{...}</code> for maximal matching, with a corresponding <code>**{...}?</code> for minimal matching. Space is allowed on either side of the asterisks. The curlies are taken to be a closure returning an Int or a Range object.
<pre>     / value was (\d ** {1..6}?) with ([\w]**{$m..$n}) /</pre>

<p>It is illegal to return a list, so this easy mistake fails:</p>

<pre>     / [foo]**{1,3} /</pre>

<p>(At least, it fails in the absence of <code>use rx :listquantifier</code>, which is likely to be unimplemented in Perl 6.0.0 anyway.)</p>

<p>The optimizer will likely optimize away things like <code>**{1..*}</code> so that the closure is never actually run in that case. But it&#39;s a closure that must be run in the general case, so you can use it to generate a range on the fly based on the earlier matching. (Of course, bear in mind the closure must be run <i>before</i> attempting to match whatever it quantifies.)</p>
</li>

<li><code>&#60;...&#62;</code> are now extensible metasyntax delimiters or <i>assertions</i> (i.e. they replace Perl 5&#39;s crufty <code>(?...)</code> syntax).</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Variable_(non-)interpolation"
>Variable (non-)interpolation</a></h1>

<ul>
<li>In Perl 6 regexes, variables don&#39;t interpolate.</li>

<li>Instead they&#39;re passed <i>raw</i> to the regex engine, which can then decide how to handle them (more on that below).</li>

<li>The default way in which the engine handles a scalar is to match it as a <code>&#60;&#39;...&#39;&#62;</code> literal (i.e. it does not treat the interpolated string as a subpattern). In other words, a Perl 6:
<pre>     / $var /</pre>

<p>is like a Perl 5:</p>

<pre>     / \Q$var\E /</pre>

<p>However, if <code>$var</code> contains a <code>Regex</code> object, instead of attempting to convert it to a string, it is called as a subrule, as if you said <code>&#60;$var&#62;</code>. (See assertions below.) This form does not capture, and it fails if <code>$var</code> is tainted.</p>
</li>

<li>An interpolated array:
<pre>     / @cmds /</pre>

<p>is matched as if it were an alternation of its elements:</p>

<pre>     / [ @cmds[0] | @cmds[1] | @cmds[2] | ... ] /</pre>

<p>As with a scalar variable, each element is matched as a literal unless it happens to be a <code>Regex</code> object, in which case it is matched as a subrule. As with scalar subrules, a tainted subrule always fails. All string values pay attention to the current <code>:ignorecase</code> setting, while <code>Regex</code> values use their own <code>:ignorecase</code> settings.</p>
</li>

<li>An interpolated hash matches the longest possible key of the hash as a literal, or fails if no key matches. (A <code>&#34;&#34;</code> key will match anywhere, provided no longer key matches.)
<ul>
<li>If the corresponding value of the hash element is a closure, it is executed.</li>

<li>If the value is a string, it is matched literally, starting after where the key left off matching. As a natural consequence, if the value is <code>&#34;&#34;</code>, nothing special happens except that the key match succeeds.</li>

<li>If it is a <code>Regex</code> object, it is executed as a subrule, with an initial position <i>after</i> the matched key. (This is further described below under the <code>&#60;%hash&#62;</code> notation.) As with scalar subrules, a tainted subrule always fails, and no capture is attempted.</li>

<li>If the value is a number, this entry represents a &#34;false match&#34;. The match position is set back to before the current false match, and the key is rematched using the same hash, but this time ignoring any keys longer than the number. (This is measured in the default Unicode level in effect where the hash was declared, usually graphemes. If the current Unicode level is lower, the results are as if the string to be matched had been upconverted to the hash&#39;s Unicode level. If the current Unicode level is higher, the results are undefined if the string contains any characters whose interpretation would be changed by the higher Unicode level, such as language-dependent ligatures.)</li>

<li>Any other value causes the match to fail.</li>
</ul>

<p>All hash keys, and values that are strings, pay attention to the <code>:ignorecase</code> setting. (Subrules maintain their own case settings.)</p>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Extensible_metasyntax_(&#60;...&#62;)"
>Extensible metasyntax (<code>&#60;...&#62;</code>)</a></h1>

<p>Both <code>&#60;</code> and <code>&#62;</code> are metacharacters, and are usually (but not always) used in matched pairs. (Some combinations of metacharacters function as standalone tokens, and these may include angles. These are described below.)</p>

<p>For matched pairs, the first character after <code>&#60;</code> determines the behavior of the assertion:</p>

<ul>
<li>A leading alphabetic character means it&#39;s a capturing grammatical assertion (i.e. a subrule or a named character class - see below):
<pre>     / &#60;sign&#62;? &#60;mantissa&#62; &#60;exponent&#62;? /</pre>

<p>The first character after the identifier determines the treatment of the rest of the text before the closing angle. The underlying semantics is that of a function or method call, so if the first character is a left parenthesis, it really is a call:</p>

<pre>    &#60;foo(&#39;bar&#39;)&#62;</pre>

<p>If the first character after the identifier is whitespace, the subsequent text (following any whitespace) is passed as regex, so:</p>

<pre>    &#60;foo bar&#62;</pre>

<p>is more or less equivalent to</p>

<pre>    &#60;foo(/bar/)&#62;</pre>

<p>To pass a regex with leading whitespace you must use the parenthesized form.</p>

<p>If the first character is a colon, the rest of the text (following any whitespace) is passed as a string, so the previous may also be written as:</p>

<pre>    &#60;foo: bar&#62;</pre>

<p>To pass a string with leading whitespace you must use the parenthesized form.</p>

<p>If the first character is a plus or minus, the initial identifier is taken as a character class, so</p>

<pre>    &#60;foo+bar-baz&#62;</pre>

<p>is equivalent to</p>

<pre>    &#60;+foo+bar-baz&#62;</pre>

<p>(See below.)</p>
</li>

<li>The special named assertions include:
<pre>     / &#60;before pattern&#62; /    # was /(?=pattern)/
     / &#60;after pattern&#62; /     # was /(?&#60;=pattern)/

     / &#60;sp&#62; /                # match the SPACE character (U+0020)
     / &#60;ws&#62; /                # match &#34;whitespace&#34;:
                             #   \s+ if it&#39;s between two \w characters,
                             #   \s* otherwise

     / &#60;at($pos)&#62; /          # match only at a particular StrPos
                             # short for &#60;?{ .pos == $pos }&#62;</pre>

<p>The <code>after</code> assertion implements lookbehind by reversing the syntax tree and looking for things in the opposite order going to the left. It is illegal to do lookbehind on a pattern that cannot be reversed.</p>

<p>Note: the effect of a forward-scanning lookbehind at the top level can be achieved with:</p>

<pre>    / .*? prestuff &#60;( mainpat )&#62; /</pre>
</li>

<li>A leading <code>?</code> causes the assertion not to capture what it matches (see <a href="#Subrule_captures" class="podlinkpod"
>&#34;Subrule captures&#34;</a>. For example:
<pre>     / &#60;ident&#62;  &#60;ws&#62;  /      # $/&#60;ident&#62; and $/&#60;ws&#62; both captured
     / &#60;?ident&#62; &#60;ws&#62;  /      # only $/&#60;ws&#62; captured
     / &#60;?ident&#62; &#60;?ws&#62; /      # nothing captured</pre>

<p>The non-capturing behavior may be overridden with a <code>:keepall</code>.</p>
</li>

<li>A leading <code>$</code> indicates an indirect subrule. The variable must contain either a <code>Regex</code> object, or a string to be compiled as the regex. The string is never matched literally.
<p>By default <code>&#60;$foo&#62;</code> is captured into <code>$&#60;foo&#62;</code>, but you can use the <code>&#60;?$foo&#62;</code> form to suppress capture, and you can always say <code>$&#60;$foo&#62; := &#60;$foo&#62;</code> if you prefer to include the sigil in the key.</p>
</li>

<li>A leading <code>::</code> indicates a symbolic indirect subrule:
<pre>     / &#60;::($somename)&#62; /</pre>

<p>The variable must contain the name of a subrule. By the rules of single method dispatch this is first searched for in the current grammar and its ancestors. If this search fails an attempt is made to dispatch via MMD, in which case it can find subrules defined as multis rather than methods. This form is not captured by default.</p>
</li>

<li>A leading <code>@</code> matches like a bare array except that each element is treated as a subrule (string or <code>Regex</code> object) rather than as a literal. That is, a string is forced to be compiled as a subrule instead of being matched literally. (There is no difference for a <code>Regex</code> object.)
<p>By default <code>&#60;@foo&#62;</code> is captured into <code>$&#60;foo&#62;</code>, but you can use the <code>&#60;?@foo&#62;</code> form to suppress capture, and you can always say <code>$&#60;@foo&#62; := &#60;@foo&#62;</code> if you prefer to include the sigil in the key.</p>
</li>

<li>A leading <code>%</code> matches like a bare hash except that a string value is always treated as a subrule, even if it is a string that must be compiled to a regex at match time. (Numeric values may still indicate &#34;false match&#34;. and a closure may do whatever it likes.)
<p>By default <code>&#60;%foo&#62;</code> is captured into <code>$&#60;foo&#62;</code>, but you can use the <code>&#60;?%foo&#62;</code> form to suppress capture, and you can always say <code>$&#60;%foo&#62; := &#60;%foo&#62;</code> if you prefer to include the sigil in the key.</p>

<p>With both bare hash and hash in angles, the key is counted as &#34;matched&#34; immediately; that is, the current match position is set to <code>after</code> the key token before calling any subrule in the value. That subrule may, however, magically access the key anyway as if the subrule had started before the key and matched with <code>&#60;KEY&#62;</code> assertion. That is, <code>$&#60;KEY&#62;</code> will contain the keyword or token that this subrule was looked up under, and that value will be returned by the current match object even if you do nothing special with it within the match. (This also works for the name of a macro as seen from an <code>is parsed</code> regex, since internally that turns into a hash lookup.)</p>

<p>As with bare hash, the longest key matches according to the venerable <i>longest token rule</i>, but in addition, you may combine multiple hashes under the same longest-token consideration like this:</p>

<pre>    &#60;%statement|%prefix|%term&#62;</pre>

<p>This means that, despite being in a later hash, <code>%term&#60;food&#62;</code> will be selected in preference to <code>%prefix&#60;foo&#62;</code> because it&#39;s the longer token. However, if there is a tie, the earlier hash wins, so <code>%statement&#60;if&#62;</code> hides any <code>%prefix&#60;if&#62;</code> or <code>%term&#60;if&#62;</code>.</p>

<p>In contrast, if you say</p>

<pre>    [ &#60;%prefix&#62; | &#60;%term&#62; ]</pre>

<p>a <code>%prefix&#60;foo&#62;</code> would be selected in preference to a <code>%term&#60;food&#62;</code>. (Which is not what you usually want if your language is to do longest-token consistently.)</p>
</li>

<li>A leading <code>{</code> indicates code that produces a regex to be interpolated into the pattern at that point as a subrule:
<pre>     / (&#60;?ident&#62;)  &#60;{ %cache{$0} //= get_body($0) }&#62; /</pre>

<p>The closure is guaranteed to be run at the canonical time.</p>

<p>As with an ordinary embedded closure, an <b>explicit</b> return from a regex closure binds the <i>result object</i> for this match, ignores the rest of the current regex, and reports success:</p>

<pre>        / (\d) &#60;{ return $0.sqrt }&#62; NotReached /;</pre>

<p>This has the effect of capturing the square root of the numified string, instead of the string. The <code>NotReached</code> part is not reached.</p>

<p>These closures are invoked as anonymous methods on the <code>Match</code> object. See <a href="#Match_objects" class="podlinkpod"
>&#34;Match objects&#34;</a> below for more about result objects.</p>
</li>

<li>A leading <code>&#38;</code> interpolates the return value of a subroutine call as a regex. Hence
<pre>     &#60;&#38;foo()&#62;</pre>

<p>is short for</p>

<pre>     &#60;{ foo() }&#62;</pre>
</li>

<li>In any case of regex interpolation, if the value already happens to be a <code>Regex</code> object, it is not recompiled. If it is a string, the compiled form is cached with the string so that it is not recompiled next time you use it unless the string changes. (Any external lexical variable names must be rebound each time though.) Subrules may not be interpolated with unbalanced bracketing. An interpolated subrule keeps its own inner <code>$/</code>, so its parentheses never count toward the outer regexes groupings. (In other words, parenthesis numbering is always lexically scoped.)</li>

<li>A leading <code>?{</code> or <code>!{</code> indicates a code assertion:
<pre>     / (\d**{1..3}) &#60;?{ $0 &#60; 256 }&#62; /
     / (\d**{1..3}) &#60;!{ $0 &#60; 256 }&#62; /</pre>

<p>Similar to:</p>

<pre>     / (\d**{1..3}) { $0 &#60; 256 or fail } /
     / (\d**{1..3}) { $0 &#60; 256 and fail } /</pre>

<p>Unlike closures, code assertions are not guaranteed to be run at the canonical time if the optimizer can prove something later can&#39;t match. So you can sneak in a call to a non-canonical closure that way:</p>

<pre>     /^foo .* &#60;?{ do { say &#34;Got here!&#34; } or 1 }&#62; .* bar$/</pre>

<p>The <code>do</code> block is unlikely to run unless the string ends with &#34;<code>bar</code>&#34;.</p>
</li>

<li>A leading <code>[</code> or <code>+</code> indicates an enumerated character class. Ranges in enumerated character classes are indicated with <code>..</code>.
<pre>     / &#60;[a..z_]&#62;* /
     / &#60;+[a..z_]&#62;* /</pre>
</li>

<li>A leading <code>-</code> indicates a complemented character class:
<pre>     / &#60;-[a..z_]&#62; &#60;-alpha&#62; /</pre>

<p>This is essentially the same as using negative lookahead and dot:</p>

<pre>    / &#60;![a..z_]&#62; . &#60;!alpha&#62; . /</pre>
</li>

<li>Character classes can be combined (additively or subtractively) within a single set of angle brackets. For example:
<pre>     / &#60;[a..z]-[aeiou]+xdigit&#62; /      # consonant or hex digit</pre>

<p>If such a combination starts with a named character class, a leading <code>+</code> is allowed but not required, provided the next character is a character set operation:</p>

<pre>     / &#60;+alpha-[Jj]&#62; /              # J-less alpha
     / &#60;alpha-[Jj]&#62; /               # same thing</pre>
</li>

<li>A leading <code>&#39;</code> indicates a literal match (including whitespace):
<pre>     / &#60;&#39;match this exactly (whitespace matters)&#39;&#62; /</pre>
</li>

<li>A leading <code>&#34;</code> indicates a literal match after interpolation:
<pre>     / &#60;&#34;match $THIS exactly (whitespace still matters)&#34;&#62; /</pre>
</li>

<li>In general, any general quoting form such as <code>q</code> or <code>qq</code> will be recognized as if it had curlies around it. This includes quotes declared with the <code>quote</code> declarator:
<pre>    quote qX = q:x:c;
    /&#60;qX[cat -n {$foo}]&#62;/</pre>

<p>same as</p>

<pre>    /&#60;{ qX[cat -n {$foo}] }&#62;/</pre>

<p>This hides any <code>qX</code> rule that might be defined in the grammar. Note that this means that the language parser has to pass the current list of quote forms into the regex parser since it needs to be known at compile time.</p>
</li>

<li>The special assertion <code>&#60;.&#62;</code> matches any logical grapheme (including a Unicode combining character sequences):
<pre>     / seekto = &#60;.&#62; /  # Maybe a combined char</pre>

<p>Same as:</p>

<pre>     / seekto = [:graphs .] /</pre>
</li>

<li>A leading <code>!</code> indicates a negated meaning (always a zero-width assertion):
<pre>     / &#60;!before _ &#62; /    # We aren&#39;t before an _</pre>

<p>Note that <code>&#60;!alpha&#62;</code> is different from <code>&#60;-alpha&#62;</code> because the latter matches <code>/./</code> when it is not an alpha.</p>
</li>
</ul>

<p>The following tokens include angles but are not required to balance:</p>

<ul>
<li>A <code>&#60;(</code> token indicates the start of a result capture, while the corresponding <code>)&#62;</code> token indicates its endpoint. When matched, these behave as assertions that are always true, but have the side effect of setting the <code>.from</code> and <code>.to</code> attributes of the match object. That is:
<pre>    / foo &#60;( \d+ )&#62; bar /</pre>

<p>is equivalent to:</p>

<pre>    / &#60;after foo&#62; \d+ &#60;before bar&#62; /</pre>

<p>except that the scan for &#34;<code>foo</code>&#34; can be done in the forward direction, while a lookbehind assertion would presumably scan for <code>\d+</code> and then match &#34;<code>foo</code>&#34; backwards. The use of <code>&#60;(...)&#62;</code> affects only the meaning of the <i>result object</i> and the positions of the beginning and ending of the match. That is, after the match above, <code>$()</code> contains only the digits matched, and <code>.pos</code> is pointing to after the digits. Other captures (named or numbered) are unaffected and may be accessed through <code>$/</code>.</p>
</li>

<li>A <code>&#171;</code> or <code>&#60;&#60;</code> token indicates a left word boundary. A <code>&#187;</code> or <code>&#62;&#62;</code> token indicates a right word boundary. (As separate tokens, these need not be balanced.) Perl 5&#39;s <code>\b</code> is replaced by a <code>&#60;?wb&#62;</code> &#34;word boundary&#34; assertion, while <code>\B</code> becomes <code>&#60;!wb&#62;</code>. (None of these are dependent on the definition of <code>&#60;ws&#62;</code>, but only on the <code>\s</code> definition of whitespace.)</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Backslash_reform"
>Backslash reform</a></h1>

<ul>
<li>The <code>\p</code> and <code>\P</code> properties become intrinsic grammar rules such as (<code>&#60;alpha&#62;</code> and <code>&#60;!alpha&#62;</code>). They may be combined using the above-mentioned character class notation: <code>&#60;[_]+alpha+digit&#62;</code>. Regardless of the higher-level character class names, low-level Unicode properties are always available with a prefix of <code>is</code>. Hence, <code>&#60;+isLu+isLt&#62;</code> is equivalent to <code>&#60;+upper+title&#62;</code>. If you define your own &#34;is&#34; properties they hide any Unicode properties of the same name.</li>

<li>The <code>\L...\E</code>, <code>\U...\E</code>, and <code>\Q...\E</code> sequences are gone. In the rare cases that need them you can use <code>&#60;{ lc $regex }&#62;</code> etc.</li>

<li>The <code>\G</code> sequence is gone. Use <code>:p</code> instead. (Note, however, that it makes no sense to use <code>:p</code> within a pattern, since every internal pattern is implicitly anchored to the current position.) See the <code>at</code> assertion below.</li>

<li>Backreferences (e.g. <code>\1</code>, <code>\2</code>, etc.) are gone; <code>$0</code>, <code>$1</code>, etc. can be used instead, because variables are no longer interpolated.</li>

<li>New backslash sequences, <code>\h</code> and <code>\v</code>, match horizontal and vertical whitespace respectively, including Unicode.</li>

<li><code>\s</code> now matches any Unicode whitespace character.</li>

<li>The new backslash sequence <code>\N</code> matches anything except a logical newline; it is the negation of <code>\n</code>.</li>

<li>A series of other new capital backslash sequences are also the negation of their lower-case counterparts:
<ul>
<li><code>\H</code> matches anything but horizontal whitespace.</li>

<li><code>\V</code> matches anything but vertical whitespace.</li>

<li><code>\T</code> matches anything but a tab.</li>

<li><code>\R</code> matches anything but a return.</li>

<li><code>\F</code> matches anything but a formfeed.</li>

<li><code>\E</code> matches anything but an escape.</li>

<li><code>\X...</code> matches anything but the specified character (specified in hexadecimal).</li>
</ul>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Regexes_really_are_regexes_now"
>Regexes really are regexes now</a></h1>

<ul>
<li>The Perl 5 <code>qr/pattern/</code> regex constructor is gone.</li>

<li>The Perl 6 equivalents are:
<pre>     regex { pattern }    # always takes {...} as delimiters
     rx    / pattern /    # can take (almost any) chars as delimiters</pre>

<p>You may not use whitespace or alphanumerics for delimiters. Space is optional unless needed to distinguish from modifier arguments or function parens. So you may use parens as your <code>rx</code> delimiters, but only if you interpose whitespace:</p>

<pre>     rx ( pattern )      # okay
     rx( 1,2,3 )         # tries to call rx function</pre>

<p>(This is true for all quotelike constructs in Perl 6.)</p>
</li>

<li>If either form needs modifiers, they go before the opening delimiter:
<pre>     $regex = regex :g:s:i { my name is (.*) };
     $regex = rx:g:s:i     / my name is (.*) /;    # same thing</pre>

<p>Space is necessary after the final modifier if you use any bracketing character for the delimiter. (Otherwise it would be taken as an argument to the modifier.)</p>
</li>

<li>You may not use colons for the delimiter. Space is allowed between modifiers:
<pre>     $regex = rx :g :s :i / my name is (.*) /;</pre>
</li>

<li>The name of the constructor was changed from <code>qr</code> because it&#39;s no longer an interpolating quote-like operator. <code>rx</code> is short for <i>regex</i>, (not to be confused with regular expressions).</li>

<li>As the syntax indicates, it is now more closely analogous to a <code>sub {...}</code> constructor. In fact, that analogy runs <i>very</i> deep in Perl 6.</li>

<li>Just as a raw <code>{...}</code> is now always a closure (which may still execute immediately in certain contexts and be passed as an object in others), so too a raw <code>/.../</code> is now always a <code>Regex</code> object (which may still match immediately in certain contexts and be passed as an object in others).</li>

<li>Specifically, a <code>/.../</code> matches immediately in a value context (void, Boolean, string, or numeric), or when it is an explicit argument of a <code>~~</code>. Otherwise it&#39;s a <code>Regex</code> constructor identical to the explicit <code>regex</code> form. So this:
<pre>     $var = /pattern/;</pre>

<p>no longer does the match and sets <code>$var</code> to the result. Instead it assigns a <code>Regex</code> object to <code>$var</code>.</p>
</li>

<li>The two cases can always be distinguished using <code>m{...}</code> or <code>rx{...}</code>:
<pre>     $var = m{pattern};    # Match regex immediately, assign result
     $var = rx{pattern};   # Assign regex expression itself</pre>
</li>

<li>Note that this means that former magically lazy usages like:
<pre>     @list = split /pattern/, $str;</pre>

<p>are now just consequences of the normal semantics.</p>
</li>

<li>It&#39;s now also possible to set up a user-defined subroutine that acts like <code>grep</code>:
<pre>     sub my_grep($selector, *@list) {
         given $selector {
             when Regex { ... }
             when Code  { ... }
             when Hash  { ... }
             # etc.
         }
     }</pre>

<p>Using <code>{...}</code> or <code>/.../</code> in the scalar context of the first argument causes it to produce a <code>Code</code> or <code>Regex</code> object, which the switch statement then selects upon.</p>
</li>

<li>Just as <code>rx</code> has variants, so does the <code>regex</code> declarator. In particular, there are two special variants for use in grammars: <code>token</code> and <code>rule</code>.
<p>A token declaration:</p>

<pre>    token ident { [ &#60;alpha&#62; | _ ] \w+ }</pre>

<p>never backtracks by default. That is, it likes to commit to whatever it has scanned so far. The above is equivalent to</p>

<pre>    regex ident { [ &#60;alpha&#62;: | _: ]: \w+: }</pre>

<p>but rather easier to read. The bare <code>*</code>, <code>+</code>, and <code>?</code> quantifiers never backtrack in a <code>token</code> unless some outer regex has specified a <code>:panic</code> option that applies. If you want to prevent even that, use <code>*:</code>, <code>+:</code>, or <code>?:</code> to prevent any backtracking into the quantifier. If you want to explicitly backtrack, append either a <code>?</code> or a <code>+</code> to the quantifier. The <code>?</code> forces minimal matching as usual, while the <code>+</code> forces greedy matching. The <code>token</code> declarator is really just short for</p>

<pre>    regex :ratchet { ... }</pre>

<p>The other is the <code>rule</code> declarator, for declaring non-terminal productions in a grammar. Like a <code>token</code>, it also does not backtrack by default. In addition, a <code>rule</code> regex also assumes <code>:sigspace</code>. A <code>rule</code> is really short for:</p>

<pre>    regex :ratchet :sigspace { ... }</pre>
</li>

<li>The Perl 5 <code>?...?</code> syntax (<i>succeed once</i>) was rarely used and can be now emulated more cleanly with a state variable:
<pre>    $result = do { state $x ||= m/ pattern /; }    # only matches first time</pre>

<p>To reset the pattern, simply say <code>$x = 0</code>. Though if you want <code>$x</code> visible you&#39;d have to avoid using a block:</p>

<pre>    $result = state $x ||= m/ pattern /;
    ...
    $x = 0;</pre>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Backtracking_control"
>Backtracking control</a></h1>

<ul>
<li>By default, backtracking is greedy in <code>rx</code>, <code>m</code>, <code>s</code>, and the like. It&#39;s also greedy in ordinary <code>regex</code> declarations. In <code>rule</code> and <code>token</code> declarations, backtracking must be explicit.</li>

<li>To force the preceding atom to do eager backtracking, append a <code>:?</code> or <code>?</code> to the atom. If the preceding token is a quantifier, the <code>:</code> may be omitted, so <code>*?</code> works just as in Perl 5.</li>

<li>To force the preceding atom to do greedy backtracking, append a <code>:+</code> or <code>+</code> to the atom. If the preceding token is a quantifier, the <code>:</code> may be omitted. (Perl 5 has no corresponding construct because backtracking always defaults to greedy in Perl 5.)</li>

<li>To force the preceding atom to do no backtracking, use a single <code>:</code> without a subsequent <code>?</code> or <code>+</code>. Backtracking over a single colon causes the regex engine not to retry the preceding atom:
<pre>     ms/ \( &#60;expr&#62; [ , &#60;expr&#62; ]*: \) /</pre>

<p>(i.e. there&#39;s no point trying fewer <code>&#60;expr&#62;</code> matches, if there&#39;s no closing parenthesis on the horizon)</p>

<p>To force all the atoms in an expression not to backtrack by default, use <code>:ratchet</code> or <code>rule</code> or <code>token</code>.</p>
</li>

<li>Backtracking over a double colon causes the surrounding group of alternations to immediately fail:
<pre>     ms/ [ if :: &#60;expr&#62; &#60;block&#62;
          | for :: &#60;list&#62; &#60;block&#62;
          | loop :: &#60;loop_controls&#62;? &#60;block&#62;
          ]
     /</pre>

<p>(i.e. there&#39;s no point trying to match a different keyword if one was already found but failed). Note that you can still back into such an alternation, so you may also need to put <code>:</code> after it if you also want to disable that. If an explicit or implicit <code>:ratchet</code> has disabled backtracking by supplying an implicit <code>:</code>, you need to put an explicit <code>:+</code> after the alternation to enable backing into another alternative if the first pick fails.</p>
</li>

<li>Backtracking over a triple colon causes the current regex to fail outright (no matter where in the regex it occurs):
<pre>     regex ident {
           ( [&#60;alpha&#62;|_] \w* ) ::: { fail if %reserved{$0} }
         | &#34; [&#60;alpha&#62;|_] \w* &#34;
     }

     ms/ get &#60;ident&#62;? /</pre>

<p>(i.e. using an unquoted reserved word as an identifier is not permitted)</p>
</li>

<li>Backtracking over a <code>&#60;commit&#62;</code> assertion causes the entire match to fail outright, no matter how many subrules down it happens:
<pre>     regex subname {
         ([&#60;alpha&#62;|_] \w*) &#60;commit&#62; { fail if %reserved{$0} }
     }
     ms/ sub &#60;subname&#62;? &#60;block&#62; /</pre>

<p>(i.e. using a reserved word as a subroutine name is instantly fatal to the <i>surrounding</i> match as well)</p>
</li>

<li>A <code>&#60;cut&#62;</code> assertion always matches successfully, and has the side effect of deleting the parts of the string already matched.</li>

<li>Attempting to backtrack past a <code>&#60;cut&#62;</code> causes the complete match to fail (like backtracking past a <code>&#60;commit&#62;</code>). This is because there&#39;s now no preceding text to backtrack into.</li>

<li>This is useful for throwing away successfully processed input when matching from an input stream or an iterator of arbitrary length.</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Named_Regexes"
>Named Regexes</a></h1>

<ul>
<li>The analogy between <code>sub</code> and <code>regex</code> extends much further.</li>

<li>Just as you can have anonymous subs and named subs...</li>

<li>...so too you can have anonymous regexes and <i>named</i> regexes (and tokens, and rules):
<pre>     token ident { [&#60;alpha&#62;|_] \w* }

     # and later...

     @ids = grep /&#60;ident&#62;/, @strings;</pre>
</li>

<li>As the above example indicates, it&#39;s possible to refer to named regexes, such as:
<pre>     regex serial_number { &#60;[A..Z]&#62; \d**{8} }
     token type { alpha | beta | production | deprecated | legacy }</pre>

<p>in other regexes as named assertions:</p>

<pre>     rule identification { [soft|hard]ware &#60;type&#62; &#60;serial_number&#62; }</pre>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Nothing_is_illegal"
>Nothing is illegal</a></h1>

<ul>
<li>The null pattern is now illegal.</li>

<li>To match whatever the prior successful regex matched, use:
<pre>     /&#60;prior&#62;/</pre>
</li>

<li>To match the zero-width string, use:
<pre>     /&#60;null&#62;/</pre>

<p>For example:</p>

<pre>     split /&#60;?null&#62;/, $string</pre>

<p>splits between characters.</p>
</li>

<li>To match a null alternative, use:
<pre>     /a|b|c|&#60;?null&#62;/</pre>

<p>This makes it easier to catch errors like this:</p>

<pre>    /a|b|c|/</pre>

<p>As a special case, however, the first null alternative in a match like</p>

<pre>     ms/ [
          | if :: &#60;expr&#62; &#60;block&#62;
          | for :: &#60;list&#62; &#60;block&#62;
          | loop :: &#60;loop_controls&#62;? &#60;block&#62;
          ]
     /</pre>

<p>is simply ignored. Only the first alternative is special that way. If you write:</p>

<pre>     ms/ [
              if :: &#60;expr&#62; &#60;block&#62;              |
              for :: &#60;list&#62; &#60;block&#62;             |
              loop :: &#60;loop_controls&#62;? &#60;block&#62;  |
          ]
     /</pre>

<p>it&#39;s still an error.</p>
</li>

<li>However, it&#39;s okay for a non-null syntactic construct to have a degenerate case matching the null string:
<pre>     $something = &#34;&#34;;
     /a|b|c|$something/;</pre>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Return_values_from_matches"
>Return values from matches</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Match_objects"
>Match objects</a></h2>

<ul>
<li>A match always returns a Match object, which is also available as <code>$/</code>, which is a contextual lexical declared in the outer subroutine that is calling the regex. (A closure lexically embedded in a regex does not redeclare <code>$/</code>, so <code>$/</code> always refers to the current match, not any prior submatch done within the closure).</li>

<li>Notionally, a match object contains (among other things) a boolean success value, a scalar <i>result object</i>, an array of ordered submatch objects, and a hash of named submatch objects. To provide convenient access to these various values, the match object evaluates differently in different contexts:
<ul>
<li>In boolean context it evaluates as true or false (i.e. did the match succeed?):
<pre>     if /pattern/ {...}
     # or:
     /pattern/; if $/ {...}</pre>

<p>With <code>:global</code> or <code>:overlap</code> or <code>:exhaustive</code> the boolean is allowed to return true on the first match. The <code>Match</code> object can produce the rest of the results lazily if evaluated in list context.</p>
</li>

<li>In string context it evaluates to the stringified value of its <i>result object</i>, which is usually the entire matched string:
<pre>     print %hash{ &#34;{$text ~~ /&#60;?ident&#62;/}&#34; };
     # or equivalently:
     $text ~~ /&#60;?ident&#62;/  &#38;&#38;  print %hash{~$/};</pre>

<p>But generally you should say <code>~$/</code> if you mean <code>~$/</code>.</p>
</li>

<li>In numeric context it evaluates to the numeric value of its <i>result object</i>, which is usually the entire matched string:
<pre>     $sum += /\d+/;
     # or equivalently:
     /\d+/; $sum = $sum + $/;</pre>
</li>

<li>When used as a scalar, a <code>Match</code> object evaluates to its underlying result object. Usually this is just the entire match string, but you can override that by calling <code>return</code> inside a regex:
<pre>    my $moose = $(m:{
        &#60;antler&#62; &#60;body&#62;
        { return Moose.new( body =&#62; $&#60;body&#62;().attach($&#60;antler&#62;) ) }
        # match succeeds -- ignore the rest of the regex
    });</pre>

<p><code>$()</code> is a shorthand for <code>$($/)</code>. The result object may be of any type, not just a string.</p>

<p>You may also capture a subset of the match as the result object using the <code>&#60;(...)&#62;</code> construct:</p>

<pre>    &#34;foo123bar&#34; ~~ / foo &#60;( \d+ )&#62; bar /
    say $();    # says 123</pre>

<p>In this case the result object is always a string when doing string matching, and a list of one or more elements when doing array matching.</p>

<p>Additionally, the <code>Match</code> object delegates its <code>coerce</code> calls (such as <code>+$match</code> and <code>~$match</code>) to its underlying result object. The only exception is that <code>Match</code> handles boolean coercion itself, which returns whether the match had succeeded at least once.</p>

<p>This means that these two work the same:</p>

<pre>    / &#60;moose&#62; { return $$&#60;moose&#62; as Moose } /
    / &#60;moose&#62; { return $&#60;moose&#62;  as Moose } /</pre>
</li>

<li>When used as an array, a <code>Match</code> object pretends to be an array of all its positional captures. Hence
<pre>     ($key, $val) = ms/ (\S+) =&#62; (\S+)/;</pre>

<p>can also be written:</p>

<pre>     $result = ms/ (\S+) =&#62; (\S+)/;
     ($key, $val) = @$result;</pre>

<p>To get a single capture into a string, use a subscript:</p>

<pre>     $mystring = &#34;{ ms/ (\S+) =&#62; (\S+)/[0] }&#34;;</pre>

<p>To get all the captures into a string, use a <i>zen</i> slice:</p>

<pre>     $mystring = &#34;{ ms/ (\S+) =&#62; (\S+)/[] }&#34;;</pre>

<p>Or cast it into an array:</p>

<pre>     $mystring = &#34;@( ms/ (\S+) =&#62; (\S+)/ )&#34;;</pre>

<p>Note that, as a scalar variable, <code>$/</code> doesn&#39;t automatically flatten in list context. Use <code>@()</code> as a shorthand for <code>@($/)</code> to flatten the positional captures under list context. Note that a <code>Match</code> object is allowed to evaluate its match lazily in list context. Use <code>**@()</code> to force an eager match.</p>
</li>

<li>When used as a hash, a <code>Match</code> object pretends to be a hash of all its named captures. The keys do not include any sigils, so if you capture to variable <code>@&#60;foo&#62;</code> its real name is <code>$/{&#39;foo&#39;}</code> or <code>$/&#60;foo&#62;</code>. However, you may still refer to it as <code>@&#60;foo&#62;</code> anywhere <code>$/</code> is visible. (But it is erroneous to use the same name for two different capture datatypes.)
<p>Note that, as a scalar variable, <code>$/</code> doesn&#39;t automatically flatten in list context. Use <code>%()</code> as a shorthand for <code>%($/)</code> to flatten as a hash, or bind it to a variable of the appropriate type. As with <code>@()</code>, it&#39;s possible for <code>%()</code> to produce its pairs lazily in list context.</p>
</li>

<li>The numbered captures may be treated as named, so <code>$&#60;0 1 2&#62;</code> is equivalent to <code>$/[0,1,2]</code>. This allows you to write slices of intermixed named and numbered captures.</li>

<li>In ordinary code, variables <code>$0</code>, <code>$1</code>, etc. are just aliases into <code>$/[0]</code>, <code>$/[1]</code>, etc. Hence they will all be undefined if the last match failed (unless they were explicitly bound in a closure without using the <code>let</code> keyword).</li>
</ul>
</li>

<li><code>Match</code> objects have methods that provide additional information about the match. For example:
<pre>     if m/ def &#60;ident&#62; &#60;codeblock&#62; / {
         say &#34;Found sub def from index $/.from() to index $/.to()&#34;;
     }</pre>

<p>Warning: these methods usually return values of type <code>StrPos</code>, which you should not treat as integers. The interpolation of these values in the example above is slightly naughty, and likely to print out the positions not as numbers but as &#34;<code>Graphs(42)</code>&#34; or some such.</p>
</li>

<li>All match attempts--successful or not--against any regex, subrule, or subpattern (see below) return an object of class <code>Match</code>. That is:
<pre>     $match_obj = $str ~~ /pattern/;
     say &#34;Matched&#34; if $match_obj;</pre>
</li>

<li>This returned object is also automatically assigned to the lexical <code>$/</code> variable, unless the match statement is inside another regex. That is:
<pre>     $str ~~ /pattern/;
     say &#34;Matched&#34; if $/;</pre>
</li>

<li>Inside a regex, the <code>$/</code> variable holds the current regex&#39;s incomplete <code>Match</code> object (which can be modified via the internal <code>$/</code>). For example:
<pre>    $str ~~ / foo                 # Match &#39;foo&#39;
               { $/ = &#39;bar&#39; }     # But pretend we matched &#39;bar&#39;
             /;
    say $/;                       # says &#39;bar&#39;</pre>

<p>This is slightly dangerous, insofar as you might return something that does not behave like a <code>Match</code> object to some context that requires one. Fortunately, you normally just want to return a result object instead:</p>

<pre>    $str ~~ / foo                 # Match &#39;foo&#39;
               { return &#39;bar&#39; }   # But pretend we matched &#39;bar&#39;
             /;
    say $();                      # says &#39;bar&#39;</pre>
</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Subpattern_captures"
>Subpattern captures</a></h2>

<ul>
<li>Any part of a regex that is enclosed in capturing parentheses is called a <i>subpattern</i>. For example:
<pre>        #               subpattern
        #  _________________/\____________________
        # |                                       |
        # |       subpattern  subpattern          |
        # |          __/\__    __/\__             |
        # |         |      |  |      |            |
     ms/ (I am the (walrus), ( khoo )**{2} kachoo) /;</pre>
</li>

<li>Each subpattern in a regex produces a <code>Match</code> object if it is successfully matched.</li>

<li>Each subpattern&#39;s <code>Match</code> object is pushed onto the array inside the outer <code>Match</code> object belonging to the surrounding scope (known as its <i>parent <code>Match</code> object</i>). The surrounding scope may be either the innermost surrounding subpattern (if the subpattern is nested) or else the entire regex itself.</li>

<li>Like all captures, these assignments to the array are hypothetical, and are undone if the subpattern is backtracked.</li>

<li>For example, if the following pattern matched successfully:
<pre>        #                subpat-A
        #  _________________/\____________________
        # |                                       |
        # |         subpat-B  subpat-C            |
        # |          __/\__    __/\__             |
        # |         |      |  |      |            |
     ms/ (I am the (walrus), ( khoo )**{2} kachoo) /;</pre>

<p>then the <code>Match</code> objects representing the matches made by <i>subpat-B</i> and <i>subpat-C</i> would be successively pushed onto the array inside <i>subpat- A</i>&#39;s <code>Match</code> object. Then <i>subpat-A</i>&#39;s <code>Match</code> object would itself be pushed onto the array inside the <code>Match</code> object for the entire regex (i.e. onto <code>$/</code>&#39;s array).</p>
</li>

<li>As a result of these semantics, capturing parentheses in Perl 6 are hierarchical, not linear (see <a href="#Nested_subpattern_captures" class="podlinkpod"
>&#34;Nested subpattern captures&#34;</a>).</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Accessing_captured_subpatterns"
>Accessing captured subpatterns</a></h2>

<ul>
<li>The array elements of a <code>Match</code> object are referred to using either the standard array access notation (e.g. <code>$/[0]</code>, <code>$/[1]</code>, <code>$/[2]</code>, etc.) or else via the corresponding lexically scoped numeric aliases (i.e. <code>$0</code>, <code>$1</code>, <code>$2</code>, etc.) So:
<pre>     say &#34;$/[1] was found between $/[0] and $/[2]&#34;;</pre>

<p>is the same as:</p>

<pre>     say &#34;$1 was found between $0 and $2&#34;;</pre>
</li>

<li>Note that, in Perl 6, the numeric capture variables start from $0, not $1, with the numbers corresponding to the element&#39;s index inside <code>$/</code>.</li>

<li>The array elements of the regex&#39;s <code>Match</code> object (i.e. <code>$/</code>) store individual <code>Match</code> objects representing the substrings that were matched and captured by the first, second, third, etc. <i>outermost</i> (i.e. unnested) subpatterns. So these elements can be treated like fully fledged match results. For example:
<pre>     if m/ (\d\d\d\d)-(\d\d)-(\d\d) (BCE?|AD|CE)?/ {
           ($yr, $mon, $day) = $/[0..2];
           $era = &#34;$3&#34; if $3;                    # stringify/boolify
           @datepos = ( $0.from() .. $2.to() );  # Call Match methods
     }</pre>
</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Nested_subpattern_captures"
>Nested subpattern captures</a></h2>

<ul>
<li>Substrings matched by <i>nested</i> subpatterns (i.e. nested capturing parens) are assigned to the array inside the nested subpattern&#39;s parent <code>Match</code> object, not to the array of <code>$/</code>.</li>

<li>This behavior is quite different to Perl 5 semantics:
<pre>      # Perl 5...
      #
      # $1---------------------  $4---------  $5------------------
      # |   $2---------------  | |          | | $6----  $7------  |
      # |   |         $3--   | | |          | | |     | |       | |
      # |   |         |   |  | | |          | | |     | |       | |
     m/ ( A (guy|gal|g(\S+)  ) ) (sees|calls) ( (the|a) (gal|guy) ) /x;</pre>
</li>

<li>In Perl 6, nested parens produce properly nested captures:
<pre>      # Perl 6...
      #
      # $0---------------------  $1---------  $2------------------
      # |   $0[0]------------  | |          | | $2[0]-  $2[1]---  |
      # |   |       $0[0][0] | | |          | | |     | |       | |
      # |   |         |   |  | | |          | | |     | |       | |
     m/ ( A (guy|gal|g(\S+)  ) ) (sees|calls) ( (the|a) (gal|guy) ) /;</pre>
</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Quantified_subpattern_captures"
>Quantified subpattern captures</a></h2>

<ul>
<li>If a subpattern is directly quantified (using <i>any</i> quantifier), it no longer produces a single <code>Match</code> object. Instead, it produces a list of <code>Match</code> objects corresponding to the sequence of individual matches made by the repeated subpattern.</li>

<li>Because a quantified subpattern returns a list of <code>Match</code> objects, the corresponding array element for the quantified capture will store a (nested) array rather than a single <code>Match</code> object. For example:
<pre>     if m/ (\w+) \: (\w+ \s+)* / {
         say &#34;Key:    $0&#34;;         # Unquantified --&#62; single Match
         say &#34;Values: @($1)&#34;;      # Quantified   --&#62; array of Match
     }</pre>
</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Indirectly_quantified_subpattern_captures"
>Indirectly quantified subpattern captures</a></h2>

<ul>
<li>A subpattern may sometimes be nested inside a quantified non-capturing structure:
<pre>      #       non-capturing       quantifier
      #  __________/\____________  __/\__
      # |                        ||      |
      # |   $0         $1        ||      |
      # |  _^_      ___^___      ||      |
      # | |   |    |       |     ||      |
     m/ [ (\w+) \: (\w+ \h*)* \n ]**{2..*} /</pre>

<p>Non-capturing brackets <i>don&#39;t</i> create a separate nested lexical scope, so the two subpatterns inside them are actually still in the regex&#39;s top-level scope, hence their top-level designations: <code>$0</code> and <code>$1</code>.</p>
</li>

<li>However, because the two subpatterns are inside a quantified structure, <code>$0</code> and <code>$1</code> will each contain an array. The elements of that array will be the submatches returned by the corresponding subpatterns on each iteration of the non-capturing parentheses. For example:
<pre>     my $text = &#34;foo:food fool\nbar:bard barb&#34;;

               #   $0--     $1------
               #   |   |    |       |
     $text ~~ m/ [ (\w+) \: (\w+ \h*)* \n ]**{2..*} /;

     # Because they&#39;re in a quantified non-capturing block...
     # $0 contains the equivalent of:
     #
     #       [ Match.new(str=&#62;&#39;foo&#39;), Match.new(str=&#62;&#39;bar&#39;) ]
     #
     # and $1 contains the equivalent of:
     #
     #       [ Match.new(str=&#62;&#39;food &#39;),
     #         Match.new(str=&#62;&#39;fool&#39; ),
     #         Match.new(str=&#62;&#39;bard &#39;),
     #         Match.new(str=&#62;&#39;barb&#39; ),
     #       ]</pre>
</li>

<li>In contrast, if the outer quantified structure is a <i>capturing</i> structure (i.e. a subpattern) then it <i>will</i> introduce a nested lexical scope. That outer quantified structure will then return an array of <code>Match</code> objects representing the captures of the inner parens for <i>every</i> iteration (as described above). That is:
<pre>     my $text = &#34;foo:food fool\nbar:bard barb&#34;;

               # $0-----------------------
               # |                        |
               # | $0[0]    $0[1]---      |
               # | |   |    |       |     |
     $text ~~ m/ ( (\w+) \: (\w+ \h*)* \n )**{2..*} /;

     # Because it&#39;s in a quantified capturing block,
     # $0 contains the equivalent of:
     #
     #       [ Match.new( str=&#62;&#34;foo:food fool\n&#34;,
     #                    arr=&#62;[ Match.new(str=&#62;&#39;foo&#39;),
     #                           [
     #                               Match.new(str=&#62;&#39;food &#39;),
     #                               Match.new(str=&#62;&#39;fool&#39;),
     #                           ]
     #                         ],
     #                  ),
     #         Match.new( str=&#62;&#39;bar:bard barb&#39;,
     #                    arr=&#62;[ Match.new(str=&#62;&#39;bar&#39;),
     #                           [
     #                               Match.new(str=&#62;&#39;bard &#39;),
     #                               Match.new(str=&#62;&#39;barb&#39;),
     #                           ]
     #                         ],
     #                  ),
     #       ]
     #
     # and there is no $1</pre>
</li>

<li>In other words, quantified non-capturing parens collect their components into handy flattened lists, whereas quantified capturing parens collect their components in a handy hierarchical structure.</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Subpattern_numbering"
>Subpattern numbering</a></h2>

<ul>
<li>The index of a given subpattern can always be statically determined, but is not necessarily unique nor always monotonic. The numbering of subpatterns restarts in each lexical scope (either a regex, a subpattern, or the branch of an alternation).</li>

<li>In particular, the index of capturing parentheses restarts after each <code>|</code>. Hence:
<pre>                  # $0      $1    $2   $3    $4           $5
     $tune_up = rx/ (don&#39;t) (ray) (me) (for) (solar tea), (d&#39;oh!)
                  # $0      $1      $2    $3        $4
                  | (every) (green) (BEM) (devours) (faces)
                  /;</pre>

<p>This means that if the second alternation matches, the <code>@$/</code> array will contain <code>(&#39;every&#39;, &#39;green&#39;, &#39;BEM&#39;, &#39;devours&#39;, &#39;faces&#39;)</code> rather than <code>(undef, undef, undef, undef, undef, undef, &#39;every&#39;, &#39;green&#39;, &#39;BEM&#39;, &#39;devours&#39;, &#39;faces&#39;)</code> (as the same regex would in Perl 5).</p>
</li>

<li>Note that it is still possible to mimic the monotonic Perl 5 capture indexing semantics. See <a href="#Numbered_scalar_aliasing" class="podlinkpod"
>&#34;Numbered scalar aliasing&#34;</a> below for details.</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Subrule_captures"
>Subrule captures</a></h2>

<ul>
<li>Any call to a named <code>&#60;regex&#62;</code> within a pattern is known as a <i>subrule</i>, whether that regex is actually defined as a <code>regex</code> or <code>token</code> or <code>rule</code> or even an ordinary <code>method</code> or <code>multi</code>.</li>

<li>Any bracketed construct that is aliased (see <a href="#Aliasing" class="podlinkpod"
>&#34;Aliasing&#34;</a> below) to a named variable is also a subrule.</li>

<li>For example, this regex contains three subrules:
<pre>      # subrule       subrule      subrule
      #  __^__    _______^______    __^__
      # |     |  |              |  |     |
     m/ &#60;ident&#62;  $&#60;spaces&#62;:=(\s*)  &#60;digit&#62;+ /</pre>
</li>

<li>Just like subpatterns, each successfully matched subrule within a regex produces a <code>Match</code> object. But, unlike subpatterns, that <code>Match</code> object is not assigned to the array inside its parent <code>Match</code> object. Instead, it is assigned to an entry of the hash inside its parent <code>Match</code> object. For example:
<pre>      #  .... $/ .....................................
      # :                                             :
      # :              .... $/[0] ..................  :
      # :             :                             : :
      # : $/&#60;ident&#62;   :        $/[0]&#60;ident&#62;         : :
      # :   __^__     :           __^__             : :
      # :  |     |    :          |     |            : :
     ms/  &#60;ident&#62; \: ( known as &#60;ident&#62; previously ) /</pre>
</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Accessing_captured_subrules"
>Accessing captured subrules</a></h2>

<ul>
<li>The hash entries of a <code>Match</code> object can be referred to using any of the standard hash access notations (<code>$/{&#39;foo&#39;}</code>, <code>$/&#60;bar&#62;</code>, <code>$/&#171;baz&#187;</code>, etc.), or else via corresponding lexically scoped aliases (<code>$&#60;foo&#62;</code>, <code>$&#171;bar&#187;</code>, <code>$&#60;baz&#62;</code>, etc.) So the previous example also implies:
<pre>      #    $&#60;ident&#62;             $0&#60;ident&#62;
      #     __^__                 __^__
      #    |     |               |     |
     ms/  &#60;ident&#62; \: ( known as &#60;ident&#62; previously ) /</pre>
</li>

<li>Note that it makes no difference whether a subrule is angle-bracketed (<code>&#60;ident&#62;</code>) or aliased (<code>$&#60;ident&#62; := (&#60;alpha&#62;\w*)</code>). The name&#39;s the thing.</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Repeated_captures_of_the_same_subrule"
>Repeated captures of the same subrule</a></h2>

<ul>
<li>If a subrule appears two (or more) times in any branch of a lexical scope (i.e. twice within the same subpattern and alternation), or if the subrule is quantified anywhere within a given scope, then its corresponding hash entry is always assigned an array of <code>Match</code> objects rather than a single <code>Match</code> object.</li>

<li>Successive matches of the same subrule (whether from separate calls, or from a single quantified repetition) append their individual <code>Match</code> objects to this array. For example:
<pre>     if ms/ mv &#60;file&#62; &#60;file&#62; / {
         $from = $&#60;file&#62;[0];
         $to   = $&#60;file&#62;[1];
     }</pre>

<p>Likewise, with a quantified subrule:</p>

<pre>     if ms/ mv &#60;file&#62;**{2} / {
         $from = $&#60;file&#62;[0];
         $to   = $&#60;file&#62;[1];
     }</pre>

<p>And with a mixture of both:</p>

<pre>     if ms/ mv &#60;file&#62;+ &#60;file&#62; / {
         $to   = pop @($&#60;file&#62;);
         @from = @($&#60;file&#62;);
     }</pre>
</li>

<li>However, if a subrule is explicitly renamed (or aliased -- see <a href="#Aliasing" class="podlinkpod"
>&#34;Aliasing&#34;</a>), then only the <i>final</i> name counts when deciding whether it is or isn&#39;t repeated. For example:
<pre>     if ms/ mv &#60;file&#62; $&#60;dir&#62;:=&#60;file&#62; / {
         $from = $&#60;file&#62;;  # Only one subrule named &#60;file&#62;, so scalar
         $to   = $&#60;dir&#62;;   # The Capture Formerly Known As &#60;file&#62;
     }</pre>

<p>Likewise, neither of the following constructions causes <code>&#60;file&#62;</code> to produce an array of <code>Match</code> objects, since none of them has two or more <code>&#60;file&#62;</code> subrules in the same lexical scope:</p>

<pre>     if ms/ (keep) &#60;file&#62; | (toss) &#60;file&#62; / {
         # Each &#60;file&#62; is in a separate alternation, therefore &#60;file&#62;
         # is not repeated in any one scope, hence $&#60;file&#62; is
         # not an Array object...
         $action = $0;
         $target = $&#60;file&#62;;
     }

     if ms/ &#60;file&#62; \: (&#60;file&#62;|none) / {
         # Second &#60;file&#62; nested in subpattern which confers a
         # different scope...
         $actual  = $/&#60;file&#62;;
         $virtual = $/[0]&#60;file&#62; if $/[0]&#60;file&#62;;
     }</pre>
</li>

<li>On the other hand, unaliased square brackets don&#39;t confer a separate scope (because they don&#39;t have an associated <code>Match</code> object). So:
<pre>     if ms/ &#60;file&#62; \: [&#60;file&#62;|none] / { # Two &#60;file&#62;s in same scope
         $actual  = $/&#60;file&#62;[0];
         $virtual = $/&#60;file&#62;[1] if $/&#60;file&#62;[1];
     }</pre>
</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Aliasing"
>Aliasing</a></h2>

<p>Aliases can be named or numbered. They can be scalar-, array-, or hash-like. And they can be applied to either capturing or non-capturing constructs. The following sections highlight special features of the semantics of some of those combinations.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Named_scalar_aliasing_to_subpatterns"
>Named scalar aliasing to subpatterns</a></h3>

<ul>
<li>If a named scalar alias is applied to a set of <i>capturing</i> parens:
<pre>        #          ______/capturing parens\_____
        #         |                             |
        #         |                             |
     ms/ $&#60;key&#62;:=( (&#60;[A..E]&#62;) (\d**{3..6}) (X?) ) /;</pre>

<p>then the outer capturing parens no longer capture into the array of <code>$/</code> as unaliased parens would. Instead the aliased parens capture into the hash of <code>$/</code>; specifically into the hash element whose key is the alias name.</p>
</li>

<li>So, in the above example, a successful match sets <code>$&#60;key&#62;</code> (i.e. <code>$/&#60;key&#62;</code>), but <i>not</i> <code>$0</code> (i.e. not <code>$/[0]</code>).</li>

<li>More specifically:
<ul>
<li><code>$/&#60;key&#62;</code> will contain the <code>Match</code> object that would previously have been placed in <code>$/[0]</code>.</li>

<li><code>$/&#60;key&#62;[0]</code> will contain the A-E letter,</li>

<li><code>$/&#60;key&#62;[1]</code> will contain the digits,</li>

<li><code>$/&#60;key&#62;[2]</code> will contain the optional X.</li>
</ul>
</li>

<li>Another way to think about this behavior is that aliased parens create a kind of lexically scoped named subrule; that the contents of the parentheses are treated as if they were part of a separate subrule whose name is the alias.</li>
</ul>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Named_scalar_aliases_applied_to_non-capturing_brackets"
>Named scalar aliases applied to non-capturing brackets</a></h3>

<ul>
<li>If a named scalar alias is applied to a set of <i>non-capturing</i> brackets:
<pre>        #          ___/non-capturing brackets\__
        #         |                             |
        #         |                             |
     ms/ $&#60;key&#62;:=[ (&#60;[A..E]&#62;) (\d**{3..6}) (X?) ] /;</pre>

<p>then the corresponding <code>$/&#60;key&#62;</code> Match object contains only the string matched by the non-capturing brackets.</p>
</li>

<li>In particular, the array of the <code>$/&#60;key&#62;</code> entry is empty. That&#39;s because square brackets do not create a nested lexical scope, so the subpatterns are unnested and hence correspond to $0, $1, and $2, and <i>not</i> to <code>$/&#60;key&#62;[0]</code>, <code>$/&#60;key&#62;[1]</code>, and <code>$/&#60;key&#62;[2]</code>.</li>

<li>In other words:
<ul>
<li><code>$/&#60;key&#62;</code> will contain the complete substring matched by the square brackets (in a <code>Match</code> object, as described above),</li>

<li><code>$0</code> will contain the A-E letter,</li>

<li><code>$1</code> will contain the digits,</li>

<li><code>$2</code> will contain the optional X.</li>
</ul>
</li>
</ul>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Named_scalar_aliasing_to_subrules"
>Named scalar aliasing to subrules</a></h3>

<ul>
<li>If a subrule is aliased, it assigns its <code>Match</code> object to the hash entry whose key is the name of the alias. And it <i>no longer</i> assigns anything to the hash entry whose key is the subrule name. That is:
<pre>     if m/ ID\: $&#60;id&#62;:=&#60;ident&#62; / {
         say &#34;Identified as $/&#60;id&#62;&#34;;    # $/&#60;ident&#62; is undefined
     }</pre>
</li>

<li>Hence aliasing a subrule <i>changes</i> the destination of the subrule&#39;s <code>Match</code> object. This is particularly useful for differentiating two or more calls to the same subrule in the same scope. For example:
<pre>     if ms/ mv &#60;file&#62;+ $&#60;dir&#62;:=&#60;file&#62; / {
         @from = @($&#60;file&#62;);
         $to   = $&#60;dir&#62;;
     }</pre>
</li>
</ul>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Numbered_scalar_aliasing"
>Numbered scalar aliasing</a></h3>

<ul>
<li>If a numbered alias is used instead of a named alias:
<pre>     m/ $1:=(&#60;-[:]&#62;*) \:  $0:=&#60;ident&#62; /</pre>

<p>the behavior is exactly the same as for a named alias (i.e. the various cases described above), except that the resulting <code>Match</code> object is assigned to the corresponding element of the appropriate array rather than to an element of the hash.</p>
</li>

<li>If any numbered alias is used, the numbering of subsequent unaliased subpatterns in the same scope automatically increments from that alias number (much like enum values increment from the last explicit value). That is:
<pre>      #  ---$1---    -$2-    ---$6---    -$7-
      # |        |  |    |  |        |  |    |
     m/ $1:=(food)  (bard)  $6:=(bazd)  (quxd) /;</pre>
</li>

<li>This <i>follow-on</i> behavior is particularly useful for reinstituting Perl5 semantics for consecutive subpattern numbering in alternations:
<pre>     $tune_up = rx/ (don&#39;t) (ray) (me) (for) (solar tea), (d&#39;oh!)
                  | $6:=(every) (green) (BEM) (devours) (faces)
                  #             $7      $8    $9        $10
                  /;</pre>
</li>

<li>It also provides an easy way in Perl 6 to reinstitute the unnested numbering semantics of nested Perl 5 subpatterns:
<pre>      # Perl 5...
      #               $1
      #  _____________/\______________
      # |    $2          $3       $4  |
      # |  __/\___   ____/\____   /\  |
      # | |       | |          | |  | |
     m/ ( (&#60;[A..E]&#62;) (\d**{3..6}) (X?) ) /;


      # Perl 6...
      #               $0
      #  _____________/\______________
      # |  $0[0]       $0[1]    $0[2] |
      # |  __/\___   ____/\____   /\  |
      # | |       | |          | |  | |
     m/ ( (&#60;[A..E]&#62;) (\d**{3..6}) (X?) ) /;


      # Perl 6 simulating Perl 5...
      #                 $1
      #  _______________/\________________
      # |        $2          $3       $4  |
      # |      __/\___   ____/\____   /\  |
      # |     |       | |          | |  | |
     m/ $1:=[ (&#60;[A..E]&#62;) (\d**{3..6}) (X?) ] /;</pre>

<p>The non-capturing brackets don&#39;t introduce a scope, so the subpatterns within them are at regex scope, and hence numbered at the top level. Aliasing the square brackets to <code>$1</code> means that the next subpattern at the same level (i.e. the <code>(&#60;[A..E]&#62;)</code>) is numbered sequentially (i.e. <code>$2</code>), etc.</p>
</li>
</ul>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Scalar_aliases_applied_to_quantified_constructs"
>Scalar aliases applied to quantified constructs</a></h3>

<ul>
<li>All of the above semantics apply equally to aliases which are bound to quantified structures.</li>

<li>The only difference is that, if the aliased construct is a subrule or subpattern, that quantified subrule or subpattern will have returned a list of <code>Match</code> objects (as described in <a href="#Quantified_subpattern_captures" class="podlinkpod"
>&#34;Quantified subpattern captures&#34;</a> and <a href="#Repeated_captures_of_the_same_subrule" class="podlinkpod"
>&#34;Repeated captures of the same subrule&#34;</a>). So the corresponding array element or hash entry for the alias will contain an array, instead of a single <code>Match</code> object.</li>

<li>In other words, aliasing and quantification are completely orthogonal. For example:
<pre>     if m/ mv $0:=&#60;file&#62;+ / {
         # &#60;file&#62;+ returns a list of Match objects,
         # so $0 contains an array of Match objects,
         # one for each successful call to &#60;file&#62;

         # $/&#60;file&#62; does not exist (it&#39;s pre-empted by the alias)
     }


     if m/ mv $&#60;from&#62;:=(\S+ \s+)* / {
         # Quantified subpattern returns a list of Match objects,
         # so $/&#60;from&#62; contains an array of Match
         # objects, one for each successful match of the subpattern

         # $0 does not exist (it&#39;s pre-empted by the alias)
     }</pre>
</li>

<li>Note, however, that a set of quantified <i>non-capturing</i> brackets always returns a single <code>Match</code> object which contains only the complete substring that was matched by the full set of repetitions of the brackets (as described in <a href="#Named_scalar_aliases_applied_to_non-capturing_brackets" class="podlinkpod"
>&#34;Named scalar aliases applied to non-capturing brackets&#34;</a>). For example:
<pre>     &#34;coffee fifo fumble&#34; ~~ m/ $&#60;effs&#62;:=[f &#60;-[f]&#62;**{1..2} \s*]+ /;

     say $&#60;effs&#62;;    # prints &#34;fee fifo fum&#34;</pre>
</li>
</ul>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Array_aliasing"
>Array aliasing</a></h3>

<ul>
<li>An alias can also be specified using an array as the alias instead of a scalar. For example:
<pre>     m/ mv @&#60;from&#62;:=[(\S+) \s+]* &#60;dir&#62; /;</pre>
</li>

<li>Using the <code>@&#60;alias&#62;:=</code> notation instead of a <code>$&#60;alias&#62;:=</code> mandates that the corresponding hash entry or array element <i>always</i> receives an array of <code>Match</code> objects, even if the construct being aliased would normally return a single <code>Match</code> object. This is useful for creating consistent capture semantics across structurally different alternations (by enforcing array captures in all branches):
<pre>     ms/ Mr?s? @&#60;names&#62;:=&#60;ident&#62; W\. @&#60;names&#62;:=&#60;ident&#62;
        | Mr?s? @&#60;names&#62;:=&#60;ident&#62;
        /;

     # Aliasing to @&#60;names&#62; means $/&#60;names&#62; is always
     # an Array object, so...

     say @($/&#60;names&#62;);</pre>
</li>

<li>For convenience and consistency, <code>@&#60;key&#62;</code> can also be used outside a regex, as a shorthand for <code>@( $/&#60;key&#62; )</code>. That is:
<pre>     ms/ Mr?s? @&#60;names&#62;:=&#60;ident&#62; W\. @&#60;names&#62;:=&#60;ident&#62;
        | Mr?s? @&#60;names&#62;:=&#60;ident&#62;
        /;

     say @&#60;names&#62;;</pre>
</li>

<li>If an array alias is applied to a quantified pair of non-capturing brackets, it captures the substrings matched by each repetition of the brackets into separate elements of the corresponding array. That is:
<pre>     m/ mv $&#60;files&#62;:=[ f.. \s* ]* /; # $/&#60;files&#62; assigned a single
                                     # Match object containing the
                                     # complete substring matched by
                                     # the full set of repetitions
                                     # of the non-capturing brackets

     m/ mv @&#60;files&#62;:=[ f.. \s* ]* /; # $/&#60;files&#62; assigned an array,
                                     # each element of which is a
                                     # Match object containing
                                     # the substring matched by Nth
                                     # repetition of the non-
                                     # capturing bracket match</pre>
</li>

<li>If an array alias is applied to a quantified pair of capturing parens (i.e. to a subpattern), then the corresponding hash or array element is assigned a list constructed by concatenating the array values of each <code>Match</code> object returned by one repetition of the subpattern. That is, an array alias on a subpattern flattens and collects all nested subpattern captures within the aliased subpattern. For example:
<pre>     if ms/ $&#60;pairs&#62;:=( (\w+) \: (\N+) )+ / {
         # Scalar alias, so $/&#60;pairs&#62; is assigned an array
         # of Match objects, each of which has its own array
         # of two subcaptures...

         for @($&#60;pairs&#62;) -&#62; $pair {
             say &#34;Key: $pair[0]&#34;;
             say &#34;Val: $pair[1]&#34;;
         }
     }


     if ms/ @&#60;pairs&#62;:=( (\w+) \: (\N+) )+ / {
         # Array alias, so $/&#60;pairs&#62; is assigned an array
         # of Match objects, each of which is flattened out of
         # the two subcaptures within the subpattern

         for @($&#60;pairs&#62;) -&#62; $key, $val {
             say &#34;Key: $key&#34;;
             say &#34;Val: $val&#34;;
         }
     }</pre>
</li>

<li>Likewise, if an array alias is applied to a quantified subrule, then the hash or array element corresponding to the alias is assigned a list containing the array values of each <code>Match</code> object returned by each repetition of the subrule, all flattened into a single array:
<pre>     rule pair { (\w+) \: (\N+) \n }

     if ms/ $&#60;pairs&#62;:=&#60;pair&#62;+ / {
         # Scalar alias, so $/&#60;pairs&#62; contains an array of
         # Match objects, each of which is the result of the
         # &#60;pair&#62; subrule call...

         for @($&#60;pairs&#62;) -&#62; $pair {
             say &#34;Key: $pair[0]&#34;;
             say &#34;Val: $pair[1]&#34;;
         }
     }


     if ms/ mv @&#60;pairs&#62;:=&#60;pair&#62;+ / {
         # Array alias, so $/&#60;pairs&#62; contains an array of
         # Match objects, all flattened down from the
         # nested arrays inside the Match objects returned
         # by each match of the &#60;pair&#62; subrule...

         for @($&#60;pairs&#62;) -&#62; $key, $val {
             say &#34;Key: $key&#34;;
             say &#34;Val: $val&#34;;
         }
     }</pre>
</li>

<li>In other words, an array alias is useful to flatten into a single array any nested captures that might occur within a quantified subpattern or subrule. Whereas a scalar alias is useful to preserve within a top-level array the internal structure of each repetition.</li>

<li>It is also possible to use a numbered variable as an array alias. The semantics are exactly as described above, with the sole difference being that the resulting array of <code>Match</code> objects is assigned into the appropriate element of the regex&#39;s match array rather than to a key of its match hash. For example:
<pre>     if m/ mv  \s+  @0:=((\w+) \s+)+  $1:=((\W+) (\s*))* / {
         #          |                 |
         #          |                 |
         #          |                  \_ Scalar alias, so $1 gets an
         #          |                     array, with each element
         #          |                     a Match object containing
         #          |                     the two nested captures
         #          |
         #           \___ Array alias, so $0 gets a flattened array of
         #                just the (\w+) captures from each repetition

         @from     = @($0);      # Flattened list

         $to_str   = $1[0][0];   # Nested elems of
         $to_gap   = $1[0][1];   #    unflattened list
     }</pre>
</li>

<li>Note again that, outside a regex, <code>@0</code> is simply a shorthand for <code>@($0)</code>, so the first assignment above could also have been written:
<pre>     @from = @0;</pre>
</li>
</ul>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Hash_aliasing"
>Hash aliasing</a></h3>

<ul>
<li>An alias can also be specified using a hash as the alias variable, instead of a scalar or an array. For example:
<pre>     m/ mv %&#60;location&#62;:=( (&#60;ident&#62;) \: (\N+) )+ /;</pre>
</li>

<li>A hash alias causes the corresponding hash or array element in the current scope&#39;s <code>Match</code> object to be assigned a (nested) Hash object (rather than an <code>Array</code> object or a single <code>Match</code> object).</li>

<li>If a hash alias is applied to a subrule or subpattern then the first nested numeric capture becomes the key of each hash entry and any remaining numeric captures become the values (in an array if there is more than one).</li>

<li>As with array aliases it is also possible to use a numbered variable as a hash alias. Once again, the only difference is where the resulting <code>Match</code> object is stored:
<pre>     rule one_to_many {  (\w+) \: (\S+) (\S+) (\S+) }

     if ms/ %0:=&#60;one_to_many&#62;+ / {
         # $/[0] contains a hash, in which each key is provided by
         # the first subcapture within C&#60;one_to_many&#62;, and each
         # value is an array containing the
         # subrule&#39;s second, third, fourth, etc. subcaptures...

         for %($/[0]) -&#62; $pair {
             say &#34;One:  $pair.key()&#34;;
             say &#34;Many: { @($pair.value) }&#34;;
         }
     }</pre>
</li>

<li>Outside the regex, <code>%0</code> is a shortcut for <code>%($0)</code>:
<pre>         for %0 -&#62; $pair {
             say &#34;One:  $pair.key()&#34;;
             say &#34;Many: @($pair.value)&#34;;
         }</pre>
</li>
</ul>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="External_aliasing"
>External aliasing</a></h3>

<ul>
<li>Instead of using internal aliases like:
<pre>     m/ mv  @&#60;files&#62;:=&#60;ident&#62;+  $&#60;dir&#62;:=&#60;ident&#62; /</pre>

<p>the name of an ordinary variable can be used as an <i>external</i> alias, like so:</p>

<pre>     m/ mv  @files:=&#60;ident&#62;+  $dir:=&#60;ident&#62; /</pre>
</li>

<li>In this case, the behavior of each alias is exactly as described in the previous sections, except that any resulting capture is bound directly (but still hypothetically) to the variable of the specified name that must already exist in the scope in which the regex is declared.</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Capturing_from_repeated_matches"
>Capturing from repeated matches</a></h2>

<ul>
<li>When an entire regex is successfully matched with repetitions (specified via the <code>:x</code> or <code>:g</code> flag) or overlaps (specified via the <code>:ov</code> or <code>:ex</code> flag), it will usually produce a series of distinct matches.</li>

<li>A successful match under any of these flags still returns a single <code>Match</code> object in <code>$/</code>. However, this object may represent a partial evaluation of the regex. Moreover, the values of this match object are slightly different from those provided by a non-repeated match:
<ul>
<li>The boolean value of <code>$/</code> after such matches is true or false, depending on whether the pattern matched.</li>

<li>The string value is the substring from the start of the first match to the end of the last match (<i>including</i> any intervening parts of the string that the regex skipped over in order to find later matches).</li>

<li>Subcaptures are returned as a multidimensional list, which the user can choose to process in either of two ways. If you refer to <code>@()</code>, the multidimensionality is ignored and all the matches are returned flattened (but still lazily). If you refer to @@(), you can get each individual sublist as a Capture object. (That is, there is a <code>@@()</code> coercion operator that happens, like <code>@()</code>, to default to <code>$/</code>.) As with any multidimensional list, each sublist can be lazy separately.</li>
</ul>

<p>For example:</p>

<pre>     if $text ~~ ms:g/ (\S+:) &#60;rocks&#62; / {
         say &#39;Full match context is: [$/]&#39;;
     }</pre>

<p>But the list of individual match objects corresponding to each separate match is also available:</p>

<pre>     if $text ~~ ms:g/ (\S+:) &#60;rocks&#62; / {
         say &#34;Matched { +@@() } times&#34;;    # Note: forced eager here

         for @@() -&#62; $m {
             say &#34;Match between $m.from() and $m.to()&#34;;
             say &#39;Right on, dude!&#39; if $m[0] eq &#39;Perl&#39;;
             say &#34;Rocks like $m&#60;rocks&#62;&#34;;
         }
     }</pre>
</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name=":keepall"
><code>:keepall</code></a></h2>

<ul>
<li>All regexes remember everything if <code>:keepall</code> is in effect anywhere in the outer dynamic scope. In this case everything inside the angles is used as part of the key. Suppose the earlier example parsed whitespace:
<pre>     / &#60;key&#62; &#60;?ws&#62; &#60;&#39;=&#62;&#39;&#62; &#60;?ws&#62; &#60;value&#62; { %hash{$&#60;key&#62;} = $&#60;value&#62; } /</pre>

<p>The two instances of <code>&#60;?ws&#62;</code> above would store an array of two values accessible as <code>@&#60;?ws&#62;</code>. It would also store the literal match into <code>$&#60;&#39;=\&#62;&#39;&#62;</code>. Just to make sure nothing is forgotten, under <code>:keepall</code> any text or whitespace not otherwise remembered is attached as an extra property on the subsequent node. (The name of that property is &#34;<code>pretext</code>&#34;.)</p>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Grammars"
>Grammars</a></h1>

<ul>
<li>Your private <code>ident</code> rule shouldn&#39;t clobber someone else&#39;s <code>ident</code> rule. So some mechanism is needed to confine rules to a namespace.</li>

<li>If subs are the model for rules, then modules/classes are the obvious model for aggregating them. Such collections of rules are generally known as <i>grammars</i>.</li>

<li>Just as a class can collect named actions together:
<pre>     class Identity {
         method name { &#34;Name = $.name&#34; }
         method age  { &#34;Age  = $.age&#34;  }
         method addr { &#34;Addr = $.addr&#34; }

         method desc {
             print &#38;.name(), &#34;\n&#34;,
                   &#38;.age(),  &#34;\n&#34;,
                   &#38;.addr(), &#34;\n&#34;;
         }

         # etc.
     }</pre>

<p>so too a grammar can collect a set of named rules together:</p>

<pre>     grammar Identity {
         rule name { Name = (\N+) }
         rule age  { Age  = (\d+) }
         rule addr { Addr = (\N+) }
         rule desc {
             &#60;name&#62; \n
             &#60;age&#62;  \n
             &#60;addr&#62; \n
         }

         # etc.
     }</pre>
</li>

<li>Like classes, grammars can inherit:
<pre>     grammar Letter {
         rule text     { &#60;greet&#62; &#60;body&#62; &#60;close&#62; }

         rule greet { [Hi|Hey|Yo] $&#60;to&#62;:=(\S+?) , $$}

         rule body     { &#60;line&#62;+? }   # note: backtracks forwards via +?

         rule close { Later dude, $&#60;from&#62;:=(.+) }

         # etc.
     }

     grammar FormalLetter is Letter {

         rule greet { Dear $&#60;to&#62;:=(\S+?) , $$}

         rule close { Yours sincerely, $&#60;from&#62;:=(.+) }

     }</pre>
</li>

<li>Just like the methods of a class, the rule definitions of a grammar are inherited (and polymorphic!). So there&#39;s no need to respecify <code>body</code>, <code>line</code>, etc.</li>

<li>Perl 6 will come with at least one grammar predefined:
<pre>     grammar Perl {    # Perl&#39;s own grammar

         rule prog { &#60;statement&#62;* }

         rule statement {
                   | &#60;decl&#62;
                   | &#60;loop&#62;
                   | &#60;label&#62; [&#60;cond&#62;|&#60;sideff&#62;|;]
         }

         rule decl { &#60;sub&#62; | &#60;class&#62; | &#60;use&#62; }

         # etc. etc. etc.
     }</pre>
</li>

<li>Hence:
<pre>     given $source_code {
         $parsetree = m:keepall/&#60;Perl.prog&#62;/;
     }</pre>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Syntactic_categories"
>Syntactic categories</a></h1>

<p>For writing your own backslash and assertion subrules or macros, you may use the following syntactic categories:</p>

<pre>     token rule_backslash:&#60;w&#62; { ... }     # define your own \w and \W
     token rule_assertion:&#60;*&#62; { ... }     # define your own &#60;*stuff&#62;
     macro rule_metachar:&#60;,&#62; { ... }     # define a new metacharacter
     macro rule_mod_internal:&#60;x&#62; { ... } # define your own /:x() stuff/
     macro rule_mod_external:&#60;x&#62; { ... } # define your own m:x()/stuff/</pre>

<p>As with any such syntactic shenanigans, the declaration must be visible in the lexical scope to have any effect. It&#39;s possible the internal/external distinction is just a trait, and that some of those things are subs or methods rather than subrules or macros. (The numeric regex modifiers are recognized by fallback macros defined with an empty operator name.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Pragmas"
>Pragmas</a></h1>

<p>Various pragmas may be used to control various aspects of regex compilation and usage not otherwise provided for. These are tied to the particular declarator in question:</p>

<pre>    use s :foo;         # control s defaults
    use m :foo;         # control m defaults
    use rx :foo;        # control rx defaults
    use regex :foo;     # control regex defaults
    use token :foo;     # control token defaults
    use rule :foo;      # control rule defaults</pre>

<p>(It is a general policy in Perl 6 that any pragma designed to influence the surface behavior of a keyword is identical to the keyword itself, unless there is good reason to do otherwise. On the other hand, pragmas designed to influence deep semantics should not be named identically, though of course some similarity is good.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Transliteration"
>Transliteration</a></h1>

<a name="msg_2"></a>
<a href="?hide_quotes=no#msg_2" onclick="return tog_quote(2);">
<div ID="header_shown_2" style="display: none;">
- Hide the snippet from t/builtins/strings/trans.t (line 8 ~ line 67) -
</div>
<div ID="header_hidden_2" style="display: block;">
- Show the snippet from t/builtins/strings/trans.t (line 8 ~ line 67, 60 lines) -
</div>
</a>
<div ID="hide_2" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S05/Transliteration&gt;
=cut


plan 13;

is("ABC".trans( ('A'=&gt;'a'), ('B'=&gt;'b'), ('C'=&gt;'c') ),"abc",
        "Each side can be individual characters");

is("XYZ".trans( ('XYZ' =&gt; 'xyz') ),"xyz",
           "The two sides of the any pair can be strings interpreted as tr/// would multichar");


is("ABC".trans( ('A-C' =&gt; 'a-c') ),"abc",
           "The two sides of the any pair can be strings interpreted as tr/// would range");

is("ABC-DEF".trans(("-AB-Z" =&gt; "_a-z")),"abc_def",
           "If the first character is a dash it isn't part of a range");

is("ABC-DEF".trans(("A-YZ-" =&gt; "a-z_")),"abc_def",
           "If the last character is a dash it isn't part of a range");


#skip 2, "loops forever with Pugs 6.2.10";
is("ABCDEF".trans( ('AB-E' =&gt; 'ab-e') ), "abcdeF",
                  "The two sides can consists of both chars and ranges");
is("ABCDEFGH".trans( ('A-CE-G' =&gt; 'a-ce-g') ),"abcDefgH",
                  "The two sides can consist of multiple ranges");

# These will need the way the hashses deal with pairs.

# This works by accedent.
is("ABCXYZ".trans( (['A'..'C'] =&gt; ['a'..'c']), (&lt;X Y Z&gt; =&gt; &lt;x y z&gt;) ),"abcxyz",
           "The two sides of each pair may also be array references" );

# We're probally unable to "fix" these two as long as the left hand of =&gt; gets stringified
is("abcde".trans( ('a-e' =&gt; ['A' .. 'E']) ), "ABCDE",
	   "Using string range on one side and array reference on the other");


is("ABCDE".trans( (['A' .. 'E'] =&gt; "a-e") ), "abcde",
	   "Using array reference on one side and string range on the other");


is(" &lt;&gt;&amp;".trans( (['&lt;',    '&gt;',    '&amp;',    ] =&gt; 
                  ['&amp;lt;', '&amp;gt;', '&amp;amp;' ]))," &amp;lt;&amp;gt;&amp;amp;",
         "The array version can map one characters to one-or-more characters except spaces");

is(" &lt;&gt;&amp;".trans( ([' ',      '&lt;',    '&gt;',    '&amp;'    ] =&gt; 
                  ['&amp;nbsp;', '&amp;lt;', '&amp;gt;', '&amp;amp;' ])),"&amp;nbsp;&amp;lt;&amp;gt;&amp;amp;",
         "The array version can map one-or-more characters to one-or-more characters");

eval_is('"abc".trans(&lt;== "a" =&gt; "A")', "Abc",
    "you're allowed to leave off the (...) named arg parens when you use &lt;==",
    :todo&lt;feature&gt;);

# XXX should this work?
#eval_is('"abc".trans &lt;== "a" =&gt; "A"', "Abc",
#   "you're allowed to leave off the (...) named arg parens when you use &lt;==",
#   :todo&lt;feature&gt;);</pre>
</div>


<ul>
<li>The <code>tr///</code> quote-like operator now also has a method form called <code>trans()</code>. Its argument is a list of pairs. You can use anything that produces a pair list:
<pre>     $str.trans( %mapping.pairs.sort );</pre>

<p>Use the <code>.=</code> form to do a translation in place:</p>

<pre>     $str.=trans( %mapping.pairs.sort );</pre>
</li>

<li>The two sides of any pair can be strings interpreted as <code>tr///</code> would:
<pre>     $str.=trans( &#39;A..C&#39; =&#62; &#39;a..c&#39;, &#39;XYZ&#39; =&#62; &#39;xyz&#39; );</pre>

<p>As a degenerate case, each side can be individual characters:</p>

<pre>     $str.=trans( &#39;A&#39;=&#62;&#39;a&#39;, &#39;B&#39;=&#62;&#39;b&#39;, &#39;C&#39;=&#62;&#39;c&#39; );</pre>
</li>

<li>The two sides of each pair may also be Array objects:
<pre>     $str.=trans( [&#39;A&#39;..&#39;C&#39;] =&#62; [&#39;a&#39;..&#39;c&#39;], &#60;X Y Z&#62; =&#62; &#60;x y z&#62; );</pre>
</li>

<li>The array version can map one-or-more characters to one-or-more characters:
<pre>     $str.=trans( [&#39; &#39;,      &#39;&#60;&#39;,    &#39;&#62;&#39;,    &#39;&#38;&#39;    ] =&#62;
                  [&#39;&#38;nbsp;&#39;, &#39;&#38;lt;&#39;, &#39;&#38;gt;&#39;, &#39;&#38;amp;&#39; ]);</pre>

<p>In the case that more than one sequence of input characters matches, the longest one wins. In the case of two identical sequences the first in order wins.</p>

<p>There are also method forms of <code>m//</code> and <code>s///</code>:</p>

<pre>     $str.match(//);
     $str.subst(//, &#34;replacement&#34;);
     $str.subst(//, {&#34;replacement&#34;});
     $str.=subst(//, &#34;replacement&#34;);
     $str.=subst(//, {&#34;replacement&#34;});</pre>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Positional_matching,_fixed_width_types"
>Positional matching, fixed width types</a></h1>

<ul>
<li>To anchor to a particular position in the general case you can use the <code>&#60;at($pos)&#62;</code> assertion to say that the current position is the same as the position object you supply. You may set the current match position via the <code>:c</code> and <code>:p</code> modifiers.
<p>However, please remember that in Perl 6 string positions are generally <i>not</i> integers, but objects that point to a particular place in the string regardless of whether you count by bytes or codepoints or graphemes. If used with an integer, the <code>at</code> assertion will assume you mean the current lexically scoped Unicode level, on the assumption that this integer was somehow generated in this same lexical scope. If this is outside the current string&#39;s allowed Unicode abstraction levels, an exception is thrown. See S02 for more discussion of string positions.</p>
</li>

<li><code>Buf</code> types are based on fixed-width cells and can therefore handle integer positions just fine, and treat them as array indices. In particular, <code>buf8</code> (also known as <code>buf</code>) is just an old-school byte string. Matches against <code>Buf</code> types are restricted to ASCII semantics in the absence of an <i>explicit</i> modifi