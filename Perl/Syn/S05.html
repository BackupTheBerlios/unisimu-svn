<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<meta HTTP-EQUIV="content-type" CONTENT="text/html; charset=UTF-8">
<head>
<title>S05</title>
<link rel="stylesheet" href="http://dev.perl.org/css/perl.css" type="text/css" />
<link rev="made" href="mailto:" />
<script language="javascript1.2"><!--
var agt = navigator.userAgent.toLowerCase();

var is_opera = (agt.indexOf("opera") != -1);
var is_ie = (agt.indexOf("msie") != -1) && document.all && !is_opera;
var is_ie5 = (agt.indexOf("msie 5") != -1) && document.all;

function tog() {
  // tog: toggle the visibility of html elements (arguments[1..]) from none to
  // arguments[0].  Return what should be returned in a javascript onevent().
  display = arguments[0];
  for( var i=1; i<arguments.length; i++ ) {    
    var x = document.getElementById(arguments[i]);
    if (!x) continue;
    if (x.style.display == "none" || x.style.display == "") {
      x.style.display = display;
    } else {
      x.style.display = "none";
    }
  } 

  var e = is_ie ? window.event : this;
  if (e) {
    if (is_ie) {
      e.cancelBubble = true;
      e.returnValue = false;
      return false;
    } else {
      return false;
    }
  }
}

function tog_quote( idnum ) {
  return tog( 'block', 'header_shown_' + idnum, 'header_hidden_' + idnum,
	   'hide_' + idnum );
}

//--></script>
</head>

<body>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" valign="middle">
<big><strong><span class="block">&nbsp;TITLE</span></strong></big>
</td></tr>
</table>

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#TITLE">TITLE</a></li>
	<li><a href="#AUTHORS">AUTHORS</a></li>
	<li><a href="#VERSION">VERSION</a></li>
	<li><a href="#New20match20result20and20capture20variables">New match result and capture variables</a></li>
	<li><a href="#Unchanged20syntactic20features">Unchanged syntactic features</a></li>
	<li><a href="#Modifiers">Modifiers</a></li>
	<li><a href="#Changed20metacharacters">Changed metacharacters</a></li>
	<li><a href="#New20metacharacters">New metacharacters</a></li>
	<li><a href="#Bracket20rationalization">Bracket rationalization</a></li>
	<li><a href="#Variable2028non2d29interpolation">Variable (non-)interpolation</a></li>
	<li><a href="#Extensible20metasyntax20283c2e2e2e3e29">Extensible metasyntax (<code>&lt;...&gt;</code>)</a></li>
	<li><a href="#Backslash20reform">Backslash reform</a></li>
	<li><a href="#Regexes20really20are20regexes20now">Regexes really are regexes now</a></li>
	<li><a href="#Backtracking20control">Backtracking control</a></li>
	<li><a href="#Named20Regexes">Named Regexes</a></li>
	<li><a href="#Nothing20is20illegal">Nothing is illegal</a></li>
	<li><a href="#Return20values20from20matches">Return values from matches</a></li>
	<ul>

		<li><a href="#Match20objects">Match objects</a></li>
		<li><a href="#Subpattern20captures">Subpattern captures</a></li>
		<li><a href="#Accessing20captured20subpatterns">Accessing captured subpatterns</a></li>
		<li><a href="#Nested20subpattern20captures">Nested subpattern captures</a></li>
		<li><a href="#Quantified20subpattern20captures">Quantified subpattern captures</a></li>
		<li><a href="#Indirectly20quantified20subpattern20captures">Indirectly quantified subpattern captures</a></li>
		<li><a href="#Subpattern20numbering">Subpattern numbering</a></li>
		<li><a href="#Subrule20captures">Subrule captures</a></li>
		<li><a href="#Accessing20captured20subrules">Accessing captured subrules</a></li>
		<li><a href="#Repeated20captures20of20the20same20subrule">Repeated captures of the same subrule</a></li>
		<li><a href="#Aliasing">Aliasing</a></li>
		<ul>

			<li><a href="#Named20scalar20aliasing20to20subpatterns">Named scalar aliasing to subpatterns</a></li>
			<li><a href="#Named20scalar20aliases20applied20to20non2dcapturing20brackets">Named scalar aliases applied to non-capturing brackets</a></li>
			<li><a href="#Named20scalar20aliasing20to20subrules">Named scalar aliasing to subrules</a></li>
			<li><a href="#Numbered20scalar20aliasing">Numbered scalar aliasing</a></li>
			<li><a href="#Scalar20aliases20applied20to20quantified20constructs">Scalar aliases applied to quantified constructs</a></li>
			<li><a href="#Array20aliasing">Array aliasing</a></li>
			<li><a href="#Hash20aliasing">Hash aliasing</a></li>
			<li><a href="#External20aliasing">External aliasing</a></li>
		</ul>

		<li><a href="#Capturing20from20repeated20matches">Capturing from repeated matches</a></li>
		<li><a href="#3akeepall"><code>:keepall</code></a></li>
	</ul>

	<li><a href="#Grammars">Grammars</a></li>
	<li><a href="#Syntactic20categories">Syntactic categories</a></li>
	<li><a href="#Pragmas">Pragmas</a></li>
	<li><a href="#Transliteration">Transliteration</a></li>
	<li><a href="#Positional20matching2c20fixed20width20types">Positional matching, fixed width types</a></li>
	<li><a href="#Matching20against20non2dstrings">Matching against non-strings</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="TITLE">TITLE</a></h1>
<p>Synopsis 5: Regexes and Rules</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="AUTHORS">AUTHORS</a></h1>
<p>Damian Conway &lt;<a href="mailto:damian@conway.org">damian@conway.org</a>&gt; and
Allison Randal &lt;<a href="mailto:al@shadowed.net">al@shadowed.net</a>&gt;</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="VERSION">VERSION</a></h1>
<pre>
   Maintainer: Patrick Michaud &lt;pmichaud@pobox.com&gt; and
               Larry Wall &lt;larry@wall.org&gt;
   Date: 24 Jun 2002
   Last Modified: 16 Aug 2006
   Number: 5
   Version: 32</pre>
<p>This document summarizes Apocalypse 5, which is about the new regex
syntax.  We now try to call them <em>regex</em> rather than ``regular
expressions'' because they haven't been regular expressions for a
long time, and we think the popular term ``regex'' is in the process of
becoming a technical term with a precise meaning of: ``something you do
pattern matching with, kinda like a regular expression''.</p>
<p>In any case, when referring to recursive patterns within a grammar,
the terms <em>rule</em> and <em>token</em> are generally preferred.</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="New20match20result20and20capture20variables">New match result and capture variables</a></h1>
<p>The underlying match result object is now available as the <code>$/</code>
variable, which is implicitly lexically scoped.  All access to the
current (or most recent) match is through this variable, even when
it doesn't look like it.  The individual capture variables (such as <code>$0</code>,
<code>$1</code>, etc.) are just elements of <code>$/</code>.</p>
<p>By the way, unlike in Perl 5, the numbered capture variables now
start at <code>$0</code> instead of <code>$1</code>.  See below.</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Unchanged20syntactic20features">Unchanged syntactic features</a></h1>
<p>The following regex features use the same syntax as in Perl 5:</p>
<ul>
<li></li>
Capturing: (...)
<p></p>
<li></li>
Repetition quantifiers: *, +, and ?
<p></p>
<li></li>
Alternatives:  |
<p></p>
<li></li>
Backslash escape:  \
<p></p>
<li></li>
Minimal matching suffix:   ??,  *?,  +?
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Modifiers">Modifiers</a></h1>
<ul>
<li></li>
The extended syntax (<code>/x</code>) is no longer required...it's the default.
(In fact, it's pretty much mandatory--the only way to get back to
the old syntax is with the <code>:Perl5</code>/<code>:P5</code> modifier.)
<p></p>
<li></li>
There are no <code>/s</code> or <code>/m</code> modifiers (changes to the meta-characters
replace them - see below).
<p></p>
<li></li>
There is no <code>/e</code> evaluation modifier on substitutions; instead use:
<pre>
     s/pattern/{ doit() }/</pre>
<p>Instead of <code>/ee</code> say:</p>
<pre>
     s/pattern/{ eval doit() }/</pre>
<p></p>
<li></li>
Modifiers are now placed as adverbs at the <em>start</em> of a match/substitution:
<pre>
     m:g:i/\s* (\w*) \s* ,?/;</pre>
<p>Every modifier must start with its own colon.  The delimiter must be
separated from the final modifier by whitespace if it would otherwise be taken
as an argument to the preceding modifier (which is true for any
bracketing character).</p>
<p></p>
<li></li>
The single-character modifiers also have longer versions:
<pre>
         :i        :ignorecase
         :g        :global</pre>
<p></p>
<li></li>
The <code>:c</code> (or <code>:continue</code>) modifier causes the pattern to continue
scanning from the string's current <code>.pos</code>:
<pre>
     m:c/ pattern /        # start at end of
                           # previous match on $_</pre>
<p>Note that this does not automatically anchor the pattern to the starting
location.  (Use <code>:p</code> for that.)  The pattern you supply to <code>split</code>
has an implicit <code>:c</code> modifier.</p>
<p>The <code>:continue</code> modifier takes an optional argument of type <code>StrPos</code>
which specifies the point at which to start scanning for a match.
This should not be used unless you know what you're doing, or just
happen to like hard-to-debug infinite loops.</p>
<p></p>
<li></li>
The <code>:p</code> (or <code>:pos</code>) modifier causes the pattern to try to match only at
the string's current <code>.pos</code>:
<pre>
     m:p/ pattern /        # match at end of
                           # previous match on $_</pre>
<p>Since this is implicitly anchored to the position, it's suitable for
building parsers and lexers.  The pattern you supply to a Perl macro's
<code>is parsed</code> trait has an implicit <code>:p</code> modifier.</p>
<p>Note that</p>
<pre>
     m:c/pattern/</pre>
<p>is roughly equivalent to</p>
<pre>
     m:p/.*? &lt;( pattern )&gt; /</pre>
<p>Also note that any regex called as a subrule is implicitly anchored to the
current position anyway.</p>
<p>The <code>:pos</code> modifier takes an optional argument of type <code>StrPos</code>
which specifies the point at which to attempt a match.  This should not
be used lightly.  Put it in the category of a ``goto''.</p>
<p></p>
<li></li>
The new <code>:s</code> (<code>:sigspace</code>) modifier causes whitespace sequences
to be considered ``significant''; they are replaced by a whitespace
matching rule, <code>&lt;?ws&gt;</code>.  That is,
<pre>
     m:s/ next cmd =   &lt;condition&gt;/</pre>
<p>is the same as:</p>
<pre>
     m/ &lt;?ws&gt; next &lt;?ws&gt; cmd &lt;?ws&gt; = &lt;?ws&gt; &lt;condition&gt;/</pre>
<p>which is effectively the same as:</p>
<pre>
     m/ \s* next \s+ cmd \s* = \s* &lt;condition&gt;/</pre>
<p>But in the case of</p>
<pre>
     m:s {(a|\*) (b|\+)}</pre>
<p>or equivalently,</p>
<pre>
     m { (a|\*) &lt;?ws&gt; (b|\+) }</pre>
<p><code>&lt;?ws&gt;</code> can't decide what to do until it sees the data.
It still does the right thing.  If not, define your own <code>&lt;?ws&gt;</code>
and <code>:sigspace</code> will use that.</p>
<p>In general you don't need to use <code>:sigspace</code> within grammars because
the parser rules automatically handle whitespace policy for you.
In this context, whitespace often includes comments, depending on
how the grammar chooses to define its whitespace rule.  Although the
default <code>&lt;?ws&gt;</code> subrule recognizes no comment construct, any
grammar is free to override the rule.  The <code>&lt;?ws&gt;</code> rule is not
intended to mean the same thing everywhere.</p>
<p>It's also possible to pass an argument to <code>:sigspace</code> specifying
a completely different subrule to apply.  This can be any rule, it
doesn't have to match whitespace.  When discussing this modifier, it is
important to distinguish the significant whitespace in the pattern from
the ``whitespace'' being matched, so we'll call the pattern's whitespace
<em>sigspace</em>, and generally reserve <em>whitespace</em> to indicate whatever
<code>&lt;?ws&gt;</code> matches in the current grammar. The correspondence
between sigspace and whitespace is primarily metaphorical, which is
why the correspondence is both useful and (potentially) confusing.</p>
<p>The <code>:s</code> modifier is considered sufficiently important that
match variants are defined for them:</p>
<pre>
    ms/match some words/                        # same as m:sigspace
    ss/match some words/replace those words/    # same as s:sigspace</pre>
<p>Conjecture: This might become sufficiently idiomatic that <code>ms//</code> would
be better as a ``stuttered'' <code>mm//</code> instead, much as <code>qq//</code> became idiomatic.
It would also match <code>ss///</code> that way.</p>
<p></p>
<li></li>
New modifiers specify Unicode level:
<pre>
     m:bytes / .**{2} /       # match two bytes
     m:codes / .**{2} /       # match two codepoints
     m:graphs/ .**{2} /       # match two graphemes
     m:langs / .**{2} /       # match two language dependent chars</pre>
<p>There are corresponding pragmas to default to these levels.</p>
<p></p>
<li></li>
The new <code>:Perl5</code> modifier allows Perl 5 regex syntax to be used instead:
<pre>
     m:Perl5/(?mi)^[a-z]{1,2}(?=\s)/</pre>
<p>(It does not go so far as to allow you to put your modifiers at
the end.)</p>
<p></p>
<li></li>
Any integer modifier specifies a count. What kind of count is
determined by the character that follows.
<p></p>
<li></li>
If followed by an <code>x</code>, it means repetition.  Use <code>:x(4)</code> for the
general form.  So
<pre>
     s:4x [ (&lt;?ident&gt;) = (\N+) $$] [$0 =&gt; $1];</pre>
<p>is the same as:</p>
<pre>
     s:x(4) [ (&lt;?ident&gt;) = (\N+) $$] [$0 =&gt; $1];</pre>
<p>which is almost the same as:</p>
<pre>
     $_.pos = 0;
     s:c [ (&lt;?ident&gt;) = (\N+) $$] [$0 =&gt; $1] for 1..4;</pre>
<p>except that the string is unchanged unless all four matches are found.
However, ranges are allowed, so you can say <code>:x(1..4)</code> to change anywhere
from one to four matches.</p>
<p></p>
<li></li>
If the number is followed by an <code>st</code>, <code>nd</code>, <code>rd</code>, or <code>th</code>, it means
find the <em>N</em>th occurrence.  Use <code>:nth(3)</code> for the general form.  So
<pre>
     s:3rd/(\d+)/@data[$0]/;</pre>
<p>is the same as</p>
<pre>
     s:nth(3)/(\d+)/@data[$0]/;</pre>
<p>which is the same as:</p>
<pre>
     m/(\d+)/ &amp;&amp; m:c/(\d+)/ &amp;&amp; s:c/(\d+)/@data[$0]/;</pre>
<p>Lists and junctions are allowed: <code>:nth(1|2|3|5|8|13|21|34|55|89)</code>.</p>
<p>So are closures: <code>:nth{.is_fibonacci}</code></p>
<p></p>
<li></li>
With the new <code>:ov</code> (<code>:overlap</code>) modifier, the current regex will
match at all possible character positions (including overlapping)
and return all matches in a list context, or a disjunction of matches
in a scalar context.  The first match at any position is returned.
<pre>
     $str = &quot;abracadabra&quot;;</pre>
<pre>
     if $str ~~ m:overlap/ a (.*) a / {
         @substrings = @@();    # bracadabr cadabr dabr br
     }</pre>
<p></p>
<li></li>
With the new <code>:ex</code> (<code>:exhaustive</code>) modifier, the current regex will match
every possible way (including overlapping) and return all matches in a list
context, or a disjunction of matches in a scalar context.
<pre>
     $str = &quot;abracadabra&quot;;</pre>
<pre>
     if $str ~~ m:exhaustive/ a (.*) a / {
         say &quot;@()&quot;;    # br brac bracad bracadabr c cad cadabr d dabr br
     }</pre>
<p>Note that the <code>~~</code> above can return as soon as the first match is found,
and the rest of the matches may be performed lazily by <code>@()</code>.</p>
<p>[Conjecture: the <code>:exhaustive</code> modifier should have an optional argument
specifying how many seconds to run before giving up, since it's trivially
easy to ask for the heat death of the universe to happen first.]</p>
<p></p>
<li></li>
The new <code>:rw</code> modifier causes this regex to <em>claim</em> the current
string for modification rather than assuming copy-on-write semantics.
All the bindings in <code>$/</code> become lvalues into the string, such
that if you modify, say, <code>$1</code>, the original string is modified in
that location, and the positions of all the other fields modified
accordingly (whatever that means).  In the absence of this modifier
(especially if it isn't implemented yet, or is never implemented),
all pieces of <code>$/</code> are considered copy-on-write, if not read-only.
<p></p>
<li></li>
The new <code>:keepall</code> modifier causes this regex and all invoked subrules
to remember everything, even if the rules themselves don't ask for
their subrules to be remembered.  This is for forcing a grammar that
throws away whitespace and comments to keep them instead.
<p></p>
<li></li>
The new <code>:ratchet</code> modifier causes this regex to not backtrack by default.
(Generally you do not use this modifier directly, since it's implied by
<code>token</code> and <code>rule</code> declarations.)  The effect of this modifier is
to imply a <code>:</code> after every construct that could backtrack, including
bare <code>*</code>, <code>+</code>, and <code>?</code> quantifiers, as well as alternations.
<p></p>
<li></li>
The new <code>:panic</code> modifier causes this regex and all invoked subrules
to try to backtrack on any rules that would otherwise default to
not backtracking because they have <code>:ratchet</code> set.  Never panic
unless you're desperate and want the pattern matcher to do a lot of
unnecessary work.  If you have an error in your grammar, it's almost
certainly a bad idea to fix it by backtracking.
<p></p>
<li></li>
The <code>:i</code>, <code>:s</code>, <code>:Perl5</code>, and Unicode-level modifiers can be
placed inside the regex (and are lexically scoped):
<pre>
     m/:s alignment = [:i left|right|cent[er|re]] /</pre>
<p></p>
<li></li>
User-defined modifiers will be possible:
<pre>
         m:fuzzy/pattern/;</pre>
<p></p>
<li></li>
User-defined modifiers can also take arguments:
<pre>
         m:fuzzy('bare')/pattern/;</pre>
<p></p>
<li></li>
To use parens or brackets for your delimiters you have to separate:
<pre>
         m:fuzzy (pattern);</pre>
<p>or you'll end up with:</p>
<pre>
         m:fuzzy(fuzzyargs); pattern ;</pre>
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Changed20metacharacters">Changed metacharacters</a></h1>
<ul>
<li></li>
A dot <code>.</code> now matches <em>any</em> character including newline. (The <code>/s</code>
modifier is gone.)
<p></p>
<li></li>
<code>^</code> and <code>$</code> now always match the start/end of a string, like the
old <code>\A</code> and <code>\z</code>. (The <code>/m</code> modifier is gone.)
<p></p>
<li></li>
A <code>$</code> no longer matches an optional preceding <code>\n</code> so it's necessary
to say <code>\n?$</code> if that's what you mean.
<p></p>
<li></li>
<code>\n</code> now matches a logical (platform independent) newline not just <code>\x0a</code>.
<p></p>
<li></li>
The <code>\A</code>, <code>\Z</code>, and <code>\z</code> metacharacters are gone.
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="New20metacharacters">New metacharacters</a></h1>
<ul>
<li></li>
Because <code>/x</code> is default:
<ul>
<li></li>
An unescaped <code>#</code> now always introduces a comment.  If followed
by an opening bracket character (and if not in the first column),
it introduces an embedded comment that terminates with the closing
bracket.  Otherwise the comment terminates at the newline.
<p></p>
<li></li>
Whitespace is now always metasyntactic, i.e. used only for layout
and not matched literally (but see the <code>:sigspace</code> modifier described above).
<p></p></ul>
<li></li>
<code>^^</code> and <code>$$</code> match line beginnings and endings. (The <code>/m</code>
modifier is gone.)  They are both zero-width assertions.  <code>$$</code>
matches before any <code>\n</code> (logical newline), and also at the end of
the string if the final character was <em>not</em> a <code>\n</code>.  <code>^^</code> always
matches the beginning of the string and after any <code>\n</code> that is not
the final character in the string.
<p></p>
<li></li>
<code>.</code> matches an <em>anything</em>, while <code>\N</code> matches an <em>anything except
newline</em>. (The <code>/s</code> modifier is gone.)  In particular, <code>\N</code> matches
neither carriage return nor line feed.
<p></p>
<li></li>
The new <code>&amp;</code> metacharacter separates conjunctive terms.  The patterns on
either side must match with the same beginning and end point.  The
operator is list associative like <code>|</code>, has higher precedence than <code>|</code>,
and backtracking makes the right argument vary faster than the left.
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Bracket20rationalization">Bracket rationalization</a></h1>
<ul>
<li></li>
<code>(...)</code> still delimits a capturing group. However the ordering of these
groups is hierarchical rather than linear. See <a href="#nested20subpattern20captures">Nested subpattern captures</a>.
<p></p>
<li></li>
<code>[...]</code> is no longer a character class.
It now delimits a non-capturing group.
<p></p>
<li></li>
<code>{...}</code> is no longer a repetition quantifier.
It now delimits an embedded closure.
<p></p>
<li></li>
You can call Perl code as part of a regex match by using a closure.
Embedded code does not usually affect the match--it is only used
for side-effects:
<pre>
     / (\S+) { print &quot;string not blank\n&quot;; $text = $0; }
        \s+  { print &quot;but does contain whitespace\n&quot; }
     /</pre>
<p></p>
<li></li>
It can affect the match if it calls <code>fail</code>:
<pre>
     / (\d+) { $0 &lt; 256 or fail } /</pre>
<p>Closures are guaranteed to be called at the canonical time even if
the optimizer could prove that something after them can't match.
(Anything before is fair game, however.)</p>
<p></p>
<li></li>
The repetition specifier is now <code>**{...}</code> for maximal matching,
with a corresponding <code>**{...}?</code> for minimal matching.  Space is
allowed on either side of the asterisks.  The curlies are taken to
be a closure returning an Int or a Range object.
<pre>
     / value was (\d ** {1..6}?) with ([\w]**{$m..$n}) /</pre>
<p>It is illegal to return a list, so this easy mistake fails:</p>
<pre>
     / [foo]**{1,3} /</pre>
<p>(At least, it fails in the absence of <code>use rx :listquantifier</code>,
which is likely to be unimplemented in Perl 6.0.0 anyway.)</p>
<p>The optimizer will likely optimize away things like <code>**{1..*}</code>
so that the closure is never actually run in that case.  But it's
a closure that must be run in the general case, so you can use
it to generate a range on the fly based on the earlier matching.
(Of course, bear in mind the closure must be run <em>before</em> attempting to
match whatever it quantifies.)</p>
<p></p>
<li></li>
<code>&lt;...&gt;</code> are now extensible metasyntax delimiters or <em>assertions</em>
(i.e. they replace Perl 5's crufty <code>(?...)</code> syntax).
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Variable2028non2d29interpolation">Variable (non-)interpolation</a></h1>
<ul>
<li></li>
In Perl 6 regexes, variables don't interpolate.
<p></p>
<li></li>
Instead they're passed <em>raw</em> to the regex engine, which can then decide
how to handle them (more on that below).
<p></p>
<li></li>
The default way in which the engine handles a scalar is to match it
as a <code>&lt;'...'&gt;</code> literal (i.e. it does not treat the interpolated string
as a subpattern).  In other words, a Perl 6:
<pre>
     / $var /</pre>
<p>is like a Perl 5:</p>
<pre>
     / \Q$var\E /</pre>
<p>However, if <code>$var</code> contains a <code>Regex</code> object, instead of attempting to
convert it to a string, it is called as a subrule, as if you said
<code>&lt;$var&gt;</code>.  (See assertions below.)  This form does not capture,
and it fails if <code>$var</code> is tainted.</p>
<p></p>
<li></li>
An interpolated array:
<pre>
     / @cmds /</pre>
<p>is matched as if it were an alternation of its elements:</p>
<pre>
     / [ @cmds[0] | @cmds[1] | @cmds[2] | ... ] /</pre>
<p>As with a scalar variable, each element is matched as a literal
unless it happens to be a <code>Regex</code> object, in which case it is matched
as a subrule.  As with scalar subrules, a tainted subrule always fails.
All string values pay attention to the current <code>:ignorecase</code> setting,
while <code>Regex</code> values use their own <code>:ignorecase</code> settings.</p>
<p></p>
<li></li>
An interpolated hash matches the longest possible key of the hash
as a literal, or fails if no key matches.  (A <code>&quot;&quot;</code> key
will match anywhere, provided no longer key matches.)
<ul>
<li></li>
If the corresponding value of the hash element is a closure, it
is executed.
<p></p>
<li></li>
If the value is a string, it is matched literally, starting after where
the key left off matching.  As a natural consequence, if the value is
<code>&quot;&quot;</code>, nothing special happens except that the key match succeeds.
<p></p>
<li></li>
If it is a <code>Regex</code> object, it is executed as a subrule, with an
initial position <em>after</em> the matched key.  (This is further described
below under the <code>&lt;%hash&gt;</code> notation.)  As with scalar subrules,
a tainted subrule always fails, and no capture is attempted.
<p></p>
<li></li>
If the value is a number, this entry represents a ``false match''.
The match position is set back to before the current false match, and the
key is rematched using the same hash, but this time ignoring any keys
longer than the number.  (This is measured in the default Unicode
level in effect where the hash was declared, usually graphemes. If
the current Unicode level is lower, the results are as if the string
to be matched had been upconverted to the hash's Unicode level.  If
the current Unicode level is higher, the results are undefined if the
string contains any characters whose interpretation would be changed
by the higher Unicode level, such as language-dependent ligatures.)
<p></p>
<li></li>
Any other value causes the match to fail.
<p></p></ul>
<p>All hash keys, and values that are strings, pay attention to the
<code>:ignorecase</code> setting.  (Subrules maintain their own case settings.)</p>
</ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Extensible20metasyntax20283c2e2e2e3e29">Extensible metasyntax (<code>&lt;...&gt;</code>)</a></h1>
<p>Both <code>&lt;</code> and <code>&gt;</code> are metacharacters, and are usually (but not
always) used in matched pairs.  (Some combinations of metacharacters
function as standalone tokens, and these may include angles.  These are
described below.)</p>
<p>For matched pairs, the first character after <code>&lt;</code> determines the
behavior of the assertion:</p>
<ul>
<li></li>
A leading alphabetic character means it's a capturing grammatical 
assertion (i.e. a subrule or a named character class - see below):
<pre>
     / &lt;sign&gt;? &lt;mantissa&gt; &lt;exponent&gt;? /</pre>
<p>The first character after the identifier determines the treatment of
the rest of the text before the closing angle.  The underlying semantics
is that of a function or method call, so if the first character is
a left parenthesis, it really is a call:</p>
<pre>
    &lt;foo('bar')&gt;</pre>
<p>If the first character is a colon, the rest of the text (following any
whitespace) is passed as a string, so the previous may also be written as:</p>
<pre>
    &lt;foo: bar&gt;</pre>
<p>If the first character is whitespace, the subsequent text is passed as regex,
so:</p>
<pre>
    &lt;foo bar&gt;</pre>
<p>is more or less equivalent to</p>
<pre>
    &lt;foo(/bar/)&gt;</pre>
<p>If the first character is a plus or minus, the initial identifier is taken
as a character class, so</p>
<pre>
    &lt;foo+bar-baz&gt;</pre>
<p>is equivalent to</p>
<pre>
    &lt;+foo+bar-baz&gt;</pre>
<p>(See below.)</p>
<p></p>
<li></li>
The special named assertions include:
<pre>
     / &lt;before pattern&gt; /    # was /(?=pattern)/
     / &lt;after pattern&gt; /     # was /(?&lt;=pattern)/</pre>
<pre>
     / &lt;sp&gt; /                # match the SPACE character (U+0020)
     / &lt;ws&gt; /                # match &quot;whitespace&quot;:
                             #   \s+ if it's between two \w characters,
                             #   \s* otherwise</pre>
<pre>
     / &lt;at($pos)&gt; /          # match only at a particular StrPos
                             # short for &lt;?{ .pos == $pos }&gt;</pre>
<p>The <code>after</code> assertion implements lookbehind by reversing the syntax
tree and looking for things in the opposite order going to the left.
It is illegal to do lookbehind on a pattern that cannot be reversed.</p>
<p>Note: the effect of a forward-scanning lookbehind at the top level
can be achieved with:</p>
<pre>
    / .*? prestuff &lt;( mainpat )&gt; /</pre>
<p></p>
<li></li>
A leading <code>?</code> causes the assertion not to capture what it matches (see
<a href="#subrule20captures">Subrule captures</a>. For example:
<pre>
     / &lt;ident&gt;  &lt;ws&gt;  /      # $/&lt;ident&gt; and $/&lt;ws&gt; both captured
     / &lt;?ident&gt; &lt;ws&gt;  /      # only $/&lt;ws&gt; captured
     / &lt;?ident&gt; &lt;?ws&gt; /      # nothing captured</pre>
<p>The non-capturing behavior may be overridden with a <code>:keepall</code>.</p>
<p></p>
<li></li>
A leading <code>$</code> indicates an indirect subrule.  The variable must contain
either a <code>Regex</code> object, or a string to be compiled as the regex.  The
string is never matched literally.
<p>By default <code>&lt;$foo&gt;</code> is captured into <code>$&lt;foo&gt;</code>, but you can
use the <code>&lt;?$foo&gt;</code> form to suppress capture, and you can always say
<code>$&lt;$foo&gt; := &lt;$foo&gt;</code> if you prefer to include the sigil in the key.</p>
<p></p>
<li></li>
A leading <code>::</code> indicates a symbolic indirect subrule:
<pre>
     / &lt;::($somename)&gt; /</pre>
<p>The variable must contain the name of a subrule.  By the rules of
single method dispatch this is first searched for in the current
grammar and its ancestors.  If this search fails an attempt is made
to dispatch via MMD, in which case it can find subrules defined as
multis rather than methods.  This form is not captured by default.</p>
<p></p>
<li></li>
A leading <code>@</code> matches like a bare array except that each element is
treated as a subrule (string or <code>Regex</code> object) rather than as a literal.
That is, a string is forced to be compiled as a subrule instead of being
matched literally.  (There is no difference for a <code>Regex</code> object.)
<p>By default <code>&lt;@foo&gt;</code> is captured into <code>$&lt;foo&gt;</code>, but you can
use the <code>&lt;?@foo&gt;</code> form to suppress capture, and you can always say
<code>$&lt;@foo&gt; := &lt;@foo&gt;</code> if you prefer to include the sigil in the key.</p>
<p></p>
<li></li>
A leading <code>%</code> matches like a bare hash except that a string value is
always treated as a subrule, even if it is a string that must be compiled
to a regex at match time.  (Numeric values may still indicate ``false match''.
and a closure may do whatever it likes.)
<p>By default <code>&lt;%foo&gt;</code> is captured into <code>$&lt;foo&gt;</code>, but you can
use the <code>&lt;?%foo&gt;</code> form to suppress capture, and you can always say
<code>$&lt;%foo&gt; := &lt;%foo&gt;</code> if you prefer to include the sigil in the key.</p>
<p>With both bare hash and hash in angles, the key is counted as ``matched''
immediately; that is, the current match position is set to <code>after</code> the key
token before calling any subrule in the value.  That subrule may, however,
magically access the key anyway as if the subrule had started before the
key and matched with <code>&lt;KEY&gt;</code> assertion.  That is, <code>$&lt;KEY&gt;</code>
will contain the keyword or token that this subrule was looked up under,
and that value will be returned by the current match object even if
you do nothing special with it within the match.  (This also works
for the name of a macro as seen from an <code>is parsed</code> regex, since
internally that turns into a hash lookup.)</p>
<p>As with bare hash, the longest key matches according to the venerable
<em>longest token rule</em>, but in addition, you may combine multiple hashes
under the same longest-token consideration like this:</p>
<pre>
    &lt;%statement|%prefix|%term&gt;</pre>
<p>This means that, despite being in a later hash, <code>%term&lt;food&gt;</code>
will be selected in preference to <code>%prefix&lt;foo&gt;</code> because it's
the longer token.  However, if there is a tie, the earlier hash wins,
so <code>%statement&lt;if&gt;</code> hides any <code>%prefix&lt;if&gt;</code> or <code>%term&lt;if&gt;</code>.</p>
<p>In contrast, if you say</p>
<pre>
    [ &lt;%prefix&gt; | &lt;%term&gt; ]</pre>
<p>a <code>%prefix&lt;foo&gt;</code> would be selected in preference to a <code>%term&lt;food&gt;</code>.
(Which is not what you usually want if your language is to do longest-token
consistently.)</p>
<p></p>
<li></li>
A leading <code>{</code> indicates code that produces a regex to be interpolated
into the pattern at that point as a subrule:
<pre>
     / (&lt;?ident&gt;)  &lt;{ %cache{$0} //= get_body($0) }&gt; /</pre>
<p>The closure is guaranteed to be run at the canonical time.</p>
<p>As with an ordinary embedded closure, an <strong>explicit</strong> return from a
regex closure binds the <em>result object</em> for this match, ignores the
rest of the current regex, and reports success:</p>
<pre>
        / (\d) &lt;{ return $0.sqrt }&gt; NotReached /;</pre>
<p>This has the effect of capturing the square root of the numified string,
instead of the string.  The <code>NotReached</code> part is not reached.</p>
<p>These closures are invoked as anonymous methods on the <code>Match</code> object.
See <a href="#match20objects">Match objects</a> below for more about result objects.</p>
<p></p>
<li></li>
A leading <code>&amp;</code> interpolates the return value of a subroutine call as
a regex.  Hence
<pre>
     &lt;&amp;foo()&gt;</pre>
<p>is short for</p>
<pre>
     &lt;{ foo() }&gt;</pre>
<p></p>
<li></li>
In any case of regex interpolation, if the value already happens to be
a <code>Regex</code> object, it is not recompiled.  If it is a string, the compiled
form is cached with the string so that it is not recompiled next
time you use it unless the string changes.  (Any external lexical
variable names must be rebound each time though.)  Subrules may not be
interpolated with unbalanced bracketing.  An interpolated subrule
keeps its own inner <code>$/</code>, so its parentheses never count toward the
outer regexes groupings.  (In other words, parenthesis numbering is always
lexically scoped.)
<p></p>
<li></li>
A leading <code>?{</code> or <code>!{</code> indicates a code assertion:
<pre>
     / (\d**{1..3}) &lt;?{ $0 &lt; 256 }&gt; /
     / (\d**{1..3}) &lt;!{ $0 &lt; 256 }&gt; /</pre>
<p>Similar to:</p>
<pre>
     / (\d**{1..3}) { $0 &lt; 256 or fail } /
     / (\d**{1..3}) { $0 &lt; 256 and fail } /</pre>
<p>Unlike closures, code assertions are not guaranteed to be run at the
canonical time if the optimizer can prove something later can't match.
So you can sneak in a call to a non-canonical closure that way:</p>
<pre>
     /^foo .* &lt;?{ do { say &quot;Got here!&quot; } or 1 }&gt; .* bar$/</pre>
<p>The <code>do</code> block is unlikely to run unless the string ends with ``<code>bar</code>''.</p>
<p></p>
<li></li>
A leading <code>[</code> or <code>+</code> indicates an enumerated character class.  Ranges
in enumerated character classes are indicated with <code>..</code>.
<pre>
     / &lt;[a..z_]&gt;* /
     / &lt;+[a..z_]&gt;* /</pre>
<p></p>
<li></li>
A leading <code>-</code> indicates a complemented character class:
<pre>
     / &lt;-[a..z_]&gt; &lt;-alpha&gt; /</pre>
<p>This is essentially the same as using negative lookahead and dot:</p>
<pre>
    / &lt;![a..z_]&gt; . &lt;!alpha&gt; . /</pre>
<p></p>
<li></li>
Character classes can be combined (additively or subtractively) within
a single set of angle brackets. For example:
<pre>
     / &lt;[a..z]-[aeiou]+xdigit&gt; /      # consonant or hex digit</pre>
<p>If such a combination starts with a named character class, a leading
<code>+</code> is allowed but not required, provided the next character is a
character set operation:</p>
<pre>
     / &lt;+alpha-[Jj]&gt; /              # J-less alpha
     / &lt;alpha-[Jj]&gt; /               # same thing</pre>
<p></p>
<li></li>
A leading <code>'</code> indicates a literal match (including whitespace):
<pre>
     / &lt;'match this exactly (whitespace matters)'&gt; /</pre>
<p></p>
<li></li>
A leading <code>&quot;</code> indicates a literal match after interpolation:
<pre>
     / &lt;&quot;match $THIS exactly (whitespace still matters)&quot;&gt; /</pre>
<p></p>
<li></li>
In general, any general quoting form such as <code>q</code> or <code>qq</code> will be
recognized as if it had curlies around it.  This includes quotes
declared with the <code>quote</code> declarator:
<pre>
    quote qX = q:x:c;
    /&lt;qX[cat -n {$foo}]&gt;/</pre>
<p>same as</p>
<pre>
    /&lt;{ qX[cat -n {$foo}] }&gt;/</pre>
<p>This hides any <code>qX</code> rule that might be defined in the grammar.  Note that
this means that the language parser has to pass the current list
of quote forms into the regex parser since it needs to be known at
compile time.</p>
<p></p>
<li></li>
The special assertion <code>&lt;.&gt;</code> matches any logical grapheme
(including a Unicode combining character sequences):
<pre>
     / seekto = &lt;.&gt; /  # Maybe a combined char</pre>
<p>Same as:</p>
<pre>
     / seekto = [:graphs .] /</pre>
<p></p>
<li></li>
A leading <code>!</code> indicates a negated meaning (always a zero-width assertion):
<pre>
     / &lt;!before _ &gt; /    # We aren't before an _</pre>
<p>Note that <code>&lt;!alpha&gt;</code> is different from <code>&lt;-alpha&gt;</code> because the
latter matches <code>/./</code> when it is not an alpha.</p>
<p></p></ul>
<p>The following tokens include angles but are not required to balance:</p>
<ul>
<li></li>
A <code>&lt;(</code> token indicates the start of a result capture, while the
corresponding <code>)&gt;</code> token indicates its endpoint.  When matched,
these behave as assertions that are always true, but have the side
effect of setting the <code>.from</code> and <code>.to</code> attributes of the match
object.  That is:
<pre>
    / foo &lt;( \d+ )&gt; bar /</pre>
<p>is equivalent to:</p>
<pre>
    / &lt;after foo&gt; \d+ &lt;before bar&gt; /</pre>
<p>except that the scan for ``<code>foo</code>'' can be done in the forward direction,
while a lookbehind assertion would presumably scan for <code>\d+</code> and then
match ``<code>foo</code>'' backwards.  The use of <code>&lt;(...)&gt;</code> affects only the
meaning of the <em>result object</em> and the positions of the beginning and
ending of the match.  That is, after the match above, <code>$()</code> contains
only the digits matched, and <code>.pos</code> is pointing to after the digits.
Other captures (named or numbered) are unaffected and may be accessed
through <code>$/</code>.</p>
<p></p>
<li></li>
A <code>«</code> or <code>&lt;&lt;</code> token indicates a left word boundary.  A <code>»</code> or
<code>&gt;&gt;</code> token indicates a right word boundary.  (As separate tokens,
these need not be balanced.)  Perl 5's <code>\b</code> is replaced by a <code>&lt;?wb&gt;</code>
``word boundary'' assertion, while <code>\B</code> becomes <code>&lt;!wb&gt;</code>.  (None of
these are dependent on the definition of <code>&lt;ws&gt;</code>, but only on the <code>\s</code>
definition of whitespace.)
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Backslash20reform">Backslash reform</a></h1>
<ul>
<li></li>
The <code>\p</code> and <code>\P</code> properties become intrinsic grammar rules such as
(<code>&lt;alpha&gt;</code> and <code>&lt;!alpha&gt;</code>).  They may be combined using the
above-mentioned character class notation: <code>&lt;[_]+alpha+digit&gt;</code>.
Regardless of the higher-level character class names, low-level
Unicode properties are always available with a prefix of <code>is</code>.
Hence, <code>&lt;+isLu+isLt&gt;</code> is equivalent to <code>&lt;+upper+title&gt;</code>.
If you define your own ``is'' properties they hide any Unicode properties
of the same name.
<p></p>
<li></li>
The <code>\L...\E</code>, <code>\U...\E</code>, and <code>\Q...\E</code> sequences are gone.  In the
rare cases that need them you can use <code>&lt;{ lc $regex }&gt;</code> etc.
<p></p>
<li></li>
The <code>\G</code> sequence is gone.  Use <code>:p</code> instead.  (Note, however,
that it makes no sense to use <code>:p</code> within a pattern, since every
internal pattern is implicitly anchored to the current position.)
See the <code>at</code> assertion below.
<p></p>
<li></li>
Backreferences (e.g. <code>\1</code>, <code>\2</code>, etc.) are gone; <code>$0</code>, <code>$1</code>, etc. can be
used instead, because variables are no longer interpolated.
<p></p>
<li></li>
New backslash sequences, <code>\h</code> and <code>\v</code>, match horizontal and vertical
whitespace respectively, including Unicode.
<p></p>
<li></li>
<code>\s</code> now matches any Unicode whitespace character.
<p></p>
<li></li>
The new backslash sequence <code>\N</code> matches anything except a logical
newline; it is the negation of <code>\n</code>.
<p></p>
<li></li>
A series of other new capital backslash sequences are also the negation
of their lower-case counterparts:
<ul>
<li></li>
<code>\H</code> matches anything but horizontal whitespace.
<p></p>
<li></li>
<code>\V</code> matches anything but vertical whitespace.
<p></p>
<li></li>
<code>\T</code> matches anything but a tab.
<p></p>
<li></li>
<code>\R</code> matches anything but a return.
<p></p>
<li></li>
<code>\F</code> matches anything but a formfeed.
<p></p>
<li></li>
<code>\E</code> matches anything but an escape.
<p></p>
<li></li>
<code>\X...</code> matches anything but the specified character (specified in
hexadecimal).
<p></p></ul>
</ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Regexes20really20are20regexes20now">Regexes really are regexes now</a></h1>
<ul>
<li></li>
The Perl 5  <code>qr/pattern/</code> regex constructor is gone.
<p></p>
<li></li>
The Perl 6 equivalents are:
<pre>
     regex { pattern }    # always takes {...} as delimiters
     rx    / pattern /    # can take (almost any) chars as delimiters</pre>
<p>You may not use whitespace or alphanumerics for delimiters.  Space is
optional unless needed to distinguish from modifier arguments or
function parens.  So you may use parens as your <code>rx</code> delimiters,
but only if you interpose whitespace:</p>
<pre>
     rx ( pattern )      # okay
     rx( 1,2,3 )         # tries to call rx function</pre>
<p>(This is true for all quotelike constructs in Perl 6.)</p>
<p></p>
<li></li>
If either form needs modifiers, they go before the opening delimiter:
<pre>
     $regex = regex :g:s:i { my name is (.*) };
     $regex = rx:g:s:i     / my name is (.*) /;    # same thing</pre>
<p>Space is necessary after the final modifier if you use any
bracketing character for the delimiter.  (Otherwise it would be taken as
an argument to the modifier.)</p>
<p></p>
<li></li>
You may not use colons for the delimiter.  Space is allowed between
modifiers:
<pre>
     $regex = rx :g :s :i / my name is (.*) /;</pre>
<p></p>
<li></li>
The name of the constructor was changed from <code>qr</code> because it's no
longer an interpolating quote-like operator.  <code>rx</code> is short for <em>regex</em>,
(not to be confused with regular expressions).
<p></p>
<li></li>
As the syntax indicates, it is now more closely analogous to a <code>sub {...}</code>
constructor.  In fact, that analogy runs <em>very</em> deep in Perl 6.
<p></p>
<li></li>
Just as a raw <code>{...}</code> is now always a closure (which may still
execute immediately in certain contexts and be passed as an object
in others), so too a raw <code>/.../</code> is now always a <code>Regex</code> object (which
may still match immediately in certain contexts and be passed as an
object in others).
<p></p>
<li></li>
Specifically, a <code>/.../</code> matches immediately in a value context (void,
Boolean, string, or numeric), or when it is an explicit argument of
a <code>~~</code>.  Otherwise it's a <code>Regex</code> constructor identical to the explicit
<code>regex</code> form.  So this:
<pre>
     $var = /pattern/;</pre>
<p>no longer does the match and sets <code>$var</code> to the result.
Instead it assigns a <code>Regex</code> object to <code>$var</code>.</p>
<p></p>
<li></li>
The two cases can always be distinguished using <code>m{...}</code> or <code>rx{...}</code>:
<pre>
     $var = m{pattern};    # Match regex immediately, assign result
     $var = rx{pattern};   # Assign regex expression itself</pre>
<p></p>
<li></li>
Note that this means that former magically lazy usages like:
<pre>
     @list = split /pattern/, $str;</pre>
<p>are now just consequences of the normal semantics.</p>
<p></p>
<li></li>
It's now also possible to set up a user-defined subroutine that acts
like <code>grep</code>:
<pre>
     sub my_grep($selector, *@list) {
         given $selector {
             when Regex { ... }
             when Code  { ... }
             when Hash  { ... }
             # etc.
         }
     }</pre>
<p>Using <code>{...}</code> or <code>/.../</code> in the scalar context of the first argument
causes it to produce a <code>Code</code> or <code>Regex</code> object, which the switch
statement then selects upon.</p>
<p></p>
<li></li>
Just as <code>rx</code> has variants, so does the <code>regex</code> declarator.
In particular, there are two special variants for use in grammars:
<code>token</code> and <code>rule</code>.
<p>A token declaration:</p>
<pre>
    token ident { [ &lt;alpha&gt; | _ ] \w+ }</pre>
<p>never backtracks by default.  That is, it likes to commit to whatever
it has scanned so far.  The above is equivalent to</p>
<pre>
    regex ident { [ &lt;alpha&gt;: | _: ]: \w+: }</pre>
<p>but rather easier to read.  The bare <code>*</code>, <code>+</code>, and <code>?</code> quantifiers
never backtrack in a <code>token</code> unless some outer regex has specified a
<code>:panic</code> option that applies.  If you want to prevent even that, use
<code>*:</code>, <code>+:</code>, or <code>?:</code> to prevent any backtracking into the quantifier.
If you want to explicitly backtrack, append either a <code>?</code> or a <code>+</code>
to the quantifier.   The <code>?</code> forces minimal matching as usual,
while the <code>+</code> forces greedy matching.  The <code>token</code> declarator is
really just short for</p>
<pre>
    regex :ratchet { ... }</pre>
<p>The other is the <code>rule</code> declarator, for declaring non-terminal
productions in a grammar.  Like a <code>token</code>, it also does not backtrack
by default.  In addition, a <code>rule</code> regex also assumes <code>:sigspace</code>.
A <code>rule</code> is really short for:</p>
<pre>
    regex :ratchet :sigspace { ... }</pre>
<p></p>
<li></li>
The Perl 5 <code>?...?</code> syntax (<em>succeed once</em>) was rarely used and can be
now emulated more cleanly with a state variable:
<pre>
    $result = do { state $x ||= m/ pattern /; }    # only matches first time</pre>
<p>To reset the pattern, simply say <code>$x = 0</code>.  Though if you want <code>$x</code> visible
you'd have to avoid using a block:</p>
<pre>
    $result = state $x ||= m/ pattern /;
    ...
    $x = 0;</pre>
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Backtracking20control">Backtracking control</a></h1>
<ul>
<li></li>
By default, backtracking is greedy in <code>rx</code>, <code>m</code>, <code>s</code>, and the like.
It's also greedy in ordinary <code>regex</code> declarations.  In <code>rule</code>
and <code>token</code> declarations, backtracking must be explicit.
<p></p>
<li></li>
To force the preceding atom to do eager backtracking,
append a <code>:?</code> or <code>?</code> to the atom.  If the preceding token is
a quantifier, the <code>:</code> may be omitted, so <code>*?</code> works just as
in Perl 5.
<p></p>
<li></li>
To force the preceding atom to do greedy backtracking,
append a <code>:+</code> or <code>+</code> to the atom.  If the preceding token
is a quantifier, the <code>:</code> may be omitted.  (Perl 5 has no
corresponding construct because backtracking always defaults
to greedy in Perl 5.)
<p></p>
<li></li>
To force the preceding atom to do no backtracking, use a single <code>:</code>
without a subsequent <code>?</code> or <code>+</code>.
Backtracking over a single colon causes the regex engine not to retry
the preceding atom:
<pre>
     ms/ \( &lt;expr&gt; [ , &lt;expr&gt; ]*: \) /</pre>
<p>(i.e. there's no point trying fewer <code>&lt;expr&gt;</code> matches, if there's
no closing parenthesis on the horizon)</p>
<p>To force all the atoms in an expression not to backtrack by default,
use <code>:ratchet</code> or <code>rule</code> or <code>token</code>.</p>
<p></p>
<li></li>
Backtracking over a double colon causes the surrounding group of
alternations to immediately fail:
<pre>
     ms/ [ if :: &lt;expr&gt; &lt;block&gt;
          | for :: &lt;list&gt; &lt;block&gt;
          | loop :: &lt;loop_controls&gt;? &lt;block&gt;
          ]
     /</pre>
<p>(i.e. there's no point trying to match a different keyword if one was
already found but failed).  Note that you can still back into such
an alternation, so you may also need to put <code>:</code> after it if you
also want to disable that.  If an explicit or implicit <code>:ratchet</code>
has disabled backtracking by supplying an implicit <code>:</code>, you need to
put an explicit <code>:+</code> after the alternation to enable backing into
another alternative if the first pick fails.</p>
<p></p>
<li></li>
Backtracking over a triple colon causes the current regex to fail
outright (no matter where in the regex it occurs):
<pre>
     regex ident {
           ( [&lt;alpha&gt;|_] \w* ) ::: { fail if %reserved{$0} }
         | &quot; [&lt;alpha&gt;|_] \w* &quot;
     }</pre>
<pre>
     ms/ get &lt;ident&gt;? /</pre>
<p>(i.e. using an unquoted reserved word as an identifier is not permitted)</p>
<p></p>
<li></li>
Backtracking over a <code>&lt;commit&gt;</code> assertion causes the entire match
to fail outright, no matter how many subrules down it happens:
<pre>
     regex subname {
         ([&lt;alpha&gt;|_] \w*) &lt;commit&gt; { fail if %reserved{$0} }
     }
     ms/ sub &lt;subname&gt;? &lt;block&gt; /</pre>
<p>(i.e. using a reserved word as a subroutine name is instantly fatal
to the <em>surrounding</em> match as well)</p>
<p></p>
<li></li>
A <code>&lt;cut&gt;</code> assertion always matches successfully, and has the
side effect of deleting the parts of the string already matched.
<p></p>
<li></li>
Attempting to backtrack past a <code>&lt;cut&gt;</code> causes the complete match
to fail (like backtracking past a <code>&lt;commit&gt;</code>). This is because there's
now no preceding text to backtrack into.
<p></p>
<li></li>
This is useful for throwing away successfully processed input when
matching from an input stream or an iterator of arbitrary length.
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Named20Regexes">Named Regexes</a></h1>
<ul>
<li></li>
The analogy between <code>sub</code> and <code>regex</code> extends much further.
<p></p>
<li></li>
Just as you can have anonymous subs and named subs...
<p></p>
<li></li>
...so too you can have anonymous regexes and <em>named</em> regexes (and tokens,
and rules):
<pre>
     token ident { [&lt;alpha&gt;|_] \w* }</pre>
<pre>
     # and later...</pre>
<pre>
     @ids = grep /&lt;ident&gt;/, @strings;</pre>
<p></p>
<li></li>
As the above example indicates, it's possible to refer to named regexes,
such as:
<pre>
     regex serial_number { &lt;[A..Z]&gt; \d**{8} }
     token type { alpha | beta | production | deprecated | legacy }</pre>
<p>in other regexes as named assertions:</p>
<pre>
     rule identification { [soft|hard]ware &lt;type&gt; &lt;serial_number&gt; }</pre>
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Nothing20is20illegal">Nothing is illegal</a></h1>
<ul>
<li></li>
The null pattern is now illegal.
<p></p>
<li></li>
To match whatever the prior successful regex matched, use:
<pre>
     /&lt;prior&gt;/</pre>
<p></p>
<li></li>
To match the zero-width string, use:
<pre>
     /&lt;null&gt;/</pre>
<p>For example:</p>
<pre>
     split /&lt;?null&gt;/, $string</pre>
<p>splits between characters.</p>
<p></p>
<li></li>
To match a null alternative, use:
<pre>
     /a|b|c|&lt;?null&gt;/</pre>
<p>This makes it easier to catch errors like this:</p>
<pre>
    /a|b|c|/</pre>
<p>As a special case, however, the first null alternative in a match like</p>
<pre>
     ms/ [
          | if :: &lt;expr&gt; &lt;block&gt;
          | for :: &lt;list&gt; &lt;block&gt;
          | loop :: &lt;loop_controls&gt;? &lt;block&gt;
          ]
     /</pre>
<p>is simply ignored.  Only the first alternative is special that way.
If you write:</p>
<pre>
     ms/ [
              if :: &lt;expr&gt; &lt;block&gt;              |
              for :: &lt;list&gt; &lt;block&gt;             |
              loop :: &lt;loop_controls&gt;? &lt;block&gt;  |
          ]
     /</pre>
<p>it's still an error.</p>
<p></p>
<li></li>
However, it's okay for a non-null syntactic construct to have a degenerate
case matching the null string:
<pre>
     $something = &quot;&quot;;
     /a|b|c|$something/;</pre>
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Return20values20from20matches">Return values from matches</a></h1>
<p>
</p>
<h2><a name="Match20objects">Match objects</a></h2>
<ul>
<li></li>
A match always returns a Match object, which is also available
as <code>$/</code>, which is a contextual lexical declared in the outer
subroutine that is calling the regex.  (A closure lexically embedded
in a regex does not redeclare <code>$/</code>, so <code>$/</code> always refers to the
current match, not any prior submatch done within the closure).
<p></p>
<li></li>
Notionally, a match object contains (among other things) a boolean
success value, a scalar <em>result object</em>, an array of ordered submatch
objects, and a hash of named submatch objects.  To provide convenient
access to these various values, the match object evaluates differently
in different contexts:
<ul>
<li></li>
In boolean context it evaluates as true or false (i.e. did the match
succeed?):
<pre>
     if /pattern/ {...}
     # or:
     /pattern/; if $/ {...}</pre>
<p>With <code>:global</code> or <code>:overlap</code> or <code>:exhaustive</code> the boolean is
allowed to return true on the first match.  The <code>Match</code> object can
produce the rest of the results lazily if evaluated in list context.</p>
<p></p>
<li></li>
In string context it evaluates to the stringified value of its
<em>result object</em>, which is usually the entire matched string:
<pre>
     print %hash{ &quot;{$text ~~ /&lt;?ident&gt;/}&quot; };
     # or equivalently:
     $text ~~ /&lt;?ident&gt;/  &amp;&amp;  print %hash{~$/};</pre>
<p>But generally you should say <code>~$/</code> if you mean <code>~$/</code>.</p>
<p></p>
<li></li>
In numeric context it evaluates to the numeric value of its
<em>result object</em>, which is usually the entire matched string:
<pre>
     $sum += /\d+/;
     # or equivalently:
     /\d+/; $sum = $sum + $/;</pre>
<p></p>
<li></li>
When used as a scalar, a <code>Match</code> object evaluates to its underlying
result object.  Usually this is just the entire match string, but
you can override that by calling <code>return</code> inside a regex:
<pre>
    my $moose = $(m:{
        &lt;antler&gt; &lt;body&gt;
        { return Moose.new( body =&gt; $&lt;body&gt;().attach($&lt;antler&gt;) ) }
        # match succeeds -- ignore the rest of the regex
    });</pre>
<p><code>$()</code> is a shorthand for <code>$($/)</code>.  The result object may be of any type,
not just a string.</p>
<p>You may also capture a subset of the match as the result object using
the <code>&lt;(...)&gt;</code> construct:</p>
<pre>
    &quot;foo123bar&quot; ~~ / foo &lt;( \d+ )&gt; bar /
    say $();    # says 123</pre>
<p>In this case the result object is always a string when doing string
matching, and a list of one or more elements when doing array matching.</p>
<p>Additionally, the <code>Match</code> object delegates its <code>coerce</code> calls
(such as <code>+$match</code> and <code>~$match</code>) to its underlying result object.
The only exception is that <code>Match</code> handles boolean coercion itself,
which returns whether the match had succeeded at least once.</p>
<p>This means that these two work the same:</p>
<pre>
    / &lt;moose&gt; { return $$&lt;moose&gt; as Moose } /
    / &lt;moose&gt; { return $&lt;moose&gt;  as Moose } /</pre>
<p></p>
<li></li>
When used as an array, a <code>Match</code> object pretends to be an array of all
its positional captures.  Hence
<pre>
     ($key, $val) = ms/ (\S+) =&gt; (\S+)/;</pre>
<p>can also be written:</p>
<pre>
     $result = ms/ (\S+) =&gt; (\S+)/;
     ($key, $val) = @$result;</pre>
<p>To get a single capture into a string, use a subscript:</p>
<pre>
     $mystring = &quot;{ ms/ (\S+) =&gt; (\S+)/[0] }&quot;;</pre>
<p>To get all the captures into a string, use a <em>zen</em> slice:</p>
<pre>
     $mystring = &quot;{ ms/ (\S+) =&gt; (\S+)/[] }&quot;;</pre>
<p>Or cast it into an array:</p>
<pre>
     $mystring = &quot;@( ms/ (\S+) =&gt; (\S+)/ )&quot;;</pre>
<p>Note that, as a scalar variable, <code>$/</code> doesn't automatically flatten
in list context.  Use <code>@()</code> as a shorthand for <code>@($/)</code> to flatten
the positional captures under list context.  Note that a <code>Match</code> object
is allowed to evaluate its match lazily in list context.  Use <code>**@()</code>
to force an eager match.</p>
<p></p>
<li></li>
When used as a hash, a <code>Match</code> object pretends to be a hash of all its named
captures.  The keys do not include any sigils, so if you capture to
variable <code>@&lt;foo&gt;</code> its real name is <code>$/{'foo'}</code> or <code>$/&lt;foo&gt;</code>.
However, you may still refer to it as <code>@&lt;foo&gt;</code> anywhere <code>$/</code>
is visible.  (But it is erroneous to use the same name for two different
capture datatypes.)
<p>Note that, as a scalar variable, <code>$/</code> doesn't automatically flatten
in list context.  Use <code>%()</code> as a shorthand for <code>%($/)</code> to flatten as a
hash, or bind it to a variable of the appropriate type.  As with <code>@()</code>,
it's possible for <code>%()</code> to produce its pairs lazily in list context.</p>
<p></p>
<li></li>
The numbered captures may be treated as named, so <code>$&lt;0 1 2&gt;</code>
is equivalent to <code>$/[0,1,2]</code>.  This allows you to write slices of
intermixed named and numbered captures.
<p></p>
<li></li>
In ordinary code, variables <code>$0</code>, <code>$1</code>, etc. are just aliases into
<code>$/[0]</code>, <code>$/[1]</code>, etc.  Hence they will all be undefined if the
last match failed (unless they were explicitly bound in a closure without
using the <code>let</code> keyword).
<p></p></ul>
<li></li>
<code>Match</code> objects have methods that provide additional information about
the match. For example:
<pre>
     if m/ def &lt;ident&gt; &lt;codeblock&gt; / {
         say &quot;Found sub def from index $/.from() to index $/.to()&quot;;
     }</pre>
<p>Warning: these methods usually return values of type <code>StrPos</code>,
which you should not treat as integers.  The interpolation of these
values in the example above is slightly naughty, and likely to print
out the positions not as numbers but as ``<code>Graphs(42)</code>'' or some such.</p>
<p></p>
<li></li>
All match attempts--successful or not--against any regex, subrule, or
subpattern (see below) return an object of class <code>Match</code>. That is:
<pre>
     $match_obj = $str ~~ /pattern/;
     say &quot;Matched&quot; if $match_obj;</pre>
<p></p>
<li></li>
This returned object is also automatically assigned to the lexical
<code>$/</code> variable, unless the match statement is inside another regex. That is:
<pre>
     $str ~~ /pattern/;
     say &quot;Matched&quot; if $/;</pre>
<p></p>
<li></li>
Inside a regex, the <code>$/</code> variable holds the current regex's
incomplete <code>Match</code> object (which can be modified via the internal <code>$/</code>).
For example:
<pre>
    $str ~~ / foo                 # Match 'foo'
               { $/ = 'bar' }     # But pretend we matched 'bar'
             /;
    say $/;                       # says 'bar'</pre>
<p>This is slightly dangerous, insofar as you might return something that
does not behave like a <code>Match</code> object to some context that requires
one.  Fortunately, you normally just want to return a result object instead:</p>
<pre>
    $str ~~ / foo                 # Match 'foo'
               { return 'bar' }   # But pretend we matched 'bar'
             /;
    say $();                      # says 'bar'</pre>
<p></p></ul>
<p>
</p>
<h2><a name="Subpattern20captures">Subpattern captures</a></h2>
<ul>
<li></li>
Any part of a regex that is enclosed in capturing parentheses is called a
<em>subpattern</em>. For example:
<pre>
        #               subpattern
        #  _________________/\____________________
        # |                                       |
        # |       subpattern  subpattern          |
        # |          __/\__    __/\__             |
        # |         |      |  |      |            |
     ms/ (I am the (walrus), ( khoo )**{2} kachoo) /;</pre>
<p></p>
<li></li>
Each subpattern in a regex produces a <code>Match</code> object if it is
successfully matched.
<p></p>
<li></li>
Each subpattern's <code>Match</code> object is pushed onto the array inside
the outer <code>Match</code> object belonging to the surrounding scope (known as
its <em>parent <code>Match</code> object</em>). The surrounding scope may be either the
innermost surrounding subpattern (if the subpattern is nested) or else
the entire regex itself.
<p></p>
<li></li>
Like all captures, these assignments to the array are hypothetical, and
are undone if the subpattern is backtracked.
<p></p>
<li></li>
For example, if the following pattern matched successfully:
<pre>
        #                subpat-A
        #  _________________/\____________________
        # |                                       |
        # |         subpat-B  subpat-C            |
        # |          __/\__    __/\__             |
        # |         |      |  |      |            |
     ms/ (I am the (walrus), ( khoo )**{2} kachoo) /;</pre>
<p>then the <code>Match</code> objects representing the matches made by <em>subpat-B</em>
and <em>subpat-C</em> would be successively pushed onto the array inside <em>subpat-
A</em>'s <code>Match</code> object. Then <em>subpat-A</em>'s <code>Match</code> object would itself be
pushed onto the array inside the <code>Match</code> object for the entire regex
(i.e. onto <code>$/</code>'s array).</p>
<p></p>
<li></li>
As a result of these semantics, capturing parentheses in Perl 6 are
hierarchical, not linear (see <a href="#nested20subpattern20captures">Nested subpattern captures</a>).
<p></p></ul>
<p>
</p>
<h2><a name="Accessing20captured20subpatterns">Accessing captured subpatterns</a></h2>
<ul>
<li></li>
The array elements of a <code>Match</code> object are referred to using either the
standard array access notation (e.g. <code>$/[0]</code>, <code>$/[1]</code>, <code>$/[2]</code>, etc.)
or else via the corresponding lexically scoped numeric aliases (i.e.
<code>$0</code>, <code>$1</code>, <code>$2</code>, etc.) So:
<pre>
     say &quot;$/[1] was found between $/[0] and $/[2]&quot;;</pre>
<p>is the same as:</p>
<pre>
     say &quot;$1 was found between $0 and $2&quot;;</pre>
<p></p>
<li></li>
Note that, in Perl 6, the numeric capture variables start from $0, not
$1, with the numbers corresponding to the element's index inside <code>$/</code>.
<p></p>
<li></li>
The array elements of the regex's <code>Match</code> object (i.e. <code>$/</code>)
store individual <code>Match</code> objects representing the substrings that were
matched and captured by the first, second, third, etc. <em>outermost</em>
(i.e. unnested) subpatterns. So these elements can be treated like fully
fledged match results. For example:
<pre>
     if m/ (\d\d\d\d)-(\d\d)-(\d\d) (BCE?|AD|CE)?/ {
           ($yr, $mon, $day) = $/[0..2];
           $era = &quot;$3&quot; if $3;                    # stringify/boolify
           @datepos = ( $0.from() .. $2.to() );  # Call Match methods
     }</pre>
<p></p></ul>
<p>
</p>
<h2><a name="Nested20subpattern20captures">Nested subpattern captures</a></h2>
<ul>
<li></li>
Substrings matched by <em>nested</em> subpatterns (i.e. nested capturing
parens) are assigned to the array inside the nested subpattern's parent <code>Match</code>
object, not to the array of <code>$/</code>.
<p></p>
<li></li>
This behavior is quite different to Perl 5 semantics:
<pre>
      # Perl 5...
      #
      # $1---------------------  $4---------  $5------------------
      # |   $2---------------  | |          | | $6----  $7------  |
      # |   |         $3--   | | |          | | |     | |       | |
      # |   |         |   |  | | |          | | |     | |       | |
     m/ ( A (guy|gal|g(\S+)  ) ) (sees|calls) ( (the|a) (gal|guy) ) /x;</pre>
<p></p>
<li></li>
In Perl 6, nested parens produce properly nested captures:
<pre>
      # Perl 6...
      #
      # $0---------------------  $1---------  $2------------------
      # |   $0[0]------------  | |          | | $2[0]-  $2[1]---  |
      # |   |       $0[0][0] | | |          | | |     | |       | |
      # |   |         |   |  | | |          | | |     | |       | |
     m/ ( A (guy|gal|g(\S+)  ) ) (sees|calls) ( (the|a) (gal|guy) ) /;</pre>
<p></p></ul>
<p>
</p>
<h2><a name="Quantified20subpattern20captures">Quantified subpattern captures</a></h2>
<ul>
<li></li>
If a subpattern is directly quantified (using <em>any</em> quantifier), it no
longer produces a single <code>Match</code> object. Instead, it produces a list
of <code>Match</code> objects corresponding to the sequence of individual matches
made by the repeated subpattern.
<p></p>
<li></li>
Because a quantified subpattern returns a list of <code>Match</code> objects, the
corresponding array element for the quantified capture will store a
(nested) array rather than a single <code>Match</code> object.  For example:
<pre>
     if m/ (\w+) \: (\w+ \s+)* / {
         say &quot;Key:    $0&quot;;         # Unquantified --&gt; single Match
         say &quot;Values: @($1)&quot;;      # Quantified   --&gt; array of Match
     }</pre>
<p></p></ul>
<p>
</p>
<h2><a name="Indirectly20quantified20subpattern20captures">Indirectly quantified subpattern captures</a></h2>
<ul>
<li></li>
A subpattern may sometimes be nested inside a quantified non-capturing
structure:
<pre>
      #       non-capturing       quantifier
      #  __________/\____________  __/\__
      # |                        ||      |
      # |   $0         $1        ||      |
      # |  _^_      ___^___      ||      |
      # | |   |    |       |     ||      |
     m/ [ (\w+) \: (\w+ \h*)* \n ]**{2..*} /</pre>
<p>Non-capturing brackets <em>don't</em> create a separate nested lexical scope,
so the two subpatterns inside them are actually still in the regex's
top-level scope, hence their top-level designations: <code>$0</code> and <code>$1</code>.</p>
<p></p>
<li></li>
However, because the two subpatterns are inside a quantified
structure, <code>$0</code> and <code>$1</code> will each contain an array.
The elements of that array will be the submatches returned by the
corresponding subpatterns on each iteration of the non-capturing
parentheses. For example:
<pre>
     my $text = &quot;foo:food fool\nbar:bard barb&quot;;</pre>
<pre>
               #   $0--     $1------
               #   |   |    |       |
     $text ~~ m/ [ (\w+) \: (\w+ \h*)* \n ]**{2..*} /;</pre>
<pre>
     # Because they're in a quantified non-capturing block...
     # $0 contains the equivalent of:
     #
     #       [ Match.new(str=&gt;'foo'), Match.new(str=&gt;'bar') ]
     #
     # and $1 contains the equivalent of:
     #
     #       [ Match.new(str=&gt;'food '),
     #         Match.new(str=&gt;'fool' ),
     #         Match.new(str=&gt;'bard '),
     #         Match.new(str=&gt;'barb' ),
     #       ]</pre>
<p></p>
<li></li>
In contrast, if the outer quantified structure is a <em>capturing</em>
structure (i.e. a subpattern) then it <em>will</em> introduce a nested
lexical scope. That outer quantified structure will then
return an array of <code>Match</code> objects representing the captures
of the inner parens for <em>every</em> iteration (as described above). That is:
<pre>
     my $text = &quot;foo:food fool\nbar:bard barb&quot;;</pre>
<pre>
               # $0-----------------------
               # |                        |
               # | $0[0]    $0[1]---      |
               # | |   |    |       |     |
     $text ~~ m/ ( (\w+) \: (\w+ \h*)* \n )**{2..*} /;</pre>
<pre>
     # Because it's in a quantified capturing block,
     # $0 contains the equivalent of:
     #
     #       [ Match.new( str=&gt;&quot;foo:food fool\n&quot;,
     #                    arr=&gt;[ Match.new(str=&gt;'foo'),
     #                           [
     #                               Match.new(str=&gt;'food '),
     #                               Match.new(str=&gt;'fool'),
     #                           ]
     #                         ],
     #                  ),
     #         Match.new( str=&gt;'bar:bard barb',
     #                    arr=&gt;[ Match.new(str=&gt;'bar'),
     #                           [
     #                               Match.new(str=&gt;'bard '),
     #                               Match.new(str=&gt;'barb'),
     #                           ]
     #                         ],
     #                  ),
     #       ]
     #
     # and there is no $1</pre>
<p></p>
<li></li>
In other words, quantified non-capturing parens collect their components
into handy flattened lists, whereas quantified capturing parens collect
their components in a handy hierarchical structure.
<p></p></ul>
<p>
</p>
<h2><a name="Subpattern20numbering">Subpattern numbering</a></h2>
<ul>
<li></li>
The index of a given subpattern can always be statically determined, but
is not necessarily unique nor always monotonic. The numbering of subpatterns
restarts in each lexical scope (either a regex, a subpattern, or the
branch of an alternation).
<p></p>
<li></li>
In particular, the index of capturing parentheses restarts after each
<code>|</code>. Hence:
<pre>
                  # $0      $1    $2   $3    $4           $5
     $tune_up = rx/ (don't) (ray) (me) (for) (solar tea), (d'oh!)
                  # $0      $1      $2    $3        $4
                  | (every) (green) (BEM) (devours) (faces)
                  /;</pre>
<p>This means that if the second alternation matches, the <code>@$/</code> array will
contain <code>('every', 'green', 'BEM', 'devours', 'faces')</code> rather than
<code>(undef, undef, undef, undef, undef, undef, 'every', 'green', 'BEM',
'devours', 'faces')</code> (as the same regex would in Perl 5).</p>
<p></p>
<li></li>
Note that it is still possible to mimic the monotonic Perl 5 capture
indexing semantics.  See <a href="#numbered20scalar20aliasing">Numbered scalar aliasing</a> below for details.
<p></p></ul>
<p>
</p>
<h2><a name="Subrule20captures">Subrule captures</a></h2>
<ul>
<li></li>
Any call to a named <code>&lt;regex&gt;</code> within a pattern is known as a
<em>subrule</em>, whether that regex is actually defined as a <code>regex</code> or
<code>token</code> or <code>rule</code> or even an ordinary <code>method</code> or <code>multi</code>.
<p></p>
<li></li>
Any bracketed construct that is aliased (see <a href="#aliasing">Aliasing</a> below) to a
named variable is also a subrule.
<p></p>
<li></li>
For example, this regex contains three subrules:
<pre>
      # subrule       subrule      subrule
      #  __^__    _______^______    __^__
      # |     |  |              |  |     |
     m/ &lt;ident&gt;  $&lt;spaces&gt;:=(\s*)  &lt;digit&gt;+ /</pre>
<p></p>
<li></li>
Just like subpatterns, each successfully matched subrule within a regex
produces a <code>Match</code> object. But, unlike subpatterns, that <code>Match</code>
object is not assigned to the array inside its parent <code>Match</code> object.
Instead, it is assigned to an entry of the hash inside its parent <code>Match</code>
object. For example:
<pre>
      #  .... $/ .....................................
      # :                                             :
      # :              .... $/[0] ..................  :
      # :             :                             : :
      # : $/&lt;ident&gt;   :        $/[0]&lt;ident&gt;         : :
      # :   __^__     :           __^__             : :
      # :  |     |    :          |     |            : :
     ms/  &lt;ident&gt; \: ( known as &lt;ident&gt; previously ) /</pre>
<p></p></ul>
<p>
</p>
<h2><a name="Accessing20captured20subrules">Accessing captured subrules</a></h2>
<ul>
<li></li>
The hash entries of a <code>Match</code> object can be referred to using any of the
standard hash access notations (<code>$/{'foo'}</code>, <code>$/&lt;bar&gt;</code>, <code>$/«baz»</code>,
etc.), or else via corresponding lexically scoped aliases (<code>$&lt;foo&gt;</code>,
<code>$«bar»</code>, <code>$&lt;baz&gt;</code>, etc.)  So the previous example also implies:
<pre>
      #    $&lt;ident&gt;             $0&lt;ident&gt;
      #     __^__                 __^__
      #    |     |               |     |
     ms/  &lt;ident&gt; \: ( known as &lt;ident&gt; previously ) /</pre>
<p></p>
<li></li>
Note that it makes no difference whether a subrule is angle-bracketed
(<code>&lt;ident&gt;</code>) or aliased (<code>$&lt;ident&gt; := (&lt;alpha&gt;\w*)</code>). The name's
the thing.
<p></p></ul>
<p>
</p>
<h2><a name="Repeated20captures20of20the20same20subrule">Repeated captures of the same subrule</a></h2>
<ul>
<li></li>
If a subrule appears two (or more) times in any branch of a lexical
scope (i.e. twice within the same subpattern and alternation), or if the
subrule is quantified anywhere within a given scope, then its
corresponding hash entry is always assigned an array of
<code>Match</code> objects rather than a single <code>Match</code> object.
<p></p>
<li></li>
Successive matches of the same subrule (whether from separate calls, or
from a single quantified repetition) append their individual <code>Match</code>
objects to this array. For example:
<pre>
     if ms/ mv &lt;file&gt; &lt;file&gt; / {
         $from = $&lt;file&gt;[0];
         $to   = $&lt;file&gt;[1];
     }</pre>
<p>Likewise, with a quantified subrule:</p>
<pre>
     if ms/ mv &lt;file&gt;**{2} / {
         $from = $&lt;file&gt;[0];
         $to   = $&lt;file&gt;[1];
     }</pre>
<p>And with a mixture of both:</p>
<pre>
     if ms/ mv &lt;file&gt;+ &lt;file&gt; / {
         $to   = pop @($&lt;file&gt;);
         @from = @($&lt;file&gt;);
     }</pre>
<p></p>
<li></li>
However, if a subrule is explicitly renamed (or aliased -- see <a href="#aliasing">Aliasing</a>),
then only the <em>final</em> name counts when deciding whether it is or isn't
repeated. For example:
<pre>
     if ms/ mv &lt;file&gt; $&lt;dir&gt;:=&lt;file&gt; / {
         $from = $&lt;file&gt;;  # Only one subrule named &lt;file&gt;, so scalar
         $to   = $&lt;dir&gt;;   # The Capture Formerly Known As &lt;file&gt;
     }</pre>
<p>Likewise, neither of the following constructions causes <code>&lt;file&gt;</code> to
produce an array of <code>Match</code> objects, since none of them has two or more
<code>&lt;file&gt;</code> subrules in the same lexical scope:</p>
<pre>
     if ms/ (keep) &lt;file&gt; | (toss) &lt;file&gt; / {
         # Each &lt;file&gt; is in a separate alternation, therefore &lt;file&gt;
         # is not repeated in any one scope, hence $&lt;file&gt; is
         # not an Array object...
         $action = $0;
         $target = $&lt;file&gt;;
     }</pre>
<pre>
     if ms/ &lt;file&gt; \: (&lt;file&gt;|none) / {
         # Second &lt;file&gt; nested in subpattern which confers a
         # different scope...
         $actual  = $/&lt;file&gt;;
         $virtual = $/[0]&lt;file&gt; if $/[0]&lt;file&gt;;
     }</pre>
<p></p>
<li></li>
On the other hand, unaliased square brackets don't confer a separate
scope (because they don't have an associated <code>Match</code> object). So:
<pre>
     if ms/ &lt;file&gt; \: [&lt;file&gt;|none] / { # Two &lt;file&gt;s in same scope
         $actual  = $/&lt;file&gt;[0];
         $virtual = $/&lt;file&gt;[1] if $/&lt;file&gt;[1];
     }</pre>
<p></p></ul>
<p>
</p>
<h2><a name="Aliasing">Aliasing</a></h2>
<p>Aliases can be named or numbered. They can be scalar-, array-, or hash-like.
And they can be applied to either capturing or non-capturing constructs. The
following sections highlight special features of the semantics of some
of those combinations.</p>
<p>
</p>
<h3><a name="Named20scalar20aliasing20to20subpatterns">Named scalar aliasing to subpatterns</a></h3>
<ul>
<li></li>
If a named scalar alias is applied to a set of <em>capturing</em> parens:
<pre>
        #          ______/capturing parens\_____
        #         |                             |
        #         |                             |
     ms/ $&lt;key&gt;:=( (&lt;[A..E]&gt;) (\d**{3..6}) (X?) ) /;</pre>
<p>then the outer capturing parens no longer capture into the array of
<code>$/</code> as unaliased parens would. Instead the aliased parens capture
into the hash of <code>$/</code>; specifically into the hash element
whose key is the alias name.</p>
<p></p>
<li></li>
So, in the above example, a successful match sets
<code>$&lt;key&gt;</code> (i.e. <code>$/&lt;key&gt;</code>), but <em>not</em> <code>$0</code> (i.e. not <code>$/[0]</code>).
<p></p>
<li></li>
More specifically:
<ul>
<li></li>
<code>$/&lt;key&gt;</code> will contain the <code>Match</code> object that would previously have
been placed in <code>$/[0]</code>.
<p></p>
<li></li>
<code>$/&lt;key&gt;[0]</code> will contain the A-E letter,
<p></p>
<li></li>
<code>$/&lt;key&gt;[1]</code> will contain the digits,
<p></p>
<li></li>
<code>$/&lt;key&gt;[2]</code> will contain the optional X.
<p></p></ul>
<li></li>
Another way to think about this behavior is that aliased parens create
a kind of lexically scoped named subrule; that the contents of the
parentheses are treated as if they were part of a separate subrule whose
name is the alias.
<p></p></ul>
<p>
</p>
<h3><a name="Named20scalar20aliases20applied20to20non2dcapturing20brackets">Named scalar aliases applied to non-capturing brackets</a></h3>
<ul>
<li></li>
If a named scalar alias is applied to a set of <em>non-capturing</em> brackets:
<pre>
        #          ___/non-capturing brackets\__
        #         |                             |
        #         |                             |
     ms/ $&lt;key&gt;:=[ (&lt;[A..E]&gt;) (\d**{3..6}) (X?) ] /;</pre>
<p>then the corresponding <code>$/&lt;key&gt;</code> Match object contains only the string
matched by the non-capturing brackets.</p>
<p></p>
<li></li>
In particular, the array of the <code>$/&lt;key&gt;</code> entry is empty. That's
because square brackets do not create a nested lexical scope, so the
subpatterns are unnested and hence correspond to $0, $1, and $2, and
<em>not</em> to <code>$/&lt;key&gt;[0]</code>, <code>$/&lt;key&gt;[1]</code>, and <code>$/&lt;key&gt;[2]</code>.
<p></p>
<li></li>
In other words:
<ul>
<li></li>
<code>$/&lt;key&gt;</code> will contain the complete substring matched by the square
brackets (in a <code>Match</code> object, as described above),
<p></p>
<li></li>
<code>$0</code> will contain the A-E letter,
<p></p>
<li></li>
<code>$1</code> will contain the digits,
<p></p>
<li></li>
<code>$2</code> will contain the optional X.
<p></p></ul>
</ul>
<p>
</p>
<h3><a name="Named20scalar20aliasing20to20subrules">Named scalar aliasing to subrules</a></h3>
<ul>
<li></li>
If a subrule is aliased, it assigns its <code>Match</code> object to the hash
entry whose key is the name of the alias. And it <em>no longer</em> assigns
anything to the hash entry whose key is the subrule name. That is:
<pre>
     if m/ ID\: $&lt;id&gt;:=&lt;ident&gt; / {
         say &quot;Identified as $/&lt;id&gt;&quot;;    # $/&lt;ident&gt; is undefined
     }</pre>
<p></p>
<li></li>
Hence aliasing a subrule <em>changes</em> the destination of the subrule's <code>Match</code>
object. This is particularly useful for differentiating two or more calls to
the same subrule in the same scope. For example:
<pre>
     if ms/ mv &lt;file&gt;+ $&lt;dir&gt;:=&lt;file&gt; / {
         @from = @($&lt;file&gt;);
         $to   = $&lt;dir&gt;;
     }</pre>
<p></p></ul>
<p>
</p>
<h3><a name="Numbered20scalar20aliasing">Numbered scalar aliasing</a></h3>
<ul>
<li></li>
If a numbered alias is used instead of a named alias:
<pre>
     m/ $1:=(&lt;-[:]&gt;*) \:  $0:=&lt;ident&gt; /</pre>
<p>the behavior is exactly the same as for a named alias (i.e. the various
cases described above), except that the resulting <code>Match</code> object is
assigned to the corresponding element of the appropriate array rather
than to an element of the hash.</p>
<p></p>
<li></li>
If any numbered alias is used, the numbering of subsequent unaliased
subpatterns in the same scope automatically increments from that
alias number (much like enum values increment from the last explicit
value). That is:
<pre>
      #  ---$1---    -$2-    ---$6---    -$7-
      # |        |  |    |  |        |  |    |
     m/ $1:=(food)  (bard)  $6:=(bazd)  (quxd) /;</pre>
<p></p>
<li></li>
This <em>follow-on</em> behavior is particularly useful for reinstituting
Perl5 semantics for consecutive subpattern numbering in alternations:
<pre>
     $tune_up = rx/ (don't) (ray) (me) (for) (solar tea), (d'oh!)
                  | $6:=(every) (green) (BEM) (devours) (faces)
                  #             $7      $8    $9        $10
                  /;</pre>
<p></p>
<li></li>
It also provides an easy way in Perl 6 to reinstitute the unnested
numbering semantics of nested Perl 5 subpatterns:
<pre>
      # Perl 5...
      #               $1
      #  _____________/\______________
      # |    $2          $3       $4  |
      # |  __/\___   ____/\____   /\  |
      # | |       | |          | |  | |
     m/ ( (&lt;[A..E]&gt;) (\d**{3..6}) (X?) ) /;</pre>
<pre>
      # Perl 6...
      #               $0
      #  _____________/\______________
      # |  $0[0]       $0[1]    $0[2] |
      # |  __/\___   ____/\____   /\  |
      # | |       | |          | |  | |
     m/ ( (&lt;[A..E]&gt;) (\d**{3..6}) (X?) ) /;</pre>
<pre>
      # Perl 6 simulating Perl 5...
      #                 $1
      #  _______________/\________________
      # |        $2          $3       $4  |
      # |      __/\___   ____/\____   /\  |
      # |     |       | |          | |  | |
     m/ $1:=[ (&lt;[A..E]&gt;) (\d**{3..6}) (X?) ] /;</pre>
<p>The non-capturing brackets don't introduce a scope, so the subpatterns within
them are at regex scope, and hence numbered at the top level. Aliasing the
square brackets to <code>$1</code> means that the next subpattern at the same level
(i.e. the <code>(&lt;[A..E]&gt;)</code>) is numbered sequentially (i.e. <code>$2</code>), etc.</p>
<p></p></ul>
<p>
</p>
<h3><a name="Scalar20aliases20applied20to20quantified20constructs">Scalar aliases applied to quantified constructs</a></h3>
<ul>
<li></li>
All of the above semantics apply equally to aliases which are bound to
quantified structures.
<p></p>
<li></li>
The only difference is that, if the aliased construct is a subrule or
subpattern, that quantified subrule or subpattern will have returned a
list of <code>Match</code> objects (as described in <a href="#quantified20subpattern20captures">Quantified subpattern captures</a> and <a href="#repeated20captures20of20the20same20subrule">Repeated captures of the same subrule</a>).
So the corresponding array element or hash entry for the alias will
contain an array, instead of a single <code>Match</code> object.
<p></p>
<li></li>
In other words, aliasing and quantification are completely orthogonal.
For example:
<pre>
     if m/ mv $0:=&lt;file&gt;+ / {
         # &lt;file&gt;+ returns a list of Match objects,
         # so $0 contains an array of Match objects,
         # one for each successful call to &lt;file&gt;</pre>
<pre>
         # $/&lt;file&gt; does not exist (it's pre-empted by the alias)
     }</pre>
<pre>
     if m/ mv $&lt;from&gt;:=(\S+ \s+)* / {
         # Quantified subpattern returns a list of Match objects,
         # so $/&lt;from&gt; contains an array of Match
         # objects, one for each successful match of the subpattern</pre>
<pre>
         # $0 does not exist (it's pre-empted by the alias)
     }</pre>
<p></p>
<li></li>
Note, however, that a set of quantified <em>non-capturing</em> brackets always
returns a single <code>Match</code> object which contains only the complete
substring that was matched by the full set of repetitions of the
brackets (as described in <a href="#named20scalar20aliases20applied20to20noncapturing20brackets">Named scalar aliases applied to  non-capturing brackets</a>). For example:
<pre>
     &quot;coffee fifo fumble&quot; ~~ m/ $&lt;effs&gt;:=[f &lt;-[f]&gt;**{1..2} \s*]+ /;</pre>
<pre>
     say $&lt;effs&gt;;    # prints &quot;fee fifo fum&quot;</pre>
<p></p></ul>
<p>
</p>
<h3><a name="Array20aliasing">Array aliasing</a></h3>
<ul>
<li></li>
An alias can also be specified using an array as the alias instead of a scalar.
For example:
<pre>
     m/ mv @&lt;from&gt;:=[(\S+) \s+]* &lt;dir&gt; /;</pre>
<p></p>
<li></li>
Using the <code>@&lt;alias&gt;:=</code> notation instead of a <code>$&lt;alias&gt;:=</code>
mandates that the corresponding hash entry or array element <em>always</em>
receives an array of <code>Match</code> objects, even if the
construct being aliased would normally return a single <code>Match</code> object.
This is useful for creating consistent capture semantics across
structurally different alternations (by enforcing array captures in all
branches):
<pre>
     ms/ Mr?s? @&lt;names&gt;:=&lt;ident&gt; W\. @&lt;names&gt;:=&lt;ident&gt;
        | Mr?s? @&lt;names&gt;:=&lt;ident&gt;
        /;</pre>
<pre>
     # Aliasing to @&lt;names&gt; means $/&lt;names&gt; is always
     # an Array object, so...</pre>
<pre>
     say @($/&lt;names&gt;);</pre>
<p></p>
<li></li>
For convenience and consistency, <code>@&lt;key&gt;</code> can also be used outside a
regex, as a shorthand for <code>@( $/&lt;key&gt; )</code>. That is:
<pre>
     ms/ Mr?s? @&lt;names&gt;:=&lt;ident&gt; W\. @&lt;names&gt;:=&lt;ident&gt;
        | Mr?s? @&lt;names&gt;:=&lt;ident&gt;
        /;</pre>
<pre>
     say @&lt;names&gt;;</pre>
<p></p>
<li></li>
If an array alias is applied to a quantified pair of non-capturing
brackets, it captures the substrings matched by each repetition of the
brackets into separate elements of the corresponding array. That is:
<pre>
     m/ mv $&lt;files&gt;:=[ f.. \s* ]* /; # $/&lt;files&gt; assigned a single
                                     # Match object containing the
                                     # complete substring matched by
                                     # the full set of repetitions
                                     # of the non-capturing brackets</pre>
<pre>
     m/ mv @&lt;files&gt;:=[ f.. \s* ]* /; # $/&lt;files&gt; assigned an array,
                                     # each element of which is a
                                     # Match object containing
                                     # the substring matched by Nth
                                     # repetition of the non-
                                     # capturing bracket match</pre>
<p></p>
<li></li>
If an array alias is applied to a quantified pair of capturing parens
(i.e. to a subpattern), then the corresponding hash or array element is
assigned a list constructed by concatenating the array values of each
<code>Match</code> object returned by one repetition of the subpattern. That is,
an array alias on a subpattern flattens and collects all nested
subpattern captures within the aliased subpattern. For example:
<pre>
     if ms/ $&lt;pairs&gt;:=( (\w+) \: (\N+) )+ / {
         # Scalar alias, so $/&lt;pairs&gt; is assigned an array
         # of Match objects, each of which has its own array
         # of two subcaptures...</pre>
<pre>
         for @($&lt;pairs&gt;) -&gt; $pair {
             say &quot;Key: $pair[0]&quot;;
             say &quot;Val: $pair[1]&quot;;
         }
     }</pre>
<pre>
     if ms/ @&lt;pairs&gt;:=( (\w+) \: (\N+) )+ / {
         # Array alias, so $/&lt;pairs&gt; is assigned an array
         # of Match objects, each of which is flattened out of
         # the two subcaptures within the subpattern</pre>
<pre>
         for @($&lt;pairs&gt;) -&gt; $key, $val {
             say &quot;Key: $key&quot;;
             say &quot;Val: $val&quot;;
         }
     }</pre>
<p></p>
<li></li>
Likewise, if an array alias is applied to a quantified subrule, then the
hash or array element corresponding to the alias is assigned a list
containing the array values of each <code>Match</code> object returned by each
repetition of the subrule, all flattened into a single array:
<pre>
     rule pair { (\w+) \: (\N+) \n }</pre>
<pre>
     if ms/ $&lt;pairs&gt;:=&lt;pair&gt;+ / {
         # Scalar alias, so $/&lt;pairs&gt; contains an array of
         # Match objects, each of which is the result of the
         # &lt;pair&gt; subrule call...</pre>
<pre>
         for @($&lt;pairs&gt;) -&gt; $pair {
             say &quot;Key: $pair[0]&quot;;
             say &quot;Val: $pair[1]&quot;;
         }
     }</pre>
<pre>
     if ms/ mv @&lt;pairs&gt;:=&lt;pair&gt;+ / {
         # Array alias, so $/&lt;pairs&gt; contains an array of
         # Match objects, all flattened down from the
         # nested arrays inside the Match objects returned
         # by each match of the &lt;pair&gt; subrule...</pre>
<pre>
         for @($&lt;pairs&gt;) -&gt; $key, $val {
             say &quot;Key: $key&quot;;
             say &quot;Val: $val&quot;;
         }
     }</pre>
<p></p>
<li></li>
In other words, an array alias is useful to flatten into a single array
any nested captures that might occur within a quantified subpattern or subrule.
Whereas a scalar alias is useful to preserve within a top-level array
the internal structure of each repetition.
<p></p>
<li></li>
It is also possible to use a numbered variable as an array alias.
The semantics are exactly as described above, with the sole difference
being that the resulting array of <code>Match</code> objects is assigned into the
appropriate element of the regex's match array rather than to a key of
its match hash. For example:
<pre>
     if m/ mv  \s+  @0:=((\w+) \s+)+  $1:=((\W+) (\s*))* / {
         #          |                 |
         #          |                 |
         #          |                  \_ Scalar alias, so $1 gets an
         #          |                     array, with each element
         #          |                     a Match object containing
         #          |                     the two nested captures
         #          |
         #           \___ Array alias, so $0 gets a flattened array of
         #                just the (\w+) captures from each repetition</pre>
<pre>
         @from     = @($0);      # Flattened list</pre>
<pre>
         $to_str   = $1[0][0];   # Nested elems of
         $to_gap   = $1[0][1];   #    unflattened list
     }</pre>
<p></p>
<li></li>
Note again that, outside a regex, <code>@0</code> is simply a shorthand for
<code>@($0)</code>, so the first assignment above could also have been written:
<pre>
     @from = @0;</pre>
<p></p></ul>
<p>
</p>
<h3><a name="Hash20aliasing">Hash aliasing</a></h3>
<ul>
<li></li>
An alias can also be specified using a hash as the alias variable,
instead of a scalar or an array. For example:
<pre>
     m/ mv %&lt;location&gt;:=( (&lt;ident&gt;) \: (\N+) )+ /;</pre>
<p></p>
<li></li>
A hash alias causes the corresponding hash or array element in the
current scope's <code>Match</code> object to be assigned a (nested) Hash object
(rather than an <code>Array</code> object or a single <code>Match</code> object).
<p></p>
<li></li>
If a hash alias is applied to a subrule or subpattern then the first nested
numeric capture becomes the key of each hash entry and any remaining numeric
captures become the values (in an array if there is more than one).
<p></p>
<li></li>
As with array aliases it is also possible to use a numbered variable as
a hash alias. Once again, the only difference is where the resulting
<code>Match</code> object is stored:
<pre>
     rule one_to_many {  (\w+) \: (\S+) (\S+) (\S+) }</pre>
<pre>
     if ms/ %0:=&lt;one_to_many&gt;+ / {
         # $/[0] contains a hash, in which each key is provided by
         # the first subcapture within C&lt;one_to_many&gt;, and each
         # value is an array containing the
         # subrule's second, third, fourth, etc. subcaptures...</pre>
<pre>
         for %($/[0]) -&gt; $pair {
             say &quot;One:  $pair.key()&quot;;
             say &quot;Many: { @($pair.value) }&quot;;
         }
     }</pre>
<p></p>
<li></li>
Outside the regex, <code>%0</code> is a shortcut for <code>%($0)</code>:
<pre>
         for %0 -&gt; $pair {
             say &quot;One:  $pair.key()&quot;;
             say &quot;Many: @($pair.value)&quot;;
         }</pre>
<p></p></ul>
<p>
</p>
<h3><a name="External20aliasing">External aliasing</a></h3>
<ul>
<li></li>
Instead of using internal aliases like:
<pre>
     m/ mv  @&lt;files&gt;:=&lt;ident&gt;+  $&lt;dir&gt;:=&lt;ident&gt; /</pre>
<p>the name of an ordinary variable can be used as an <em>external</em> alias, like so:</p>
<pre>
     m/ mv  @files:=&lt;ident&gt;+  $dir:=&lt;ident&gt; /</pre>
<p></p>
<li></li>
In this case, the behavior of each alias is exactly as described in the
previous sections, except that any resulting capture is bound
directly (but still hypothetically) to the variable of the specified
name that must already exist in the scope in which the regex is declared.
<p></p></ul>
<p>
</p>
<h2><a name="Capturing20from20repeated20matches">Capturing from repeated matches</a></h2>
<ul>
<li></li>
When an entire regex is successfully matched with repetitions
(specified via the <code>:x</code> or <code>:g</code> flag) or overlaps (specified via the
<code>:ov</code> or <code>:ex</code> flag), it will usually produce a series
of distinct matches.
<p></p>
<li></li>
A successful match under any of these flags still returns a single
<code>Match</code> object in <code>$/</code>. However, this object may represent a partial
evaluation of the regex.   Moreover, the values of this match object
are slightly different from those provided by a non-repeated match:
<ul>
<li></li>
The boolean value of <code>$/</code> after such matches is true or false, depending on
whether the pattern matched.
<p></p>
<li></li>
The string value is the substring from the start of the first match to
the end of the last match (<em>including</em> any intervening parts of the
string that the regex skipped over in order to find later matches).
<p></p>
<li></li>
Subcaptures are returned as a multidimensional list, which the user can
choose to process in either of two ways.  If you refer to
<code>@()</code>, the multidimensionality is ignored and all the matches are returned
flattened (but still lazily).  If you refer to @@(), you can
get each individual sublist as a Capture object. (That is, there is a <code>@@()</code>
coercion operator that happens, like <code>@()</code>, to default to <code>$/</code>.)
As with any multidimensional list, each sublist can be lazy separately.
<p></p></ul>
<p>For example:</p>
<pre>
     if $text ~~ ms:g/ (\S+:) &lt;rocks&gt; / {
         say 'Full match context is: [$/]';
     }</pre>
<p>But the list of individual match objects corresponding to each separate
match is also available:</p>
<pre>
     if $text ~~ ms:g/ (\S+:) &lt;rocks&gt; / {
         say &quot;Matched { +@@() } times&quot;;    # Note: forced eager here</pre>
<pre>
         for @@() -&gt; $m {
             say &quot;Match between $m.from() and $m.to()&quot;;
             say 'Right on, dude!' if $m[0] eq 'Perl';
             say &quot;Rocks like $m&lt;rocks&gt;&quot;;
         }
     }</pre>
</ul>
<p>
</p>
<h2><a name="3akeepall"><code>:keepall</code></a></h2>
<ul>
<li></li>
All regexes remember everything if <code>:keepall</code> is in effect
anywhere in the outer dynamic scope.  In this case everything inside
the angles is used as part of the key.  Suppose the earlier example
parsed whitespace:
<pre>
     / &lt;key&gt; &lt;?ws&gt; &lt;'=&gt;'&gt; &lt;?ws&gt; &lt;value&gt; { %hash{$&lt;key&gt;} = $&lt;value&gt; } /</pre>
<p>The two instances of <code>&lt;?ws&gt;</code> above would store an array of two
values accessible as <code>@&lt;?ws&gt;</code>.  It would also store the literal
match into <code>$&lt;'=\&gt;'&gt;</code>.  Just to make sure nothing is forgotten,
under <code>:keepall</code> any text or whitespace not otherwise remembered is
attached as an extra property on the subsequent node. (The name of
that property is ``<code>pretext</code>''.)</p>
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Grammars">Grammars</a></h1>
<ul>
<li></li>
Your private <code>ident</code> rule shouldn't clobber someone else's
<code>ident</code> rule.  So some mechanism is needed to confine rules to a namespace.
<p></p>
<li></li>
If subs are the model for rules, then modules/classes are the obvious
model for aggregating them.  Such collections of rules are generally
known as <em>grammars</em>.
<p></p>
<li></li>
Just as a class can collect named actions together:
<pre>
     class Identity {
         method name { &quot;Name = $.name&quot; }
         method age  { &quot;Age  = $.age&quot;  }
         method addr { &quot;Addr = $.addr&quot; }</pre>
<pre>
         method desc {
             print &amp;.name(), &quot;\n&quot;,
                   &amp;.age(),  &quot;\n&quot;,
                   &amp;.addr(), &quot;\n&quot;;
         }</pre>
<pre>
         # etc.
     }</pre>
<p>so too a grammar can collect a set of named rules together:</p>
<pre>
     grammar Identity {
         rule name { Name = (\N+) }
         rule age  { Age  = (\d+) }
         rule addr { Addr = (\N+) }
         rule desc {
             &lt;name&gt; \n
             &lt;age&gt;  \n
             &lt;addr&gt; \n
         }</pre>
<pre>
         # etc.
     }</pre>
<p></p>
<li></li>
Like classes, grammars can inherit:
<pre>
     grammar Letter {
         rule text     { &lt;greet&gt; &lt;body&gt; &lt;close&gt; }</pre>
<pre>
         rule greet { [Hi|Hey|Yo] $&lt;to&gt;:=(\S+?) , $$}</pre>
<pre>
         rule body     { &lt;line&gt;+? }   # note: backtracks forwards via +?</pre>
<pre>
         rule close { Later dude, $&lt;from&gt;:=(.+) }</pre>
<pre>
         # etc.
     }</pre>
<pre>
     grammar FormalLetter is Letter {</pre>
<pre>
         rule greet { Dear $&lt;to&gt;:=(\S+?) , $$}</pre>
<pre>
         rule close { Yours sincerely, $&lt;from&gt;:=(.+) }</pre>
<pre>
     }</pre>
<p></p>
<li></li>
Just like the methods of a class, the rule definitions of a grammar are
inherited (and polymorphic!). So there's no need to respecify <code>body</code>,
<code>line</code>, etc.
<p></p>
<li></li>
Perl 6 will come with at least one grammar predefined:
<pre>
     grammar Perl {    # Perl's own grammar</pre>
<pre>
         rule prog { &lt;statement&gt;* }</pre>
<pre>
         rule statement {
                   | &lt;decl&gt;
                   | &lt;loop&gt;
                   | &lt;label&gt; [&lt;cond&gt;|&lt;sideff&gt;|;]
         }</pre>
<pre>
         rule decl { &lt;sub&gt; | &lt;class&gt; | &lt;use&gt; }</pre>
<pre>
         # etc. etc. etc.
     }</pre>
<p></p>
<li></li>
Hence:
<pre>
     given $source_code {
         $parsetree = m:keepall/&lt;Perl.prog&gt;/;
     }</pre>
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Syntactic20categories">Syntactic categories</a></h1>
<p>For writing your own backslash and assertion subrules or macros, you may
use the following syntactic categories:</p>
<pre>
     token rule_backslash:&lt;w&gt; { ... }     # define your own \w and \W
     token rule_assertion:&lt;*&gt; { ... }     # define your own &lt;*stuff&gt;
     macro rule_metachar:&lt;,&gt; { ... }     # define a new metacharacter
     macro rule_mod_internal:&lt;x&gt; { ... } # define your own /:x() stuff/
     macro rule_mod_external:&lt;x&gt; { ... } # define your own m:x()/stuff/</pre>
<p>As with any such syntactic shenanigans, the declaration must be
visible in the lexical scope to have any effect.  It's possible
the internal/external distinction is just a trait, and that some
of those things are subs or methods rather than subrules or macros.
(The numeric regex modifiers are recognized by fallback macros defined
with an empty operator name.)</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Pragmas">Pragmas</a></h1>
<p>Various pragmas may be used to control various aspects of regex
compilation and usage not otherwise provided for.  These are tied
to the particular declarator in question:</p>
<pre>
    use s :foo;         # control s defaults
    use m :foo;         # control m defaults
    use rx :foo;        # control rx defaults
    use regex :foo;     # control regex defaults
    use token :foo;     # control token defaults
    use rule :foo;      # control rule defaults</pre>
<p>(It is a general policy in Perl 6 that any pragma designed to influence
the surface behavior of a keyword is identical to the keyword itself, unless
there is good reason to do otherwise.  On the other hand, pragmas designed
to influence deep semantics should not be named identically, though of
course some similarity is good.)</p>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Transliteration">Transliteration</a></h1>
<a name="msg_3"></a>
<a href="?hide_quotes=no#msg_3" onclick="return tog_quote(3);">
<div ID=header_shown_3 style="display: none;">- Hide t/builtins/strings/trans.t (line 8 ~ line 67) -
</div>
<div ID=header_hidden_3 style="display: block;">- Show t/builtins/strings/trans.t (60 lines) -</div>
</a>
</p>
<div ID=hide_3 style="display:none; border:1px solid">
<pre>
L&lt;S05/Transliteration&gt;
=cut


plan 13;

is("ABC".trans( ('A'=&gt;'a'), ('B'=&gt;'b'), ('C'=&gt;'c') ),"abc",
        "Each side can be individual characters");

is("XYZ".trans( ('XYZ' =&gt; 'xyz') ),"xyz",
           "The two sides of the any pair can be strings interpreted as tr/// would multichar");


is("ABC".trans( ('A-C' =&gt; 'a-c') ),"abc",
           "The two sides of the any pair can be strings interpreted as tr/// would range");

is("ABC-DEF".trans(("-AB-Z" =&gt; "_a-z")),"abc_def",
           "If the first character is a dash it isn't part of a range");

is("ABC-DEF".trans(("A-YZ-" =&gt; "a-z_")),"abc_def",
           "If the last character is a dash it isn't part of a range");


#skip 2, "loops forever with Pugs 6.2.10";
is("ABCDEF".trans( ('AB-E' =&gt; 'ab-e') ), "abcdeF",
                  "The two sides can consists of both chars and ranges");
is("ABCDEFGH".trans( ('A-CE-G' =&gt; 'a-ce-g') ),"abcDefgH",
                  "The two sides can consist of multiple ranges");

# These will need the way the hashses deal with pairs.

# This works by accedent.
is("ABCXYZ".trans( (['A'..'C'] =&gt; ['a'..'c']), (&lt;X Y Z&gt; =&gt; &lt;x y z&gt;) ),"abcxyz",
           "The two sides of each pair may also be array references" );

# We're probally unable to "fix" these two as long as the left hand of =&gt; gets stringified
is("abcde".trans( ('a-e' =&gt; ['A' .. 'E']) ), "ABCDE",
	   "Using string range on one side and array reference on the other");


is("ABCDE".trans( (['A' .. 'E'] =&gt; "a-e") ), "abcde",
	   "Using array reference on one side and string range on the other");


is(" &lt;&gt;&amp;".trans( (['&lt;',    '&gt;',    '&amp;',    ] =&gt; 
                  ['&amp;lt;', '&amp;gt;', '&amp;amp;' ]))," &amp;lt;&amp;gt;&amp;amp;",
         "The array version can map one characters to one-or-more characters except spaces");

is(" &lt;&gt;&amp;".trans( ([' ',      '&lt;',    '&gt;',    '&amp;'    ] =&gt; 
                  ['&amp;nbsp;', '&amp;lt;', '&amp;gt;', '&amp;amp;' ])),"&amp;nbsp;&amp;lt;&amp;gt;&amp;amp;",
         "The array version can map one-or-more characters to one-or-more characters");

eval_is('"abc".trans(&lt;== "a" =&gt; "A")', "Abc",
    "you're allowed to leave off the (...) named arg parens when you use &lt;==",
    :todo&lt;feature&gt;);

# XXX should this work?
#eval_is('"abc".trans &lt;== "a" =&gt; "A"', "Abc",
#   "you're allowed to leave off the (...) named arg parens when you use &lt;==",
#   :todo&lt;feature&gt;);</pre>
</div><ul>
<li></li>
The <code>tr///</code> quote-like operator now also has a method form called
<code>trans()</code>.  Its argument is a list of pairs.  You can use anything that
produces a pair list:
<pre>
     $str.trans( %mapping.pairs.sort );</pre>
<p>Use the <code>.=</code> form to do a translation in place:</p>
<pre>
     $str.=trans( %mapping.pairs.sort );</pre>
<p></p>
<li></li>
The two sides of any pair can be strings interpreted as <code>tr///</code> would:
<pre>
     $str.=trans( 'A..C' =&gt; 'a..c', 'XYZ' =&gt; 'xyz' );</pre>
<p>As a degenerate case, each side can be individual characters:</p>
<pre>
     $str.=trans( 'A'=&gt;'a', 'B'=&gt;'b', 'C'=&gt;'c' );</pre>
<p></p>
<li></li>
The two sides of each pair may also be Array objects:
<pre>
     $str.=trans( ['A'..'C'] =&gt; ['a'..'c'], &lt;X Y Z&gt; =&gt; &lt;x y z&gt; );</pre>
<p></p>
<li></li>
The array version can map one-or-more characters to one-or-more
characters:
<pre>
     $str.=trans( [' ',      '&lt;',    '&gt;',    '&amp;'    ] =&gt;
                  ['&amp;nbsp;', '&amp;lt;', '&amp;gt;', '&amp;amp;' ]);</pre>
<p>In the case that more than one sequence of input characters matches,
the longest one wins.  In the case of two identical sequences the
first in order wins.</p>
<p>There are also method forms of <code>m//</code> and <code>s///</code>:</p>
<pre>
     $str.match(//);
     $str.subst(//, &quot;replacement&quot;);
     $str.subst(//, {&quot;replacement&quot;});
     $str.=subst(//, &quot;replacement&quot;);
     $str.=subst(//, {&quot;replacement&quot;});</pre>
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Positional20matching2c20fixed20width20types">Positional matching, fixed width types</a></h1>
<ul>
<li></li>
To anchor to a particular position in the general case you can use
the <code>&lt;at($pos)&gt;</code> assertion to say that the current position
is the same as the position object you supply.  You may set the
current match position via the <code>:c</code> and <code>:p</code> modifiers.
<p>However, please remember that in Perl 6 string positions are generally
<em>not</em> integers, but objects that point to a particular place in
the string regardless of whether you count by bytes or codepoints or
graphemes.  If used with an integer, the <code>at</code> assertion will assume
you mean the current lexically scoped Unicode level, on the assumption
that this integer was somehow generated in this same lexical scope.
If this is outside the current string's allowed Unicode abstraction levels, an
exception is thrown.  See S02 for more discussion of string positions.</p>
<p></p>
<li></li>
<code>Buf</code> types are based on fixed-width cells and can therefore
handle integer positions just fine, and treat them as array indices.
In particular, <code>buf8</code> (also known as <code>buf</code>) is just an old-school byte string.
Matches against <code>Buf</code> types are restricted to ASCII semantics in
the absence of an <em>explicit</em> modifier asking for the array's values
to be treated as some particular encoding such as UTF-32.  (This is
also true for those compact arrays that are considered isomorphic to
<code>Buf</code> types.)  Positions within <code>Buf</code> types are always integers,
counting one per unit cell of the underlying array.  Be aware that
``from'' and ``to'' positions are reported as being between elements.
If matching against a compact array <code>@foo</code>, a final position of 42
indicates that <code>@foo[42]</code> was the first element <em>not</em> included.
<p></p></ul>
<p>
<a href="#__index__"><small>Back to Top</small></a>
</p>
<hr />
<h1><a name="Matching20against20non2dstrings">Matching against non-strings</a></h1>
<a name="msg_2"></a>
<a href="?hide_quotes=no#msg_2" onclick="return tog_quote(2);">
<div ID=header_shown_2 style="display: none;">- Hide t/rules/nonstrings.t (line 9 ~ line 42) -
</div>
<div ID=header_hidden_2 style="display: block;">- Show t/rules/nonstrings.t (34 lines) -</div>
</a>
</p>
<div ID=hide_2 style="display:none; border:1px solid">
<pre>
L&lt;S05/"Matching against non-strings"&gt;

=cut

# String-like things...

my $fh = open($?FILE);
rule monster { dr\wgon }; # contrived pattern which does not match itself; we're going to look for it in this file
rule cheese { camembert | cheddar  };
my $stream;
eval '$stream is from($fh)';

eval_ok('$stream ~~ /&lt;cheese&gt;/', 'rules on streams, positive', :todo&lt;feature&gt;); # should match
eval_ok('! ($stream ~~ /&lt;monster&gt;/)', 'rules on streams, negative', :todo&lt;feature&gt;); # shouldn't match

# And arrays...

my Dog $a;
my Cat $b;
my Fish $c;

my @array = ($a, $b, $c);

eval_ok('rule canine { &lt;.isa(Dog)&gt; }; @array ~~ /&lt;canine&gt;/', 'rules on an array - positive', :todo&lt;feature&gt;);
eval_ok('rule herbivore { &lt;.isa(Antelope)&gt; }; ! @array ~~ /&lt;herbivore&gt;/', 'rules on an array - negative', :todo&lt;feature&gt;);
# These seem to be failing for some sort of scoping error rather than a problem with the 
# rule matching itself.

# And matching against each element of an array... a different topic really, but it's still in
# that bit of the synopsis.

my @names = ('zaphod', 'ford', 'arthur', 'slartibartfast');
my $arrr = rule { ar };
eval_is('@names&gt;&gt;.match($arrr)', 2, 'matching with hyper-operator', :todo&lt;feature&gt;);</pre>
</div><ul>
<li></li>
Anything that can be tied to a string can be matched against a
regex. This feature is particularly useful with input streams:
<pre>
     my $stream is from($fh);       # tie scalar to filehandle</pre>
<pre>
     # and later...</pre>
<pre>
     $stream ~~ m/pattern/;         # match from stream</pre>
<p></p>
<li></li>
Any non-compact array of mixed strings or objects can be matched
against a regex:
<pre>
    @array ~~ / foo &lt;,&gt; bar &lt;elem&gt;* /;</pre>
<p>The special <code>&lt;,&gt;</code> subrule matches the boundary between elements.
The <code>&lt;elem&gt;</code> assertion matches any individual array element.
It is the equivalent of the ``dot'' metacharacter for the whole element.</p>
<p>If the array elements are strings, they are concatenated virtually into
a single logical string.  If the array elements are tokens or other
such objects, the objects must provide appropriate methods for the
kinds of subrules to match against.  It is an assertion error to match
a string-matching assertion against an object that doesn't provide
a string view.  However, pure object lists can be parsed as long as
the match (including any subrules) restricts itself to assertions like:</p>
<pre>
     &lt;.isa(Dog)&gt;
     &lt;.does(Bark)&gt;
     &lt;.can('scratch')&gt;</pre>
<p>It is permissible to mix objects and strings in an array as long as they're
in different elements.  You may not embed objects in strings, however.
Any object may, of course, pretend to be a string element if it likes.</p>
<p>Please be aware that the warnings on <code>.from</code> and <code>.to</code> returning
opaque objects goes double for matching against an array, where a
particular position reflects both a position within the array and
(potentially) a position within a string of that array.  Do not
expect to do math with such values.  Nor should you expect to be
able to extract a substr that crosses element boundaries.</p>
<p></p>
<li></li>
To match against each element of an array, use a hyper operator:
<pre>
     @array».match($regex);</pre>
<p></p></ul>
<p><a href="#__index__"><small>Back to Top</small></a></p>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" valign="middle">
<big><strong><span class="block">&nbsp;TITLE</span></strong></big>
</td></tr>
</table>

</body>

</html>
