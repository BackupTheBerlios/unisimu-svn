<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
           "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>S03</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="http://dev.perl.org/css/perl.css">

<script type="text/javascript">
var agt = navigator.userAgent.toLowerCase();

var is_opera = (agt.indexOf("opera") != -1);
var is_ie = (agt.indexOf("msie") != -1) && document.all && !is_opera;
var is_ie5 = (agt.indexOf("msie 5") != -1) && document.all;

function tog() {
  // tog: toggle the visibility of html elements (arguments[1..]) from none to
  // arguments[0].  Return what should be returned in a javascript onevent().
  display = arguments[0];
  for( var i=1; i<arguments.length; i++ ) {
    var x = document.getElementById(arguments[i]);
    if (!x) continue;
    if (x.style.display == "none" || x.style.display == "") {
      x.style.display = display;
    } else {
      x.style.display = "none";
    }
  }

  var e = is_ie ? window.event : this;
  if (e) {
    if (is_ie) {
      e.cancelBubble = true;
      e.returnValue = false;
      return false;
    } else {
      return false;
    }
  }
}

function tog_quote( idnum ) {
  return tog( 'block', 'header_shown_' + idnum, 'header_hidden_' + idnum,
       'hide_' + idnum );
}

</script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.03,
  using Pod::Simple::PullParser v2.02,
  under Perl v5.008007 at Thu Aug 24 14:07:11 2006 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
            <strong>S03.html</strong> - generated by smartlinks.pl at Thu Aug 24 14:07:11 2006 GMT.
        
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Changes_to_Perl_5_operators'>Changes to Perl 5 operators</a>
  <li class='indexItem indexItem1'><a href='#New_operators'>New operators</a>
  <li class='indexItem indexItem1'><a href='#Smart_matching'>Smart matching</a>
  <li class='indexItem indexItem1'><a href='#Meta_operators'>Meta operators</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Assignment_operators'>Assignment operators</a>
    <li class='indexItem indexItem2'><a href='#Negated_relational_operators.'>Negated relational operators.</a>
    <li class='indexItem indexItem2'><a href='#Hyper_operators'>Hyper operators</a>
    <li class='indexItem indexItem2'><a href='#Reduction_operators'>Reduction operators</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Junctive_operators'>Junctive operators</a>
  <li class='indexItem indexItem1'><a href='#Chained_comparisons'>Chained comparisons</a>
  <li class='indexItem indexItem1'><a href='#Binding'>Binding</a>
  <li class='indexItem indexItem1'><a href='#Declarators'>Declarators</a>
  <li class='indexItem indexItem1'><a href='#Argument_List_Interpolating'>Argument List Interpolating</a>
  <li class='indexItem indexItem1'><a href='#Feed_operators'>Feed operators</a>
  <li class='indexItem indexItem1'><a href='#Invocant_marker'>Invocant marker</a>
  <li class='indexItem indexItem1'><a href='#Traversing_arrays_in_parallel'>Traversing arrays in parallel</a>
  <li class='indexItem indexItem1'><a href='#Minimal_whitespace_DWIMmery'>Minimal whitespace DWIMmery</a>
  <li class='indexItem indexItem1'><a href='#Precedence'>Precedence</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 3: Summary of Perl 6 Operators</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Luke Palmer &#60;luke@luqui.org&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre>  Maintainer: Larry Wall &#60;larry@wall.org&#62;
  Date: 8 Mar 2004
  Last Modified: 16 Aug 2006
  Number: 3
  Version: 56</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Changes_to_Perl_5_operators"
>Changes to Perl 5 operators</a></h1>

<p>Several operators have been given new names to increase clarity and better Huffman-code the language, while others have changed precedence. (If an operator is not mentioned in this Synopsis, assume that it remains the same as in Perl 5. And if that doesn&#39;t make sense, assume this document is faulty. :)</p>

<ul>
<li>Perl 5&#39;s <code>${...}</code>, <code>@{...}</code>, <code>%{...}</code>, etc. dereferencing forms are now <code>$(...)</code>, <code>@(...)</code>, <code>%(...)</code>, etc. instead.</li>

<li><code>-&#62;</code> becomes <code>.</code>, like the rest of the world uses.</li>

<li>The string concatenation <code>.</code> becomes <code>~</code>. Think of it as &#34;stitching&#34; the two ends of its arguments together. String append is likewise <code>~=</code>.</li>

<li>All postfix operators that do not start with a dot also have an alternate form that does. (The converse does not hold--just because you can write <code>x().foo</code> doesn&#39;t mean you can write <code>x()foo</code>.) In the absence of a postfix interpretation, the dot form will call the corresponding prefix operator instead. So <code>x().!</code> will call <code>!x()</code> unless someone defines a postfix <code>!</code> operator. In particular, you can say things like <code>$array.@</code> and <code>$filename.-e.-r</code>, but you can&#39;t say <code>$fh.=</code> because there&#39;s a <code>.=</code> operator already.</li>

<li>Unary <code>~</code> now imposes a string (<code>Str</code>) context on its argument, and <code>+</code> imposes a numeric (<code>Num</code>) context (as opposed to being a no-op in Perl 5). Along the same lines, <code>?</code> imposes a boolean (<code>Bool</code>) context, and the <code>[,]</code> list operator imposes a function-arguments (<code>Capture</code>) context on its arguments. Unary sigils impose the container context implied by their sigil. As with Perl 5, however, <code>$$foo[bar]</code> parses as <code>$($foo)[bar]</code>, so you need <code>$($foo[bar])</code> to mean the other way.
<a name="msg_26"></a>
<a href="?hide_quotes=no#msg_26" onclick="return tog_quote(26);">
<div ID="header_shown_26" style="display: none;">
- Hide the snippet from t/syntax/force_context.t (line 55 ~ line 74) -
</div>
<div ID="header_hidden_26" style="display: block;">
- Show the snippet from t/syntax/force_context.t (line 55 ~ line 74, 20 lines) -
</div>
</a>
<div ID="hide_26" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Changes to Perl 5 operators/"?" imposes boolean context&gt;
# boolean context
{
    my $a = '';
    is(ref(?$a), 'Bool', 'it is forced into a Bool');
    ok(!(?$a), 'it is forced into boolean context');

    my $b = 'This will be true';
    is(ref(?$b), 'Bool', 'it is forced into a Bool');
    ok(?$b, 'it is forced into boolean context');

    my $c = 0;
    is(ref(?$c), 'Bool', 'it is forced into a Bool');
    ok(!(?$c), 'it is forced into boolean context');

    my $d = 1;
    is(ref(?$d), 'Bool', 'it is forced into a Bool');
    ok(?$d, 'it is forced into boolean context');
}</pre>
</div>


<a name="msg_25"></a>
<a href="?hide_quotes=no#msg_25" onclick="return tog_quote(25);">
<div ID="header_shown_25" style="display: none;">
- Hide the snippet from t/syntax/force_context.t (line 38 ~ line 53) -
</div>
<div ID="header_hidden_25" style="display: block;">
- Show the snippet from t/syntax/force_context.t (line 38 ~ line 53, 16 lines) -
</div>
</a>
<div ID="hide_25" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Changes to Perl 5 operators/Unary ~ string context&gt;
# string context
{
    my $a = 10.500000;
    is(ref(~$a), 'Str', 'it is forced into a Str');
    is(~$a, '10.5', 'forced into string context');

    my $b = -100;
    is(ref(~$b), 'Str', 'it is forced into a Str');
    is(~$b, '-100', 'forced into string context');

    my $c = -100.1010;
    is(ref(~$c), 'Str', 'it is forced into a Str');
    is(~$c, '-100.101', 'forced into string context');
}</pre>
</div>

</li>

<li>Bitwise operators get a data type prefix: <code>+</code>, <code>~</code>, or <code>?</code>. For example, Perl 5&#39;s <code>|</code> becomes either <code>+|</code> or <code>~|</code> or <code>?|</code>, depending on whether the operands are to be treated as numbers, strings, or boolean values. Perl 5&#39;s left shift <code> &#60;&#60; </code> becomes <code> +&#60; </code>, and correspondingly with right shift. Perl 5&#39;s unary <code>~</code> (one&#39;s complement) becomes either <code>+^</code> or <code>~^</code> or <code>?^</code>, since a bitwise NOT is like an exclusive-or against solid ones. Note that <code>?^</code> is functionally identical to <code>!</code>, but conceptually coerces to boolean first and then flips the bit. Please use <code>!</code> instead.
<p><code>?|</code> is a logical OR but differs from <code>||</code> in that <code>?|</code> always evaluates both sides and returns a standard boolean value. That is, it&#39;s equivalent to <code>?$a + ?$b != 0</code>. Another difference is that it has the precedence of an additive operator.</p>

<p><code>?&#38;</code> is a logical AND but differs from <code>&#38;&#38;</code> in that <code>?&#38;</code> always evaluates both sides and returns a standard boolean value. That is, it&#39;s equivalent to <code>?$a * ?$b != 0</code>. Another difference is that it has the precedence of a multiplicative operator.</p>

<p>Bitwise string operators (those starting with <code>~</code>) may only be applied to <code>Buf</code> types or similar compact integer arrays, and treat the entire chunk of memory as a single huge integer. They differ from the <code>+</code> operators in that the <code>+</code> operators would try to convert the string to a number first on the assumption that the string was an ASCII representation of a number.</p>
</li>

<li><code>x</code> splits into two operators: <code>x</code> (which concatenates repetitions of a string to produce a single string), and <code>xx</code> (which creates a list of repetitions of a list or scalar). <code>&#34;foo&#34; xx *</code> represents an arbitrary number of copies, useful for initializing lists. The left side of an <code>xx</code> is evaluated only once. (To call a block repeatedly, use a <code>map</code> instead.)</li>

<li>The <code>? :</code> conditional operator becomes <code>?? !!</code>. It is a syntax error to use an operator in the middle that binds looser in precedence, such as <code>=</code>.</li>

<li><code>qw{ ... }</code> gets a synonym: <code> &#60; ... </code> &#62;, and an interpolating variant, <code>&#171;...&#187;</code>. For those still living without the blessings of Unicode, that can also be written: <code>&#60;&#60; ... &#62;&#62;</code>.</li>

<li>The scalar comma <code>,</code> now constructs a <code>List</code> object from its operands. You have to use a <code>[-1]</code> subscript to get the last one.</li>

<li>The unary backslash operator captures its arguments, and returns an object representing those arguments. You can <i>dereference</i> this object in several ways to retrieve different parts of the arguments; see the definition of <code>Capture</code> in S02 for details. (No whitespace is allowed after the backslash because that would instead start an &#34;unspace&#34;, that is, an escaped sequence of whitespace or comments. See S02 for details. However, oddly enough, because of that unspace rule, saying <code>\\ $foo</code> turns out to be equivalent to <code>\$foo</code>.)</li>

<li>The old scalar <code>..</code> flipflop operator is now done with <code>ff</code> operator. (<code>..</code> now always produces a <code>Range</code> object even in scalar context.) The <code>ff</code> operator may take a caret on either end to exclude either the beginning or ending. There is also a corresponding <code>fff</code> operator with Perl 5&#39;s <code>...</code> semantics. You may say
<pre>    /foo/ ff *</pre>

<p>to indicate a flipflop that never flops once flipped.</p>
</li>

<li>All comparison operators are unified at the same precedence level. See Chained Comparisons below.</li>

<li>The list assignment operator now parses on the right like any other list operator, so you don&#39;t need parens on the right side of:
<pre>    @foo = 1,2,3;</pre>

<p>You do still need them on the left for</p>

<pre>    ($a,$b,$c) = 1,2,3;</pre>

<p>since assignment operators are tighter than comma to their left.</p>
</li>

<li>The scalar assignment operator still parses as it did before, so
<pre>    loop ($a = 1, $b = 2; ; $a++, $b++) {...}</pre>

<p>still works fine. The syntactic distinction between scalar and list assignment is similar to the way Perl 5 defines it, but has to be a little different because we can no longer decide on the basis of the sigil. The following forms are parsed as &#34;simple lvalues&#34;, and imply scalar assignment:</p>

<pre>    $a          # simple scalar variable
    $(ANY)      # scalar dereference (including $$a)
    $::(ANY)    # symbolic scalar dereference
    ANY[SIMPLE] # single simple subscript
    ANY{SIMPLE} # single simple subscript
    ANY&#60;x&#62;      # single literal subscript</pre>

<p>Where SIMPLE is (recursively) defined as one of the forms above, plus the following forms:</p>

<pre>    123         # single literal
    &#39;x&#39;         # single literal
    &#34;$x&#34;        # single literal
    qq/$x/      # single literal
    +TERM       # any single term coerced to numeric
    -TERM       # any single term coerced to numeric</pre>

<a name="msg_24"></a>
<a href="?hide_quotes=no#msg_24" onclick="return tog_quote(24);">
<div ID="header_shown_24" style="display: none;">
- Hide the snippet from t/syntax/force_context.t (line 25 ~ line 36) -
</div>
<div ID="header_hidden_24" style="display: block;">
- Show the snippet from t/syntax/force_context.t (line 25 ~ line 36, 12 lines) -
</div>
</a>
<div ID="hide_24" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Changes to Perl 5 operators/"-TERM" "coerced to numeric"&gt;
# numeric (-) context
{
    my $a = '2 is my favorite number';
    is(ref(-$a), 'Num', 'it is forced into a Num');
    is(-$a, -2, 'forced into numeric context');

    my $b = 'Did you know that, 2 is my favorite number';
    is(ref(-$b), 'Num', 'it is forced into a Num');
    is(-$b, 0, 'non numbers forced into numeric context are 0');
}</pre>
</div>


<pre>    ~TERM       # any single term coerced to string
    ?TERM       # any single term coerced to boolean
    !TERM       # any single term coerced to boolean</pre>

<a name="msg_27"></a>
<a href="?hide_quotes=no#msg_27" onclick="return tog_quote(27);">
<div ID="header_shown_27" style="display: none;">
- Hide the snippet from t/syntax/force_context.t (line 75 ~ line 108) -
</div>
<div ID="header_hidden_27" style="display: block;">
- Show the snippet from t/syntax/force_context.t (line 75 ~ line 108, 34 lines) -
</div>
</a>
<div ID="hide_27" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Changes to Perl 5 operators/"!TERM" "coerced to boolean"&gt;
# ! boolean context
{
    my $a = '';
    is(ref(!$a), 'Bool', 'it is forced into a Bool');
    ok(!$a, 'it is forced into boolean context');

    my $b = 'This will be true';
    is(ref(!$b), 'Bool', 'it is forced into a Bool');
    ok(!(!$b), 'it is forced into boolean context');

    my $c = 0;
    is(ref(!$c), 'Bool', 'it is forced into a Bool');
    ok(!$c, 'it is forced into boolean context');

    my $d = 1;
    is(ref(!$d), 'Bool', 'it is forced into a Bool');
    ok(!(!$d), 'it is forced into boolean context');
}

# int context
{
    my $a = '2 is my favorite number';
    is(ref(int($a)), 'Int', 'it is forced into a Int');
    is(+$a, 2, 'forced into integer context');

    my $b = 'Did you know that, 2 is my favorite number';
    is(ref(int($b)), 'Int', 'it is forced into a Int');
    is(int($b), 0, 'non numbers forced into integer context are 0');

    my $c = 1.21122111;
    is(ref(int($c)), 'Int', 'it is forced into a Int');
    is(int($c), 1, 'float numbers forced into integer context are 0');
}</pre>
</div>


<pre>    (SIMPLE)    # any simple expression in circumfix parens</pre>

<p>Note that circumfix parens are considered simple only when used as part of a subscript. Putting parens around the entire lvalue still implies list context as in Perl 5.</p>

<p>We also include:</p>

<pre>    OP SIMPLE   
    SIMPLE OP
    SIMPLE OP SIMPLE</pre>

<p>where <code>OP</code> includes any standard scalar operators in the five precedence levels autoincrement, exponentiation, symbolic unary, multiplicative, and additive; but these are limited to standard operators that are known to return numbers, strings, or booleans.</p>

<p>Operators that imply list operations are excluded: prefix <code>@</code>, prefix <code>%</code> and infix <code>xx</code>, for instance. Hyper operators are also excluded, but post-assignment forms such as <code>SIMPLE += SIMPLE</code> are allowed.</p>

<p>All other forms imply parsing as a list assignment, which may or may not result in a list assignment at run time. (See below.) However, this is exclusively a syntactic distinction, and no semantic or type information is used, since it influences subsequent parsing. In particular, even if a function is known to return a scalar value from its declaration, you must use <code>+</code> or <code>~</code> if you wish to force scalar parsing from within a subscript:</p>

<pre>    @a[foo()] = bar();          # foo() and bar() called in list context
    @a[+foo()] = bar();         # foo() and bar() called in scalar context</pre>

<p>But note that the first form still works fine if <code>foo()</code> and <code>bar()</code> are scalar functions that are not context sensitive. The difference in parsing is only an issue if <code>bar()</code> is followed by a comma or some such.</p>

<p>For non-simple lvalues, at run time, both sides are evaluated in list context, but if the left side results in a single non-list scalar, the right side is treated as a single scalar value, as if the right side had been evaluated in list context (which is indeed the case) but coerced into scalar context.</p>

<p>If the left side returns a list, however, then regardless of whether the list contains a single or multiple values, the right side values are assigned one by one as in any other list assignment, discarding any extra values if the right side is too long, or assigning undef if the right side is too short. To force list assignment when a subscript would return a non-list, either put parens around the entire lvalue, or use a comma within the subscript. (A semicolon in the subscript also works to indicate multidimensional slices.)</p>

<p>Assuming</p>

<pre>    sub bar { return &#60;a b c&#62; }</pre>

<p>then we have:</p>

<pre>    sub foo { return 1,2,3 }
    @a[foo()] = bar();          # (@a[1,2,3]) = &#60;a b c&#62;

    sub foo { return 1 }
    @a[foo()] = bar();          # @a[1] = [&#60;a b c&#62;]

    sub foo { return(1) }
    @a[foo()] = bar();          # @a[1] = [&#60;a b c&#62;]

    sub foo { return (1) }
    @a[foo()] = bar();          # (@a[1]) = &#60;a b c&#62;

    sub foo { return 1 }
    @a[foo(),] = bar();         # (@a[1]) = &#60;a b c&#62;

    sub foo { return 1 }
    (@a[foo()]) = bar();        # (@a[1]) = &#60;a b c&#62;</pre>

<p>Those are all parsed as list assignments, but we get different run-time behaviors based on the run-time type of the left side.</p>

<p>In general, this will all just do what the user expects most of the time. The rest of the time scalar or list behavior can be forced with minimal syntax.</p>
</li>

<li>List operators are all parsed consistently. As in Perl 5, to the left a list operator look like term, while to the right it looks like an operator that is looser than comma. Unlike in Perl 5, the difference between the list operator form and the function form is consistently indicated via whitespace between the list operator and the first argument. If there is whitespace, it is always a list operator, and the next token will be taken as the first term of the list (or if there are no terms, as the expression terminator). Any infix operator occurring where a term is expected will be misinterpreted as a term:
<pre>    say + 2;    # means say(+2);</pre>

<p>If there is no whitespace, subsequent parsing depends on the syntactic category of the next item. Parentheses (with or without a dot) turn the list operator into a function call instead, and all the function&#39;s arguments must be passed inside the parentheses (with the sole exception of an adverbial block, which may follow the parentheses).</p>

<p>Other than various forms of parentheses, all other postfixes are disallowed immediately after a list operator, even if there are no arguments. To add a postfix to an argumentless list operator you must write it as a function call with empty parentheses:</p>

<pre>    foo.[]      # ILLEGAL
    foo++       # ILLEGAL
    foo().[]    # legal
    foo()++     # legal (if foo() is rw)</pre>

<p>After the parentheses any postfix operators are allowed, and apply to the result of the function call. (Also note that the postfix restriction applies only to list operators; it doesn&#39;t apply to methods. It is legal to say</p>

<pre>    $foo.bar&#60;a b c&#62;</pre>

<p>to mean</p>

<pre>    $foo.bar().{&#39;a&#39;,&#39;b&#39;,&#39;c&#39;}</pre>

<p>because methods never assume there are arguments unless followed by parentheses or a colon.)</p>

<p>If the next item after the list operator is either an infix operator or a term, a syntax error is reported. [Conjecture: this may be relaxed in non-strict mode.]</p>

<p>Examples:</p>

<pre>    say foo + 1;                        say(foo(+1));
    say foo $x;                         say(foo($x));
    say foo$x;                          ILLEGAL, need space or parens
    say foo+1;                          ILLEGAL, need space or parens
    say foo++;                          ILLEGAL, need parens

    say foo($bar+1),$baz                say(foo($bar+1), $baz);
    say foo.($bar+1),$baz               say(foo($bar+1), $baz);
    say foo ($bar+1),$baz               say(foo($bar+1, $baz));
    say foo .($bar+1),$baz              say(foo($_.($bar+1), $baz));

    say foo[$bar+1],$baz                ILLEGAL, need foo()[]
    say foo.[$bar+1],$baz               ILLEGAL, need foo().[]
    say foo [$bar+1],$baz               say(foo([$bar+1], $baz));
    say foo .[$bar+1],$baz              say(foo($_.[$bar+1], $baz));

    say foo{$bar+1},$baz                ILLEGAL, need foo(){}
    say foo.{$bar+1},$baz               ILLEGAL, need foo().{}
    say foo {$bar+1},$baz               say(foo({$bar+1}, $baz));
    say foo .{$bar+1},$baz              say(foo($_.{$bar+1}, $baz));

    say foo&#60;$bar+1&#62;,$baz                ILLEGAL, need foo()&#60;&#62;
    say foo.&#60;$bar+1&#62;,$baz               ILLEGAL, need foo().&#60;&#62;
    say foo &#60;$bar+1&#62;,$baz               say(foo(&#60;$bar+1&#62;, $baz));
    say foo .&#60;$bar+1&#62;,$baz              say(foo($_.&#60;$bar+1&#62;, $baz));</pre>

<p>Note that Perl 6 is making a consistent three-way distinction between term vs postfix vs infix, and will interpret an overloaded character like <code>&#60;</code> accordingly:</p>

<pre>    any &#60;a b c&#62;                 any(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)        # term
    any()&#60;a b c&#62;                (any).{&#39;a&#39;,&#39;b&#39;,&#39;c&#39;}     # postfix
    any() &#60; $x                  (any) &#60; $x              # infix
    any&#60;a b c&#62;                  ILLEGAL                 # stealth postfix</pre>

<p>This will seem unfamiliar and &#34;undwimmy&#34; to Perl 5 programmers, who are used to a grammar that sloppily hardwires a few postfix operators at the price of extensibility. Perl 6 chooses instead to mandate a whitespace dependency in order to gain a completely extensible class of postfix operators.</p>
</li>

<li>A list operator&#39;s arguments are also terminated by a closure that is not followed by a comma or colon. (And a semicolon is implied if the closure is the final thing on a line. Use an &#34;unspace&#34; to suppress that.) This final closure may be followed by a postfix, in which case the postfix is applied to the result of the entire list operator.</li>

<li>A function predeclared as 0-ary is never considered list operator, though it allows an optional set of empty parentheses. Unlike functions and list operators with arguments (see above), a 0-ary function does not require parentheses even if followed immediately by a postfix.</li>

<li>A non-multi sub predeclared with an arity of exactly 1 parses as a named unary in precedence. All other subs with arguments parse as list operators. (In other words, a named unary operator may be declared to take extra arguments only if they are named-only arguments.)</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="New_operators"
>New operators</a></h1>

<a name="msg_7"></a>
<a href="?hide_quotes=no#msg_7" onclick="return tog_quote(7);">
<div ID="header_shown_7" style="display: none;">
- Hide the snippet from t/operators/operator.t (line 8 ~ line 84) -
</div>
<div ID="header_hidden_7" style="display: block;">
- Show the snippet from t/operators/operator.t (line 8 ~ line 84, 77 lines) -
</div>
</a>
<div ID="hide_7" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S03/"New operators"&gt;
=cut

plan 29;

my $str1 = "foo";
my $str2 = "bar";
my $str3 = "foobar";
my $str4 = $str1~$str2;

is($str3, $str4, "~");

my $bar = "";
($str3 eq $str4) ?? ($bar = 1) !! ($bar = 0);

ok($bar, "?? !!");

my $five = 5;
my $four = 4;
my $wibble = 4;

ok(!($five == $four), "== (false)");
ok($wibble == $four, "== (true)");
ok(!($wibble != $four), "== (false)");
ok($five != $four, "!= (true)");

ok($five == 5, "== (const on rhs)");
ok(!($five != 5), "!= (const on rhs)");

ok(5 == $five, "== (const on lhs)");
ok(!(5 != $five), "!= (const on lhs)");

ok($five == (2 + 3), "== (sum on rhs)");
ok(!($five != (2 + 3)), "== (sum on rhs)");

is(2 + 3, $five, "== (sum on lhs)");
ok((2 + 3) == 5, "== (sum on lhs)");
ok(!((2 + 3) != $five), "== (sum on lhs)");

# String Operations
is("text " ~ "stitching", "text stitching", 'concatenation with ~ operator');

# Bit Stitching

is(2 || 3, 2, "|| returns first true value");
is(2 ?| 3, 1, "boolean or (?|) returns 0 or 1");
ok(!(defined( 0 || undef)), "|| returns last false value of list?");
is(0 ?| undef, 0, "boolean or (?|) returns 0 or 1", :todo);

#junctions

ok((all((4|5|6) + 3) == one(7|8|9)), "all elements in junction are incremented");
ok((any(1..6) == one(1|2|3|4|5|6)), "any elements will match via junction");


ok( 7 &gt; any(4..12), "any test against scalar" );


my @oldval  = (5, 8, 12);

my @newval1 = (17, 15, 14); # all greater
my @newval2 = (15, 7,  20); # some less some greater
my @newval3 = (3, 1, 4);    # all less
my @newval4 = (1,2,40);     

ok( any(@newval4) &gt; any(@oldval), "any test array against any array" );
ok( any(@newval4) &gt; all(@oldval), "any test array against all array" );
ok( all(@newval2) &gt; any(@oldval), "all test array against any array" );
ok( all(@newval1) &gt; all(@oldval), "all test array against all array" );

ok(42 &gt; 12 &amp; 20 &amp; 32, "test the all infix operator");


# Hyper ops
my @rv;
@rv = (1,2,3,4) &gt;&gt;+&lt;&lt; (1,2,3,4);
is("@rv[]", "2 4 6 8", 'hyper-add');</pre>
</div>


<ul>
<li>Binary <code>//</code> is just like <code>||</code>, except that it tests its left side for definedness instead of truth. There is a low-precedence form, too: <code>err</code>.</li>

<li>Binary <code>===</code> tests immutable type and value correspondence: for two value types (that is, immutable types), tests whether they are the same value (eg. <code>1 === 1</code>); for two mutable types (object types), checks whether they have the same identity value. (For most such types the identity is simply the reference itself.) It is not true that <code>[1,2] === [1,2]</code> because those are different <code>Array</code> objects, but it is true that <code>@a === @a</code> because those are the same <code>Array</code> object).
<p>Any object type may pretend to be a value type by defining a <code>.SKID</code> method which returns a value type that can be recursively compared using <code>===</code>, or in cases where that is impractical, by overloading <code>===</code> such that the comparison treats values consistently with their &#34;eternal&#34; identity. (Strings are defined as values this way despite also being objects.)</p>

<p>Two values are never equivalent unless they are of exactly the same type. By contrast, <code>eq</code> always coerces to string, while <code>==</code> always coerces to numeric. In fact, <code>$a eq $b</code> really means &#34;<code>~$a === ~$b</code>&#34; and <code>$a == $b</code> means <code>+$a === +$b</code>.</p>

<p>Note also that, while string hashes use <code>eq</code> semantics by default, object hashes use <code>===</code> semantics.</p>
</li>

<li>Binary <code>eqv</code> tests equality much like <code>===</code> does, but does so with &#34;snapshot&#34; semantics rather than &#34;eternal&#34; semantics. For top-level components of your value that are of immutable types, <code>eqv</code> is identical in behavior to <code>===</code>. For components of your value that are mutable, however, rather than comparing object identity using <code>===</code>, the <code>eqv</code> operator tests whether the canonical representation of both subvalues would be identical if we took a snapshot of them right now and compared those (now-immutable) snapshots using <code>===</code>.
<p>If that&#39;s not enough flexibility, there is also an <code>eqv()</code> function that can be passed additional information specifying how you want canonical values to be generated before comparison. This gives <code>eqv()</code> the same kind of expressive power as a sort signature. (And indeed, the <code>cmp</code> operator from Perl 5 also has a functional analog, <code>cmp()</code>, that takes additional instructions on how to do 3-way comparisons of the kind that a sorting algorithm wants.) In particular, a signature passed to <code>eqv()</code> will be bound to the two operands in question, and then the comparison will proceed on the formal parameters according to the information contained in the signature, so you can force numeric, string, natural, or other comparisons with proper declarations of the parameter&#39;s type and traits. If the signature doesn&#39;t match the operands, <code>eqv()</code> reverts to standard <code>eqv</code> comparison. (Likewise for <code>cmp()</code>.)</p>
</li>

<li>Binary <code>cmp</code> is no longer the comparison operator that forces stringification. Use the <code>leg</code> operator for the old Perl 5 <code>cmp</code> semantics. The <code>cmp</code> is just like the <code>eqv</code> above except that instead of returning <code>Bool::False</code> or <code>Bool::True</code> values it always returns <code>Order::Increase</code>, <code>Order::Same</code>, or <code>Order::Decrease</code> (which numerify to -1, 0, or +1).</li>

<li>the <code>leg</code> operator (less than, equal, or greater) is defined in terms of <code>cmp</code>, so <code>$a leg $b</code> is now defined as <code>~$a cmp ~$b</code>. The sort operator still defaults to <code>cmp</code> rather than <code>leg</code>. The <code>&#60;=&#62;</code> operator&#39;s semantics are unchanged except that it returns an <code>Order</code> value as described above. In other words, <code>$a &#60;=&#62; $b</code> is now equivalent to <code>+$a cmp +$b</code>.</li>

<li>Binary <code>=&#62;</code> is no longer just a &#34;fancy comma&#34;. It now constructs a <code>Pair</code> object that can, among other things, be used to pass named arguments to functions. It provides scalar context to both sides. Its precedence is now equivalent to assignment, and it is right associative.</li>

<li><code>^^</code> is the high-precedence version of <code>xor</code>.</li>

<li><code>=~</code> becomes the &#34;smart match&#34; operator <code>~~</code>, with a whole new set of semantics. Anywhere you used <code>=~</code> before you now use <code>~~</code>, but <code>~~</code> is much more general now. See &#34;Smart matching&#34; below for details. (To catch &#34;brainos&#34;, the Perl 6 parser defines an <code>infix:&#60;=~&#62;</code> macro which always fails at compile time with a message directing the user either to use <code>~~</code> or <code>~=</code> (string append) instead, or to put a space between if they really wanted to assign a stringified value.) A negated smart match is spelled <code>!~~</code>.</li>

<li>&#34;Unary&#34; <code>.</code> calls its single argument (which must be a postfix operator) on <code>$_</code>. (It&#39;s not really a unary operator, so we put it in quotes.)</li>

<li>The <code>..</code> range operator has variants with <code>^</code> on either end to indicate exclusion of that endpoint from the range. It always produces a <code>Range</code> object. Range objects are lazy iterators, and can be interrogated for their current <code>.min</code> and <code>.max</code> values (which change as they are iterated). Ranges are not autoreversing: <code>2..1</code> is always a null range, as is <code>1^..^2</code>. To reverse a range use:
<pre>    2..1:by(-1)
    reverse 1..2</pre>

<p>(The <code>reverse</code> is preferred because it works for alphabetic ranges as well.)</p>

<p>Because <code>Range</code> objects are lazy, they do not automatically generate a list. So smart matching against a <code>Range</code> object smartmatches the endpoints in the domain of the object being matched, so fractional numbers are <code>not</code> truncated before comparison to integer ranges:</p>

<pre>    1.5 ~~ 1^..^2  # true, equivalent to 1 &#60; 1.5 &#60; 2
    2.1 ~~ 1..2    # false, equivalent to 1 &#60;= 2.1 &#60;= 2</pre>

<p>If a <code>*</code> (see the &#34;Whatever&#34; type in S02) occurs on the right side of a range, it is taken to mean &#34;positive infinity&#34; in whatever space the range is operating. A <code>*</code> on the left means &#34;negative infinity&#34; for types that support negative values. If the <code>*</code> occurs on one side but not the other, the type is inferred from the other argument. A star on both sides will match any value that supports the <code>Ordered</code> role.</p>

<pre>    0..*        # 0 .. +Inf
    &#39;a&#39;..*      # &#39;a&#39; .. &#39;zzzzzzzzzzzzzzzzzzzzzzzzzzzzz...&#39;
    *..0        # -Inf .. 0
    *..*        # &#34;-Inf .. +Inf&#34;, really Ordered
    1.2.3..*    # Any version higher than 1.2.3.</pre>

<p>Note: infinite lists are constructed lazily. And even though <code>*..*</code> can&#39;t be constructed at all, it&#39;s still useful as a selector object.</p>
</li>

<li>The unary <code>^</code> operator generates a range from <code>0</code> up to one less than its argument. So <code>^4</code> is short for <code>0..^4</code> or <code>0..3</code>.
<pre>    for ^4 { say $_ } # 0, 1, 2, 3</pre>

<p>If applied to a list, it generates a multidimensional set of subscripts.</p>

<pre>    for ^(3,3) { ... } # (0,0)(0,1)(0,2)(1,0)(1,1)(1,2)(2,0)(2,1)(2,2)</pre>

<p>If applied to a type name, it indicates the metaclass instance instead, so <code>^Moose</code> is short for <code>META(Moose)</code> or <code>Moose.META</code>. It still kinda means &#34;what is this thing&#39;s domain&#34; in an abstract sort of way.</p>
</li>

<li>The <code>...</code> operator is the &#34;yada, yada, yada&#34; list operator, which is used as the body in function prototypes. It complains bitterly (by calling <code>fail</code>) if it is ever executed. Variant <code>???</code> calls <code>warn</code>, and <code>!!!</code> calls <code>die</code>. The argument is optional, but if provided, is passed onto the <code>fail</code>, <code>warn</code>, or <code>die</code>. Otherwise the system will make up a message for you based on the context, indicating that you tried to execute something that is stubbed out. (This message differs from what <code>fail</code>, <code>warn</code>, and <code>die</code> would say by default, since the latter operators typically point out bad data or programming rather than just an incomplete design.)</li>

<li>In addition to the ordinary <code>.</code> method invocation, there are variants <code>.*</code>, <code>.?</code>, and <code>.+</code> to control how multiple related methods of the same name are handled. The <code>.=</code> operator does inplace modification of the object on the left. The <code>.^</code> operator calls a class metamethod; <code>foo.^bar</code> is short for <code>foo.META.bar</code>.</li>

<li>Unary <code>=</code> reads lines from a filehandle or filename, or iterates an iterator, or in general causes a scalar to explode its guts when it would otherwise not. How it does that is context sensitive. For instance, <code>=$iterator</code> is scalar/list sensitive and will produce one value in scalar context but many values in list context. (Use <code>@$iterator</code> to force a fetch of all the values even in scalar context, and <code>$$iterator</code> to force a fetch of a single value even in list context.) On the other hand, <code>=$capture</code> interpolates all parts of the capture that makes sense in the current list context, depending on what controls that list context.</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Smart_matching"
>Smart matching</a></h1>

<p>Here is the current table of smart matches. The list is intended to reflect forms that can be recognized at compile time. If none of these forms is recognized at compile time, it falls through to do MMD to <code>infix:&#60;~~&#62;()</code>, which presumably reflects similar semantics, but can finesse things that aren&#39;t exact type matches. Note that all types are scalarized here. Both <code>~~</code> and <code>given</code>/<code>when</code> provide scalar contexts to their arguments. (You can always hyperize <code>~~</code> explicitly, though.) So both <code>$_</code> and <code>$x</code> here are potentially references to container objects. And since lists promote to arrays in scalar context, there need be no separate entries for lists.</p>

<pre>    $_      $x        Type of Match Implied    Matching Code
    ======  =====     =====================    =============
    Any     Code:($)   scalar sub truth         match if $x($_)
    Hash    Hash      hash keys identical      match if $_.keys.sort &#187;eq&#171; $x.keys.sort
    Hash    any(Hash) hash key intersection    match if $_{any(Hash.keys)}
    Hash    Array     hash value slice truth   match if $_{any(@$x)}
    Hash    any(list) hash key slice existence match if exists $_{any(list)}
    Hash    all(list) hash key slice existence match if exists $_{all(list)}
    Hash    Regex     hash key grep            match if any($_.keys) ~~ /$x/
    Hash    Any       hash entry existence     match if exists $_{$x}
    Hash    .{Any}    hash element truth*      match if $_{Any}
    Hash    .&#60;string&#62; hash element truth*      match if $_&#60;string&#62;
    Array   Array     arrays are comparable    match if $_ &#187;~~&#171; $x
    Array   any(list) list intersection        match if any(@$_) ~~ any(list)
    Array   Regex     array grep               match if any(@$_) ~~ /$x/
    Array   Num       array contains number    match if any($_) == $x
    Array   Str       array contains string    match if any($_) eq $x
    Array   .[number] array element truth*     match if $_[number]
    Num     NumRange  in numeric range         match if $min &#60;= $_ &#60;= $max
    Str     StrRange  in string range          match if $min le $_ le $max
    Capture Signature parameter binding        match if $cap can bind to $sig
    Code    Signature signature compatibility* match if $_ is a subset of $x
  Signature Signature signature compatibility  match if $_ is a subset of $x
    Any     Code:()   simple closure truth*    match if $x() (ignoring $_)
    Any     Class     class membership         match if $_.does($x)
    Any     Role      role playing             match if $_.does($x)
    Any     Num       numeric equality         match if $_ == $x
    Any     Str       string equality          match if $_ eq $x
    Any     .method   method truth*            match if $_.method
    Any     Regex     pattern match            match if $_ ~~ /$x/
    Any     subst     substitution match*      match if $_ ~~ subst
    Any     boolean   simple expression truth* match if $x.true given $_
    Any     undef     undefined                match unless defined $_
    Any     Whatever  default                  match anything
    Any     Any       run-time dispatch        match if infix:&#60;~~&#62;($_, $x)</pre>

<p>Matches marked with * are non-reversible, typically because <code>~~</code> takes its left side as the topic for the right side, and sets the topic to a private instance of <code>$_</code> for its right side, so <code>$_</code> means something different on either side. Such non-reversible constructs can be made reversible by putting the leading term into a closure to defer the binding of <code>$_</code>. For example:</p>

<pre>    $x ~~ .does(Storable)       # okay
    .does(Storable) ~~ $x       # not okay--gets wrong $_ on left
    { .does(Storable) } ~~ $x   # okay--closure binds its $_ to $x</pre>

<p>Exactly the same consideration applies to <code>given</code> and <code>when</code>:</p>

<pre>    given $x { when .does(Storable) {...} }      # okay
    given .does(Storable) { when $x {...} }      # not okay
    given { .does(Storable) } { when $x {...} }  # okay</pre>

<p>Boolean expressions are those known to return a boolean value, such as comparisons, or the unary <code>?</code> operator. They may reference <code>$_</code> explicitly or implicitly. If they don&#39;t reference <code>$_</code> at all, that&#39;s okay too--in that case you&#39;re just using the switch structure as a more readable alternative to a string of elsifs. Note, however, that this means you can&#39;t write:</p>

<pre>    given $boolean {
        when True {...}
        when False {...}
    }</pre>

<p>because it will always choose the <code>True</code> case. Instead use something like:</p>

<pre>    given $boolean {
        when .true {...}
        when .not {...}
    }</pre>

<p>Better, just use an <code>if</code> statement.</p>

<p>The primary use of the <code>~~</code> operator is to return a boolean value in a boolean context. However, for certain operands such as regular expressions, use of the operator within scalar or list context transfers the context to that operand, so that, for instance, a regular expression can return a list of matched substrings, as in Perl 5. The complete list of such operands is TBD.</p>

<p>It has not yet been determined if run-time dispatch of <code>~~</code> will attempt to emulate the compile-time precedence table before reverting to MMD, or just go directly to MMD. There are good arguments for both sides, and we can decide when we see more examples of how it&#39;ll work out.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Meta_operators"
>Meta operators</a></h1>

<p>Perl 6&#39;s operators have been greatly regularized, for instance, by consistently prefixing numeric, stringwise, and boolean operators with <code>+</code>, <code>~</code> and <code>?</code> respectively to indicate whether the bitwise operation is done on a number, a string, or a single bit. But that&#39;s just a naming convention, and if you wanted to add a new bitwise <code>&#172;</code> operator, you&#39;d have the add the <code>+&#172;</code>, <code>~&#172;</code>, and <code>?&#172;</code> operators yourself. Similarly, the carets that exclude the endpoints on ranges are there by convention only.</p>

<p>In contrast to that, Perl 6 has four standard metaoperators for turning a given existing operator into a related operator that is more powerful (or at least differently powerful). These differ from a mere naming convention in that Perl automatically generates these new metaoperators from user-defined operators as well as from builtins. In fact, you&#39;re not generally supposed to define the individual metaoperations--their semantics are supposed to be self-evident by the transformation of the base operator.</p>

<p>Note: spaces are never allowed between any metaoperator and the operator it&#39;s modifying, because all operators including modified ones have to be recognized by the Longest-Token Rule, which disallows spaces within a token.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Assignment_operators"
>Assignment operators</a></h2>

<p>These are already familiar to C and Perl programmers. (Though the <code>.=</code> operator now means to call a mutating method on the object on the left, and <code>~=</code> is string concatenation.) Most non-relational infix operators may be turned into their corresponding assignment operator by suffixing with <code>=</code>. The limitation is actually based on whether the left side can function both as an rvalue and an lvalue by the usual correspondence:</p>

<pre>    A op= B;
    A = A op B;</pre>

<p>Existing forms ending in <code>=</code> may not be modified with this metaoperator.</p>

<p>Regardless of the precedence of the base operator, the precedence of any assignment operators is forced to be the same as that of ordinary assignment.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Negated_relational_operators."
>Negated relational operators.</a></h2>

<p>Any infix relational operator may be transformed into its negative by prefixing with <code>!</code>. A couple of these have traditional shortcuts:</p>

<pre>    Full form   Shortcut
    ---------   --------
    !==         !=
    !eq         ne</pre>

<p>but most of them do not:</p>

<pre>    !~~
    !&#60;
    !&#62;=
    !ge
    !===
    !eqv
    !=:=</pre>

<p>To avoid visual confusion with the <code>!!</code> operator, you may not modify any operator already beginning with <code>!</code>.</p>

<p>The precedence of any negated operator is the same as the base operator.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Hyper_operators"
>Hyper operators</a></h2>

<p>The Unicode characters <code>&#187;</code> (<code>\x[BB]</code>) and <code>&#171;</code> (<code>\x[AB]</code>) and their ASCII digraphs <code>&#62;&#62;</code> and <code>&#60;&#60;</code> are used to denote &#34;list operations&#34;, which operate on each element of two lists (or arrays) and return a list (or array) of the results. Spaces are not allowed on the &#34;pointy&#34; end of each &#34;hyper&#34;, but are allowed on the blunt end (except for postfix operators, which must still follow postfix spacing rules, but do allow for an additional dot before the &#34;hyper&#34;).</p>

<p>The precedence of any hyperoperator is the same as its base operator. This means that you must parenthesize your lists for most operators. For example:</p>

<pre>     (1,1,2,3,5) &#187;+&#171; (1,2,3,5,8);  # (2,3,5,8,13)</pre>

<p>If either argument is insufficiently dimensioned, Perl &#34;upgrades&#34; it:</p>

<pre>     (3,8,2,9,3,8) &#62;&#62;-&#60;&#60; 1;          # (2,7,1,8,2,7)</pre>

<p>In fact, this is the <i>only</i> form that will work for an unordered type such as a <code>Bag</code>:</p>

<pre>     Bag(3,8,2,9,3,8) &#62;&#62;-&#60;&#60; 1;       # Bag(2,7,1,8,2,7) ~~ Bag(1,2,2,7,7,8)</pre>

<p>When using a unary operator, only put the &#34;hyper&#34; on the side of the single operand:</p>

<pre>     @negatives = -&#171; @positives;

     @positions&#187;++;            # Increment all positions

     @positions.&#187;++;           # Same thing, dot form
     @positions&#187;.++;           # Same thing, dot form
     @positions.&#187;.++;          # Same thing, dot form
     @positions\  .&#187;\  .++;    # Same thing, long dot form

     @objects.&#187;.run();
     (&#34;f&#34;,&#34;oo&#34;,&#34;bar&#34;).&#62;&#62;.chars;   # (1,2,3)</pre>

<p>Note that method calls are really postfix operators, not infix, so you shouldn&#39;t put a <code>&#171;</code> after the dot.</p>

<p>Hyper operators are defined recursively on arrays, so:</p>

<pre>    -&#171; [[1, 2], 3]               #    [-&#171;[1, 2], -&#171;3]
                                 # == [[-1, -2], -3]
    [[1, 2], 3] &#187;+&#171; [4, [5, 6]]  #    [[1,2] &#187;+&#171; 4, 3 &#187;+&#171; [5, 6]]
                                 # == [[5, 6], [8, 9]]</pre>

<p>More generally, hyper operators work recursively for any object matching the <code>Each</code> role even if the object itself doesn&#39;t support the operator in question:</p>

<pre>    Bag(3,8,[2,Seq(9,3)],8) &#62;&#62;-&#60;&#60; 1;         # Bag(2,7,[1,Seq(8,2)],7)
    Seq(3,8,[2,Seq(9,3)],8) &#62;&#62;-&#60;&#60; (1,1,2,1); # Seq(2,7,[0,Seq(7,1)],7)</pre>

<p>In particular, tree node types with <code>Each</code> semantics enable visitation:</p>

<pre>    $tree.&#187;.foo;        # short for $tree.foo, $tree.each: { .&#187;.foo }</pre>

<p>If not all nodes support the operation, you need a form of it that specifies the call is optional:</p>

<pre>    $tree.&#187;.?foo;       # short for $tree.?foo, $tree.each: { .&#187;.?foo }
    $tree.&#187;.*foo;       # short for $tree.*foo, $tree.each: { .&#187;.*foo }</pre>

<p>You are not allowed to define your own hyper operators, because they are supposed to have consistent semantics derivable entirely from the modified scalar operator. If you&#39;re looking for a mathematical vector product, this isn&#39;t where you&#39;ll find it. A hyperoperator is one of the ways that you can promise to the optimizer that your code is parallelizable. (The tree visitation above is allowed to have side effects, but it is erroneous for the meaning of those side effects to depend on the order of visitation. [Conjecture: we could allow dependencies that assume top-down visitation and only leaves sibling calls unordered.])</p>

<p>Even in the absence of hardware that can do parallel processing, hyperoperators may be faster than the corresponding scalar operators if they can factor out looping overhead to lower-level code, or can apply loop-unrolling optimizations, or can factor out some or all of the MMD dispatch overhead, based on the known types of the operands (and also based on the fact that hyper operators promise no interaction among the &#34;iterations&#34;, whereas the corresponding scalar operator in a loop cannot make the same promise unless all the operations within the loop are known to be side-effect free.)</p>

<p>In particular, infix hyperops on two <code>int</code> or <code>num</code> arrays need only do a single MMD dispatch to find the correct function to call for all pairs, and can further bypass any type-checking or type-coercion entry points to such functions when there are known to be low-level entry points of the appropriate type. (And similarly for unary <code>int</code> or <code>num</code> ops.)</p>

<p>Application-wide analysis of finalizable object types may also enable such optimizations to be applied to <code>Int</code>, <code>Num</code>, and such. In the absence of that, run-time analysis of partial MMD dispatch may save some MMD searching overhead. Or particular object arrays might even keep track of their own run-time type purity and cache partial MMD dispatch tables when they know they&#39;re likely to be used in hyperops.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Reduction_operators"
>Reduction operators</a></h2>

<a name="msg_9"></a>
<a href="?hide_quotes=no#msg_9" onclick="return tog_quote(9);">
<div ID="header_shown_9" style="display: none;">
- Hide the snippet from t/subroutines/multi_sub.t (line 69 ~ line 86) -
</div>
<div ID="header_hidden_9" style="display: block;">
- Show the snippet from t/subroutines/multi_sub.t (line 69 ~ line 86, 18 lines) -
</div>
</a>
<div ID="hide_9" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/"Reduction operators"&gt;

proto prefix:&lt;[+]&gt; (*@args) {
    my $accum = 0;
    $accum += $_ for @args;
    return $accum * 2; # * 2 is intentional here
}

is ([+] 1,2,3), 12, "[+] overloaded by proto definition";

# more similar tests

proto prefix:&lt;moose&gt; ($arg) { $arg + 1 }
is (moose 3), 4, "proto definition of prefix:&lt;moose&gt; works";

proto prefix:&lt;elk&gt; ($arg) {...}
multi prefix:&lt;elk&gt; ($arg) { $arg + 1 }
is (elk 3), 4, "multi definition of prefix:&lt;elk&gt; works";</pre>
</div>


<a name="msg_8"></a>
<a href="?hide_quotes=no#msg_8" onclick="return tog_quote(8);">
<div ID="header_shown_8" style="display: none;">
- Hide the snippet from t/operators/reduce_le1arg.t (line 6 ~ line 58) -
</div>
<div ID="header_hidden_8" style="display: block;">
- Show the snippet from t/operators/reduce_le1arg.t (line 6 ~ line 58, 53 lines) -
</div>
</a>
<div ID="hide_8" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/"Reduction operators"&gt;

is ([**] ()), 1, "[**] () eq 1 (arguably nonsensical)";
is ([*] ()), 1, "[*] () eq 1";
dies_ok( { [/] () }, "[/] () should fail");
dies_ok( { [%] () }, "[%] () should fail");
dies_ok( { [x] () }, "[x] () should fail");
dies_ok( { [xx] () }, "[xx] () should fail");
is ([+&amp;] ()), +^0, "[+&amp;] () eq +^0";
dies_ok( { [+&lt;] () }, "[+&lt;] () should fail");
dies_ok( { [+&gt;] () }, "[+&gt;] () should fail");
dies_ok( { [~&amp;] () }, "[~&amp;] () should fail");
dies_ok( { [~&lt;] () }, "[~&lt;] () should fail");
dies_ok( { [~&gt;] () }, "[~&gt;] () should fail");
is ([+] ()), 0, "[+] () eq 0";
is ([-] ()), 0, "[-] () eq 0";
is ([~] ()), '', "[~] () eq ''";
is ([+|] ()), 0, "[+|] () eq 0";
is ([+^] ()), 0, "[+^] () eq 0";
is ([~|] ()), '', "[~|] () eq ''";
is ([~^] ()), '', "[~^] () eq ''";
# eval_is "[&amp;] ()", all(), "[&amp;] () eq all()";
# eval_is "[|] ()", any(), "[|] () eq any()";
# eval_is "[^] ()", one(), "[^] () eq one()";
eval_is "[!==] ()", Bool::False, "[!==] () eq False";
is ([==] ()), Bool::True, "[==] () eq True";
is ([&lt;] ()), Bool::True, "[&lt;] () eq True";
is ([&lt;=] ()), Bool::True, "[&lt;=] () eq True";
is ([&gt;] ()), Bool::True, "[&gt;] () eq True";
is ([&gt;=] ()), Bool::True, "[&gt;=] () eq True";
is ([~~] ()), Bool::True, "[~~] () eq True";
eval_is "[!~~] ()", Bool::False, "[!~~] () eq False";
is ([eq] ()), Bool::True, "[eq] () eq True)";
eval_is "[!eq] ()", Bool::False, "[!eq] () eq False";
is ([lt] ()), Bool::True, "[lt] () eq True";
is ([le] ()), Bool::True, "[le] () eq True";
is ([gt] ()), Bool::True, "[gt] () eq True";
is ([ge] ()), Bool::True, "[ge] () eq True";
is ([=:=] ()), Bool::True, "[=:=] () eq True";
eval_is "[!=:=] ()", Bool::False, "[!=:=] () eq False";
is ([===] ()), Bool::True, "[===] () eq True";
eval_is "[!===] ()", Bool::False, "[!===] () eq False";
eval_is "[eqv] ()", Bool::True, "[eqv] () eq True";
eval_is "[!eqv] ()", Bool::False, "[!eqv] () eq False";
is ([&amp;&amp;] ()), Bool::True, "[&amp;&amp;] () eq True";
is ([||] ()), Bool::False, "[||] () eq False";
is ([^^] ()), Bool::False, "[^^] () eq False";
is (defined ([//] ())), Bool::False, "[//] () not defined";
is (defined ([=] ())), Bool::False, "[=] () not defined";
is ([,] ()), (), "[,] () eq ()";
eval_is "[¥] ()", [], "[¥] () eq []";

# need to add one elems list cases</pre>
</div>


<p>The final metaoperator in Perl 6 is the reduction operator. Any infix operator (except for non-associating operators and assignment operators) can be surrounded by square brackets in term position to create a list operator that reduces using that operation:</p>

<pre>    [+] 1, 2, 3;      # 1 + 2 + 3 = 6
    my @a = (5,6);
    [*] @a;           # 5 * 6 = 30</pre>

<p>As with all the metaoperators, space is not allowed inside. The whole thing parses as a single token.</p>

<p>A reduction operator has the same precedence as a list operator. In fact, a reduction operator really is a list operator, and is invoked as one. Hence, you can implement a reduction operator in one of two ways. Either you can write an explicit list operator:</p>

<pre>    proto prefix:&#60;[+]&#62; (*@args) {
        my $accum = 0;
        while (@args) {
            $accum += @args.shift();
        }
        return $accum;
    }</pre>

<p>or you can let the system autogenerate one for you based on the corresponding infix operator, probably by currying:</p>

<pre>    # (examples, actual system may define prefix:[**] instead)
    &#38;prefix:&#60;[*]&#62; ::= &#38;reduce.assuming(&#38;infix:&#60;*&#62;, 1);
    &#38;prefix:&#60;[**]&#62; ::= &#38;reducerev.assuming(&#38;infix:&#60;**&#62;);</pre>

<p>As a special form of name, the non-prefix notation, as in</p>

<pre>    proto [foo] (*@args) {
        ...
    }</pre>

<p>or</p>

<pre>    &#38;[foo] ::= ...</pre>

<p>defines both the <code>[foo]</code> reduce operator and the <code>foo</code> infix operator. Where appropriate, use of the infix form may be optimized like this:</p>

<pre>    # Original          # Optimized
    $a foo $b           # [foo] $a, $b
    $a foo $b foo $c    # [foo] $a, $b, $c</pre>

<p>If the reduction operator is defined separately from the infix operator, it must associate the same way as the operator used:</p>

<pre>    [-] 4, 3, 2;      # 4-3-2 = (4-3)-2 = -1
    [**] 4, 3, 2;     # 4**3**2 = 4**(3**2) = 262144</pre>

<p>For list-associating operators (like <code>&#60;</code>), all arguments are taken together, just as if you had written it out explicitly:</p>

<pre>    [&#60;] 1, 3, 5;      # 1 &#60; 3 &#60; 5</pre>

<p>If fewer than two arguments are given, a dispatch is still attempted with whatever arguments are given, and it is up to the receiver of that dispatch to deal with fewer than two arguments. Note that the proto list operator definition is the most general, so you are allowed to define different ways to handle the one argument case depending on type:</p>

<pre>    multi prefix:&#60;[foo]&#62; (Int $x) { 42 }
    multi prefix:&#60;[foo]&#62; (Str $x) { fail &#34;Can&#39;t foo a single Str&#34; }</pre>

<p>However, the zero argument case must of necessity be handled by the proto version, since there is no type information to dispatch on. Operators that wish to specify an identity value should do so by specifying the proto listop. Among the builtin operators, <code>[+]()</code> returns 0 and <code>[*]()</code> returns 1, for instance.</p>

<p>By default, if there is one argument, the built-in reduce operators return that one argument. However, this default doesn&#39;t make sense for operators like <code>&#60;</code> that don&#39;t return the same type as they take, so these kinds of operators overload the single-argument case to return something more meaningful. All the comparison operators return a boolean for either 1 or 0 arguments. Negated operators return <code>Bool::False</code>, and all the rest return <code>Bool::True</code>.</p>

<p>You can also make a reduce operator of the comma operator. This has the effect of dereferencing its arguments into another argument list as if they&#39;d been placed there directly.</p>

<pre>    @args = \@foo,1,2,3;
    push [,] @args;     # same as push @foo,1,2,3</pre>

<p>See S06 for more.</p>

<p>You may also reduce using the semicolon second-dimension separator:</p>

<pre>    [[;] 1,2,3]   # equivalent to [1;2;3]</pre>

<p>Builtin reduce operators return the following identity values:</p>

<pre>    [**]()      # 1     (arguably nonsensical)
    [*]()       # 1
    [/]()       # fail  (reduce is nonsensical)
    [%]()       # fail  (reduce is nonsensical)
    [x]()       # fail  (reduce is nonsensical)
    [xx]()      # fail  (reduce is nonsensical)
    [+&#38;]()      # +^0   (-1 on 2&#39;s complement machine)
    [+&#60;]()      # fail  (reduce is nonsensical)
    [+&#62;]()      # fail  (reduce is nonsensical)
    [~&#38;]()      # fail  (sensical but 1&#39;s length indeterminate)
    [~&#60;]()      # fail  (reduce is nonsensical)
    [~&#62;]()      # fail  (reduce is nonsensical)
    [+]()       # 0
    [-]()       # 0
    [~]()       # &#39;&#39;
    [+|]()      # 0
    [+^]()      # 0
    [~|]()      # &#39;&#39;    (length indeterminate but 0&#39;s default)
    [~^]()      # &#39;&#39;    (length indeterminate but 0&#39;s default)
    [&#38;]()       # all()
    [|]()       # any()
    [^]()       # one()
    [!==]()     # Bool::False   (also for 1 arg)
    [==]()      # Bool::True    (also for 1 arg)
    [&#60;]()       # Bool::True    (also for 1 arg)
    [&#60;=]()      # Bool::True    (also for 1 arg)
    [&#62;]()       # Bool::True    (also for 1 arg)
    [&#62;=]()      # Bool::True    (also for 1 arg)
    [~~]()      # Bool::True    (also for 1 arg)
    [!~~]()     # Bool::False   (also for 1 arg)
    [eq]()      # Bool::True    (also for 1 arg)
    [!eq]()     # Bool::False   (also for 1 arg)
    [lt]()      # Bool::True    (also for 1 arg)
    [le]()      # Bool::True    (also for 1 arg)
    [gt]()      # Bool::True    (also for 1 arg)
    [ge]()      # Bool::True    (also for 1 arg)
    [=:=]()     # Bool::True    (also for 1 arg)
    [!=:=]()    # Bool::False   (also for 1 arg)
    [===]()     # Bool::True    (also for 1 arg)
    [!===]()    # Bool::False   (also for 1 arg)
    [eqv]()     # Bool::True    (also for 1 arg)
    [!eqv]()    # Bool::False   (also for 1 arg)
    [&#38;&#38;]()      # Bool::True
    [||]()      # Bool::False
    [^^]()      # Bool::False
    [//]()      # undef
    [=]()       # undef    (same for all assignment operators)
    [,]()       # ()
    [&#165;]()       # []</pre>

<p>User-defined operators may define their own identity values, but there is no explicit identity property. The value is implicit in the behavior of the 0-arg reduce, so mathematical code wishing to find the identity value for an operation can call <code>prefix:{&#34;[$opname]&#34;}()</code> to discover it.</p>

<p>To call some other non-infix function as a reduce operator, you may define an alias in infix form. The infix form will parse the right argument as a scalar even if the aliased function would have parsed it as a list:</p>

<pre>    &#38;infix:&#60;dehash&#62; ::= postcircumfix:&#60;{ }&#62;;
    $x = [dehash] $a,&#39;foo&#39;,&#39;bar&#39;;  # $a&#60;foo&#62;&#60;bar&#62;, not $a&#60;foo bar&#62;</pre>

<p>Alternately, just define your own <code>prefix:&#60;[dehash]&#62;</code> routine.</p>

<p>Note that, because a reduce is a list operator, the argument list is evaluated in list context. Therefore the following would be incorrect:</p>

<pre>    $x = [dehash] %a,&#39;foo&#39;,&#39;bar&#39;;</pre>

<p>You&#39;d instead have to say one of:</p>

<pre>    $x = [dehash] \%a,&#39;foo&#39;,&#39;bar&#39;;
    $x = [dehash] %a&#60;foo&#62;,&#39;bar&#39;;</pre>

<p>On the plus side, this works without a star:</p>

<pre>    @args = (\%a,&#39;foo&#39;,&#39;bar&#39;);
    $x = [dehash] @args;</pre>

<p>A reduce operator returns only a scalar result regardless of context. (Even <code>[,]</code> returns a single <code>Capture</code> object which is then spliced into the outer argument list.) To return all intermediate results, backslash the operator:</p>

<pre>    say [\+] 1..*  #  (1, 3, 6, 10, 15, ...)</pre>

<p>The visual picture of a triangle is not accidental. To produce a triangular list of lists, you can use a &#34;triangular comma&#34;:</p>

<pre>    [\,] 1..5
    [1],
    [1,2],
    [1,2,3],
    [1,2,3,4],
    [1,2,3,4,5]</pre>

<p>If there is ambiguity between a triangular reduce and an infix operator beginning with backslash, the infix operator is chosen, and an extra backslash indicates the corresponding triangular reduce. As a consequence, defining an infix operator beginning with backslash, <code>infix:&#60;\x&#62;</code> say, will make it impossible to write certain triangular reduction operators, since <code>[\x]</code> would mean the normal reduction of <code>infix:&#60;\x&#62;</code> operator, not the triangular reduction of <code>infix:&#60;x&#62;</code>. This is deemed to be an insignificant problem.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Junctive_operators"
>Junctive operators</a></h1>

<a name="msg_12"></a>
<a href="?hide_quotes=no#msg_12" onclick="return tog_quote(12);">
<div ID="header_shown_12" style="display: none;">
- Hide the snippet from t/junction/misc_junctions.t (line 145 ~ line 152) -
</div>
<div ID="header_hidden_12" style="display: block;">
- Show the snippet from t/junction/misc_junctions.t (line 145 ~ line 152, 8 lines) -
</div>
</a>
<div ID="hide_12" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S03/"Junctive operators"&gt;

=cut

# Canonical stringification of a junction
sub j (Junction $j) { return $j.perl }

{</pre>
</div>


<a name="msg_11"></a>
<a href="?hide_quotes=no#msg_11" onclick="return tog_quote(11);">
<div ID="header_shown_11" style="display: none;">
- Hide the snippet from t/junction/misc_junctions.t (line 13 ~ line 144) -
</div>
<div ID="header_hidden_11" style="display: block;">
- Show the snippet from t/junction/misc_junctions.t (line 13 ~ line 144, 132 lines) -
</div>
</a>
<div ID="hide_11" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S03/"Junctive operators"&gt;

=cut

{ # L&lt;S09/"Junctions"&gt;

    # initalize them all to empty strings
    my $a = '';
    my $b = '';
    my $c = '';
    
    # make sure they all match to an empty string
    ok('' eq ($a &amp; $b &amp; $c), 'junction of ($a &amp; $b &amp; $c) matches and empty string');
    ok('' eq all($a, $b, $c), 'junction of all($a, $b, $c) matches and empty string');   
    
    # give $a a value
    $a = 'a';  
    
    # make sure that at least one of them matches 'a' 
    ok('a' eq ($b | $c | $a), 'junction of ($b | $c | $a) matches at least one "a"');
    ok('a' eq any($b, $c, $a), 'junction of any($b, $c, $a) matches at least one "a"');   

    ok('' eq ($b | $c | $a), 'junction of ($b | $c | $a) matches at least one empty string');
    ok('' eq any($b, $c, $a), 'junction of any($b, $c, $a) matches at least one empty string');
    
    # make sure that ~only~ one of them matches 'a'
    ok('a' eq ($b ^ $c ^ $a), 'junction of ($b ^ $c ^ $a) matches at ~only~ one "a"');
    ok('a' eq one($b, $c, $a), 'junction of one($b, $c, $a) matches at ~only~ one "a"');
    
    # give $b a value
    $b = 'a';
    
    # now this will fail
    ok('a' ne ($b ^ $c ^ $a), 'junction of ($b ^ $c ^ $a) matches at more than one "a"');              

    # change $b and give $c a value
    $b = 'b';
    $c = 'c';
    
    ok('a' eq ($b ^ $c ^ $a), 'junction of ($b ^ $c ^ $a) matches at ~only~ one "a"');
    ok('b' eq ($a ^ $b ^ $c), 'junction of ($a ^ $b ^ $c) matches at ~only~ one "b"');
    ok('c' eq ($c ^ $a ^ $b), 'junction of ($c ^ $a ^ $b) matches at ~only~ one "c"');  

    ok('a' eq ($b | $c | $a), 'junction of ($b | $c | $a) matches at least one "a"');
    ok('b' eq ($a | $b | $c), 'junction of ($a | $b | $c) matches at least one "b"');
    ok('c' eq ($c | $a | $b), 'junction of ($c | $a | $b) matches at least one "c"'); 
    
    # test junction to junction
    
    ok(('a' | 'b' | 'c') eq ($a &amp; $b &amp; $c), 'junction ("a" | "b" | "c") matches junction ($a &amp; $b &amp; $c)');    
    ok(('a' &amp; 'b' &amp; 'c') eq ($a | $b | $c), 'junction ("a" &amp; "b" &amp; "c") matches junction ($a | $b | $c)'); 
    
    # mix around variables and literals
    
    ok(($a &amp; 'b' &amp; 'c') eq ('a' | $b | $c), 'junction ($a &amp; "b" &amp; "c") matches junction ("a" | $b | $c)');              
    ok(($a &amp; 'b' &amp; $c) eq ('a' | $b | 'c'), 'junction ($a &amp; "b" &amp; $c) matches junction ("a" | $b | "c")');              
    
}

# same tests, but with junctions as variables
{
        # initalize them all to empty strings
    my $a = '';
    my $b = '';
    my $c = '';
    
    my $all_of_them = $a &amp; $b &amp; $c;
    ok('' eq $all_of_them, 'junction variable of ($a &amp; $b &amp; $c) matches and empty string');
    
    $a = 'a';  
    
    my $any_of_them = $b | $c | $a;
    ok('a' eq $any_of_them, 'junction variable of ($b | $c | $a) matches at least one "a"');  
    ok('' eq $any_of_them, 'junction variable of ($b | $c | $a) matches at least one empty string');
    
    my $one_of_them = $b ^ $c ^ $a;
    ok('a' eq $one_of_them, 'junction variable of ($b ^ $c ^ $a) matches at ~only~ one "a"');
    
    $b = 'a';
    
    {
        my $one_of_them = $b ^ $c ^ $a;
        ok('a' ne $one_of_them, 'junction variable of ($b ^ $c ^ $a) matches at more than one "a"');              
    }
    
    $b = 'b';
    $c = 'c';
    
    {
        my $one_of_them = $b ^ $c ^ $a;    
        ok('a' eq $one_of_them, 'junction of ($b ^ $c ^ $a) matches at ~only~ one "a"');
        ok('b' eq $one_of_them, 'junction of ($a ^ $b ^ $c) matches at ~only~ one "b"');
        ok('c' eq $one_of_them, 'junction of ($c ^ $a ^ $b) matches at ~only~ one "c"');  
    }

    {
        my $any_of_them = $b | $c | $a;
        ok('a' eq $any_of_them, 'junction of ($b | $c | $a) matches at least one "a"');
        ok('b' eq $any_of_them, 'junction of ($a | $b | $c) matches at least one "b"');
        ok('c' eq $any_of_them, 'junction of ($c | $a | $b) matches at least one "c"'); 
    }

}

{
    my $j = 1 | 2;
    $j = 5;
    is($j, 5, 'reassignment of junction variable');
}

{
    my ($j,$k,$l);

    $j = 1|2;
    is(ref($j),'Junction', 'basic junction type reference test');

    $k=$j;
    is(ref($k),'Junction', 'assignment preserves reference');

    # XXX does this next one make any sense?
    $l=\$j;
    is(ref($l),'Junction', 'hard reference to junction');
}


=pod

Tests junction examples from Synopsis 03 

j() is used to convert a junction to canonical string form, currently
just using .perl until a better approach presents itself.</pre>
</div>


<a name="msg_10"></a>
<a href="?hide_quotes=no#msg_10" onclick="return tog_quote(10);">
<div ID="header_shown_10" style="display: none;">
- Hide the snippet from t/junction/associative.t (line 13 ~ line 40) -
</div>
<div ID="header_hidden_10" style="display: block;">
- Show the snippet from t/junction/associative.t (line 13 ~ line 40, 28 lines) -
</div>
</a>
<div ID="hide_10" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S03/"Junctive operators"&gt;

=cut

{ # L&lt;S09/"Junctions"&gt;

    is('1 2 3', ~((1|2)|3).values, "Left-associative any, | operator");
    is('1 2 3', ~(1|(2|3)).values, "Right-associative any, | operator");

    is('1 2 3', ~any(any(1,2),3).values, "Left-associative any()");
    is('1 2 3', ~any(1,any(2,3)).values, "Right-associative any()");

    is('1 2 3', ~((1&amp;2)&amp;3).values, "Left-associative all, &amp; operator");
    is('1 2 3', ~(1&amp;(2&amp;3)).values, "Right-associative all, &amp; operator");

    is('1 2 3', ~all(all(1,2),3).values, "Left-associative all()");
    is('1 2 3', ~all(1,all(2,3)).values, "Right-associative all()");

    isnt('1 2 3', ~((1^2)^3).values, "Left-associative one, ^ operator");
    isnt('1 2 3', ~(1^(2^3)).values, "Right-associative one, ^ operator");

    isnt('1 2 3', ~one(one(1,2),3).values, "Left-associative one()");
    isnt('1 2 3', ~one(1,one(2,3)).values, "Right-associative one()");

    is('1 2 3', ~none(none(1,2),3).values, "Left-associative none()");
    is('1 2 3', ~none(1,none(2,3)).values, "Right-associative none()");

}</pre>
</div>


<p><code>|</code>, <code>&#38;</code>, and <code>^</code> are no longer bitwise operators (see <a href="#Changes_to_Perl_5_operators" class="podlinkpod"
>&#34;Changes to Perl 5 operators&#34;</a>) but now serve a much higher cause: they are now the junction constructors.</p>

<p>A junction is a single value that is equivalent to multiple values. They thread through operations, returning another junction representing the result:</p>

<a name="msg_17"></a>
<a href="?hide_quotes=no#msg_17" onclick="return tog_quote(17);">
<div ID="header_shown_17" style="display: none;">
- Hide the snippet from t/junction/misc_junctions.t (line 215 ~ line 286) -
</div>
<div ID="header_hidden_17" style="display: block;">
- Show the snippet from t/junction/misc_junctions.t (line 215 ~ line 286, 72 lines) -
</div>
</a>
<div ID="hide_17" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S03/"Junctive operators" /They thread through operations/&gt;

 On Fri, 2005-02-11 at 10:46 +1100, Damian Conway wrote:
 &gt; Subject: Re: Fwd: Junctive puzzles.
 &gt;
 &gt; Junctions have an associated boolean predicate that's preserved across 
 &gt; operations on the junction. Junctions also implicitly distribute across 
 &gt; operations, and rejunctify the results.

=cut

{
    my @subs = (sub {3}, sub {2});

    my ($got, $want);

    is(j(any(@subs)()), j(3|2), '.() on any() junction of subs');

    $want = (3&amp;2);
    $got = all(@subs)();
    is(j($got), j($want), '.() on all() junction of subs');

    $want = (3^2);
    $got = one(@subs)();
    is(j($got), j($want), '.() on one() junction of subs');

    $want = none(3,2);
    $got = none(@subs)();
    is(j($got), j($want), '.() on none() junction of subs');

    $want = one( any(3,2), all(3,2) );
    $got = one( any(@subs), all(@subs) )();
    is(j($got), j($want), '.() on complex junction of subs');

    # Avoid future constant folding
    #my $rand = rand;
    #my $zero = int($rand-$rand);
    #my @subs = (sub {3+$zero}, sub {2+$zero});
}

# Check functional and operator versions produce the same structure
{
    is(j((1|2)^(3&amp;4)), j(one(any(1,2),all(3,4))),
        '((1|2)^(3&amp;4)) equiv to one(any(1,2),all(3,4))');

    is(j((1|2)&amp;(3&amp;4)), j(all(any(1,2),all(3,4))), 
        '((1|2)&amp;(3&amp;4)) equiv to all(any(1,2),all(3,4))');

    is(j((1|2)|(3&amp;4)), j(any(any(1,2),all(3,4))),
        '((1|2)|(3&amp;4)) equiv to any(any(1,2),all(3,4))');
}

is(none(1).pick, undef, 'none(1).pick should be undef');
is(none(1,1).pick, undef, 'none(1,1).pick should be undef');

is(one(1).pick, 1, 'one(1).pick should be 1');
is(one(1,1).pick, undef, 'one(1,1).pick should be undef');

is(all(1).pick, 1, 'all(1).pick should be 1');
is(all(1,1).pick, 1, 'all(1,1).pick should be 1');
is(all(1,2).pick, undef, 'all(1,2).pick should be undef');

# junction in boolean context
ok(?(0&amp;0) == ?(0&amp;&amp;0), 'boolean context');
ok(?(0&amp;1) == ?(0&amp;&amp;1), 'boolean context');
ok(?(1&amp;1) == ?(1&amp;&amp;1), 'boolean context');
ok(?(1&amp;0) == ?(1&amp;&amp;0), 'boolean context');
ok(!(?(0&amp;0) != ?(0&amp;&amp;0)), 'boolean context');
ok(!(?(0&amp;1) != ?(0&amp;&amp;1)), 'boolean context');
ok(!(?(1&amp;1) != ?(1&amp;&amp;1)), 'boolean context');
ok(!(?(1&amp;0) != ?(1&amp;&amp;0)), 'boolean context');</pre>
</div>


<a name="msg_13"></a>
<a href="?hide_quotes=no#msg_13" onclick="return tog_quote(13);">
<div ID="header_shown_13" style="display: none;">
- Hide the snippet from t/junction/misc_junctions.t (line 153 ~ line 162) -
</div>
<div ID="header_hidden_13" style="display: block;">
- Show the snippet from t/junction/misc_junctions.t (line 153 ~ line 162, 10 lines) -
</div>
</a>
<div ID="hide_13" style="display:none; border:1px solid">
<pre style="margin-left: 6px">    # L&lt;S03/"Junctive operators" /They thread through operations/&gt;
    my ($got, $want);
    $got = ((1|2|3)+4);
    $want = (5|6|7);
    is( j($got), j($want), 'thread + returning junctive result');

    $got = ((1|2) + (3&amp;4));
    $want = ((4|5) &amp; (5|6));
    is( j($got), j($want), 'thread + returning junctive combination of results');</pre>
</div>


<pre>     (1|2|3) + 4;                            # 5|6|7
     (1|2) + (3&#38;4);                          # (4|5) &#38; (5|6)</pre>

<p>Note how when two junctions are applied through an operator, the result is a junction representing the operator applied to each combination of values.</p>

<p>Junctions come with the functional variants <code>any</code>, <code>all</code>, <code>one</code>, and <code>none</code>.</p>

<p>This opens doors for constructions like:</p>

<a name="msg_14"></a>
<a href="?hide_quotes=no#msg_14" onclick="return tog_quote(14);">
<div ID="header_shown_14" style="display: none;">
- Hide the snippet from t/junction/misc_junctions.t (line 163 ~ line 183) -
</div>
<div ID="header_hidden_14" style="display: block;">
- Show the snippet from t/junction/misc_junctions.t (line 163 ~ line 183, 21 lines) -
</div>
</a>
<div ID="hide_14" style="display:none; border:1px solid">
<pre style="margin-left: 6px">    # L&lt;S03/"Junctive operators" /This opens doors for constructions like/&gt;
    # unless $roll == any(1..6) { print "Invalid roll" }
    my ($roll, $note);
    $roll = 3; $note = '';
    unless $roll == any(1..6) { $note = "Invalid roll"; };
    is($note, "", 'any() junction threading ==');

    $roll = 7; $note = '';
    unless $roll == any(1..6) { $note = "Invalid roll"; };
    is($note, "Invalid roll", 'any() junction threading ==');

    # if $roll == 1|2|3 { print "Low roll" }
    $roll = 4; $note = '';
    if $roll == 1|2|3 { $note = "Low roll" }
    is($note, "", '| junction threading ==');

    $roll = 2; $note = '';
    if $roll == 1|2|3 { $note = "Low roll" }
    is($note, "Low roll", '| junction threading ==');</pre>
</div>


<pre>     unless $roll == any(1..6) { print &#34;Invalid roll&#34; }

     if $roll == 1|2|3 { print &#34;Low roll&#34; }</pre>

<p>Junctions work through subscripting:</p>

<a name="msg_15"></a>
<a href="?hide_quotes=no#msg_15" onclick="return tog_quote(15);">
<div ID="header_shown_15" style="display: none;">
- Hide the snippet from t/junction/misc_junctions.t (line 184 ~ line 198) -
</div>
<div ID="header_hidden_15" style="display: block;">
- Show the snippet from t/junction/misc_junctions.t (line 184 ~ line 198, 15 lines) -
</div>
</a>
<div ID="hide_15" style="display:none; border:1px solid">
<pre style="margin-left: 6px">    # L&lt;S03/"Junctive operators" /Junctions work through subscripting/&gt;
    my ($got, @foo);
    $got = ''; @foo = ();
    $got ~= 'y' if try { @foo[any(1,2,3)] };
    is($got, '', "junctions work through subscripting, 0 matches");

    $got = ''; @foo = (0,1);
    $got ~= 'y' if try { @foo[any(1,2,3)] };
    is($got, '', "junctions work through subscripting, 1 match");

    $got = ''; @foo = (1,1,1);
    $got ~= 'y' if try { @foo[any(1,2,3)] };
    is($got, '', "junctions work through subscripting, 3 matches");</pre>
</div>


<pre>    print if @foo[any(1,2,3)]</pre>

<p>Junctions are specifically unordered. So if you say</p>

<a name="msg_16"></a>
<a href="?hide_quotes=no#msg_16" onclick="return tog_quote(16);">
<div ID="header_shown_16" style="display: none;">
- Hide the snippet from t/junction/misc_junctions.t (line 199 ~ line 214) -
</div>
<div ID="header_hidden_16" style="display: block;">
- Show the snippet from t/junction/misc_junctions.t (line 199 ~ line 214, 16 lines) -
</div>
</a>
<div ID="hide_16" style="display:none; border:1px solid">
<pre style="margin-left: 6px">    # L&lt;S03/"Junctive operators" /Junctions are specifically unordered/&gt;
    # Compiler *can* reorder and parallelize but *may not* so don't test
    # for all(@foo) {...};  

    # Not sure what is expected
    #my %got = ('1' =&gt; 1); # Hashes are unordered too
    #@foo = (2,3,4);
    #for all(@foo) { %got{$_} = 1; };
    #is( %got.keys.sort.join(','), '1,2,3,4',
    #    'for all(...) { ...} as parallelizable');
}

=pod

These are implemented but still awaiting clarification on p6l.</pre>
</div>


<pre>    for all(@foo) {...}</pre>

<p>it indicates to the compiler that there is no coupling between loop iterations and they can be run in any order or even in parallel.</p>

<p>Use of negative operators with syntactically recognizable junctions may produce a warning on code that works differently in English than in Perl. Instead of writing</p>

<pre>    if $a != 1 | 2 | 3 {...}</pre>

<p>you need to write</p>

<pre>    if not $a == 1 | 2 | 3 {...}</pre>

<p>However, this is only a syntactic warning, and</p>

<pre>    if $a != $b {...}</pre>

<p>will not complain if $b happens to contain a junction at runtime.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Chained_comparisons"
>Chained comparisons</a></h1>

<a name="msg_23"></a>
<a href="?hide_quotes=no#msg_23" onclick="return tog_quote(23);">
<div ID="header_shown_23" style="display: none;">
- Hide the snippet from t/operators/relational.t (line 103 ~ line 110) -
</div>
<div ID="header_hidden_23" style="display: block;">
- Show the snippet from t/operators/relational.t (line 103 ~ line 110, 8 lines) -
</div>
</a>
<div ID="hide_23" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/"Chained comparisons"&gt;

ok("5" gt "4" gt "3", "5 gt 4 gt 3 chained str comparison");
ok("3" lt "4" lt "5", "3 lt 4 gt 5 chained str comparison");
ok(!("3" gt "4" lt "5"), "!(3 gt 4 lt 5) chained str comparison");
ok("5" eq "5" gt "0", '"5" eq "5" gt "0" chained str comparison with equality');
ok("5" le "5" gt "0", "5 le 5 gt 0 chained str comparison with le");
ok("0" lt "5" ge "5", "0 lt 5 ge 5 chained comparison with ge");</pre>
</div>


<a name="msg_22"></a>
<a href="?hide_quotes=no#msg_22" onclick="return tog_quote(22);">
<div ID="header_shown_22" style="display: none;">
- Hide the snippet from t/operators/relational.t (line 93 ~ line 102) -
</div>
<div ID="header_hidden_22" style="display: block;">
- Show the snippet from t/operators/relational.t (line 93 ~ line 102, 10 lines) -
</div>
</a>
<div ID="hide_22" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/"Chained comparisons"&gt;

# this works ...
is('e' gt 'a' lt 'j', 'e' gt 'a' &amp;&amp; 'a' lt 'j', 'multi-way comp e gt a lt j works');

# however this doesn't which makes 
# me think these are not implemented
is('e' lt 'a' lt 'j', 'e' lt 'a' &amp;&amp; 'a' lt 'j', 'multi-way comp e lt a lt j works');

## NOTE: these tests moved here from t/03operator.t </pre>
</div>


<a name="msg_21"></a>
<a href="?hide_quotes=no#msg_21" onclick="return tog_quote(21);">
<div ID="header_shown_21" style="display: none;">
- Hide the snippet from t/operators/relational.t (line 53 ~ line 92) -
</div>
<div ID="header_hidden_21" style="display: block;">
- Show the snippet from t/operators/relational.t (line 53 ~ line 92, 40 lines) -
</div>
</a>
<div ID="hide_21" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/"Chained comparisons"&gt;

ok(5 &gt; 4 &gt; 3, "chained comparison");
ok(3 &lt; 4 &lt; 5, "chained comparison");
ok(5 == 5 &gt; -5, "chained comparison with equality");
ok(!(3 &gt; 4 &lt; 5), "chained n &gt; n &lt; n comparison");
ok(5 &lt;= 5 &gt; -5, "chained comparison with &lt;=");
ok(-5 &lt; 5 &gt;= 5, "chained comparison with &gt;=");

## For Strings: &lt;, &lt;=, &lt;=&gt;, &gt;=, &gt;

# less than

ok('a' lt 'b', 'a is less than b');
ok(!('b' lt 'a'), 'b is ~not~ less than a');

# greater than

ok('b' gt 'a', 'b is greater than a');
ok(!('a' gt 'b'), 'a is ~not~ greater than b');

# less than or equal to

ok('a' le 'b', 'a is less than or equal to b');
ok('a' le 'a', 'a is less than or equal to a');
ok(!('b' le 'a'), 'b is ~not~ less than or equal to a');

# greater than or eqaul to

ok('b' ge 'a', 'b is greater than or equal to a');
ok('b' ge 'b', 'b is greater than or equal to b');
ok(!('b' ge 'c'), 'b is ~not~ greater than or equal to c');

# cmp

is('a' cmp 'a', 0,  'a is equal to a');
is('a' cmp 'b', -1, 'a is less than b');
is('b' cmp 'a', 1,  'b is greater than a');

## Multiway comparisons (RFC 025)</pre>
</div>


<a name="msg_20"></a>
<a href="?hide_quotes=no#msg_20" onclick="return tog_quote(20);">
<div ID="header_shown_20" style="display: none;">
- Hide the snippet from t/operators/relational.t (line 43 ~ line 52) -
</div>
<div ID="header_hidden_20" style="display: block;">
- Show the snippet from t/operators/relational.t (line 43 ~ line 52, 10 lines) -
</div>
</a>
<div ID="hide_20" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/"Chained comparisons"&gt;

# this works ...
is(5 &gt; 1 &lt; 10, 5 &gt; 1 &amp;&amp; 1 &lt; 10, 'multi-way comp 5 &gt; 1 &lt; 10 works');

# however this doesn't which makes 
# me think these are not implemented
is(5 &lt; 1 &lt; 10, 5 &lt; 1 &amp;&amp; 1 &lt; 10, 'multi-way comp 5 &lt; 1 &lt; 10 works');

## NOTE: these tests moved here from t/03operator.t </pre>
</div>


<a name="msg_19"></a>
<a href="?hide_quotes=no#msg_19" onclick="return tog_quote(19);">
<div ID="header_shown_19" style="display: none;">
- Hide the snippet from t/operators/listquote.t (line 38 ~ line 76) -
</div>
<div ID="header_hidden_19" style="display: block;">
- Show the snippet from t/operators/listquote.t (line 38 ~ line 76, 39 lines) -
</div>
</a>
<div ID="hide_19" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/"Chained comparisons"&gt;

my $s = join 'a', &lt;x y z&gt;;
is($s, "xayaz", 'list context &lt;list&gt;');

my $s = join [,] &lt;a x y z&gt;;
is($s, "xayaz", 'listop &lt;list&gt;');

my $x = try { [1,2,3].join&lt;a b c&gt; };
ok($!, '.join&lt;abc&gt; parses but semantic error');
is($x, [1,2,3].join()&lt;a b c&gt;, '.join&lt;a b c&gt; not treated as argument');

my @y = try { {:a&lt;1&gt;, :b(2)}&lt;a b c&gt; };
is(@y, [1,2,undef], '{...}&lt;a b c&gt; is hash subscript');

eval '{:a&lt;1&gt;, :b(2)} &lt;a b c&gt;';
ok($!, '{...} &lt;...&gt; parsefail');

ok((1 | 3) &lt; 3, '(...) &lt; 3 no parsefail');

eval '(1 | 3)&lt;3';
ok($!, '()&lt;3 parsefail');

eval 'print &lt; 3';
ok($!, 'print &lt; 3 parsefail');

my $z = eval 'reverse&lt;1 2 3&gt;';
ok($!, 'reverse&lt;1 2 3&gt; parsefail');

eval ':foo &lt;1 2 3&gt;';
ok($!, ':foo &lt;1 2 3&gt; parsefail');

my $r = eval ':foo &lt;3';
is($r, Bool::True, ':foo &lt;3 is comparison');

my $p = eval ':foo&lt;1 2 3&gt;';
is($p, 'foo' =&gt; (1,2,3), ':foo&lt;1 2 3&gt; is pair of list');

=cut</pre>
</div>


<p>Perl 6 supports the natural extension to the comparison operators, allowing multiple operands.</p>

<pre>    if 1 &#60; $a &#60; 100 { say &#34;Good, you picked a number *between* 1 and 100.&#34; }

    if 3 &#60; $roll &#60;= 6              { print &#34;High roll&#34; }

    if 1 &#60;= $roll1 == $roll2 &#60;= 6  { print &#34;Doubles!&#34; }</pre>

<p>Note: any operator beginning with <code>&#60;</code> must have whitespace in front of it, or it will be interpreted as a hash subscript instead.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Binding"
>Binding</a></h1>

<a name="msg_6"></a>
<a href="?hide_quotes=no#msg_6" onclick="return tog_quote(6);">
<div ID="header_shown_6" style="display: none;">
- Hide the snippet from t/operators/binding/subs.t (line 5 ~ line 85) -
</div>
<div ID="header_hidden_6" style="display: block;">
- Show the snippet from t/operators/binding/subs.t (line 5 ~ line 85, 81 lines) -
</div>
</a>
<div ID="hide_6" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/"Binding"&gt;

# Tests for binding the return value of subroutines (both as RHS and LHS).

plan 8;

{
    my sub foo { 42 }

    my $var := foo();
    is $var, 42,
        "binding a var to the return value of a sub (a constant) works (1)";

    dies_ok { $var = 23 },
        "binding a var to the return value of a sub (a constant) works (2)";
}

=begin unspecced

{
    my sub foo { 42 }

    dies_ok { foo() := 23 },
        "using the constant return value of a sub as the LHS in a binding operation dies";
}

There're two ways one can argue:
* 42 is constant, and rebinding constants doesn't work, so foo() := 23 should
  die.
* 42 is constant, but the implicit return() packs the constant 42 into a
  readonly 42, and readonly may be rebound.
  To clear the terminology,
    42                  # 42 is a constant
    sub foo ($a) {...}  # $a is a readonly

=end unspecced

=cut

{
    my sub foo { my $var = 42; $var }

    my $var := foo();
    is $var, 42,
        "binding a var to the return value of a sub (a variable) works (1)";

    dies_ok { $var = 23 },
        "binding a var to the return value of a sub (a variable) works (2)", :todo&lt;bug&gt;;
}

{
    my sub foo is rw { my $var = 42; $var }

    my $var := foo();
    is $var, 42,
        "binding a var to the return value of an 'is rw' sub (a variable) works (1)";

    lives_ok { $var = 23 },
        "binding a var to the return value of an 'is rw' sub (a variable) works (2)";
    is $var, 23,
        "binding a var to the return value of an 'is rw' sub (a variable) works (3)";
}

{
    my sub foo is rw { my $var = 42; $var }

    lives_ok { foo() := 23 },
        "using the variable return value of an 'is rw' sub as the LHS in a binding operation works", :todo&lt;bug&gt;;
}

=for discussion

Should the constant return value be autopromoted to a var? Or should it stay a
constant?

{
    my sub foo is rw { 42 }

    dies_ok/lives_ok { foo() := 23 },
        "using the constant return value of an 'is rw' sub as the LHS in a binding operation behaves correctly";
}</pre>
</div>


<a name="msg_4"></a>
<a href="?hide_quotes=no#msg_4" onclick="return tog_quote(4);">
<div ID="header_shown_4" style="display: none;">
- Hide the snippet from t/operators/binding/scalars.t (line 9 ~ line 14) -
</div>
<div ID="header_hidden_4" style="display: block;">
- Show the snippet from t/operators/binding/scalars.t (line 9 ~ line 14, 6 lines) -
</div>
</a>
<div ID="hide_4" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S03/"Binding"&gt;

=cut

plan 28;</pre>
</div>


<a name="msg_3"></a>
<a href="?hide_quotes=no#msg_3" onclick="return tog_quote(3);">
<div ID="header_shown_3" style="display: none;">
- Hide the snippet from t/operators/binding/nested.t (line 5 ~ line 340) -
</div>
<div ID="header_hidden_3" style="display: block;">
- Show the snippet from t/operators/binding/nested.t (line 5 ~ line 340, 336 lines) -
</div>
</a>
<div ID="hide_3" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/"Binding"&gt;

# Tests for binding multidimensional structures.

plan 43;

# Nested refs as RHS in a binding operation
{
    my $struct = [
        "ignored",
        {
            key =&gt; {
                ignored =&gt; 23,
                subkey  =&gt; [
                    "ignored",
                    42,
                ],
            },
            ignored =&gt; 19,
        },
    ];

    is $struct[1]&lt;key&gt;&lt;subkey&gt;[1], 42, "basic sanity (1)";

    my $abbrev := $struct[1]&lt;key&gt;&lt;subkey&gt;[1];
    is $abbrev, 42,
        "using a multidimensional structure as RHS in a binding op works (1)";

    $struct[1]&lt;key&gt;&lt;subkey&gt;[1] = 43;
    is $abbrev, 43,
        "using a multidimensional structure as RHS in a binding op works (2)";

    $abbrev = 44;
    is $struct[1]&lt;key&gt;&lt;subkey&gt;[1], 44,
        "using a multidimensional structure as RHS in a binding op works (3)";
}

# Nested refs as LHS in a binding operation
{
    my $struct = [
        "ignored",
        {
            key =&gt; {
                ignored =&gt; 23,
                subkey  =&gt; [
                    "ignored",
                    42,
                ],
            },
            ignored =&gt; 19,
        },
    ];

    is $struct[1]&lt;key&gt;&lt;subkey&gt;[1], 42, "basic sanity (2)";

    my $abbrev = 30;
    try { $struct[1]&lt;key&gt;&lt;subkey&gt;[1] := $abbrev };
    is $abbrev, 30,
        "using a multidimensional structure as LHS in a binding op works (1)";

    $struct[1]&lt;key&gt;&lt;subkey&gt;[1] = 31;
    is $abbrev, 31,
        "using a multidimensional structure as LHS in a binding op works (2)", :todo&lt;bug&gt;;

    $abbrev = 32;
    is $struct[1]&lt;key&gt;&lt;subkey&gt;[1], 32,
        "using a multidimensional structure as LHS in a binding op works (3)", :todo&lt;bug&gt;;
}

# Evil more evil structure: with an embedded "is rw" sub!
# As RHS...
{
    my $innerstruct = {
        ignored =&gt; 23,
        subkey  =&gt; [
            "ignored",
            42,
        ],
    };

    my sub get_innerstruct () is rw { $innerstruct }

    my $struct = [
        "ignored",
        {
            key     =&gt; &amp;get_innerstruct,
            ignored =&gt; 19,
        },
    ];

    is $struct[1]&lt;key&gt;()&lt;subkey&gt;[1], 42, "basic sanity (3)";

    my $abbrev := $struct[1]&lt;key&gt;()&lt;subkey&gt;[1];
    is $abbrev, 42,
        "using a multidimensional structure with an embedded sub as RHS works (1)";

    $struct[1]&lt;key&gt;()&lt;subkey&gt;[1] = 43;
    is $abbrev, 43,
        "using a multidimensional structure with an embedded sub as RHS works (2)";

    $abbrev = 44;
    is $struct[1]&lt;key&gt;()&lt;subkey&gt;[1], 44,
        "using a multidimensional structure with an embedded sub as RHS works (3)";
}

# ...and as LHS
{
    my $innerstruct = {
        ignored =&gt; 23,
        subkey  =&gt; [
            "ignored",
            42,
        ],
    };

    my sub get_innerstruct () is rw { $innerstruct }

    my $struct = [
        "ignored",
        {
            key     =&gt; &amp;get_innerstruct,
            ignored =&gt; 19,
        },
    ];

    is $struct[1]&lt;key&gt;()&lt;subkey&gt;[1], 42, "basic sanity (4)";

    my $abbrev = 30;
    try { $struct[1]&lt;key&gt;()&lt;subkey&gt;[1] := $abbrev };
    is $abbrev, 30,
        "using a multidimensional structure with an embedded sub as LHS works (1)";

    $struct[1]&lt;key&gt;()&lt;subkey&gt;[1] = 31;
    is $abbrev, 31,
        "using a multidimensional structure with an embedded sub as LHS works (2)", :todo&lt;bug&gt;;

    $abbrev = 32;
    is $struct[1]&lt;key&gt;()&lt;subkey&gt;[1], 32,
        "using a multidimensional structure with an embedded sub as LHS works (3)", :todo&lt;bug&gt;;
}

# Binding should cope with a subtree being redefined.
# As RHS...
{
    my $struct = [
        "ignored",
        {
            key =&gt; {
                ignored =&gt; 23,
                subkey  =&gt; [
                    "ignored",
                    42,
                ],
            },
            ignored =&gt; 19,
        },
    ];

    is $struct[1]&lt;key&gt;&lt;subkey&gt;[1], 42, "basic sanity (5)";

    my $abbrev := $struct[1]&lt;key&gt;&lt;subkey&gt;[1];
    is $abbrev, 42,
        "RHS binding should cope with a subtree being redefined (1)";

    $struct[1]&lt;key&gt;&lt;subkey&gt;[1] = 43;
    is $abbrev, 43,
        "RHS binding should cope with a subtree being redefined (2)";

    $struct[1] = "foo";
    is $struct[1], "foo",
        "RHS binding should cope with a subtree being redefined (3)";
    is $abbrev, 43,
        "RHS binding should cope with a subtree being redefined (4)";

    $abbrev = 44;
    is $abbrev, 44,
        "RHS binding should cope with a subtree being redefined (5)";
    is $struct[1], "foo",
        "RHS binding should cope with a subtree being redefined (6)";
}

# ...and as LHS
{
    my $struct = [
        "ignored",
        {
            key =&gt; {
                ignored =&gt; 23,
                subkey  =&gt; [
                    "ignored",
                    42,
                ],
            },
            ignored =&gt; 19,
        },
    ];

    is $struct[1]&lt;key&gt;&lt;subkey&gt;[1], 42, "basic sanity (6)";

    my $abbrev = 42;
    try { $struct[1]&lt;key&gt;&lt;subkey&gt;[1] := $abbrev };
    is $abbrev, 42,
        "LHS binding should cope with a subtree being redefined (1)";

    $struct[1]&lt;key&gt;&lt;subkey&gt;[1] = 43;
    is $abbrev, 43,
        "LHS binding should cope with a subtree being redefined (2)", :todo&lt;bug&gt;;

    $struct[1] = "foo";
    is $struct[1], "foo",
        "LHS binding should cope with a subtree being redefined (3)";
    is $abbrev, 43,
        "LHS binding should cope with a subtree being redefined (4)", :todo&lt;bug&gt;;

    $abbrev = 44;
    is $abbrev, 44,
        "LHS binding should cope with a subtree being redefined (5)";
    is $struct[1], "foo",
        "LHS binding should cope with a subtree being redefined (6)";
}

# Tests for binding an element of a structure to an element of another
# structure.
{
    my $foo = [
        "ignored",
        {
            key =&gt; {
                ignored =&gt; 1,
                subkey  =&gt; [
                    "ignored",
                    2,
                ],
            },
            ignored =&gt; 3,
        },
    ];

    my $bar = [
        "ignored",
        {
            key =&gt; {
                ignored =&gt; 4,
                subkey  =&gt; [
                    "ignored",
                    5,
                ],
            },
            ignored =&gt; 6,
        },
    ];

    try { $bar[1]&lt;key&gt;&lt;subkey&gt; := $foo[1]&lt;key&gt; };
    is try{ $bar[1]&lt;key&gt;&lt;subkey&gt;&lt;subkey&gt;[1] }, 2,
        "binding an element of a structure to an element of another structure works (1)", :todo&lt;bug&gt;;

    try { $foo[1]&lt;key&gt;&lt;subkey&gt;[1] = 7 };
    is try{ $bar[1]&lt;key&gt;&lt;subkey&gt;&lt;subkey&gt;[1] }, 7,
        "binding an element of a structure to an element of another structure works (2)", :todo&lt;bug&gt;;

    try { $bar[1]&lt;key&gt;&lt;subkey&gt;&lt;subkey&gt;[1] = 8 };
    is try { $foo[1]&lt;key&gt;&lt;subkey&gt;[1] }, 8,
        "binding an element of a structure to an element of another structure works (3)", :todo&lt;bug&gt;;
}

# Tests for binding an element of a structure to an element of *the same*
# structure, effectively creating an infinite structure.
{
    my $struct = [
        "ignored",
        {
            key =&gt; {
                foo    =&gt; "bar",
                subkey =&gt; [
                    "ignored",
                    100,
                ],
            },
            ignored =&gt; 200,
        },
    ];

    try { $struct[1]&lt;key&gt;&lt;subkey&gt;[1] := $struct[1]&lt;key&gt; };
    is $struct[1]&lt;key&gt;&lt;subkey&gt;[1]&lt;foo&gt;, "bar",
        "binding an element of a structure to an element of the same structure works (1)", :todo&lt;bug&gt;;

    try { $struct[1]&lt;key&gt;&lt;subkey&gt;[1]&lt;foo&gt; = "new_value" };
    is $struct[1]&lt;key&gt;&lt;foo&gt;, "new_value",
        "binding an element of a structure to an element of the same structure works (2)", :todo&lt;bug&gt;;

    $struct[1]&lt;key&gt;&lt;foo&gt; = "very_new_value";
    is $struct[1]&lt;key&gt;&lt;subkey&gt;[1]&lt;foo&gt;, "very_new_value",
        "binding an element of a structure to an element of the same structure works (3)", :todo&lt;bug&gt;;

    $struct[1]&lt;key&gt;&lt;subkey&gt;[1] = 23;
    is $struct[1]&lt;key&gt;, 23,
        "binding an element of a structure to an element of the same structure works (4)", :todo&lt;bug&gt;;
}

# Test that rebinding to some other value really breaks up the binding.
{
    my $struct = [
        "ignored",
        {
            key =&gt; {
                ignored =&gt; 23,
                subkey  =&gt; [
                    "ignored",
                    42,
                ],
            },
            ignored =&gt; 19,
        },
    ];

    is $struct[1]&lt;key&gt;&lt;subkey&gt;[1], 42, "basic sanity (7)";

    my $abbrev := $struct[1]&lt;key&gt;&lt;subkey&gt;[1];
    is $abbrev, 42,
        "rebinding to some other value destroys the previous binding (1)";

    $struct[1]&lt;key&gt;&lt;subkey&gt;[1] = 43;
    is $abbrev, 43,
        "rebinding to some other value destroys the previous binding (2)";

    $abbrev = 44;
    is $struct[1]&lt;key&gt;&lt;subkey&gt;[1], 44,
        "rebinding to some other value destroys the previous binding (3)";

    $abbrev := 45;
    is $abbrev, 45,
        "rebinding to some other value destroys the previous binding (4)";
    is $struct[1]&lt;key&gt;&lt;subkey&gt;[1], 44,
        "rebinding to some other value destroys the previous binding (5)";
}</pre>
</div>


<a name="msg_2"></a>
<a href="?hide_quotes=no#msg_2" onclick="return tog_quote(2);">
<div ID="header_shown_2" style="display: none;">
- Hide the snippet from t/operators/binding/hashes.t (line 5 ~ line 181) -
</div>
<div ID="header_hidden_2" style="display: block;">
- Show the snippet from t/operators/binding/hashes.t (line 5 ~ line 181, 177 lines) -
</div>
</a>
<div ID="hide_2" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/"Binding"&gt;

plan 37;

# Binding of hash elements.
# See thread "Binding of array elements" on p6l started by Ingo Blechschmidt:
# L&lt;"http://www.nntp.perl.org/group/perl.perl6.language/22915"&gt;
{
  my %hash  = (:a&lt;x&gt;, :b&lt;y&gt;, :c&lt;z&gt;);
  my $var   = "d";

  try { %hash&lt;b&gt; := $var };
  is %hash&lt;b&gt;, "d", "basic binding of a hash element (1)", :todo&lt;feature&gt;;
  unless %hash&lt;b&gt; eq "d" {
    skip_rest "Skipping binding of hash elements tests (not yet implemented in the normal runcore)";
    exit;
  }

  $var = "e";
  is %hash&lt;b&gt;, "e", "basic binding of a hash element (2)";

  %hash&lt;b&gt; = "f";
  is $var,     "f", "basic binding of a hash element (3)";
}

{
  my %hash  = (:a&lt;x&gt;, :b&lt;y&gt;, :c&lt;z&gt;);
  my $var   = "d";

  %hash&lt;b&gt; := $var;
  $var      = "e";
  is %hash&lt;b&gt;, "e",             "binding of hash elements works with .delete (1)";

  %hash.delete("b");
  # $var unchanged, but assigning to $var doesn't modify @hash any
  # longer; similarily, changing @hash[1] doesn't modify $var now
  is $var,   "e",               "binding of hash elements works with .delete (2)";
  is ~%hash.values.sort, "x z", "binding of hash elements works with .delete (3)";

  $var     = "f";
  %hash&lt;b&gt; = "g";
  is $var,     "f",             "binding of hash elements works with .delete (4)";
  is %hash&lt;b&gt;, "g",             "binding of hash elements works with .delete (5)";
}

{
  my %hash  = (:a&lt;x&gt;, :b&lt;y&gt;, :c&lt;z&gt;);
  my $var   = "d";

  %hash&lt;b&gt; := $var;
  $var      = "e";
  is %hash&lt;b&gt;, "e", "binding of hash elements works with resetting the hash (1)";

  %hash = ();
  # $var unchanged, but assigning to $var doesn't modify @hash any
  # longer; similarily, changing @hash[1] doesn't modify $var now
  is $var,   "e",   "binding of hash elements works with resetting the hash (2)";
  is ~%hash, "",    "binding of hash elements works with resetting the hash (3)";

  $var     = "f";
  %hash&lt;b&gt; = "g";
  is $var,     "f", "binding of hash elements works with resetting the hash (4)";
  is %hash&lt;b&gt;, "g", "binding of hash elements works with resetting the hash (5)";
}

{
  my %hash  = (:a&lt;x&gt;, :b&lt;y&gt;, :c&lt;z&gt;);
  my $var   = "d";

  %hash&lt;b&gt; := $var;
  $var      = "e";
  is %hash&lt;b&gt;, "e", "binding of hash elements works with rebinding the hash (1)";

  my %other_hash = (:p&lt;q&gt;, :r&lt;s&gt;, :t&lt;u&gt;);
  %hash := %other_hash;
  # $var unchanged, but assigning to $var doesn't modify @hash any
  # longer; similarily, changing @hash[1] doesn't modify $var now
  is $var,    "e",  "binding of hash elements works with rebinding the hash (2)";
  is ~%hash.values.sort, "q s u",
    "binding of hash elements works with rebinding the hash (3)";

  $var     = "f";
  %hash&lt;b&gt; = "g";
  is $var,     "f", "binding of hash elements works with rebinding the hash (4)";
  is %hash&lt;b&gt;, "g", "binding of hash elements works with rebinding the hash (5)";
}

{
  my sub foo (%h) { %h&lt;b&gt; = "new_value" }

  my %hash  = (:a&lt;x&gt;, :b&lt;y&gt;, :c&lt;z&gt;);
  my $var   = "d";
  %hash&lt;b&gt; := $var;

  foo %hash;
  is $var,    "new_value",     "passing a hash to a sub expecting a hash behaves correctly (1)";
  is ~%hash.values.sort, "new_value x z",
    "passing a hash to a sub expecting a hash behaves correctly (2)";
}

{
  my sub foo (Hash $h) { $h&lt;b&gt; = "new_value" }

  my %hash  = (:a&lt;x&gt;, :b&lt;y&gt;, :c&lt;z&gt;);
  my $var   = "d";
  %hash&lt;b&gt; := $var;

  foo %hash;
  is $var, "new_value",
    "passing a hash to a sub expecting a hashref behaves correctly (1)";
  is ~%hash.values.sort, "new_value x z",
    "passing a hash to a sub expecting a hashref behaves correctly (2)";
}

# Binding of not yet existing elements should autovivify
{
  my %hash;
  my $var = "d";

  lives_ok { %hash&lt;b&gt; := $var },
                    "binding of not yet existing elements should autovivify (1)";
  is %hash&lt;b&gt;, "d", "binding of not yet existing elements should autovivify (2)";

  $var = "e";
  is %hash&lt;b&gt;, "e", "binding of not yet existing elements should autovivify (3)";
  is $var,     "e", "binding of not yet existing elements should autovivify (4)";
}

# Assignment (not binding) creates new containers
{
  my %hash  = (:a&lt;x&gt;, :b&lt;y&gt;, :c&lt;z&gt;);
  my $var   = "d";

  %hash&lt;b&gt; := $var;
  $var      = "e";
  is %hash&lt;b&gt;, "e",                   "hash assignment creates new containers (1)";

  my %new_hash = %hash;
  $var         = "f";
  # %hash&lt;b&gt; and $var are now "f", but %new_hash is unchanged.
  is $var,                   "f",     "hash assignment creates new containers (2)";
  is ~%hash\   .values.sort, "f x z", "hash assignment creates new containers (3)";
  is ~%new_hash.values.sort, "e x z", "hash assignment creates new containers (4)";
}

# Binding does not create new containers
{
  my %hash  = (:a&lt;x&gt;, :b&lt;y&gt;, :c&lt;z&gt;);
  my $var   = "d";

  %hash&lt;b&gt; := $var;
  $var      = "e";
  is %hash&lt;b&gt;, "e",                   "hash binding does not create new containers (1)";

  my %new_hash := %hash;
  $var          = "f";
  # %hash&lt;b&gt; and $var are now "f", but %new_hash is unchanged.
  is $var,        "f",                "hash binding does not create new containers (2)";
  is ~%hash\   .values.sort, "f x z", "hash binding does not create new containers (3)";
  is ~%new_hash.values.sort, "f x z", "hash binding does not create new containers (4)";
}

# Binding %hash := $hashref.
# See
# http://colabti.de/irclogger/irclogger_log/perl6?date=2005-11-06,Sun&amp;sel=388#l564
# and consider the magic behind parameter binding (which is really normal
# binding).
{
  my $hashref = { a =&gt; "a", b =&gt; "b" };
  my %hash   := $hashref;

  is +%hash, 2,                    'binding %hash := $hashref works (1)';

  %hash&lt;b&gt; = "c";
  is ~$hashref.values.sort, "a c", 'binding %hash := $hashref works (2)';
  is ~%hash\  .values.sort, "a c", 'binding %hash := $hashref works (3)';
}</pre>
</div>


<a name="msg_1"></a>
<a href="?hide_quotes=no#msg_1" onclick="return tog_quote(1);">
<div ID="header_shown_1" style="display: none;">
- Hide the snippet from t/operators/binding/arrays.t (line 5 ~ line 222) -
</div>
<div ID="header_hidden_1" style="display: block;">
- Show the snippet from t/operators/binding/arrays.t (line 5 ~ line 222, 218 lines) -
</div>
</a>
<div ID="hide_1" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/"Binding"&gt;

plan 46;

# Binding of array elements.
# See thread "Binding of array elements" on p6l started by Ingo Blechschmidt:
# L&lt;"http://www.nntp.perl.org/group/perl.perl6.language/22915"&gt;
{
  my @array  = &lt;a b c&gt;;
  my $var    = "d";

  try { @array[1] := $var };
  is @array[1], "d", "basic binding of an array element (1)", :todo&lt;feature&gt;;
  unless @array[1] eq "d" {
    skip_rest "Skipping binding of array elements tests (not yet implemented in the normal runcore)";
    exit;
  }

  $var = "e";
  is @array[1], "e", "basic binding of an array element (2)";

  @array[1] = "f";
  is $var,      "f", "basic binding of an array element (3)";
}

{
  my @array  = &lt;a b c&gt;;
  my $var    = "d";

  @array[1] := $var;
  $var       = "e";
  is @array[1], "e",  "binding of array elements works with .delete (1)";

  @array.delete(1);
  # $var unchanged, but assigning to $var doesn't modify @array any
  # longer; similarily, changing @array[1] doesn't modify $var now
  is $var,    "e",    "binding of array elements works with .delete (2)";
  is ~@array, "a  c", "binding of array elements works with .delete (3)";

  $var      = "f";
  @array[1] = "g";
  is $var,      "f",  "binding of array elements works with .delete (4)";
  is @array[1], "g",  "binding of array elements works with .delete (5)";
}

{
  my @array  = &lt;a b c&gt;;
  my $var    = "d";

  @array[1] := $var;
  $var       = "e";
  is @array[1], "e", "binding of array elements works with resetting the array (1)";

  @array = ();
  # $var unchanged, but assigning to $var doesn't modify @array any
  # longer; similarily, changing @array[1] doesn't modify $var now
  is $var,    "e",   "binding of array elements works with resetting the array (2)";
  is ~@array, "",    "binding of array elements works with resetting the array (3)";

  $var      = "f";
  @array[1] = "g";
  is $var,      "f", "binding of array elements works with resetting the array (4)";
  is @array[1], "g", "binding of array elements works with resetting the array (5)";
}

{
  my @array  = &lt;a b c&gt;;
  my $var    = "d";

  @array[1] := $var;
  $var       = "e";
  is @array[1], "e",   "binding of array elements works with rebinding the array (1)";

  my @other_array = &lt;x y z&gt;;
  @array := @other_array;
  # $var unchanged, but assigning to $var doesn't modify @array any
  # longer; similarily, changing @array[1] doesn't modify $var now
  is $var,    "e",     "binding of array elements works with rebinding the array (2)";
  is ~@array, "x y z", "binding of array elements works with rebinding the array (3)";

  $var      = "f";
  @array[1] = "g";
  is $var,      "f",   "binding of array elements works with rebinding the array (4)";
  is @array[1], "g",   "binding of array elements works with rebinding the array (5)";
}

{
  my sub foo (@arr) { @arr[1] = "new_value" }

  my @array  = &lt;a b c&gt;;
  my $var    = "d";
  @array[1] := $var;

  foo @array;
  is $var,    "new_value",     "passing an array to a sub expecting an array behaves correctly (1)";
  is ~@array, "a new_value c", "passing an array to a sub expecting an array behaves correctly (2)";
}

{
  my sub foo (Array $arr) { $arr[1] = "new_value" }

  my @array  = &lt;a b c&gt;;
  my $var    = "d";
  @array[1] := $var;

  foo @array;
  is $var,    "new_value",     "passing an array to a sub expecting an arrayref behaves correctly (1)";
  is ~@array, "a new_value c", "passing an array to a sub expecting an arrayref behaves correctly (2)";
}

{
  my sub foo (*@args) { @args[1] = "new_value" }

  my @array  = &lt;a b c&gt;;
  my $var    = "d";
  @array[1] := $var;

  foo @array;
  is $var,    "new_value",     "passing an array to a slurpying sub behaves correctly (1)";
  is ~@array, "a new_value c", "passing an array to a slurpying sub behaves correctly (2)";
}

{
  my sub foo (*@args) { push @args, "new_value" }

  my @array  = &lt;a b c&gt;;
  my $var    = "d";
  @array[1] := $var;

  foo @array;
  is $var,    "d",     "passing an array to a slurpying sub behaves correctly (3)";
  is ~@array, "a d c", "passing an array to a slurpying sub behaves correctly (4)";
}

# Binding of not yet existing elements should autovivify
{
  my @array;
  my $var    = "d";

  lives_ok { @array[1] := $var },
                     "binding of not yet existing elements should autovivify (1)";
  is @array[1], "d", "binding of not yet existing elements should autovivify (2)";

  $var = "e";
  is @array[1], "e", "binding of not yet existing elements should autovivify (3)";
  is $var,      "e", "binding of not yet existing elements should autovivify (4)";
}

# Binding with .splice
{
  my @array  = &lt;a b c&gt;;
  my $var    = "d";

  @array[1] := $var;
  $var       = "e";
  is @array[1], "e",  "binding of array elements works with splice (1)";

  splice @array, 1, 1, ();
  # $var unchanged, but assigning to $var doesn't modify @array any
  # longer; similarily, changing @array[1] doesn't modify $var now
  is $var,    "e",    "binding of array elements works with splice (2)";
  is ~@array, "a  c", "binding of array elements works with splice (3)";

  $var      = "f";
  @array[1] = "g";
  is $var,      "f",  "binding of array elements works with splice (4)";
  is @array[1], "g",  "binding of array elements works with splice (5)";
}

# Assignment (not binding) creates new containers
{
  my @array  = &lt;a b c&gt;;
  my $var    = "d";

  @array[1] := $var;
  $var       = "e";
  is @array[1], "e",       "array assignment creates new containers (1)";

  my @new_array = @array;
  $var          = "f";
  # @array[$idx] and $var are now "f", but @new_array is unchanged.
  is $var,        "f",     "array assignment creates new containers (2)";
  is ~@array,     "a f c", "array assignment creates new containers (3)";
  is ~@new_array, "a e c", "array assignment creates new containers (4)";
}

# Binding does not create new containers
{
  my @array  = &lt;a b c&gt;;
  my $var    = "d";

  @array[1] := $var;
  $var       = "e";
  is @array[1], "e",       "array binding does not create new containers (1)";

  my @new_array := @array;
  $var           = "f";
  # @array[$idx] and $var are now "f", but @new_array is unchanged.
  is $var,        "f",     "array binding does not create new containers (2)";
  is ~@array,     "a f c", "array binding does not create new containers (3)";
  is ~@new_array, "a f c", "array binding does not create new containers (4)";
}

# Binding @array := $arrayref.
# See
# http://colabti.de/irclogger/irclogger_log/perl6?date=2005-11-06,Sun&amp;sel=388#l564
# and consider the magic behind parameter binding (which is really normal
# binding).
{
  my $arrayref  = [&lt;a b c&gt;];
  my @array    := $arrayref;

  is +@array, 3,          'binding @array := $arrayref works (1)';

  @array[1] = "B";
  is ~$arrayref, "a B c", 'binding @array := $arrayref works (2)';
  is ~@array,    "a B c", 'binding @array := $arrayref works (3)';
}</pre>
</div>


<p>A new form of assignment is present in Perl 6, called <i>binding</i>, used in place of typeglob assignment. It is performed with the <code>:=</code> operator. Instead of replacing the value in a container like normal assignment, it replaces the container itself. For instance:</p>

<a name="msg_5"></a>
<a href="?hide_quotes=no#msg_5" onclick="return tog_quote(5);">
<div ID="header_shown_5" style="display: none;">
- Hide the snippet from t/operators/binding/scalars.t (line 15 ~ line 124) -
</div>
<div ID="header_hidden_5" style="display: block;">
- Show the snippet from t/operators/binding/scalars.t (line 15 ~ line 124, 110 lines) -
</div>
</a>
<div ID="hide_5" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/"Binding" /replaces the container itself\.  For instance:/&gt;
# Basic scalar binding tests
{
  my $x = 'Just Another';
  is($x, 'Just Another', 'normal assignment works');

  my $y := $x;
  is($y, 'Just Another', 'y is now bound to x');

  ok($y =:= $x, 'y is bound to x (we checked with the =:= identity op)');

  my $z = $x;
  is($z, 'Just Another', 'z is not bound to x');

  ok(!($z =:= $x), 'z is not bound to x (we checked with the =:= identity op)', :todo);

  $y = 'Perl Hacker';
  is($y, 'Perl Hacker', 'y has been changed to "Perl Hacker"');
  is($x, 'Perl Hacker', 'x has also been changed to "Perl Hacker"');

  is($z, 'Just Another', 'z is still "Just Another" because it was not bound to x');
}

# Binding and $CALLER::
{
  sub bar {
    return $CALLER::a eq $CALLER::b;
  }

  sub foo {
    env $a = "foo";
    env $b := $a;
    return bar(); # &amp;&amp; bar2();
  }

  ok(foo(), "CALLER resolves bindings in caller's dynamic scope");
}

# Binding to swap
{
  my $a = "a";
  my $b = "b";

  ($a, $b) := ($b, $a);
  is($a, 'b', '$a has been changed to "b"');
  is($b, 'a', '$b has been changed to "a"');

  $a = "c";
  is($a, 'c', 'binding to swap didn\'t make the vars readonly');
}

# More tests for binding a list
{
  my $a = "a";
  my $b = "b";
  my $c = "c";

  ($a, $b) := ($c, $c);
  is($a, 'c', 'binding a list literal worked (1)');
  is($b, 'c', 'binding a list literal worked (2)');

  $c = "d";
  is($a, 'd', 'binding a list literal really worked (1)');
  is($b, 'd', 'binding a list literal really worked (2)');
}

# Binding subroutine parameters
# XXX! When executed in interactive Pugs, the following test works!
{
  my $a;
  my $b = sub($arg) { $a := $arg };
  my $val = 42;

  $b($val);
  is $a, 42, "bound readonly sub param was bound correctly (1)";
  $val++;
  is $a, 43, "bound readonly sub param was bound correctly (2)";

  dies_ok { $a = 23 },
    "bound readonly sub param remains readonly (1)";
  is $a, 43,
    "bound readonly sub param remains readonly (2)";
  is $val, 43,
    "bound readonly sub param remains readonly (3)";
}

{
  my $a;
  my $b = sub($arg is rw) { $a := $arg };
  my $val = 42;

  $b($val);
  is $a, 42, "bound rw sub param was bound correctly (1)";
  $val++;
  is $a, 43, "bound rw sub param was bound correctly (2)";

  lives_ok { $a = 23 }, "bound rw sub param remains rw (1)";
  is $a, 23,            "bound rw sub param remains rw (2)";
  is $val, 23,          "bound rw sub param remains rw (3)";
}

# := actually takes subroutine parameter list
{
  my $a;
  eval '(:$a) := (:a&lt;foo&gt;)';
  is($a, "foo", "bound keyword", :todo);
  my @tail;
  eval '($a, *@tail) := (1, 2, 3)';
  ok($a == 1 and ~@tail eq '2 3', 'bound slurpy', :todo);
}</pre>
</div>


<pre>    my $x = &#39;Just Another&#39;;
    my $y := $x;
    $y = &#39;Perl Hacker&#39;;</pre>

<p>After this, both <code>$x</code> and <code>$y</code> contain the string <code>&#34;Perl Hacker&#34;</code>, since they are really just two different names for the same variable.</p>

<p>There is another variant, spelled <code>::=</code>, that does the same thing at compile time.</p>

<p>There is also an identity test, <code>=:=</code>, which tests whether two names are bound to the same underlying variable. <code>$x =:= $y</code> would return true in the above example.</p>

<p>The binding fails if the type of the variable being bound is sufficiently inconsistent with the type of the current declaration.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Declarators"
>Declarators</a></h1>

<p>The list of variable declarators has expanded from <code>my</code> and <code>our</code> to include:</p>

<pre>    my $foo             # ordinary lexically scoped variable
    our $foo            # lexically scoped alias to package variable
    has $foo            # object attribute
    state $foo          # persistent lexical (cloned with closures)
    constant $foo       # lexically scoped compile-time constant</pre>

<p>Variable declarators such as <code>my</code> now take a <i>signature</i> as their argument. (The syntax of function signatures is described more fully in S06.) The parentheses around the signature may be omitted for a simple declaration that declares a single variable, along with its associated type and traits. Parentheses must always be used when declaring multiple parameters:</p>

<pre>    my $a;              # okay
    my ($b, $c);        # okay
    my $b, $c;          # wrong: &#34;Use of undeclared variable: $c&#34;</pre>

<p>[XXX the following probably belongs in S06.] The syntax for constructing a <code>Signature</code> object when the parser isn&#39;t already expecting one is:</p>

<pre>    :(Dog $a, *@c)</pre>

<p>This might be used like this:</p>

<pre>    my $sig = :(Dog $a, *@c);</pre>

<p>Signatures are expected after declarators such as <code>my</code>, <code>sub</code>, <code>method</code>, <code>rule</code>, etc. In such declarators the colon may be omitted. But it&#39;s also legal to use it:</p>

<pre>    my :($b, $c);               # okay
    sub foo :($a,$b) {...}      # okay</pre>

<p>The <code>-&#62;</code> &#34;pointy block&#34; token also introduces a signature, but in this case you must omit both the colon and the parens. For instance, if you&#39;re defining the &#34;loop variable&#34; of a loop block:</p>

<pre>    for @dogpound -&#62; Dog $fido { ... }</pre>

<p>If a signature is assigned to (whether declared or colon form), the signature is converted to a list of lvalue variables and the ordinary rules of assignment apply, except that the evaluation of the right side and the assignment happens at time determined by the declarator. (With <code>my</code> this is always when an ordinary assignment would happen.) If the signature is too complicated to convert to an assignment, a compile-time error occurs. Assignment to a signature makes the same scalar/list distinction as ordinary assignment, so</p>

<pre>    my $a = foo();      # foo in scalar context
    my ($a) = foo();    # foo in list context</pre>

<p>If a signature is bound to an argument list, then the binding of the arguments proceeds as if the signature were the formal parameters for a function, except that, unlike in a function call, the parameters are bound <code>rw</code> by default rather than <code>readonly</code>. See Binding above.</p>

<p>Note that <code>temp</code> and <code>let</code> are <i>not</i> variable declarators, because their effects only take place at runtime. Therefore, they take an ordinary lvalue object as their argument. See S04 for more details.</p>

<p>There are a number of other declarators that are not variable declarators. These include both type declarators:</p>

<pre>    package Foo
    module Foo
    class Foo
    role Foo
    subset Foo</pre>

<p>and code declarators:</p>

<pre>    sub foo
    method foo
    submethod foo
    multi foo
    proto foo
    macro foo
    quote qX
    regex foo
    rule foo
    token foo</pre>

<p>These all have their uses and are explained in subsequent Synopses.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Argument_List_Interpolating"
>Argument List Interpolating</a></h1>

<p>Perl 5 forced interpolation of a function&#39;s argument list by use of the <code>&#38;</code> prefix. That option is no longer available in Perl 6, so instead the <code>[,]</code> reduction operator serves as an interpolator, by casting its operands to <code>Capture</code> objects and inserting them into the current argument list.</p>

<p>It can be used to interpolate an <code>Array</code> or <code>Hash</code> into the current call, as positional and named arguments respectively.</p>

<p>Note that those arguments still must comply with the subroutine&#39;s signature, but the presence of <code>[,]</code> defers that test until run time for that argument (and for any subsequent arguments):</p>

<pre>    my @args = \@foo, @bar;
    push [,] @args;</pre>

<p>is equivalent to:</p>

<pre>    push @foo, @bar;</pre>

<p>as is this:</p>

<pre>    my $args = \(@foo, @bar);    # construct a Capture object
    push [,] @$args;</pre>

<p>In list context, a <code>Scalar</code> holding an <code>Array</code> object does not flatten. Hence</p>

<pre>    $bar = @bar;
    push @foo, $bar;</pre>

<p>merely pushes a single <code>Array</code> object onto <code>@foo</code>. You can explicitly flatten it in either of these ways:</p>

<pre>    push @foo, @$bar;
    push @foo, $bar[];</pre>

<p>Those two forms work because the slurpy array in <code>push</code>&#39;s signature flattens the <code>Array</code> object into a list argument.</p>

<p>Note that those two forms also allow you to specify list context on assignment:</p>

<pre>    @$bar = 1,2,3;
    $bar[] = 1,2,3;</pre>

<p>For long lvalue expressions, the second form can keep the &#34;arrayness&#34; of the lvalue close to the assignment operator:</p>

<pre>    $foo.bar.baz.bletch.whatever.attr[] = 1,2,3;</pre>

<p>Otherwise you&#39;d have to write:</p>

<pre>    @($foo.bar.baz.bletch.whatever.attr) = 1,2,3;</pre>

<p>and remember the <code>@</code> at the front until you get to the <code>=</code>.</p>

<p>The empty <code>[]</code> and <code>.[]</code> postfix operators are interpreted as zero-dimensional slices returning the entire array, not null slices returning no elements. Likewise for <code>{}</code> and <code>.{}</code> on hashes, as well as the <code>&#60;&#62;</code>, <code>.&#60;&#62;</code>, <code>&#171;&#187;</code>, and <code>.&#171;&#187;</code> constant and interpolating slice subscripting forms.</p>

<p>The <code>[,]</code> operator interpolates lazily for <code>Array</code> and <code>Range</code> objects. To get an immediate interpolation like Perl 5 does, add the <code>eager</code> list operator:</p>

<pre>    func([,] 1..Inf);         # works fine
    func([,] eager 1..Inf);   # never terminates</pre>

<p>To interpolate a function&#39;s return value, you must say:</p>

<pre>    push [,] func();</pre>

<p>Within the argument list of a <code>[,]</code>, function return values are automatically exploded into their various parts, as if you&#39;d said:</p>

<pre>    my \$capture := func();
    push [,] $$capture: @$capture, %$capture;</pre>

<p>or some such. The <code>[,]</code> then handles the various zones appropriately depending on the context. An invocant only makes sense as the first argument to the outer function call. An invocant inserted anywhere else just becomes a positional argument at the front of its list, as if its colon changed back to a comma.</p>

<p>If you already have a capture variable, you can interpolate all of its bits at once using the <code>prefix:&#60;=&#62;</code> operator, which serves to iterate or dereference a scalar that would otherwise stay packed into its scalar value. The above is equivalent to:</p>

<pre>    my \$capture := func();
    push [,] =$capture;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Feed_operators"
>Feed operators</a></h1>

<a name="msg_18"></a>
<a href="?hide_quotes=no#msg_18" onclick="return tog_quote(18);">
<div ID="header_shown_18" style="display: none;">
- Hide the snippet from t/operators/pipe.t (line 12 ~ line 57) -
</div>
<div ID="header_hidden_18" style="display: block;">
- Show the snippet from t/operators/pipe.t (line 12 ~ line 57, 46 lines) -
</div>
</a>
<div ID="hide_18" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S03/"Feed operators"&gt;

=cut

plan 7;

{
    my @a = (1, 2);
    my (@b, @c);
    
    eval '@a ==&gt; @b';
    #eval '@c &lt;== @a'; # this yields the error:
    #Fail: cannot cast into a handle: VList [VInt 1,VInt 2]

    is(~@b, ~@a, "ltr pipe as simple assignment", :todo);
    is(~@c, ~@a, "rtl pipe as simple assignment", :todo);
};

{
    my @a = (1 .. 5);
    my @e = (2, 4);

    my (@b, @c);
    eval '@a ==&gt; grep { ($_ % 2) == 0 } ==&gt; @b';
    #eval '@c &lt;== grep { ($_ % 2) == 0 } &lt;== @a';

    is(~@b, ~@e, "array ==&gt; grep ==&gt; result", :todo);
    is(~@c, ~@e, "result &lt;== grep &lt;== array", :todo);
};

{
    my ($got_x, $got_y, @got_z);
    sub foo ($x, $y?, *@z) {
        $got_x = $x;
        $got_y = $y;
        @got_z = @z;
    }

    my @a = (1 .. 5);

    eval '@a ==&gt; foo "x"';

    is($got_x, "x", "x was passed as explicit param", :todo);
    is($got_y, undef, "optional param y was not bound to piped list");
    is(~@got_z, ~@a, '...slurpy array *@z got it', :todo);
};</pre>
</div>


<p>The new operators <code>==&#62;</code> and <code>&#60;==</code> are akin to UNIX pipes, but work with functions that accept and return lists. Since these lists are composed of discrete objects and not liquids, we call these <i>feed</i> operators rather than pipes. For example,</p>

<pre>     @result = map { floor($^x / 2) },
                 grep { /^ \d+ $/ },
                   @data;</pre>

<p>can also now be written with rightward feeds as:</p>

<pre>     @data ==&#62; grep { /^ \d+ $/ }
           ==&#62; map { floor($^x / 2) }
           ==&#62; @result;</pre>

<p>or with leftward feeds as:</p>

<pre>     @result &#60;== map { floor($^x / 2) }
             &#60;== grep { /^ \d+ $/ }
             &#60;== @data;</pre>

<p>Either form more clearly indicates the flow of data. See S06 for more of the (less-than-obvious) details on these two operators.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Invocant_marker"
>Invocant marker</a></h1>

<p>An appended <code>:</code> marks the invocant when using the indirect-object syntax for Perl 6 method calls. The following two statements are equivalent:</p>

<pre>    $hacker.feed(&#39;Pizza and cola&#39;);
    feed $hacker: &#39;Pizza and cola&#39;;</pre>

<p>A colon may also be used on an ordinary method call to indicate that it should be parsed as a list operator:</p>

<pre>    $hacker.feed: &#39;Pizza and cola&#39;;</pre>

<p>This colon is a separate token. A colon prefixing an adverb is not a separate token. Therefore, under the longest-token rule,</p>

<pre>    $hacker.feed:xxx(&#39;Pizza and cola&#39;);</pre>

<p>is tokenized as an adverb applying to the method:</p>

<pre>    $hacker.feed :xxx(&#39;Pizza and cola&#39;);</pre>

<p>not as an xxx sub in the argument list of .feed:</p>

<pre>    $hacker.feed: xxx(&#39;Pizza and cola&#39;);  # wrong</pre>

<p>If you want both meanings of colon, you have to put it twice:</p>

<pre>    $hacker.feed: :xxx(&#39;Pizza and cola&#39;), 1,2,3;</pre>

<p>(For similar reasons it&#39;s required to put whitespace after the colon of a label.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Traversing_arrays_in_parallel"
>Traversing arrays in parallel</a></h1>

<a name="msg_30"></a>
<a href="?hide_quotes=no#msg_30" onclick="return tog_quote(30);">
<div ID="header_shown_30" style="display: none;">
- Hide the snippet from t/builtins/lists/zip.t (line 9 ~ line 78) -
</div>
<div ID="header_hidden_30" style="display: block;">
- Show the snippet from t/builtins/lists/zip.t (line 9 ~ line 78, 70 lines) -
</div>
</a>
<div ID="hide_30" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S03/"Traversing arrays in parallel"&gt;

=cut

plan 12;

{
    my @a = (0, 2, 4);
    my @b = (1, 3, 5);

    my @e = (0 .. 5);

    my @z; @z = zip(@a; @b);
    my @y; @y = (@a ¥ @b);
    my @x; @x = (@a Y @b);

    is(~@z, ~@e, "simple zip");
    is(~@y, ~@e, "also with yen char");
    is(~@x, ~@e, "also with Y char");
};

{
    my @a = (0, 3);
    my @b = (1, 4);
    my @c = (2, 5);

    my @e = (0 .. 5);

    my @z; @z = zip(@a; @b; @c);
    my @y; @y = (@a ¥ @b ¥ @c);
    my @x; @x = (@a Y @b Y @c);

    is(~@z, ~@e, "zip of 3 arrays");
    is(~@y, ~@e, "also with yen char");
    is(~@x, ~@e, "also with Y char");
};

{
    my @a = (0, 4);
    my @b = (2, 6);
    my @c = (1, 3, 5, 7);

    my @e = (0 .. 7);

    my @z; @z = zip(zip(@a; @b); @c);
    my @y; @y = ((@a ¥ @b) ¥ @c);
    my @x; @x = ((@a Y @b) Y @c);

    is(~@z, ~@e, "zip of zipped arrays with other array");
    is(~@y, ~@e, "also as ¥");
    is(~@x, ~@e, "also as Y");
};

{
    my @a = (0, 2);
    my @b = (1, 3, 5);
    my @e = (0, 1, 2, 3, undef, 5);

    my @z = (@a ¥ @b);
    is(@z, @e, "bug in zipping - should use length of longest");
}

{
    my @a;
    my @b;

    (@a ¥ @b) = (1, 2, 3, 4);
    is(@a, [1, 3], "first half of two zipped arrays as lvalues", :todo);
    is(@b, [2, 4], "second half of the lvalue zip", :todo);
}</pre>
</div>


<p>In order to support parallel iteration over multiple arrays, Perl 6 has a <code>zip</code> function that builds <code>Seq</code> objects from the elements of two or more arrays.</p>

<pre>    for zip(@names; @codes) -&#62; [$name, $zip] {
        print &#34;Name: $name;   Zip code: $zip\n&#34;;
    }</pre>

<p><code>zip</code> has an infix synonym, the Unicode operator <code>&#165;</code>, and its ASCII equivalent <code>Y</code>.</p>

<p>To read arrays in parallel like <code>zip</code> but just sequence the values rather than generating tuples, use <code>each</code> instead of <code>zip</code>.</p>

<pre>    for each(@names; @codes) -&#62; $name, $zip {
        print &#34;Name: $name;   Zip code: $zip\n&#34;;
    }</pre>

<p>The <code>each</code> function reads to the end of the longest list, not counting lists that are known to be infinite such as <code>0..Inf</code>. Missing values are replaced with <code>undef</code>. In contrast, use <code>roundrobin</code> if you just wish to skip missing entries:</p>

<pre>    for roundrobin(@queue1; @queue2; @queue3) -&#62; $next {
        ...
    }</pre>

<p>To read arrays serially rather than in parallel, use <code>cat(@x;@y)</code>. This wins a &#34;useless use of cat award&#34; in this case since you could always just write <code>(@x,@y)</code> to mean the same thing. But sometimes it&#39;s nice to be explicit about that:</p>

<pre>    @foo := [[1,2,3],[4,5,6]]; say cat([;] @foo); # 1,2,3,4,5,6</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Minimal_whitespace_DWIMmery"
>Minimal whitespace DWIMmery</a></h1>

<p>Whitespace is no longer allowed before the opening bracket of an array or hash subscript, or the opening parenthesis of an argument list. That is:</p>

<pre>    @deadbeef[$x]         # okay
    @a       [$b]         # WRONG
    %monsters{&#39;cookie&#39;}   # okay
    %people  {&#39;john&#39;}     # WRONG
    saymewant(&#39;cookie&#39;)   # okay
    mewant   (&#39;cookie&#39;)   # WRONG</pre>

<p>One of the several useful side-effects of this restriction is that parentheses are no longer required around the condition of control constructs:</p>

<pre>    if $value eq $target {
        print &#34;Bullseye!&#34;;
    }
    while $i &#60; 10 { $i++ }</pre>

<p>It is, however, still possible to align subscripts and other postfix operators by explicitly using the <i>long dot</i> syntax (see S02):</p>

<pre>     %monsters.{&#39;cookie&#39;} = Monster.new;
     %beatles\.{&#39;ringo&#39;}  = Beatle.new;
     %people\ .{&#39;john&#39;}   = Person.new;
     %cats\   .{&#39;fluffy&#39;} = Cat.new;</pre>

<p>Whitespace is in general required between any keyword and any opening bracket that is <i>not</i> introducing a subscript or function arguments. Any keyword followed directly by parentheses will be taken as a function call instead.</p>

<pre>    if $a == 1 { say &#34;yes&#34; }            # preferred syntax
    if ($a == 1) { say &#34;yes&#34; }          # P5-ish if construct
    if($a,$b,$c)                        # if function call</pre>

<p>It is possible for <code>if()</code> to also invoke a macro call, but if so, it&#39;s a <code>prefix:&#60;if&#62;</code> macro rather than a <code>statement_control:&#60;if&#62;</code> macro.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Precedence"
>Precedence</a></h1>

<a name="msg_29"></a>
<a href="?hide_quotes=no#msg_29" onclick="return tog_quote(29);">
<div ID="header_shown_29" style="display: none;">
- Hide the snippet from t/operators/precedence.t (line 12 ~ line 165) -
</div>
<div ID="header_hidden_29" style="display: block;">
- Show the snippet from t/operators/precedence.t (line 12 ~ line 165, 154 lines) -
</div>
</a>
<div ID="hide_29" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S03/"Precedence"&gt;

=cut

plan 41;


# 1. terms

# FIXME how do we test this?

# 2. postfix method

# this wants objects, but maybe it can also work like
# @sort.map binds tighter than ++ somehow?

# 3. autoincrement

my $i = 2;
is(++$i ** 2, 9, "++ bind tighter than **");
is(--$i ** 2, 4, "-- does too");

# 4. exponentiation

is(-2**2, -4, "** bind tighter than unary -");
isa_ok(~2**4, "Str", "~4**4 is a string");

# 5. symbolic unary

is(-2 x 2, "-2-2", "unary - binds tighter than x");
is(-(2 x 2), "-22", "beh");
is(?2*2, 2, "binary -&gt; numify causes reinterpretation as, binds tighter than *");

# 6. multiplicative

is(2 x 2 + 10, 32, "x bind tighter than binary +");
is(4 + 3 * 2, 10, "* binds tighter than binary +");
is(0 - 3 / 3, -1, "/ bind tighter than binary -");

# 7. additive

is(1 ~ 2 * 3, 16, "~ binds looser than *");
ok((1 ~ 2 &amp; 12) == 12, "but tighter than &amp;");
ok((2 + 2 | 4) == 4, "and + binds tigher than |");

# 8. junctive and

ok(       (1 &amp; 2 | 3) !=3, '&amp; binds tighter than |');
ok((!(1 &amp; 2 | 3) &lt; 2), "ditto");
ok(((1 &amp; 2 ^ 3) &lt; 3), "and also ^");
ok(     !(1 &amp; 2 ^ 4) != 3, "blah blah blah");

# 9. junctive or

{ # test that | and ^ are on the same level
    my $a = (1 | 2 ^ 3);
    my $b = (1 ^ 2 | 3);

    ok($a == 3, "only one is eq 3");
    ok($a != 3, "either is ne 3");
    ok($a == 1, "either is eq 1");
    ok($b == 2, "either is eq 2, ne 3");
    ok($b == 1, "either is eq 1");
    ok($b == 3, "either is eq 3, of which only one is");
    ok(!($b != 3), "1 is ne 3, and (2 | 3) is both ne 3 and eq 3, so it's ne, so 1 ^ 2 | 3");
};

{
    my $a = (abs -1 ^ -1); # read as abs(-1 ^ -1) -&gt; (1^1)
    ok(!($a == 1), 'junctive or binds more tightly then abs (1)');

    my $b = ((abs -1) ^ -1); # -&gt; (1 ^ -1)
    ok($b == 1, "this is true because only one is == 1");
};

# 10. named unary

is((abs -1 .. 3), (1 .. 3), "abs binds tighter than ..");
is((rand 3 &lt;=&gt; 5), -1, "rand binds tighter than &lt;=&gt;");

# 11. nonchaining binary

ok(0 &lt; 2 &lt;=&gt; 1 &lt; 2, "0 &lt; 2 &lt;=&gt; 1 &lt; 2 means 0 &lt; 1 &lt; 2");

# 12. chaining binary

is((0 != 1 &amp;&amp; "foo"), "foo", "!= binds tigher than &amp;&amp;");
ok((0 || 1 == (2-1) == (0+1) || "foo") ne "foo", "== binds tigher than || also when chaning");

# 13. tight and (&amp;&amp;)

# 14. tight or (||, ^^, //)

is((1 &amp;&amp; 0 ?? 2 !! 3), 3, "&amp;&amp; binds tighter than ??");
### FIXME - need also ||, otherwise we don't prove || and ?? are diff

# 15. ternary

{
    my $a = 0 ?? "yes" !! "no";
    is($a, "no", "??!! binds tighter than =");
#    (my $b = 1) ?? "true" !! "false";
#    is($b, 1, "?? !! just thrown away with = in parens");
};


# 16. assignment

{
    my @c = 1, 2, 3;
    is(@c, (1), "= binds tighter than , (*sigh*)", :todo);
    my @a = (1, 3) ¥ (2, 4);
    is(@a, [1, 3], "= binds tighter than yen");
};

{
    my @b = ((1, 3) ¥ (2, 4));
    is(@b, [1 .. 4], "parens work around this");
};

# 17. list item separator

{
    my @d;
    eval_ok '@d &lt;== (1, 3) ¥ (2, 4), "left pointing pipe parses"', :todo;
    is(@d, [1 .. 4], "to complicate things further, left pointing pipe *does* DWIM", :todo);
    my $c = any 1, 2, 3;
    ok($c == 2, "any is less tight than comma");
}

# 18. rightward list op

{
    my @e; eval '@e = (map { $_+1 } &lt;== (1, 2, 3) ==&gt; map { $_*2 })'; # =D
    is(@e, [4, 6, 8], "&lt;== is tighter than ==&gt;", :todo);
}

# 19. pipe forward

# 20. loose and

# 21. loose or

# 22. expr terminator

# 23. uc|ucfirst|lc|lcfirst
# t/builtins/strings/uc|ucfirst|lc|lcfirst.t didn't compile because of this bug.
# Compare:
#   $ perl -we 'print uc "a" eq "A"'
#   1
# opposed to Pugs parses it:
#   $ perl -we 'print uc("a" eq "A")'
#   $    (no output)
ok (uc "a" eq "A"), "uc has the correct precedence in comparision to eq";</pre>
</div>


<p>Perl 6 has 22 precedence levels (which is fewer than Perl 5):</p>

<pre>    terms               42 3.14 &#34;eek&#34; qq[&#34;foo&#34;] [1,2,3] {...} \(@a,$b,%c)
                            $x @y %z /abc/ MyType @@multidim $^a
                            (1+2) a(1) :by(2) :!verbose :(Dog $self:)
                            .meth with implicit invocant
                            listops leftward
    method postfix      .meth .+ .? .* .() .[] .{} .&#60;&#62; .&#171;&#187; .:: .= .^
    autoincrement       ++ --
    exponentiation      **
    symbolic unary      ! + - ~ ? $ @ % &#38; +^ ~^ ?^ \ ^ =
    multiplicative      * / % x xx +&#38; +&#60; +&#62; ~&#38; ~&#60; ~&#62; ?&#38