<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
           "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>S03</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="http://dev.perl.org/css/perl.css">

<script type="text/javascript">
var agt = navigator.userAgent.toLowerCase();

var is_opera = (agt.indexOf("opera") != -1);
var is_ie = (agt.indexOf("msie") != -1) && document.all && !is_opera;
var is_ie5 = (agt.indexOf("msie 5") != -1) && document.all;

function tog() {
  // tog: toggle the visibility of html elements (arguments[1..]) from none to
  // arguments[0].  Return what should be returned in a javascript onevent().
  display = arguments[0];
  for( var i=1; i<arguments.length; i++ ) {
    var x = document.getElementById(arguments[i]);
    if (!x) continue;
    if (x.style.display == "none" || x.style.display == "") {
      x.style.display = display;
    } else {
      x.style.display = "none";
    }
  }

  var e = is_ie ? window.event : this;
  if (e) {
    if (is_ie) {
      e.cancelBubble = true;
      e.returnValue = false;
      return false;
    } else {
      return false;
    }
  }
}

function tog_quote( idnum ) {
  return tog( 'block', 'header_shown_' + idnum, 'header_hidden_' + idnum,
       'hide_' + idnum );
}

</script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.03,
  using Pod::Simple::PullParser v2.02,
  under Perl v5.008007 at Mon Oct  9 11:02:51 2006 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
            <I>This page was generated at 2006-10-09 11:02:51 GMT.
            (syn <strong>r12875</strong>, pugs <strong>r14123</strong>)</I>
        
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Changes_to_Perl_5_operators'>Changes to Perl 5 operators</a>
  <li class='indexItem indexItem1'><a href='#New_operators'>New operators</a>
  <li class='indexItem indexItem1'><a href='#Smart_matching'>Smart matching</a>
  <li class='indexItem indexItem1'><a href='#Meta_operators'>Meta operators</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Assignment_operators'>Assignment operators</a>
    <li class='indexItem indexItem2'><a href='#Negated_relational_operators'>Negated relational operators</a>
    <li class='indexItem indexItem2'><a href='#Hyper_operators'>Hyper operators</a>
    <li class='indexItem indexItem2'><a href='#Reduction_operators'>Reduction operators</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Cross_operators'>Cross operators</a>
  <li class='indexItem indexItem1'><a href='#Junctive_operators'>Junctive operators</a>
  <li class='indexItem indexItem1'><a href='#Chained_comparisons'>Chained comparisons</a>
  <li class='indexItem indexItem1'><a href='#Binding'>Binding</a>
  <li class='indexItem indexItem1'><a href='#Declarators'>Declarators</a>
  <li class='indexItem indexItem1'><a href='#Argument_List_Interpolating'>Argument List Interpolating</a>
  <li class='indexItem indexItem1'><a href='#Feed_operators'>Feed operators</a>
  <li class='indexItem indexItem1'><a href='#Invocant_marker'>Invocant marker</a>
  <li class='indexItem indexItem1'><a href='#Traversing_arrays_in_parallel'>Traversing arrays in parallel</a>
  <li class='indexItem indexItem1'><a href='#Crossing_arrays'>Crossing arrays</a>
  <li class='indexItem indexItem1'><a href='#Minimal_whitespace_DWIMmery'>Minimal whitespace DWIMmery</a>
  <li class='indexItem indexItem1'><a href='#Precedence'>Precedence</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 3: Summary of Perl 6 Operators</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Luke Palmer &#60;luke@luqui.org&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre>  Maintainer: Larry Wall &#60;larry@wall.org&#62;
  Date: 8 Mar 2004
  Last Modified: 28 Sept 2006
  Number: 3
  Version: 69</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Changes_to_Perl_5_operators"
>Changes to Perl 5 operators</a></h1>

<p>Several operators have been given new names to increase clarity and better Huffman-code the language, while others have changed precedence. (If an operator is not mentioned in this Synopsis, assume that it remains the same as in Perl 5. And if that doesn&#39;t make sense, assume this document is faulty. :)</p>

<ul>
<li>Perl 5&#39;s <code>${...}</code>, <code>@{...}</code>, <code>%{...}</code>, etc. dereferencing forms are now <code>$(...)</code>, <code>@(...)</code>, <code>%(...)</code>, etc. instead.</li>

<li><code>-&#62;</code> becomes <code>.</code>, like the rest of the world uses.
<a href="#" onclick="return tog_quote(20);">
<div ID="header_shown_20" style="display: none;">
- Hide the snippet from t/oo/methods/chaining.t (line 7 ~ line 58) -
</div>
<div ID="header_hidden_20" style="display: block;">
- Show the snippet from t/oo/methods/chaining.t (line 7 ~ line 58) -
</div>
</a>
<div ID="hide_20" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;Changes to Perl 5 operators&quot;/&quot;-&gt; becomes .&quot;&gt;

class Foo {
&nbsp; &nbsp; has $.num;
&nbsp; &nbsp; 
&nbsp; &nbsp; method bar ($self: $num) returns Foo {
&nbsp; &nbsp; &nbsp; &nbsp; $.num = $num; 
&nbsp; &nbsp; &nbsp; &nbsp; return $self;
&nbsp; &nbsp; }
&nbsp; &nbsp; 
&nbsp; &nbsp; method baz ($self: $num) returns Foo {
&nbsp; &nbsp; &nbsp; &nbsp; $.num += $num;
&nbsp; &nbsp; &nbsp; &nbsp; return $self;
&nbsp; &nbsp; }
}

my $foo = Foo.new(:num&lt;10&gt;);
isa_ok($foo, 'Foo');

# do some sanity checking to make sure it does 
# all that we expect it too first.

is($foo.num(), 10, '... got the right num value');

my $_foo1 = $foo.bar(20);
isa_ok($_foo1, 'Foo');
ok($_foo1 === $foo, '... $_foo1 and $foo are the same instances');

is($foo.num(), 20, '... got the right num value');

my $_foo2 = $foo.baz(20);
isa_ok($_foo2, 'Foo');
ok( ([===]($foo, $_foo2, $_foo1)), '... $_foo1, $_foo2 and $foo are the same instances');

is($foo.num(), 40, '... got the right num value');

# now lets try it with chained methods ...

my $_foo3;
lives_ok {
&nbsp; &nbsp; $_foo3 = $foo.bar(10).baz(5);
}, '... method chaining works';

isa_ok($_foo3, 'Foo');
ok( ([===]($_foo3, $_foo2, $_foo1, $foo)),
&nbsp; &nbsp; '... $_foo3, $_foo1, $_foo2 and $foo are the same instances');

is($foo.num(), 15, '... got the right num value');

# test attribute accessors, too
is($foo.baz(7).baz(6).num, 28, 'chained an auto-generated accessor');</pre>
</div>


<a href="#" onclick="return tog_quote(19);">
<div ID="header_shown_19" style="display: none;">
- Hide the snippet from t/oo/methods/chaining.t (line 59 ~ line 78) -
</div>
<div ID="header_hidden_19" style="display: block;">
- Show the snippet from t/oo/methods/chaining.t (line 59 ~ line 78) -
</div>
</a>
<div ID="hide_19" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;Changes to Perl 5 operators&quot;/&quot;-&gt; becomes .&quot;&gt;
# L&lt;S12/&quot;Open vs Closed Classes&quot;/&quot;though you have to be explicit&quot;&gt;
{
class Pair is also {
&nbsp; &nbsp; our &nbsp; &nbsp; &nbsp;method car () { self.key; }
&nbsp; &nbsp; our Pair method cdr () { self.value; }
}

# (A =&gt; (B =&gt; undef)) =&gt; (C =&gt; undef))
# ((A B) C)

my $cons = [=&gt;] ( [=&gt;] &lt;A B&gt;, undef ), &lt;C&gt;, undef;

## Hmm. &nbsp;Works with the latest release of Pugs (6.2.12 (r13256))
## Leaving this in as something that once didn't work (6.2.12 CPAN)

my $p = $cons.car;
ok( $cons.key.key =:= $p.car, 'chaining through temp variable' );
ok( $cons.key.key =:= $cons.car.car, 'chaining through Any return');
}</pre>
</div>

</li>

<li>The string concatenation <code>.</code> becomes <code>~</code>. Think of it as &#34;stitching&#34; the two ends of its arguments together. String append is likewise <code>~=</code>.</li>

<li>The filetest operators now return a result that is both a boolean (or in the case of <code>-s</code>, a number) and a stat buffer, so there is no longer any need for Perl 5&#39;s <code>_</code> term. Instead just cascade tests to &#34;and&#34; them:
<a href="#" onclick="return tog_quote(32);">
<div ID="header_shown_32" style="display: none;">
- Hide the snippet from t/operators/filetest.t (line 89 ~ line 97) -
</div>
<div ID="header_hidden_32" style="display: block;">
- Show the snippet from t/operators/filetest.t (line 89 ~ line 97) -
</div>
</a>
<div ID="hide_32" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Changes to Perl 5 operators/&quot;just cascade tests&quot;&gt;
ok -e -d -r &quot;t&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;stacking of filetest operators (1)&quot;;
ok -e -f -r $*PROGRAM_NAME, &quot;stacking of filetest operators (2)&quot;;
ok not -e -f -r &quot;doesnotexist.t&quot;, &quot;stacking of filetest operators (3)&quot;;
# This one should return false *all the time* (-f and -d are mutually
# exclusive):
ok not -e -f -d &quot;t&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;stacking of filetest operators (4-1)&quot;;
ok not -e -f -d &quot;doesnotexist.t&quot;, &quot;stacking of filetest operators (4-2)&quot;;
ok not -e -f -d &quot;pugs&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;stacking of filetest operators (4-3)&quot;;</pre>
</div>


<a href="#" onclick="return tog_quote(30);">
<div ID="header_shown_30" style="display: none;">
- Hide the snippet from t/operators/filetest.t (line 103 ~ line 106) -
</div>
<div ID="header_hidden_30" style="display: block;">
- Show the snippet from t/operators/filetest.t (line 103 ~ line 106) -
</div>
</a>
<div ID="hide_30" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Changes to Perl 5 operators/&quot;in the case of -s, a number&quot;&gt;
my $sizeSB = -s $*PROGRAM_NAME;
ok $sizeSB &gt; 42, '-s is a number';
ok -e $sizeSB, 'result of -s is a stat buffer', :todo&lt;bug&gt;;</pre>
</div>


<a href="#" onclick="return tog_quote(29);">
<div ID="header_shown_29" style="display: none;">
- Hide the snippet from t/operators/filetest.t (line 107 ~ line 116) -
</div>
<div ID="header_hidden_29" style="display: block;">
- Show the snippet from t/operators/filetest.t (line 107 ~ line 116) -
</div>
</a>
<div ID="hide_29" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Changes to Perl 5 operators/filetest operators return both
# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a boolean and a stat buffer&gt;
$sb = -f $*PROGRAM_NAME;
isa_ok $sb, 'Bool', 'filetest operators return a boolean', :todo&lt;feature&gt;;
$sb = -s $*PROGRAM_NAME;
isa_ok $sb, 'Num', '-s returns a number';
# We should get false, but still be able to use the result
$sb = -f &quot;t&quot;;
skip 1, '-f &quot;t&quot; is true somehow, so next test is invalid' if $sb;
ok -e $sb, 'false stat buffers can still be used', :todo&lt;bug&gt;;</pre>
</div>


<pre>    if -r -w -x $filename {...}</pre>

<p>Or put the value in a variable to do anything fancier:</p>

<a href="#" onclick="return tog_quote(31);">
<div ID="header_shown_31" style="display: none;">
- Hide the snippet from t/operators/filetest.t (line 98 ~ line 102) -
</div>
<div ID="header_hidden_31" style="display: block;">
- Show the snippet from t/operators/filetest.t (line 98 ~ line 102) -
</div>
</a>
<div ID="hide_31" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Changes to Perl 5 operators/&quot;put the value in a variable&quot;&gt;
my $sb = -e &quot;t&quot;;
ok -d $sb, 'filetest operators return a stat buffer';
$sb = -e $*PROGRAM_NAME;
ok -f -r $sb, 'filetest operators can stack on stat buffer';</pre>
</div>


<pre>    $sb = -e $filename;
    if -r $sb {...}
    if -w $sb {...}
    if -x $sb {...}</pre>
</li>

<li>All postfix operators that do not start with a dot also have an alternate form that does. (The converse does not hold--just because you can write <code>x().foo</code> doesn&#39;t mean you can write <code>x()foo</code>. Likewise the ability to say <code>$x.&#39;foo&#39;</code> does not imply that <code>$x&#39;foo&#39;</code> will work.)
<p>The postfix interpretation of an operator may be overridden by use of a quoted method call, which calls the prefix form instead. So <code>x().!</code> is always the postfix operator, but <code>x().&#39;!&#39;</code> will always call <code>!x()</code>. In particular, you can say things like <code>$array.&#39;@&#39;</code> and <code>$filename.&#39;-e&#39;.&#39;-r&#39;</code>. You may even say things like <code>$fh.&#39;=&#39;</code>, which because of the quotes will not be confused lexically with <code>$fh.=new</code>.</p>
</li>

<li>Unary <code>~</code> now imposes a string (<code>Str</code>) context on its argument, and <code>+</code> imposes a numeric (<code>Num</code>) context (as opposed to being a no-op in Perl 5). Along the same lines, <code>?</code> imposes a boolean (<code>Bool</code>) context, and the <code>|</code> unary operator imposes a function-arguments (<code>Capture</code>) context on its argument. Unary sigils impose the container context implied by their sigil. As with Perl 5, however, <code>$$foo[bar]</code> parses as <code>( $($foo) )[bar]</code>, so you need <code>$($foo[bar])</code> to mean the other way.
<a href="#" onclick="return tog_quote(27);">
<div ID="header_shown_27" style="display: none;">
- Hide the snippet from t/operators/numify.t (line 13 ~ line 58) -
</div>
<div ID="header_hidden_27" style="display: block;">
- Show the snippet from t/operators/numify.t (line 13 ~ line 58) -
</div>
</a>
<div ID="hide_27" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;Changes to Perl 5 operators&quot;/&quot;imposes a numeric&quot;&gt;

# Per Larry: L&lt;<a href="http://www.nntp.perl.org/group/perl.perl6.compiler/1134">http://www.nntp.perl.org/group/perl.perl6.compiler/1134</a>&gt;
is(+'0012', 12, &quot;+'0012' is 12&quot;);
is(+'0000', &nbsp;0, &quot;+'0000' is &nbsp;0&quot;);
is(+'000a', &nbsp;0, &quot;+'000a' is &nbsp;0 (illegal number)&quot;);

is(+'1.9e3', 1900, &quot;+'1.9e3' is 1900&quot;);
is(+'Inf', Inf, &quot;+'Inf' is Inf&quot;);
is(+'Info', 0, &quot;+'Info' is 0&quot;);
is(+'-Inf', -Inf, &quot;+'-Inf' is -Inf&quot;);
is(+'-Info', 0, &quot;+'-Info' is 0&quot;);
is(+'NaN', NaN, &quot;+'NaN' is NaN&quot;);
is(+'NaNa', 0, &quot;+'NaNa' is 0&quot;);

# XXX Not sure whether the following tests are correct
is(+'Inf ', &nbsp; &nbsp; &nbsp;Inf, &quot;numification of strings with whitspace (1)&quot;);
is(+'Inf o', &nbsp; &nbsp; &nbsp; 0, &quot;numification of strings with whitspace (2)&quot;);
is(+'NaN ', &nbsp; &nbsp; &nbsp;NaN, &quot;numification of strings with whitspace (3)&quot;);
is(+'NaN a', &nbsp; &nbsp; &nbsp; 0, &quot;numification of strings with whitspace (4)&quot;);
is(+&quot;Inf\t&quot;, &nbsp; &nbsp; Inf, &quot;numification of strings with whitspace (5)&quot;);
is(+&quot;Inf\to&quot;, &nbsp; &nbsp; &nbsp;0, &quot;numification of strings with whitspace (6)&quot;);
is(+&quot;NaN\t&quot;, &nbsp; &nbsp; NaN, &quot;numification of strings with whitspace (7)&quot;);
is(+&quot;NaN\ta&quot;, &nbsp; &nbsp; &nbsp;0, &quot;numification of strings with whitspace (8)&quot;);
is(+&quot;Inf\n&quot;, &nbsp; &nbsp; Inf, &quot;numification of strings with whitspace (9)&quot;);
is(+&quot;Inf\no&quot;, &nbsp; &nbsp; &nbsp;0, &quot;numification of strings with whitspace (10)&quot;);
is(+&quot;NaN\n&quot;, &nbsp; &nbsp; NaN, &quot;numification of strings with whitspace (11)&quot;);
is(+&quot;NaN\na&quot;, &nbsp; &nbsp; &nbsp;0, &quot;numification of strings with whitspace (12)&quot;);
is(+&quot;Inf\n\t &quot;, &nbsp;Inf, &quot;numification of strings with whitspace (13)&quot;);
is(+&quot;Inf\n\t o&quot;, &nbsp; 0, &quot;numification of strings with whitspace (14)&quot;);
is(+&quot;NaN\n\t &quot;, &nbsp;NaN, &quot;numification of strings with whitspace (15)&quot;);
is(+&quot;NaN\n\t a&quot;, &nbsp; 0, &quot;numification of strings with whitspace (16)&quot;);
is(+&quot;3 &quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3, &quot;numification of strings with whitspace (17)&quot;);

is(+'aInf', &nbsp;0, &quot;+'aInf' &nbsp;is 0&quot;);
is(+'aInfo', 0, &quot;+'aInfo' is 0&quot;);
is(+'aNaN', &nbsp;0, &quot;+'aNaN' &nbsp;is 0&quot;);
is(+'aNaNa', 0, &quot;+'aNaNa' is 0&quot;);

is( Inf, &nbsp;'Inf', &quot;'Inf' is Inf&quot;);
is(-Inf, '-Inf', &quot;'-Inf' is -Inf&quot;);

is(+(~(+Inf)), &nbsp;Inf, &quot;'+Inf' is Inf&quot;);
is(+(~(-Inf)), -Inf, &quot;'-Inf' is -Inf&quot;);</pre>
</div>


<a href="#" onclick="return tog_quote(25);">
<div ID="header_shown_25" style="display: none;">
- Hide the snippet from t/syntax/force_context.t (line 43 ~ line 58) -
</div>
<div ID="header_hidden_25" style="display: block;">
- Show the snippet from t/syntax/force_context.t (line 43 ~ line 58) -
</div>
</a>
<div ID="hide_25" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Changes to Perl 5 operators/Unary ~ string context&gt;
# string context
{
&nbsp; &nbsp; my $a = 10.500000;
&nbsp; &nbsp; isa_ok(~$a, Str, 'it is forced into a Str');
&nbsp; &nbsp; is(~$a, '10.5', 'forced into string context');

&nbsp; &nbsp; my $b = -100;
&nbsp; &nbsp; isa_ok(~$b, Str, 'it is forced into a Str');
&nbsp; &nbsp; is(~$b, '-100', 'forced into string context');

&nbsp; &nbsp; my $c = -100.1010;
&nbsp; &nbsp; isa_ok(~$c, Str, 'it is forced into a Str');
&nbsp; &nbsp; is(~$c, '-100.101', 'forced into string context');
}</pre>
</div>


<a href="#" onclick="return tog_quote(24);">
<div ID="header_shown_24" style="display: none;">
- Hide the snippet from t/syntax/force_context.t (line 60 ~ line 84) -
</div>
<div ID="header_hidden_24" style="display: block;">
- Show the snippet from t/syntax/force_context.t (line 60 ~ line 84) -
</div>
</a>
<div ID="hide_24" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Changes to Perl 5 operators/&quot;?&quot; imposes boolean context&gt;
# boolean context
{
&nbsp; &nbsp; my $a = '';
&nbsp; &nbsp; isa_ok(?$a, Bool, 'it is forced into a Bool');
&nbsp; &nbsp; ok(!(?$a), 'it is forced into boolean context');

&nbsp; &nbsp; my $b = 'This will be true';
&nbsp; &nbsp; isa_ok(?$b, Bool, 'it is forced into a Bool');
&nbsp; &nbsp; ok(?$b, 'it is forced into boolean context');

&nbsp; &nbsp; my $c = 0;
&nbsp; &nbsp; isa_ok(?$c, Bool, 'it is forced into a Bool');
&nbsp; &nbsp; ok(!(?$c), 'it is forced into boolean context');

&nbsp; &nbsp; my $d = 1;
&nbsp; &nbsp; isa_ok(?$d, Bool, 'it is forced into a Bool');
&nbsp; &nbsp; ok(?$d, 'it is forced into boolean context');

&nbsp; &nbsp; my $arrayref is context = list(1,2,3);
&nbsp; &nbsp; my $boo is context = 37;
&nbsp; &nbsp; ok eval_elsewhere('?(@$+arrayref)'), '?(@$arrayref) syntax works';
&nbsp; &nbsp; ok eval_elsewhere('?(@($+arrayref))'), '?(@($arrayref)) syntax works';
}</pre>
</div>

</li>

<li>Bitwise operators get a data type prefix: <code>+</code>, <code>~</code>, or <code>?</code>. For example, Perl 5&#39;s <code>|</code> becomes either <code>+|</code> or <code>~|</code> or <code>?|</code>, depending on whether the operands are to be treated as numbers, strings, or boolean values. Perl 5&#39;s left shift <code> &#60;&#60; </code> becomes <code> +&#60; </code>, and correspondingly with right shift. Perl 5&#39;s unary <code>~</code> (one&#39;s complement) becomes either <code>+^</code> or <code>~^</code> or <code>?^</code>, since a bitwise NOT is like an exclusive-or against solid ones. Note that <code>?^</code> is functionally identical to <code>!</code>, but conceptually coerces to boolean first and then flips the bit. Please use <code>!</code> instead.
<p><code>?|</code> is a logical OR but differs from <code>||</code> in that <code>?|</code> always evaluates both sides and returns a standard boolean value. That is, it&#39;s equivalent to <code>?$a + ?$b != 0</code>. Another difference is that it has the precedence of an additive operator.</p>

<p><code>?&#38;</code> is a logical AND but differs from <code>&#38;&#38;</code> in that <code>?&#38;</code> always evaluates both sides and returns a standard boolean value. That is, it&#39;s equivalent to <code>?$a * ?$b != 0</code>. Another difference is that it has the precedence of a multiplicative operator.</p>

<p>Bitwise string operators (those starting with <code>~</code>) may only be applied to <code>Buf</code> types or similar compact integer arrays, and treat the entire chunk of memory as a single huge integer. They differ from the <code>+</code> operators in that the <code>+</code> operators would try to convert the string to a number first on the assumption that the string was an ASCII representation of a number.</p>
</li>

<li><code>x</code> splits into two operators: <code>x</code> (which concatenates repetitions of a string to produce a single string), and <code>xx</code> (which creates a list of repetitions of a list or scalar). <code>&#34;foo&#34; xx *</code> represents an arbitrary number of copies, useful for initializing lists. The left side of an <code>xx</code> is evaluated only once. (To call a block repeatedly, use a <code>map</code> instead.)</li>

<li>The <code>? :</code> conditional operator becomes <code>?? !!</code>. It is a syntax error to use an operator in the middle that binds looser in precedence, such as <code>=</code>.</li>

<li><code>qw{ ... }</code> gets a synonym: <code> &#60; ... </code> &#62;, and an interpolating variant, <code>&#171;...&#187;</code>. For those still living without the blessings of Unicode, that can also be written: <code>&#60;&#60; ... &#62;&#62;</code>.</li>

<li>The scalar comma <code>,</code> now constructs a <code>List</code> object from its operands. You have to use a <code>[-1]</code> subscript to get the last one.</li>

<li>The unary backslash operator captures its arguments, and returns an object representing those arguments. You can <i>dereference</i> this object in several ways to retrieve different parts of the arguments; see the definition of <code>Capture</code> in S02 for details. (No whitespace is allowed after the backslash because that would instead start an &#34;unspace&#34;, that is, an escaped sequence of whitespace or comments. See S02 for details. However, oddly enough, because of that unspace rule, saying <code>\\ $foo</code> turns out to be equivalent to <code>\$foo</code>.)</li>

<li>The old scalar <code>..</code> flipflop operator is now done with <code>ff</code> operator. (<code>..</code> now always produces a <code>Range</code> object even in scalar context.) The <code>ff</code> operator may take a caret on either end to exclude either the beginning or ending. There is also a corresponding <code>fff</code> operator with Perl 5&#39;s <code>...</code> semantics. You may say
<a href="#" onclick="return tog_quote(28);">
<div ID="header_shown_28" style="display: none;">
- Hide the snippet from t/operators/flip-flop.t (line 7 ~ line 117) -
</div>
<div ID="header_hidden_28" style="display: block;">
- Show the snippet from t/operators/flip-flop.t (line 7 ~ line 117) -
</div>
</a>
<div ID="hide_28" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;Changes to Perl 5 operators&quot; /flipflop operator is now done with/&gt;

# XXX tests for fff

sub take (Int $n, Code &amp;f) { (1..$n).map:{ try { f() } } }
sub always_false { 0 }
sub always_true &nbsp;{ 1 }

# Basic ff
{
&nbsp; ok eval('1 ff 1'), 'flip-flop operator implemented', :todo&lt;feature&gt;;

}

{
&nbsp; &nbsp; my @result = eval('take 5, { ?(always_false() ff always_false()) }');
&nbsp; &nbsp; is ~@result, &quot; &nbsp; &nbsp;&quot;, &quot;always_false() ff always_false()&quot;, :todo&lt;feature&gt;;
}

{
&nbsp; &nbsp; my @result = eval('take 5, { ?(always_false() ff always_true()) }');
&nbsp; &nbsp; is ~@result, &quot; &nbsp; &nbsp;&quot;, &quot;always_false() ff always_true()&quot;, :todo&lt;feature&gt;;
}

{
&nbsp; &nbsp; my @result = eval('take 5, { ?(always_true() ff always_true()) }');
&nbsp; &nbsp; ok all(@result), &quot;always_true() ff always_true()&quot;;
}

{
&nbsp; &nbsp; my @result = eval('take 5, { ?(always_true() ff always_false()) }');
&nbsp; &nbsp; is ~@result, &quot;1 2 3 4 5&quot;, &quot;always_true() ff always_false()&quot;, :todo&lt;feature&gt;;
}

# Basic ^ff
{
&nbsp; &nbsp; my @result = eval('take 5, { ?(always_false() ^ff always_false()) }');
&nbsp; &nbsp; is ~@result, &quot; &nbsp; &nbsp;&quot;, &quot;always_false() ^ff always_false()&quot;, :todo&lt;feature&gt;;
}

{
&nbsp; &nbsp; my @result = eval('take 5, { ?(always_false() ^ff always_true()) }');
&nbsp; &nbsp; is ~@result, &quot; &nbsp; &nbsp;&quot;, &quot;always_false() ^ff always_true()&quot;, :todo&lt;feature&gt;;
}

{
&nbsp; &nbsp; my @result = eval('take 5, { ?(always_true() ^ff always_true()) }') || 1;
&nbsp; &nbsp; my $first &nbsp;= shift @result;

&nbsp; &nbsp; ok !$first &amp;&amp; all(@result), &quot;always_true() ^ff always_true()&quot;,:todo&lt;feature&gt;;
}

{
&nbsp; &nbsp; my @result = eval('take 5, { ?(always_true() ^ff always_false()) }');
&nbsp; &nbsp; is ~@result, &quot; 2 3 4 5&quot;, &quot;always_true() ^ff always_false()&quot;, :todo&lt;feature&gt;;
}

# Basic ff^
{
&nbsp; &nbsp; my @result = eval('take 5, { ?(always_false() ff^ always_false()) }');
&nbsp; &nbsp; is ~@result, &quot; &nbsp; &nbsp;&quot;, &quot;always_false() ff^ always_false()&quot;, :todo&lt;feature&gt;;
}

{
&nbsp; &nbsp; my @result = eval('take 5, { ?(always_false() ff^ always_true()) }');
&nbsp; &nbsp; is ~@result, &quot; &nbsp; &nbsp;&quot;, &quot;always_false() ff^ always_true()&quot;, :todo&lt;feature&gt;;
}

{
&nbsp; &nbsp; my @result = eval('take 5, { ?(always_true() ff^ always_true()) }');

&nbsp; &nbsp; # XXX what should the result be?
}

{
&nbsp; &nbsp; my @result = eval('take 5, { ?(always_true() ff^ always_false()) }');
&nbsp; &nbsp; is ~@result, &quot;1 2 3 4 5&quot;, &quot;always_true() ff^ always_false()&quot;, :todo&lt;feature&gt;;
}

# RHS not evaluated when in &quot;false&quot; state (perldoc perlop, /flip-flop)
{
&nbsp; &nbsp; { my $bug; ok eval('0 ff {$bug=2};$bug ||=1'),:todo&lt;feature&gt;; ok ($bug == 1), &quot;RHS not evaluated in \&quot;false\&quot; state (ff)&quot;, :todo&lt;feature&gt;; }
&nbsp; &nbsp; { my $bug; ok eval('0 ^ff {$bug=2};$bug ||=1'),:todo&lt;feature&gt;; ok ($bug == 1), &quot;RHS not evaluated in \&quot;false\&quot; state (^ff)&quot;, :todo&lt;feature&gt;; }
&nbsp; &nbsp; { my $bug; ok eval('0 ff^ {$bug=2};$bug ||=1'),:todo&lt;feature&gt;; ok ($bug == 1), &quot;RHS not evaluated in \&quot;false\&quot; state (ff^)&quot;, :todo&lt;feature&gt;; }
}

# LHS not evaluated when in &quot;true&quot; state (perldoc perlop, /flip-flop)
{
&nbsp; &nbsp; my sub true_then_die {
&nbsp; &nbsp; &nbsp; &nbsp; state $invoked;
&nbsp; &nbsp; &nbsp; &nbsp; unless $invoked++ {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;true&quot;;
&nbsp; &nbsp; &nbsp; &nbsp; } else {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; die;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; ok eval('true_then_die() &nbsp;ff &nbsp;always_false();true_then_die() ff always_false()'),
&nbsp; &nbsp; &nbsp; &nbsp; &quot;LHS not evaluated in \&quot;true\&quot; state (ff)&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; ok eval('true_then_die() ^ff &nbsp;always_false();true_then_die() ^ff always_false()'),
&nbsp; &nbsp; &nbsp; &nbsp; &quot;LHS not evaluated in \&quot;true\&quot; state (^ff)&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; ok eval('true_then_die() &nbsp;ff^ always_false();true_the_die() ff^ always_false()'),
&nbsp; &nbsp; &nbsp; &nbsp; &quot;LHS not evaluated in \&quot;true\&quot; state (ff^)&quot;, :todo&lt;feature&gt;;
}

# See thread &quot;till (the flipflop operator, formerly ..)&quot; on p6l started by Ingo
# Blechschmidt, especially Larry's reply:
# http://www.nntp.perl.org/group/perl.perl6.language/24098
{
&nbsp; &nbsp; ok eval('my sub foo ($x) { try { $x ff 0 } }; if foo(0) || !foo(1) || !foo(0) { die }'),
&nbsp; &nbsp; 	&quot;all sub invocations share the same ff-state&quot;, :todo&lt;feature&gt;;
}</pre>
</div>


<pre>    /foo/ ff *</pre>

<p>to indicate a flipflop that never flops once flipped.</p>
</li>

<li>All comparison operators are unified at the same precedence level. See Chained Comparisons below.</li>

<li>The list assignment operator now parses on the right like any other list operator, so you don&#39;t need parens on the right side of:
<a href="#" onclick="return tog_quote(33);">
<div ID="header_shown_33" style="display: none;">
- Hide the snippet from t/operators/assign.t (line 4 ~ line 699) -
</div>
<div ID="header_hidden_33" style="display: block;">
- Show the snippet from t/operators/assign.t (line 4 ~ line 699) -
</div>
</a>
<div ID="hide_33" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;Changes to Perl 5 operators&quot;/&quot;The list assignment operator now parses on the right&quot;&gt;

plan 208;

# tests various assignment styles

{
&nbsp; &nbsp; my ($foo, $bar) = (&quot;FOO&quot;, &quot;BAR&quot;);
&nbsp; &nbsp; is($foo, &quot;FOO&quot;, &quot;assigned correct value to first of two scalars&quot;);
&nbsp; &nbsp; is($bar, &quot;BAR&quot;, &quot;... and second&quot;);

&nbsp; &nbsp; ($foo, $bar) = ($bar, $foo);
&nbsp; &nbsp; is($foo, &quot;BAR&quot;, &quot;swap assignment works for the first value&quot;);
&nbsp; &nbsp; is($bar, &quot;FOO&quot;, &quot;... and second&quot;);
}

{
&nbsp; &nbsp; my $x = 1;
&nbsp; &nbsp; &amp;infix:&lt;=&gt;.($x, 0);
&nbsp; &nbsp; is($x, 0, 'assignment operator called as function');
}

{
&nbsp; &nbsp; # swap two elements in the same array 
&nbsp; &nbsp; # (moved this from array.t)
&nbsp; &nbsp; 
&nbsp; &nbsp; my @a = (1 .. 5);
&nbsp; &nbsp; @a[0,1] = @a[1,0];
&nbsp; &nbsp; is(@a[0], 2, &quot;slice assignment swapping two element in the same array&quot;);
&nbsp; &nbsp; is(@a[1], 1, &quot;slice assignment swapping two element in the same array&quot;);
}

{
&nbsp; &nbsp; # swap two elements as slice, dwim slice from @b subscript
&nbsp; &nbsp; 
&nbsp; &nbsp; my @a = (1 .. 2);
&nbsp; &nbsp; my @b = (0 .. 2);
&nbsp; &nbsp; @a[@b] = @a[1, 0], 3;
&nbsp; &nbsp; is(@a[0], 2, &quot;slice assignment swapping with array dwim&quot;);
&nbsp; &nbsp; is(@a[1], 1, &quot;slice assignment swapping with array dwim&quot;);
&nbsp; &nbsp; is(@a[2], 3, &quot;slice assignment swapping with array dwim makes listop&quot;);
}

{
&nbsp; &nbsp; # list assignments
&nbsp; &nbsp; 
&nbsp; &nbsp; my @a = (1 .. 3);
&nbsp; &nbsp; my ($one, $two, $three) = @a;
&nbsp; &nbsp; is($one, 1, &quot;list assignment my ($, $, $) = @ works&quot;);
&nbsp; &nbsp; is($two, 2, &quot;list assignment my ($, $, $) = @ works&quot;);
&nbsp; &nbsp; is($three, 3, &quot;list assignment my ($, $, $) = @ works&quot;); &nbsp; &nbsp;
}

{
&nbsp; # testing list assignment syntax 

&nbsp; &nbsp; my ($a,$b,$c,@a);
&nbsp; &nbsp; ($a,$b,$c) = 1 .. 3;
&nbsp; &nbsp; @a = 1 .. 3;
&nbsp; &nbsp; my ($s,@b) = 1 .. 3;

&nbsp; &nbsp; is($a,1,&quot;'$a' is '1'?: ($,$,$) = 1 .. 3&quot;);
&nbsp; &nbsp; is($b,2,&quot;'$b' is '2'?: ($,$,$) = 1 .. 3&quot;);
&nbsp; &nbsp; is($c,3,&quot;'$c' is '3'?: ($,$,$) = 1 .. 3&quot;); 
&nbsp; &nbsp; is(@a,'1 2 3',&quot;'{@a}' is '1 2 3'?: &nbsp; &nbsp; &nbsp; @a = 1 .. 3&quot;);
&nbsp; &nbsp; is($s,'1', &nbsp;&quot;$s is '1'?: &nbsp; &nbsp; &nbsp; my ($s,@a) = 1 .. 3&quot;);
&nbsp; &nbsp; is(@b,'2 3',&quot;'{@b}' is '2 3'?: my ($s,@a) = 1 .. 3&quot;); 
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; @a[1, 2, 3] = 100, 200, 300;
&nbsp; &nbsp; is(@a[1], 100, &quot;assigned correct value from list to sliced array&quot;);
&nbsp; &nbsp; is(@a[2], 200, &quot;... and second&quot;);
&nbsp; &nbsp; is(@a[3], 300, &quot;... and third&quot;);
&nbsp; &nbsp; is(@a[0], undef, &quot;won't modify unassigned one&quot;);

&nbsp; &nbsp; my @b;
&nbsp; &nbsp; (@b[2, 1, 0]) = 401, 201, 1;
&nbsp; &nbsp; is(@b[0], 1, &quot;assigned correct value from list to unsorted sliced array&quot;);
&nbsp; &nbsp; is(@b[1], 201, &quot;... and second&quot;);
&nbsp; &nbsp; is(@b[2], 401, &quot;... and third&quot;);
&nbsp; &nbsp; 
&nbsp; &nbsp; my @c;
&nbsp; &nbsp; my @d;
&nbsp; &nbsp; (@c[1, 2], @c[3], @d) = 100, 200, 300, 400, 500;
&nbsp; &nbsp; is(@c[1], 100, &quot;assigned correct value from list to slice-in-list&quot;);
&nbsp; &nbsp; is(@c[2], 200, &quot;... and second&quot;);
&nbsp; &nbsp; is(@c[3], 300, &quot;... and third&quot;, :todo&lt;feature&gt;);
&nbsp; &nbsp; is(@d[0], 400, &quot;... and fourth&quot;, :todo&lt;feature&gt;);
&nbsp; &nbsp; is(@d[1], 500, &quot;... and fifth&quot;, :todo&lt;feature&gt;);
&nbsp; &nbsp; is(@c[0], undef, &quot;won't modify unassigned one&quot;);

}

{
&nbsp; &nbsp; # chained @array = %hash = list assignment 
&nbsp; &nbsp; my (@a, @b, %h);
&nbsp; &nbsp; @a = %h = (1,2);
&nbsp; &nbsp; @b = %h;
&nbsp; &nbsp; is(@a[0], @b[0], &quot;chained @ = % = list assignment&quot;);
&nbsp; &nbsp; is(@a[1], @b[1], &quot;chained @ = % = list assignment&quot;);
}

{
&nbsp; &nbsp; # chained $scalar = %hash = list assignment 
&nbsp; &nbsp; my ($s, $t, %h);
&nbsp; &nbsp; $s = %h = (1,2);
&nbsp; &nbsp; $t = %h;
&nbsp; &nbsp; is($s, $t, &quot;chained $ = % = list assignment&quot;);
}

{
&nbsp; &nbsp; # (@b, @a) = (@a, @b) assignment
&nbsp; &nbsp; my (@a, @b);
&nbsp; &nbsp; @a = (1);
&nbsp; &nbsp; @b = (2);
&nbsp; &nbsp; (@b, @a) = (@a, @b);
&nbsp; &nbsp; is(@a[0], undef, &quot;(@b, @a) = (@a, @b) assignment \@a[0] == undef&quot;);
&nbsp; &nbsp; is(@b[0], 1, &nbsp; &nbsp; &quot;(@b, @a) = (@a, @b) assignment \@b[0]&quot;);
&nbsp; &nbsp; is(@b[1], 2, &nbsp; &nbsp; &quot;(@b, @a) = (@a, @b) assignment \@b[1]&quot;);
}

{
&nbsp; &nbsp; # (@b, @a) = @a, @b assignment
&nbsp; &nbsp; my (@a, @b);
&nbsp; &nbsp; @a = (1);
&nbsp; &nbsp; @b = (2);
&nbsp; &nbsp; (@b, @a) = @a, @b;
&nbsp; &nbsp; is(@a[0], undef, &quot;(@b, @a) = @a, @b assignment \@a[0] == undef&quot;);
&nbsp; &nbsp; is(@b[0], 1, &nbsp; &nbsp; &quot;(@b, @a) = @a, @b assignment \@b[0]&quot;);
&nbsp; &nbsp; is(@b[1], 2, &nbsp; &nbsp; &quot;(@b, @a) = @a, @b assignment \@b[1]&quot;);
}

{
&nbsp; &nbsp; my $a;
&nbsp; &nbsp; $a ||= 3;
&nbsp; &nbsp; is($a,3, &quot;||= operator&quot;);
&nbsp; &nbsp; $a ||= 10;
&nbsp; &nbsp; is($a,3, &quot;... and second&quot;);
}

{
&nbsp; &nbsp; my $a;
&nbsp; &nbsp; $a //= 3;
&nbsp; &nbsp; is($a, 3, &quot;//= operator&quot;);
&nbsp; &nbsp; $a //= 10;
&nbsp; &nbsp; is($a, 3, &quot;... and second&quot;);
&nbsp; &nbsp; my %hash;
&nbsp; &nbsp; %hash&lt;foo&gt; //= hash();
&nbsp; &nbsp; is(WHAT %hash&lt;foo&gt;, 'Hash', &quot;Verify //= autovivifies correctly&quot;);
}

{
&nbsp; &nbsp; my $a = 3;
&nbsp; &nbsp; $a &amp;&amp;= 42;
&nbsp; &nbsp; is($a, 42, &quot;&amp;&amp;= operator&quot;);
&nbsp; &nbsp; $a = 0;
&nbsp; &nbsp; $a &amp;&amp;= 10;
&nbsp; &nbsp; is($a, 0, &quot;... and second&quot;);
}

{
&nbsp; &nbsp; my $c; 
&nbsp; &nbsp; (($c = 3) = 4); 
&nbsp; &nbsp; is($c, 4, '(($c = 3) = 4) return val should be good as an lval');
}

{
&nbsp; &nbsp; my $x = 42;
&nbsp; &nbsp; $x += 6;
&nbsp; &nbsp; is($x, 48, '+= operator');
}

{
&nbsp; &nbsp; my $x = 42;
&nbsp; &nbsp; $x -= 6;
&nbsp; &nbsp; is($x, 36, '-= operator');
}

{
&nbsp; &nbsp; my $x = 4;
&nbsp; &nbsp; $x *= 3;
&nbsp; &nbsp; is($x, 12, '*= operator');
}

{
&nbsp; &nbsp; my $x = 6;
&nbsp; &nbsp; $x /= 3;
&nbsp; &nbsp; is($x, 2, '/= operator');
}

{
&nbsp; &nbsp; my $x = 2;
&nbsp; &nbsp; $x **= 3;
&nbsp; &nbsp; is($x, 8, '**= operator');
}

{
&nbsp; &nbsp; my $x = &quot;abc&quot;;
&nbsp; &nbsp; $x ~= &quot;yz&quot;;
&nbsp; &nbsp; is($x, 'abcyz', '~= operator');
}

{
&nbsp; &nbsp; my $x = &quot;abc&quot;;
&nbsp; &nbsp; $x x= 3;
&nbsp; &nbsp; is($x, 'abcabcabc', 'x= operator');
}

{
&nbsp; &nbsp; my @x = ( 'a', 'z' );
&nbsp; &nbsp; @x xx= 3;
&nbsp; &nbsp; is(+@x, &nbsp; 6, &nbsp; 'xx= operator elems');
&nbsp; &nbsp; is(@x[0], 'a', 'xx= operator 0');
&nbsp; &nbsp; is(@x[1], 'z', 'xx= operator 1');
&nbsp; &nbsp; is(@x[2], 'a', 'xx= operator 2');
&nbsp; &nbsp; is(@x[3], 'z', 'xx= operator 3');
&nbsp; &nbsp; is(@x[4], 'a', 'xx= operator 4');
&nbsp; &nbsp; is(@x[5], 'z', 'xx= operator 5');
}

{
&nbsp; &nbsp; my $x = 1;
&nbsp; &nbsp; $x +&amp;= 2;
&nbsp; &nbsp; is($x, 0, '+&amp;= operator');
}

{
&nbsp; &nbsp; my $x = 1;
&nbsp; &nbsp; $x +|= 2;
&nbsp; &nbsp; is($x, 3, '+|= operator');
}

{
&nbsp; &nbsp; my $x = &quot;z&quot;;
&nbsp; &nbsp; $x ~&amp;= &quot;I&quot;;
&nbsp; &nbsp; is($x, 'H', '~&amp;= operator');
}

{
&nbsp; &nbsp; my $x = &quot;z&quot;;
&nbsp; &nbsp; $x ~|= &quot;I&quot;;
&nbsp; &nbsp; is($x, '{', '~|= operator');
}

{
&nbsp; &nbsp; my $x = 4;
&nbsp; &nbsp; $x %= 3;
&nbsp; &nbsp; is($x, 1, '%= operator');
}

{
&nbsp; &nbsp; my $x = 1;
&nbsp; &nbsp; $x +^= 3;
&nbsp; &nbsp; is($x, 2, '+^= operator');
}

{
&nbsp; &nbsp; my $x = &quot;z&quot;;
&nbsp; &nbsp; $x ~^= &quot;C&quot;;
&nbsp; &nbsp; is($x, 9, '~^= operator');
}

{
&nbsp; &nbsp; my $x = 0;
&nbsp; &nbsp; $x ^^= 42;
&nbsp; &nbsp; is($x, 42, '^^= operator');
}

{
&nbsp; &nbsp; my $x = 42;
&nbsp; &nbsp; $x ?|= 24;
&nbsp; &nbsp; is($x, 1, '?|= operator');
}

{
&nbsp; &nbsp; my $x = 42;
&nbsp; &nbsp; eval '$x ?&amp;= 24'; &nbsp; # XXX: compiler blows up
&nbsp; &nbsp; is($x, 1, '?&amp;= operator', :todo);
}

{
&nbsp; &nbsp; my $x = 0;
&nbsp; &nbsp; eval '$x ?^= 42'; &nbsp; # XXX: compiler blows up
&nbsp; &nbsp; is($x, 1, '?^= operator', :todo);
}

{
&nbsp; &nbsp; my $x = 1;
&nbsp; &nbsp; eval '$x +&lt;= 8'; &nbsp; # XXX: compiler blows up
&nbsp; &nbsp; is($x, 256, '+&lt;= operator', :todo);
}

{
&nbsp; &nbsp; my $x = 511;
&nbsp; &nbsp; eval '$x +&gt;= 8'; &nbsp; # XXX: compiler blows up
&nbsp; &nbsp; is($x, 1, '+&gt;= operator', :todo);
}

# XXX: The following tests assume autoconvertion between &quot;a&quot; and buf8 type
{
&nbsp; &nbsp; my $x = &quot;a&quot;;
&nbsp; &nbsp; eval '$x ~&lt;= 8'; &nbsp; # XXX: compiler blows up
&nbsp; &nbsp; is($x, &quot;a\0&quot;, '~&lt;= operator', :todo);
}

{
&nbsp; &nbsp; my $x = &quot;aa&quot;;
&nbsp; &nbsp; eval '$x ~&gt;= 8'; &nbsp; # XXX: compiler blows up
&nbsp; &nbsp; is($x, &quot;a&quot;, '~&gt;= operator', :todo);
}

# Tests of dwimming scalar/listiness of lhs

my sub W () { substr(want, 0, 1) }

{
&nbsp; &nbsp; my $a;
&nbsp; &nbsp; my @z = ($a = W, W);
&nbsp; &nbsp; is($a, 'S', &nbsp; &nbsp;'lhs dwims $a as scalar');
&nbsp; &nbsp; is(@z[0], 'S', 'lhs dwims $a as scalar');
&nbsp; &nbsp; is(@z[1], 'L', 'lhs dwims $a as scalar');
}

{
&nbsp; &nbsp; my $a;
&nbsp; &nbsp; my @z = (($a) = W, W, W);
&nbsp; &nbsp; is($a, 'L', 'lhs dwims ($a) as list - i.e. emulate as ($a,)');
&nbsp; &nbsp; is(@z, &quot;L&quot;, 'lhs dwims ($a) as list - i.e. emulate as ($a,)');
}

{
&nbsp; &nbsp; my $a;
&nbsp; &nbsp; my $b;
&nbsp; &nbsp; my @z = (($a,$b) = W, W, W);
&nbsp; &nbsp; is($a, 'L', &nbsp; 'lhs dwims ($a,$b) as list');
&nbsp; &nbsp; is($b, 'L', &nbsp; 'lhs dwims ($a,$b) as list');
&nbsp; &nbsp; is(@z, &quot;L L&quot;, 'lhs dwims ($a,$b) as list');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my @z = (@a[0] = W, W);
&nbsp; &nbsp; is(@a, 'S', &nbsp; &nbsp;'lhs dwims @a[0] as scalar');
&nbsp; &nbsp; is(@z[0], 'S', 'lhs dwims @a[0] as scalar');
&nbsp; &nbsp; is(@z[1], 'L', 'lhs dwims @a[0] as scalar');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my @z = (@a[0,] = W, W);
&nbsp; &nbsp; is(@a, 'L', &nbsp; &nbsp; &nbsp;'lhs dwims @a[0,] as list');
&nbsp; &nbsp; is(@z[0], 'L', &nbsp; 'lhs dwims @a[0,] as list');
&nbsp; &nbsp; is(@z[1], undef, 'lhs dwims @a[0,] as list');
}

{
&nbsp; &nbsp; my %a;
&nbsp; &nbsp; my @z = (%a&lt;x&gt; = W, W);
&nbsp; &nbsp; is(%a{&quot;x&quot;}, 'S', 'lhs dwims %a&lt;x&gt; as scalar');
&nbsp; &nbsp; is(@z[0], 'S', &nbsp; 'lhs dwims %a&lt;x&gt; as scalar');
&nbsp; &nbsp; is(@z[1], 'L', &nbsp; 'lhs dwims %a&lt;x&gt; as scalar');
}

{
&nbsp; &nbsp; my %a;
&nbsp; &nbsp; my @z = (%a&lt;x y z&gt; = W, W, W);
&nbsp; &nbsp; is(%a&lt;x&gt;, 'L', &nbsp; &nbsp;'lhs dwims %a&lt;x y z&gt; as list');
&nbsp; &nbsp; is(%a&lt;y&gt;, 'L', &nbsp; &nbsp;'lhs dwims %a&lt;x y z&gt; as list');
&nbsp; &nbsp; is(%a&lt;z&gt;, 'L', &nbsp; &nbsp;'lhs dwims %a&lt;x y z&gt; as list');
}

{
&nbsp; &nbsp; my %a;
&nbsp; &nbsp; my @z = (%a{'x'} = W, W);
&nbsp; &nbsp; is(%a{&quot;x&quot;}, 'S', q/lhs dwims %a{'x'} as scalar/);
&nbsp; &nbsp; is(@z[0], 'S', &nbsp; q/lhs dwims %a{'x'} as scalar/);
&nbsp; &nbsp; is(@z[1], 'L', &nbsp; q/lhs dwims %a{'x'} as scalar/);
}

{
&nbsp; &nbsp; my %a;
&nbsp; &nbsp; my @z = (%a{'x','y','z'} = W, W, W);
&nbsp; &nbsp; is(%a&lt;x&gt;, 'L', &nbsp; &nbsp;q/lhs dwims %a{'x','y','z'} as list/);
&nbsp; &nbsp; is(%a&lt;y&gt;, 'L', &nbsp; &nbsp;q/lhs dwims %a{'x','y','z'} as list/);
&nbsp; &nbsp; is(%a&lt;z&gt;, 'L', &nbsp; &nbsp;q/lhs dwims %a{'x','y','z'} as list/);
}

{
&nbsp; &nbsp; my %a;
&nbsp; &nbsp; my @z = (%a{'x'..'z'} = W, W, W);
&nbsp; &nbsp; is(%a&lt;x&gt;, 'L', &nbsp; &nbsp;q/lhs dwims %a{'x'..'z'} as list/);
&nbsp; &nbsp; is(%a&lt;y&gt;, 'L', &nbsp; &nbsp;q/lhs dwims %a{'x'..'z'} as list/);
&nbsp; &nbsp; is(%a&lt;z&gt;, 'L', &nbsp; &nbsp;q/lhs dwims %a{'x'..'z'} as list/);
}

{
&nbsp; &nbsp; my %a;
&nbsp; &nbsp; my @z = (%a{'x' x 1} = W, W);
&nbsp; &nbsp; is(%a{&quot;x&quot;}, 'S', q/lhs dwims %a{'x' x 1} as scalar/);
&nbsp; &nbsp; is(@z[0], 'S', &nbsp; q/lhs dwims %a{'x' x 1} as scalar/);
&nbsp; &nbsp; is(@z[1], 'L', &nbsp; q/lhs dwims %a{'x' x 1} as scalar/);
}

{
&nbsp; &nbsp; my %a;
&nbsp; &nbsp; my @z = (%a{'x' xx 1} = W, W, W);
&nbsp; &nbsp; is(%a&lt;x&gt;, 'L', &nbsp; &nbsp;q/lhs dwims %a{'x' xx 1} as list/);
&nbsp; &nbsp; is(@z[0], 'L', &nbsp; &nbsp;q/lhs dwims %a{'x' xx 1} as list/);
&nbsp; &nbsp; is(@z[1], undef, &nbsp;q/lhs dwims %a{'x' xx 1} as list/);
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my $b = 0;
&nbsp; &nbsp; my @z = (@a[$b] = W, W);
&nbsp; &nbsp; is(@a, 'S', &nbsp; &nbsp;'lhs dwims @a[$b] as scalar');
&nbsp; &nbsp; is(@z[0], 'S', 'lhs dwims @a[$b] as scalar');
&nbsp; &nbsp; is(@z[1], 'L', 'lhs dwims @a[$b] as scalar');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my $b = 0;
&nbsp; &nbsp; my @z = (@a[$b,] = W, W);
&nbsp; &nbsp; is(@a, 'L', &nbsp; &nbsp; &nbsp;'lhs dwims @a[$b,] as list');
&nbsp; &nbsp; is(@z[0], 'L', &nbsp; 'lhs dwims @a[$b,] as list');
&nbsp; &nbsp; is(@z[1], undef, 'lhs dwims @a[$b,] as list');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my @b = (0,1);
&nbsp; &nbsp; my @z = (@a[@b] = W, W, W);
&nbsp; &nbsp; is(@a, 'L L', &nbsp;'lhs dwims @a[@b] as list');
&nbsp; &nbsp; is(@z[0], 'L', 'lhs dwims @a[@b] as list');
&nbsp; &nbsp; is(@z[1], 'L', 'lhs dwims @a[@b] as list');
&nbsp; &nbsp; is(@z[2], undef, 'lhs dwims @a[@b] as list');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my @b = (0,0);
&nbsp; &nbsp; my $c = 1;
&nbsp; &nbsp; my @z = (@a[@b[$c]] = W, W);
&nbsp; &nbsp; is(@a, 'S', &nbsp; &nbsp;'lhs dwims @a[@b[$c]] as scalar');
&nbsp; &nbsp; is(@z[0], 'S', 'lhs dwims @a[@b[$c]] as scalar');
&nbsp; &nbsp; is(@z[1], 'L', 'lhs dwims @a[@b[$c]] as scalar');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my @b = (0,0);
&nbsp; &nbsp; my $c = 1;
&nbsp; &nbsp; my @z = (@a[@b[$c,]] = W, W);
&nbsp; &nbsp; is(@a, 'L', &nbsp; &nbsp; &nbsp;'lhs dwims @a[@b[$c,]] as list');
&nbsp; &nbsp; is(@z[0], 'L', &nbsp; 'lhs dwims @a[@b[$c,]] as list');
&nbsp; &nbsp; is(@z[1], undef, 'lhs dwims @a[@b[$c,]] as list');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my $b = 0;
&nbsp; &nbsp; my sub foo { \@a }
&nbsp; &nbsp; my @z = eval '(foo()[$b] = W, W)';
&nbsp; &nbsp; is(@a, 'S', &nbsp; &nbsp;'lhs dwims foo()[$b] as scalar');
&nbsp; &nbsp; is(@z[0], 'S', 'lhs dwims foo()[$b] as scalar');
&nbsp; &nbsp; is(@z[1], 'L', 'lhs dwims foo()[$b] as scalar');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my $b = 0;
&nbsp; &nbsp; my sub foo { \@a }
&nbsp; &nbsp; my @z = eval '(foo()[$b,] = W, W)';
&nbsp; &nbsp; is(@a, 'L', &nbsp; &nbsp; &nbsp;'lhs dwims foo()[$b,] as list');
&nbsp; &nbsp; is(@z[0], 'L', &nbsp; 'lhs dwims foo()[$b,] as list');
&nbsp; &nbsp; is(@z[1], undef, 'lhs dwims foo()[$b,] as list');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my $b = 0;
&nbsp; &nbsp; my sub foo { \@a }
&nbsp; &nbsp; my @z = (@a[foo()[$b]] = W, W);
&nbsp; &nbsp; is(@a, 'S', &nbsp; &nbsp;'lhs dwims @a[foo()[$b]] as scalar');
&nbsp; &nbsp; is(@z[0], 'S', 'lhs dwims @a[foo()[$b]] as scalar');
&nbsp; &nbsp; is(@z[1], 'L', 'lhs dwims @a[foo()[$b]] as scalar');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my $b = 0;
&nbsp; &nbsp; my sub foo { \@a }
&nbsp; &nbsp; my @z = (@a[foo()[$b,]] = W, W);
&nbsp; &nbsp; is(@a, 'L', &nbsp; &nbsp; &nbsp;'lhs dwims @a[foo()[$b,]] as list');
&nbsp; &nbsp; is(@z[0], 'L', &nbsp; 'lhs dwims @a[foo()[$b,]] as list');
&nbsp; &nbsp; is(@z[1], undef, 'lhs dwims @a[foo()[$b,]] as list');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my sub foo { 0 }
&nbsp; &nbsp; my @z = (@a[+foo()] = W, W);
&nbsp; &nbsp; is(@a, 'S', &nbsp; &nbsp;'lhs dwims @a[+foo()] as scalar');
&nbsp; &nbsp; is(@z[0], 'S', 'lhs dwims @a[+foo()] as scalar');
&nbsp; &nbsp; is(@z[1], 'L', 'lhs dwims @a[+foo()] as scalar');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my sub foo { '0' }
&nbsp; &nbsp; my @z = (@a[~foo()] = W, W);
&nbsp; &nbsp; is(@a, 'S', &nbsp; &nbsp;'lhs dwims @a[~foo()] as scalar');
&nbsp; &nbsp; is(@z[0], 'S', 'lhs dwims @a[~foo()] as scalar');
&nbsp; &nbsp; is(@z[1], 'L', 'lhs dwims @a[~foo()] as scalar');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my sub foo { 0 }
&nbsp; &nbsp; my @z = (@a[?foo()] = W, W);
&nbsp; &nbsp; is(@a, 'S', &nbsp; &nbsp;'lhs dwims @a[?foo()] as scalar');
&nbsp; &nbsp; is(@z[0], 'S', 'lhs dwims @a[?foo()] as scalar');
&nbsp; &nbsp; is(@z[1], 'L', 'lhs dwims @a[?foo()] as scalar');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my sub foo { 1 }
&nbsp; &nbsp; my @z = (@a[!foo()] = W, W);
&nbsp; &nbsp; is(@a, 'S', &nbsp; &nbsp;'lhs dwims @a[!foo()] as scalar');
&nbsp; &nbsp; is(@z[0], 'S', 'lhs dwims @a[!foo()] as scalar');
&nbsp; &nbsp; is(@z[1], 'L', 'lhs dwims @a[!foo()] as scalar');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my $b = 0;
&nbsp; &nbsp; my sub foo { 0 }
&nbsp; &nbsp; my @z = (@a[foo()] = W, W);
&nbsp; &nbsp; is(@a, 'L L', &nbsp; &nbsp;'lhs dwims @a[foo()] as run-time scalar');
&nbsp; &nbsp; is(@z[0], 'L L', 'lhs dwims @a[foo()] as run-time scalar');
&nbsp; &nbsp; is(@z[1], undef, 'lhs dwims @a[foo()] as run-time scalar');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my $b = 0;
&nbsp; &nbsp; my sub foo { 0,1 }
&nbsp; &nbsp; my @z = (@a[foo()] = W, W);
&nbsp; &nbsp; is(@a, 'L L', &nbsp;'lhs dwims @a[foo()] as run-time list');
&nbsp; &nbsp; is(@z[0], 'L', 'lhs dwims @a[foo()] as run-time list');
&nbsp; &nbsp; is(@z[1], 'L', 'lhs dwims @a[foo()] as run-time list');
}

{
&nbsp; &nbsp; my %a;
&nbsp; &nbsp; my sub foo { 0 }
&nbsp; &nbsp; my @z = (%a{+foo()} = W, W);
&nbsp; &nbsp; is(%a, 'S', &nbsp; &nbsp;'lhs dwims %a{+foo()} as scalar', :todo&lt;bug&gt;);
&nbsp; &nbsp; is(@z[0], 'S', 'lhs dwims %a{+foo()} as scalar');
&nbsp; &nbsp; is(@z[1], 'L', 'lhs dwims %a{+foo()} as scalar');
}

{
&nbsp; &nbsp; my %a;
&nbsp; &nbsp; my sub foo { '0' }
&nbsp; &nbsp; my @z = (%a{~foo()} = W, W);
&nbsp; &nbsp; is(%a, 'S', &nbsp; &nbsp;'lhs dwims %a{~foo()} as scalar', :todo&lt;bug&gt;);
&nbsp; &nbsp; is(@z[0], 'S', 'lhs dwims %a{~foo()} as scalar');
&nbsp; &nbsp; is(@z[1], 'L', 'lhs dwims %a{~foo()} as scalar');
}

{
&nbsp; &nbsp; my %a;
&nbsp; &nbsp; my sub foo { 0 }
&nbsp; &nbsp; my @z = (%a{?foo()} = W, W);
&nbsp; &nbsp; is(%a, 'S', &nbsp; &nbsp;'lhs dwims %a{?foo()} as scalar', :todo&lt;bug&gt;);
&nbsp; &nbsp; is(@z[0], 'S', 'lhs dwims %a{?foo()} as scalar');
&nbsp; &nbsp; is(@z[1], 'L', 'lhs dwims %a{?foo()} as scalar');
}

{
&nbsp; &nbsp; my %a;
&nbsp; &nbsp; my sub foo { 1 }
&nbsp; &nbsp; my @z = (%a{!foo()} = W, W);
&nbsp; &nbsp; is(%a, 'S', &nbsp; &nbsp;'lhs dwims %a{!foo()} as scalar', :todo&lt;bug&gt;);
&nbsp; &nbsp; is(@z[0], 'S', 'lhs dwims %a{!foo()} as scalar');
&nbsp; &nbsp; is(@z[1], 'L', 'lhs dwims %a{!foo()} as scalar');
}

{
&nbsp; &nbsp; my %a;
&nbsp; &nbsp; my $b = 0;
&nbsp; &nbsp; my sub foo { 0 }
&nbsp; &nbsp; my @z = (%a{foo()} = W, W);
&nbsp; &nbsp; is(%a{0}, 'L L', 'lhs dwims %a{foo()} as run-time scalar');
&nbsp; &nbsp; is(@z[0], 'L L', 'lhs dwims %a{foo()} as run-time scalar');
&nbsp; &nbsp; is(@z[1], undef, 'lhs dwims %a{foo()} as run-time scalar');
}

{
&nbsp; &nbsp; my %a;
&nbsp; &nbsp; my $b = 0;
&nbsp; &nbsp; my sub foo { 0,1 }
&nbsp; &nbsp; my @z = (%a{foo()} = W, W);
&nbsp; &nbsp; is(%a{0}, 'L', 'lhs dwims %a{foo()} as run-time list');
&nbsp; &nbsp; is(%a{1}, 'L', 'lhs dwims %a{foo()} as run-time list');
&nbsp; &nbsp; is(@z[0], 'L', 'lhs dwims %a{foo()} as run-time list');
&nbsp; &nbsp; is(@z[1], 'L', 'lhs dwims %a{foo()} as run-time list');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my @z = (@a[0+0] = W, W);
&nbsp; &nbsp; is(@a, 'S', &nbsp; &nbsp;'lhs dwims @a[0+0] as scalar');
&nbsp; &nbsp; is(@z[0], 'S', 'lhs dwims @a[0+0] as scalar');
&nbsp; &nbsp; is(@z[1], 'L', 'lhs dwims @a[0+0] as scalar');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my @z = (@a[0*0] = W, W);
&nbsp; &nbsp; is(@a, 'S', &nbsp; &nbsp;'lhs dwims @a[0*0] as scalar');
&nbsp; &nbsp; is(@z[0], 'S', 'lhs dwims @a[0*0] as scalar');
&nbsp; &nbsp; is(@z[1], 'L', 'lhs dwims @a[0*0] as scalar');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my @z = (@a[0/1] = W, W);
&nbsp; &nbsp; is(@a, 'S', &nbsp; &nbsp;'lhs dwims @a[0/1] as scalar');
&nbsp; &nbsp; is(@z[0], 'S', 'lhs dwims @a[0/1] as scalar');
&nbsp; &nbsp; is(@z[1], 'L', 'lhs dwims @a[0/1] as scalar');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my @z = (@a[0*1**1] = W, W);
&nbsp; &nbsp; is(@a, 'S', &nbsp; &nbsp;'lhs dwims @a[0*1**1] as scalar');
&nbsp; &nbsp; is(@z[0], 'S', 'lhs dwims @a[0*1**1] as scalar');
&nbsp; &nbsp; is(@z[1], 'L', 'lhs dwims @a[0*1**1] as scalar');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my $b = 0;
&nbsp; &nbsp; my @z = (@a[$b++] = W, W);
&nbsp; &nbsp; is(@a, 'S', &nbsp; &nbsp;'lhs dwims @a[$b++] as scalar');
&nbsp; &nbsp; is(@z[0], 'S', 'lhs dwims @a[$b++] as scalar');
&nbsp; &nbsp; is(@z[1], 'L', 'lhs dwims @a[$b++] as scalar');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my $b = 1;
&nbsp; &nbsp; my @z = (@a[--$b] = W, W);
&nbsp; &nbsp; is(@a, 'S', &nbsp; &nbsp;'lhs dwims @a[--$b] as scalar');
&nbsp; &nbsp; is(@z[0], 'S', 'lhs dwims @a[--$b] as scalar');
&nbsp; &nbsp; is(@z[1], 'L', 'lhs dwims @a[--$b] as scalar');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my @z = (@a[0==1] = W, W);
&nbsp; &nbsp; is(@a, 'L L', &nbsp; &nbsp;'lhs dwims @a[0==1] as list (but coerce rhs list to one thing)');
&nbsp; &nbsp; is(@z[0], 'L L', 'lhs dwims @a[0==1] as list (but coerce rhs list to one thing)');
&nbsp; &nbsp; is(@z[1], undef, 'lhs dwims @a[0==1] as list (but coerce rhs list to one thing)');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my @z = (@a[rand 1] = W, W);
&nbsp; &nbsp; is(@a, 'L L', &nbsp; &nbsp;'lhs dwims @a[rand 1] as run-time scalar');
&nbsp; &nbsp; is(@z[0], 'L L', 'lhs dwims @a[rand 1] as run-time scalar');
&nbsp; &nbsp; is(@z[1], undef, 'lhs dwims @a[rand 1] as run-time scalar');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my @z = (@a[rand 1,] = W, W);
&nbsp; &nbsp; is(@a, 'L', &nbsp; &nbsp; &nbsp;'lhs dwims @a[rand 1,] as list');
&nbsp; &nbsp; is(@z[0], 'L', &nbsp; 'lhs dwims @a[rand 1,] as list');
&nbsp; &nbsp; is(@z[1], undef, 'lhs dwims @a[rand 1,] as list');
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my @z = (@a[(0|0).pick] = W, W);
&nbsp; &nbsp; is(@a, 'L L', &nbsp; &nbsp;'lhs dwims @a[(0|0).pick] as list');
&nbsp; &nbsp; is(@z[0], 'L L', 'lhs dwims @a[(0|0).pick] as list');
&nbsp; &nbsp; is(@z[1], undef, 'lhs dwims @a[(0|0).pick] as list');
}</pre>
</div>


<pre>    @foo = 1,2,3;</pre>

<p>You do still need them on the left for</p>

<pre>    ($a,$b,$c) = 1,2,3;</pre>

<p>since assignment operators are tighter than comma to their left.</p>
</li>

<li>The scalar assignment operator still parses as it did before, so
<a href="#" onclick="return tog_quote(22);">
<div ID="header_shown_22" style="display: none;">
- Hide the snippet from t/var/lvalue_deep_brackets.t (line 4 ~ line 47) -
</div>
<div ID="header_hidden_22" style="display: block;">
- Show the snippet from t/var/lvalue_deep_brackets.t (line 4 ~ line 47) -
</div>
</a>
<div ID="hide_22" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;Changes to Perl 5 operators&quot;/&quot;=item * The scalar assignment operator still parses&quot;&gt;
# a better smart link exists?

plan 7;

{
&nbsp; my $foo = 0;
&nbsp; $foo++;
&nbsp; is $foo, 1, 'lvalue $var works';
}

{
&nbsp; my $foo = [0];
&nbsp; $foo[0]++;
&nbsp; is $foo[0], 1, 'lvalue $var[] works';
}

{
&nbsp; my $foo = [[0]];
&nbsp; $foo[0][0]++;
&nbsp; is $foo[0][0], 1, 'lvalue $var[][] works';
}

{
&nbsp; my @foo = [0];
&nbsp; @foo[0][0]++;
&nbsp; is @foo[0][0], 1, 'lvalue @var[][] works';
}

{
&nbsp; is ++[[0]][0][0], 1, 'lvalue [[]][][] works';
}

{
&nbsp; my $foo = {a =&gt; [0]};
&nbsp; $foo&lt;a&gt;[0]++;
&nbsp; is $foo&lt;a&gt;[0], 1, 'lvalue $var&lt;&gt;[] works';
}

{
&nbsp; my %foo = (a =&gt; [0]);
&nbsp; %foo&lt;a&gt;[0]++;
&nbsp; is %foo&lt;a&gt;[0], 1, 'lvalue %var&lt;&gt;[] works';
}</pre>
</div>


<pre>    loop ($a = 1, $b = 2; ; $a++, $b++) {...}</pre>

<p>still works fine. The syntactic distinction between scalar and list assignment is similar to the way Perl 5 defines it, but has to be a little different because we can no longer decide on the basis of the sigil. The following forms are parsed as &#34;simple lvalues&#34;, and imply scalar assignment:</p>

<pre>    $a          # simple scalar variable
    $(ANY)      # scalar dereference (including $$a)</pre>

<a href="#" onclick="return tog_quote(21);">
<div ID="header_shown_21" style="display: none;">
- Hide the snippet from t/var/refs_point_to_containers.t (line 4 ~ line 66) -
</div>
<div ID="header_hidden_21" style="display: block;">
- Show the snippet from t/var/refs_point_to_containers.t (line 4 ~ line 66) -
</div>
</a>
<div ID="hide_21" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;Changes to Perl 5 operators&quot;/&quot;scalar dereference&quot;&gt;
# The link points a mention of &quot;$$&quot;. I couldn't find a better
# one that described about how references point to containers. 

# References point to containers, not cells or even values

plan 12;

{
&nbsp; my $num = 3;
&nbsp; my $ref = \$num;
&nbsp; is $$ref, 3, &quot;basic refs to scalars work&quot;;

&nbsp; $num = 4;
&nbsp; is $$ref, 4, &quot;refs to scalars point to containers, not cells or even values (1)&quot;, :todo&lt;bug&gt;;

&nbsp; $num := 5;
&nbsp; is $$ref, 5, &quot;refs to scalars point to containers, not cells or even values (2)&quot;, :todo&lt;bug&gt;;
}

{
&nbsp; my @array = (1,2,3);
&nbsp; my $ref &nbsp; = \@array[1];
&nbsp; is $$ref, 2, &quot;basic refs to arrays work&quot;;

&nbsp; @array[1] = 3;
&nbsp; is $$ref, 3, &quot;refs to arrays point to containers, not cells or even values (1)&quot;, :todo&lt;bug&gt;;

&nbsp; try { @array[1] := 4 };
&nbsp; is $$ref, 4, &quot;refs to arrays point to containers, not cells or even values (2)&quot;, :todo&lt;unspecced&gt;;
}

# Automatically created refs (autoreffing)
{
&nbsp; my @array = (1,2,3);
&nbsp; my $test &nbsp;= sub (Array $arrayref) {
&nbsp; &nbsp; is $arrayref[1], 2, &quot;automatically reffed arrays&quot;;

&nbsp; &nbsp; @array[1] = 3;
&nbsp; &nbsp; is $arrayref[1], 3, &quot;automatically reffed arrays point to containers (1)&quot;;

&nbsp; &nbsp; try { @array[1] := 4 };
&nbsp; &nbsp; is $arrayref[1], 4, &quot;automatically reffed arrays point to containers (2)&quot;, :todo&lt;unspecced&gt;;
&nbsp; };

&nbsp; $test(@array);
}

# Automatically dereffed arrays
{
&nbsp; my $arrayref = [1,2,3];
&nbsp; my $test &nbsp;= sub (@array) {
&nbsp; &nbsp; is @array[1], 2, &quot;automatically dereffed arrays&quot;;

&nbsp; &nbsp; $arrayref[1] = 3;
&nbsp; &nbsp; is @array[1], 3, &quot;automatically dereffed arrays point to containers (1)&quot;;

&nbsp; &nbsp; try { $arrayref[1] := 4 };
&nbsp; &nbsp; is @array[1], 4, &quot;automatically dereffed arrays point to containers (2)&quot;, :todo&lt;unspecced&gt;;
&nbsp; };

&nbsp; $test($arrayref);
}</pre>
</div>


<pre>    $::(ANY)    # symbolic scalar dereference
    ANY[SIMPLE] # single simple subscript
    ANY{SIMPLE} # single simple subscript
    ANY&#60;x&#62;      # single literal subscript</pre>

<p>Where SIMPLE is (recursively) defined as one of the forms above, plus the following forms:</p>

<pre>    123         # single literal
    &#39;x&#39;         # single literal
    &#34;$x&#34;        # single literal
    qq/$x/      # single literal
    +TERM       # any single term coerced to numeric
    -TERM       # any single term coerced to numeric</pre>

<a href="#" onclick="return tog_quote(26);">
<div ID="header_shown_26" style="display: none;">
- Hide the snippet from t/syntax/force_context.t (line 28 ~ line 41) -
</div>
<div ID="header_hidden_26" style="display: block;">
- Show the snippet from t/syntax/force_context.t (line 28 ~ line 41) -
</div>
</a>
<div ID="hide_26" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Changes to Perl 5 operators/&quot;-TERM&quot; &quot;coerced to numeric&quot;&gt;
# numeric (-) context
{
&nbsp; &nbsp; my $a = '2 is my favorite number';
&nbsp; &nbsp; isa_ok(-$a, Num, 'it is forced into a Num');
&nbsp; &nbsp; is(-$a, -2, 'forced into numeric context');

&nbsp; &nbsp; my $b = 'Did you know that, 2 is my favorite number';
&nbsp; &nbsp; isa_ok(-$b, Num, 'it is forced into a Num');

&nbsp; &nbsp; # doubly-negated because -0 === 0 isn't neccessarily true
&nbsp; &nbsp; is(-(-$b), 0, 'non numbers forced into numeric context are 0');
}</pre>
</div>


<pre>    ~TERM       # any single term coerced to string
    ?TERM       # any single term coerced to boolean
    !TERM       # any single term coerced to boolean</pre>

<a href="#" onclick="return tog_quote(23);">
<div ID="header_shown_23" style="display: none;">
- Hide the snippet from t/syntax/force_context.t (line 85 ~ line 123) -
</div>
<div ID="header_hidden_23" style="display: block;">
- Show the snippet from t/syntax/force_context.t (line 85 ~ line 123) -
</div>
</a>
<div ID="hide_23" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Changes to Perl 5 operators/&quot;!TERM&quot; &quot;coerced to boolean&quot;&gt;
# ! boolean context
{
&nbsp; &nbsp; my $a = '';
&nbsp; &nbsp; isa_ok(!$a, Bool, 'it is forced into a Bool');
&nbsp; &nbsp; ok(!$a, 'it is forced into boolean context');

&nbsp; &nbsp; my $b = 'This will be true';
&nbsp; &nbsp; isa_ok(!$b, Bool, 'it is forced into a Bool');
&nbsp; &nbsp; ok(!(!$b), 'it is forced into boolean context');

&nbsp; &nbsp; my $c = 0;
&nbsp; &nbsp; isa_ok(!$c, Bool, 'it is forced into a Bool');
&nbsp; &nbsp; ok(!$c, 'it is forced into boolean context');

&nbsp; &nbsp; my $d = 1;
&nbsp; &nbsp; isa_ok(!$d, Bool, 'it is forced into a Bool');
&nbsp; &nbsp; ok(!(!$d), 'it is forced into boolean context');

&nbsp; &nbsp; my $arrayref is context = list(1,2,3);

&nbsp; &nbsp; ok eval_elsewhere('!(!(@$+arrayref))'), '!(@$arrayref) syntax works';
&nbsp; &nbsp; ok eval_elsewhere('!(!(@($+arrayref)))'), '!(@($arrayref)) syntax works';
}

# int context
{
&nbsp; &nbsp; my $a = '2 is my favorite number';
&nbsp; &nbsp; isa_ok(int($a), Int, 'it is forced into a Int');
&nbsp; &nbsp; is(+$a, 2, 'forced into integer context');

&nbsp; &nbsp; my $b = 'Did you know that, 2 is my favorite number';
&nbsp; &nbsp; isa_ok(int($b), Int, 'it is forced into a Int');
&nbsp; &nbsp; is(int($b), 0, 'non numbers forced into integer context are 0');

&nbsp; &nbsp; my $c = 1.21122111;
&nbsp; &nbsp; isa_ok(int($c), Int, 'it is forced into a Int');
&nbsp; &nbsp; is(int($c), 1, 'float numbers forced into integer context are 0');
}</pre>
</div>


<pre>    (SIMPLE)    # any simple expression in circumfix parens</pre>

<p>Note that circumfix parens are considered simple only when used as part of a subscript. Putting parens around the entire lvalue still implies list context as in Perl 5.</p>

<p>We also include:</p>

<pre>    OP SIMPLE   
    SIMPLE OP
    SIMPLE OP SIMPLE</pre>

<p>where <code>OP</code> includes any standard scalar operators in the five precedence levels autoincrement, exponentiation, symbolic unary, multiplicative, and additive; but these are limited to standard operators that are known to return numbers, strings, or booleans.</p>

<p>Operators that imply list operations are excluded: prefix <code>@</code>, prefix <code>%</code> and infix <code>xx</code>, for instance. Hyper operators are also excluded, but post-assignment forms such as <code>SIMPLE += SIMPLE</code> are allowed.</p>

<p>All other forms imply parsing as a list assignment, which may or may not result in a list assignment at run time. (See below.) However, this is exclusively a syntactic distinction, and no semantic or type information is used, since it influences subsequent parsing. In particular, even if a function is known to return a scalar value from its declaration, you must use <code>+</code> or <code>~</code> if you wish to force scalar parsing from within a subscript:</p>

<pre>    @a[foo()] = bar();          # foo() and bar() called in list context
    @a[+foo()] = bar();         # foo() and bar() called in scalar context</pre>

<p>But note that the first form still works fine if <code>foo()</code> and <code>bar()</code> are scalar functions that are not context sensitive. The difference in parsing is only an issue if <code>bar()</code> is followed by a comma or some such.</p>

<p>For non-simple lvalues, at run time, both sides are evaluated in list context, but if the left side results in a single non-list scalar, the right side is treated as a single scalar value, as if the right side had been evaluated in list context (which is indeed the case) but coerced into scalar context.</p>

<p>If the left side returns a list, however, then regardless of whether the list contains a single or multiple values, the right side values are assigned one by one as in any other list assignment, discarding any extra values if the right side is too long, or assigning undef if the right side is too short. To force list assignment when a subscript would return a non-list, either put parens around the entire lvalue, or use a comma within the subscript. (A semicolon in the subscript also works to indicate multidimensional slices.)</p>

<p>Assuming</p>

<pre>    sub bar { return &#60;a b c&#62; }</pre>

<p>then we have:</p>

<pre>    sub foo { return 1,2,3 }
    @a[foo()] = bar();          # (@a[1,2,3]) = &#60;a b c&#62;

    sub foo { return 1 }
    @a[foo()] = bar();          # @a[1] = [&#60;a b c&#62;]

    sub foo { return(1) }
    @a[foo()] = bar();          # @a[1] = [&#60;a b c&#62;]

    sub foo { return (1) }
    @a[foo()] = bar();          # (@a[1]) = &#60;a b c&#62;

    sub foo { return 1 }
    @a[foo(),] = bar();         # (@a[1]) = &#60;a b c&#62;

    sub foo { return 1 }
    (@a[foo()]) = bar();        # (@a[1]) = &#60;a b c&#62;</pre>

<p>Those are all parsed as list assignments, but we get different run-time behaviors based on the run-time type of the left side.</p>

<p>In general, this will all just do what the user expects most of the time. The rest of the time scalar or list behavior can be forced with minimal syntax.</p>
</li>

<li>List operators are all parsed consistently. As in Perl 5, to the left a list operator look like term, while to the right it looks like an operator that is looser than comma. Unlike in Perl 5, the difference between the list operator form and the function form is consistently indicated via whitespace between the list operator and the first argument. If there is whitespace, it is always a list operator, and the next token will be taken as the first term of the list (or if there are no terms, as the expression terminator). Any infix operator occurring where a term is expected will be misinterpreted as a term:
<pre>    say + 2;    # means say(+2);</pre>

<p>If there is no whitespace, subsequent parsing depends on the syntactic category of the next item. Parentheses (with or without a dot) turn the list operator into a function call instead, and all the function&#39;s arguments must be passed inside the parentheses (with the sole exception of an adverbial block, which may follow the parentheses).</p>

<p>Other than various forms of parentheses, all other postfixes are disallowed immediately after a list operator, even if there are no arguments. To add a postfix to an argumentless list operator you must write it as a function call with empty parentheses:</p>

<pre>    foo.[]      # ILLEGAL
    foo++       # ILLEGAL
    foo().[]    # legal
    foo()++     # legal (if foo() is rw)</pre>

<p>After the parentheses any postfix operators are allowed, and apply to the result of the function call. (Also note that the postfix restriction applies only to list operators; it doesn&#39;t apply to methods. It is legal to say</p>

<pre>    $foo.bar&#60;a b c&#62;</pre>

<p>to mean</p>

<pre>    $foo.bar().{&#39;a&#39;,&#39;b&#39;,&#39;c&#39;}</pre>

<p>because methods never assume there are arguments unless followed by parentheses or a colon.)</p>

<p>If the next item after the list operator is either an infix operator or a term, a syntax error is reported. [Conjecture: this may be relaxed in non-strict mode.]</p>

<p>Examples:</p>

<pre>    say foo + 1;                        say(foo(+1));
    say foo $x;                         say(foo($x));
    say foo$x;                          ILLEGAL, need space or parens
    say foo+1;                          ILLEGAL, need space or parens
    say foo++;                          ILLEGAL, need parens

    say foo($bar+1),$baz                say(foo($bar+1), $baz);
    say foo.($bar+1),$baz               say(foo($bar+1), $baz);
    say foo ($bar+1),$baz               say(foo($bar+1, $baz));
    say foo .($bar+1),$baz              say(foo($_.($bar+1), $baz));

    say foo[$bar+1],$baz                ILLEGAL, need foo()[]
    say foo.[$bar+1],$baz               ILLEGAL, need foo().[]
    say foo [$bar+1],$baz               say(foo([$bar+1], $baz));
    say foo .[$bar+1],$baz              say(foo($_.[$bar+1], $baz));

    say foo{$bar+1},$baz                ILLEGAL, need foo(){}
    say foo.{$bar+1},$baz               ILLEGAL, need foo().{}
    say foo {$bar+1},$baz               say(foo({$bar+1}, $baz));
    say foo .{$bar+1},$baz              say(foo($_.{$bar+1}, $baz));

    say foo&#60;$bar+1&#62;,$baz                ILLEGAL, need foo()&#60;&#62;
    say foo.&#60;$bar+1&#62;,$baz               ILLEGAL, need foo().&#60;&#62;
    say foo &#60;$bar+1&#62;,$baz               say(foo(&#60;$bar+1&#62;, $baz));
    say foo .&#60;$bar+1&#62;,$baz              say(foo($_.&#60;$bar+1&#62;, $baz));</pre>

<p>Note that Perl 6 is making a consistent three-way distinction between term vs postfix vs infix, and will interpret an overloaded character like <code>&#60;</code> accordingly:</p>

<pre>    any &#60;a b c&#62;                 any(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)        # term
    any()&#60;a b c&#62;                (any).{&#39;a&#39;,&#39;b&#39;,&#39;c&#39;}     # postfix
    any() &#60; $x                  (any) &#60; $x              # infix
    any&#60;a b c&#62;                  ILLEGAL                 # stealth postfix</pre>

<p>This will seem unfamiliar and &#34;undwimmy&#34; to Perl 5 programmers, who are used to a grammar that sloppily hardwires a few postfix operators at the price of extensibility. Perl 6 chooses instead to mandate a whitespace dependency in order to gain a completely extensible class of postfix operators.</p>
</li>

<li>A list operator&#39;s arguments are also terminated by a closure that is not followed by a comma or colon. (And a semicolon is implied if the closure is the final thing on a line. Use an &#34;unspace&#34; to suppress that.) This final closure may be followed by a postfix, in which case the postfix is applied to the result of the entire list operator.</li>

<li>A function predeclared as 0-ary is never considered list operator, though it allows an optional set of empty parentheses. Unlike functions and list operators with arguments (see above), a 0-ary function does not require parentheses even if followed immediately by a postfix.</li>

<li>A non-multi sub predeclared with an arity of exactly 1 parses as a named unary in precedence. All other subs with arguments parse as list operators. (In other words, a named unary operator may be declared to take extra arguments only if they are named-only arguments.)</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="New_operators"
>New operators</a></h1>

<a href="#" onclick="return tog_quote(65);">
<div ID="header_shown_65" style="display: none;">
- Hide the snippet from t/operators/operator.t (line 8 ~ line 84) -
</div>
<div ID="header_hidden_65" style="display: block;">
- Show the snippet from t/operators/operator.t (line 8 ~ line 84) -
</div>
</a>
<div ID="hide_65" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S03/&quot;New operators&quot;&gt;
=cut

plan 29;

my $str1 = &quot;foo&quot;;
my $str2 = &quot;bar&quot;;
my $str3 = &quot;foobar&quot;;
my $str4 = $str1~$str2;

is($str3, $str4, &quot;~&quot;);

my $bar = &quot;&quot;;
($str3 eq $str4) ?? ($bar = 1) !! ($bar = 0);

ok($bar, &quot;?? !!&quot;);

my $five = 5;
my $four = 4;
my $wibble = 4;

ok(!($five == $four), &quot;== (false)&quot;);
ok($wibble == $four, &quot;== (true)&quot;);
ok(!($wibble != $four), &quot;== (false)&quot;);
ok($five != $four, &quot;!= (true)&quot;);

ok($five == 5, &quot;== (const on rhs)&quot;);
ok(!($five != 5), &quot;!= (const on rhs)&quot;);

ok(5 == $five, &quot;== (const on lhs)&quot;);
ok(!(5 != $five), &quot;!= (const on lhs)&quot;);

ok($five == (2 + 3), &quot;== (sum on rhs)&quot;);
ok(!($five != (2 + 3)), &quot;== (sum on rhs)&quot;);

is(2 + 3, $five, &quot;== (sum on lhs)&quot;);
ok((2 + 3) == 5, &quot;== (sum on lhs)&quot;);
ok(!((2 + 3) != $five), &quot;== (sum on lhs)&quot;);

# String Operations
is(&quot;text &quot; ~ &quot;stitching&quot;, &quot;text stitching&quot;, 'concatenation with ~ operator');

# Bit Stitching

is(2 || 3, 2, &quot;|| returns first true value&quot;);
is(2 ?| 3, 1, &quot;boolean or (?|) returns 0 or 1&quot;);
ok(!(defined( 0 || undef)), &quot;|| returns last false value of list?&quot;);
is(0 ?| undef, 0, &quot;boolean or (?|) returns 0 or 1&quot;, :todo);

#junctions

ok((all((4|5|6) + 3) == one(7|8|9)), &quot;all elements in junction are incremented&quot;);
ok((any(1..6) == one(1|2|3|4|5|6)), &quot;any elements will match via junction&quot;);


ok( 7 &gt; any(4..12), &quot;any test against scalar&quot; );


my @oldval &nbsp;= (5, 8, 12);

my @newval1 = (17, 15, 14); # all greater
my @newval2 = (15, 7, &nbsp;20); # some less some greater
my @newval3 = (3, 1, 4); &nbsp; &nbsp;# all less
my @newval4 = (1,2,40); &nbsp; &nbsp; 

ok( any(@newval4) &gt; any(@oldval), &quot;any test array against any array&quot; );
ok( any(@newval4) &gt; all(@oldval), &quot;any test array against all array&quot; );
ok( all(@newval2) &gt; any(@oldval), &quot;all test array against any array&quot; );
ok( all(@newval1) &gt; all(@oldval), &quot;all test array against all array&quot; );

ok(42 &gt; 12 &amp; 20 &amp; 32, &quot;test the all infix operator&quot;);


# Hyper ops
my @rv;
@rv = (1,2,3,4) &gt;&gt;+&lt;&lt; (1,2,3,4);
is(&quot;@rv[]&quot;, &quot;2 4 6 8&quot;, 'hyper-add');</pre>
</div>


<ul>
<li>Binary <code>//</code> is just like <code>||</code>, except that it tests its left side for definedness instead of truth. There is a low-precedence form, too: <code>err</code>.</li>

<li>Binary <code>===</code> tests immutable type and value correspondence: for two value types (that is, immutable types), tests whether they are the same value (eg. <code>1 === 1</code>); for two mutable types (object types), checks whether they have the same identity value. (For most such types the identity is simply the reference itself.) It is not true that <code>[1,2] === [1,2]</code> because those are different <code>Array</code> objects, but it is true that <code>@a === @a</code> because those are the same <code>Array</code> object).
<a href="#" onclick="return tog_quote(63);">
<div ID="header_shown_63" style="display: none;">
- Hide the snippet from t/operators/value_equivalence.t (line 7 ~ line 231) -
</div>
<div ID="header_hidden_63" style="display: block;">
- Show the snippet from t/operators/value_equivalence.t (line 7 ~ line 231) -
</div>
</a>
<div ID="hide_63" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S03/&quot;New operators&quot; /Binary ===&gt;

C&lt;===&gt; and C&lt;eqv&gt; are 2 distinct operators, where C&lt;===&gt; tests value
equivalence for immutable types and reference equivalence for 
mutable types, and C&lt;eqv&gt; tests value equivalence for snapshots of mutable
types. &nbsp;So C&lt;(1,2) === (1,2)&gt; returns true but C&lt;[1,2] === [1,2]&gt; returns 
false, and C&lt;[1,2] eqv [1,2]&gt; returns true.

=cut

plan 76;

# === on values
{
&nbsp; ok &nbsp;(1 === 1), &quot;=== on values (1)&quot;;
&nbsp; ok &nbsp;(0 === 0), &quot;=== on values (2)&quot;;
&nbsp; ok !(0 === 1), &quot;=== on values (3)&quot;;
}

# Value types
{
&nbsp; my $a = 1;
&nbsp; my $b = 1;

&nbsp; ok $a === $a, &quot;=== on value types (1-1)&quot;;
&nbsp; ok $b === $b, &quot;=== on value types (1-2)&quot;;
&nbsp; ok $a === $b, &quot;=== on value types (1-3)&quot;;
}

{
&nbsp; my $a = 1;
&nbsp; my $b = 2;

&nbsp; ok &nbsp;($a === $a), &quot;=== on value types (2-1)&quot;;
&nbsp; ok &nbsp;($b === $b), &quot;=== on value types (2-2)&quot;;
&nbsp; ok !($a === $b), &quot;=== on value types (2-3)&quot;;
}

# Reference types
{
&nbsp; my @a = (1,2,3);
&nbsp; my @b = (1,2,3);

&nbsp; ok &nbsp;(\@a === \@a), &quot;=== on array references (1)&quot;, :todo&lt;bug&gt;;
&nbsp; ok &nbsp;(\@b === \@b), &quot;=== on array references (2)&quot;, :todo&lt;bug&gt;;
&nbsp; ok !(\@a === \@b), &quot;=== on array references (3)&quot;;
}

{
&nbsp; my $a = \3;
&nbsp; my $b = \3;

&nbsp; ok &nbsp;($a === $a), &quot;=== on scalar references (1-1)&quot;;
&nbsp; ok &nbsp;($b === $b), &quot;=== on scalar references (1-2)&quot;;
&nbsp; ok !($a === $b), &quot;=== on scalar references (1-3)&quot;, :todo&lt;bug&gt;;
}

{
&nbsp; my $a = { 3 };
&nbsp; my $b = { 3 };

&nbsp; ok &nbsp;($a === $a), &quot;=== on sub references (1-1)&quot;;
&nbsp; ok &nbsp;($b === $b), &quot;=== on sub references (1-2)&quot;;
&nbsp; ok !($a === $b), &quot;=== on sub references (1-3)&quot;;
}

{
&nbsp; ok &nbsp;(&amp;say === &amp;say), &quot;=== on sub references (2-1)&quot;;
&nbsp; ok &nbsp;(&amp;map === &amp;map), &quot;=== on sub references (2-2)&quot;;
&nbsp; ok !(&amp;say === &amp;map), &quot;=== on sub references (2-3)&quot;;
}

{
&nbsp; my $num = 3;
&nbsp; my $a &nbsp; = \$num;
&nbsp; my $b &nbsp; = \$num;

&nbsp; ok &nbsp;($a === $a), &quot;=== on scalar references (2-1)&quot;;
&nbsp; ok &nbsp;($b === $b), &quot;=== on scalar references (2-2)&quot;;
&nbsp; ok &nbsp;($a === $b), &quot;=== on scalar references (2-3)&quot;;
}

{
&nbsp; ok !([1,2,3] === [4,5,6]), &quot;=== on anonymous array references (1)&quot;;
&nbsp; ok !([1,2,3] === [1,2,3]), &quot;=== on anonymous array references (2)&quot;;
&nbsp; ok !([] &nbsp; &nbsp; &nbsp;=== []), &nbsp; &nbsp; &nbsp;&quot;=== on anonymous array references (3)&quot;;
}

{
&nbsp; ok !({a =&gt; 1} === {a =&gt; 2}), &quot;=== on anonymous hash references (1)&quot;;
&nbsp; ok !({a =&gt; 1} === {a =&gt; 1}), &quot;=== on anonymous hash references (2)&quot;;
}

{
&nbsp; ok !(\3 === \4), &nbsp; &nbsp; &nbsp; &nbsp; &quot;=== on anonymous scalar references (1)&quot;;
&nbsp; ok !(\3 === \3), &nbsp; &nbsp; &nbsp; &nbsp; &quot;=== on anonymous scalar references (2)&quot;, :todo&lt;bug&gt;;
&nbsp; ok !(\undef === \undef), &quot;=== on anonymous scalar references (3)&quot;, :todo&lt;bug&gt;;
}

# Chained === (not specced, but obvious)
{
&nbsp; ok &nbsp;(3 === 3 === 3), &quot;chained === (1)&quot;;
&nbsp; ok !(3 === 3 === 4), &quot;chained === (2)&quot;;
}

# Subparam binding doesn't affect === test
{
&nbsp; my $foo;
&nbsp; my $test = -&gt; $arg { $foo === $arg };

&nbsp; $foo = 3;
&nbsp; ok &nbsp;$test($foo), &quot;subparam binding doesn't affect === (1)&quot;;
&nbsp; ok &nbsp;$test(3), &nbsp; &nbsp;&quot;subparam binding doesn't affect === (2)&quot;;

&nbsp; ok !$test(4), &nbsp; &nbsp;&quot;subparam binding doesn't affect === (3)&quot;;
&nbsp; my $bar = 4;
&nbsp; ok !$test($bar), &quot;subparam binding doesn't affect === (4)&quot;;
}

# eqv on values
{
&nbsp; ok &nbsp;(1 eqv 1), &quot;eqv on values (1)&quot;;
&nbsp; ok &nbsp;(0 eqv 0), &quot;eqv on values (2)&quot;;
&nbsp; ok !(0 eqv 1), &quot;eqv on values (3)&quot;;
}

# Value types
{
&nbsp; my $a = 1;
&nbsp; my $b = 1;

&nbsp; ok $a eqv $a, &quot;eqv on value types (1-1)&quot;;
&nbsp; ok $b eqv $b, &quot;eqv on value types (1-2)&quot;;
&nbsp; ok $a eqv $b, &quot;eqv on value types (1-3)&quot;;
}

{
&nbsp; my $a = 1;
&nbsp; my $b = 2;

&nbsp; ok &nbsp;($a eqv $a), &quot;eqv on value types (2-1)&quot;;
&nbsp; ok &nbsp;($b eqv $b), &quot;eqv on value types (2-2)&quot;;
&nbsp; ok !($a eqv $b), &quot;eqv on value types (2-3)&quot;;
}

# Reference types
{
&nbsp; my @a = (1,2,3);
&nbsp; my @b = (1,2,3);

&nbsp; ok &nbsp;(\@a eqv \@a), &quot;eqv on array references (1)&quot;;
&nbsp; ok &nbsp;(\@b eqv \@b), &quot;eqv on array references (2)&quot;;
&nbsp; ok !(\@a eqv \@b), &quot;eqv on array references (3)&quot;, :todo&lt;bug&gt;;
}

{
&nbsp; my $a = \3;
&nbsp; my $b = \3;

&nbsp; ok &nbsp;($a eqv $a), &quot;eqv on scalar references (1-1)&quot;;
&nbsp; ok &nbsp;($b eqv $b), &quot;eqv on scalar references (1-2)&quot;;
&nbsp; ok !($a eqv $b), &quot;eqv on scalar references (1-3)&quot;, :todo&lt;bug&gt;;
}

{
&nbsp; my $a = { 3 };
&nbsp; my $b = { 3 };

&nbsp; ok &nbsp;($a eqv $a), &quot;eqv on sub references (1-1)&quot;;
&nbsp; ok &nbsp;($b eqv $b), &quot;eqv on sub references (1-2)&quot;;
&nbsp; ok !($a eqv $b), &quot;eqv on sub references (1-3)&quot;;
}

{
&nbsp; ok &nbsp;(&amp;say eqv &amp;say), &quot;eqv on sub references (2-1)&quot;;
&nbsp; ok &nbsp;(&amp;map eqv &amp;map), &quot;eqv on sub references (2-2)&quot;;
&nbsp; ok !(&amp;say eqv &amp;map), &quot;eqv on sub references (2-3)&quot;;
}

{
&nbsp; my $num = 3;
&nbsp; my $a &nbsp; = \$num;
&nbsp; my $b &nbsp; = \$num;

&nbsp; ok &nbsp;($a eqv $a), &quot;eqv on scalar references (2-1)&quot;;
&nbsp; ok &nbsp;($b eqv $b), &quot;eqv on scalar references (2-2)&quot;;
&nbsp; ok &nbsp;($a eqv $b), &quot;eqv on scalar references (2-3)&quot;;
}

{
&nbsp; ok !([1,2,3] eqv [4,5,6]), &quot;eqv on anonymous array references (1)&quot;;
&nbsp; ok !([1,2,3] eqv [1,2,3]), &quot;eqv on anonymous array references (2)&quot;, :todo&lt;bug&gt;;
&nbsp; ok !([] &nbsp; &nbsp; &nbsp;eqv []), &nbsp; &nbsp; &nbsp;&quot;eqv on anonymous array references (3)&quot;, :todo&lt;bug&gt;;
}

{
&nbsp; ok !({a =&gt; 1} eqv {a =&gt; 2}), &quot;eqv on anonymous hash references (1)&quot;;
&nbsp; ok !({a =&gt; 1} eqv {a =&gt; 1}), &quot;eqv on anonymous hash references (2)&quot;;
}

{
&nbsp; ok !(\3 eqv \4), &nbsp; &nbsp; &nbsp; &nbsp; &quot;eqv on anonymous scalar references (1)&quot;;
&nbsp; ok !(\3 eqv \3), &nbsp; &nbsp; &nbsp; &nbsp; &quot;eqv on anonymous scalar references (2)&quot;, :todo&lt;bug&gt;;
&nbsp; ok !(\undef eqv \undef), &quot;eqv on anonymous scalar references (3)&quot;, :todo&lt;bug&gt;;
}

# Chained eqv (not specced, but obvious)
{
&nbsp; ok &nbsp;(3 eqv 3 eqv 3), &quot;chained eqv (1)&quot;;
&nbsp; ok !(3 eqv 3 eqv 4), &quot;chained eqv (2)&quot;;
}

# Subparam binding doesn't affect eqv test
{
&nbsp; my $foo;
&nbsp; my $test = -&gt; $arg { $foo eqv $arg };

&nbsp; $foo = 3;
&nbsp; ok &nbsp;$test($foo), &quot;subparam binding doesn't affect eqv (1)&quot;;
&nbsp; ok &nbsp;$test(3), &nbsp; &nbsp;&quot;subparam binding doesn't affect eqv (2)&quot;;

&nbsp; ok !$test(4), &nbsp; &nbsp;&quot;subparam binding doesn't affect eqv (3)&quot;;
&nbsp; my $bar = 4;
&nbsp; ok !$test($bar), &quot;subparam binding doesn't affect eqv (4)&quot;;
}</pre>
</div>


<p>Any object type may pretend to be a value type by defining a <code>.WHICH</code> method which returns a value type that can be recursively compared using <code>===</code>, or in cases where that is impractical, by overloading <code>===</code> such that the comparison treats values consistently with their &#34;eternal&#34; identity. (Strings are defined as values this way despite also being objects.)</p>

<p>Two values are never equivalent unless they are of exactly the same type. By contrast, <code>eq</code> always coerces to string, while <code>==</code> always coerces to numeric. In fact, <code>$a eq $b</code> really means &#34;<code>~$a === ~$b</code>&#34; and <code>$a == $b</code> means <code>+$a === +$b</code>.</p>

<p>Note also that, while string hashes use <code>eq</code> semantics by default, object hashes use <code>===</code> semantics.</p>
</li>

<li>Binary <code>eqv</code> tests equality much like <code>===</code> does, but does so with &#34;snapshot&#34; semantics rather than &#34;eternal&#34; semantics. For top-level components of your value that are of immutable types, <code>eqv</code> is identical in behavior to <code>===</code>. For components of your value that are mutable, however, rather than comparing object identity using <code>===</code>, the <code>eqv</code> operator tests whether the canonical representation of both subvalues would be identical if we took a snapshot of them right now and compared those (now-immutable) snapshots using <code>===</code>.
<p>If that&#39;s not enough flexibility, there is also an <code>eqv()</code> function that can be passed additional information specifying how you want canonical values to be generated before comparison. This gives <code>eqv()</code> the same kind of expressive power as a sort signature. (And indeed, the <code>cmp</code> operator from Perl 5 also has a functional analog, <code>cmp()</code>, that takes additional instructions on how to do 3-way comparisons of the kind that a sorting algorithm wants.) In particular, a signature passed to <code>eqv()</code> will be bound to the two operands in question, and then the comparison will proceed on the formal parameters according to the information contained in the signature, so you can force numeric, string, natural, or other comparisons with proper declarations of the parameter&#39;s type and traits. If the signature doesn&#39;t match the operands, <code>eqv()</code> reverts to standard <code>eqv</code> comparison. (Likewise for <code>cmp()</code>.)</p>
</li>

<li>Binary <code>cmp</code> is no longer the comparison operator that forces stringification. Use the <code>leg</code> operator for the old Perl 5 <code>cmp</code> semantics. The <code>cmp</code> is just like the <code>eqv</code> above except that instead of returning <code>Bool::False</code> or <code>Bool::True</code> values it always returns <code>Order::Increase</code>, <code>Order::Same</code>, or <code>Order::Decrease</code> (which numerify to -1, 0, or +1).</li>

<li>the <code>leg</code> operator (less than, equal, or greater) is defined in terms of <code>cmp</code>, so <code>$a leg $b</code> is now defined as <code>~$a cmp ~$b</code>. The sort operator still defaults to <code>cmp</code> rather than <code>leg</code>. The <code>&#60;=&#62;</code> operator&#39;s semantics are unchanged except that it returns an <code>Order</code> value as described above. In other words, <code>$a &#60;=&#62; $b</code> is now equivalent to <code>+$a cmp +$b</code>.</li>

<li>Binary <code>=&#62;</code> is no longer just a &#34;fancy comma&#34;. It now constructs a <code>Pair</code> object that can, among other things, be used to pass named arguments to functions. It provides scalar context to both sides. Its precedence is now equivalent to assignment, and it is right associative.</li>

<li><code>^^</code> is the high-precedence version of <code>xor</code>.</li>

<li><code>=~</code> becomes the &#34;smart match&#34; operator <code>~~</code>, with a whole new set of semantics. Anywhere you used <code>=~</code> before you now use <code>~~</code>, but <code>~~</code> is much more general now. See &#34;Smart matching&#34; below for details. (To catch &#34;brainos&#34;, the Perl 6 parser defines an <code>infix:&#60;=~&#62;</code> macro which always fails at compile time with a message directing the user either to use <code>~~</code> or <code>~=</code> (string append) instead, or to put a space between if they really wanted to assign a stringified value.) A negated smart match is spelled <code>!~~</code>.</li>

<li>&#34;Unary&#34; <code>.</code> calls its single argument (which must be a postfix operator) on <code>$_</code>. (It&#39;s not really a unary operator, so we put it in quotes.)</li>

<li>The <code>..</code> range operator has variants with <code>^</code> on either end to indicate exclusion of that endpoint from the range. It always produces a <code>Range</code> object. Range objects are lazy iterators, and can be interrogated for their current <code>.min</code> and <code>.max</code> values (which change as they are iterated). Ranges are not autoreversing: <code>2..1</code> is always a null range, as is <code>1^..^2</code>. To reverse a range use:
<a href="#" onclick="return tog_quote(64);">
<div ID="header_shown_64" style="display: none;">
- Hide the snippet from t/operators/range.t (line 30 ~ line 46) -
</div>
<div ID="header_hidden_64" style="display: block;">
- Show the snippet from t/operators/range.t (line 30 ~ line 46) -
</div>
</a>
<div ID="hide_64" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;New operators&quot; /range operator has variants/&gt;
is [1^..9], [2..9], &nbsp;&quot;bottom-exclusive range (^..) works&quot;;
is [1 ..^9], [1..8], &quot;top-exclusive range (..^) works&quot;;
is [1^..^9], [2..8], &quot;double-exclusive range (^..^) works&quot;;
is [1^..^2], [], &quot;double-exclusive range (^..^) can produce null range&quot;;

is [&quot;a&quot;^..&quot;z&quot;], [&quot;b&quot;..&quot;z&quot;], &quot;bottom-exclusive string range (^..) works&quot;;
is [&quot;a&quot;..^&quot;z&quot;], [&quot;a&quot;..&quot;y&quot;], &quot;top-exclusive string range (..^) works&quot;;
is [&quot;a&quot;^..^&quot;z&quot;], [&quot;b&quot;..&quot;y&quot;], &quot;double-exclusive string range (^..^) works&quot;;
is ['a'^..^'b'], [], &quot;double-exclusive string range (^..^) can produce null range&quot;;

is 1.5 ~~ 1^..^2, Bool::True, &quot;lazy evaluation of the range operator&quot;, :todo&lt;bug&gt;;

# Test the unary ^ operator
is ~(^5), &quot;0 1 2 3 4&quot;, &quot;unary ^num produces the range 0..^num&quot;;
is [^1], [0], &quot;unary ^ on the boundary ^1 works&quot;;
is [^0], [], &quot;unary ^0 produces null range&quot;</pre>
</div>


<pre>    2..1:by(-1)
    reverse 1..2</pre>

<p>(The <code>reverse</code> is preferred because it works for alphabetic ranges as well.)</p>

<p>Because <code>Range</code> objects are lazy, they do not automatically generate a list. So smart matching against a <code>Range</code> object smartmatches the endpoints in the domain of the object being matched, so fractional numbers are <code>not</code> truncated before comparison to integer ranges:</p>

<pre>    1.5 ~~ 1^..^2  # true, equivalent to 1 &#60; 1.5 &#60; 2
    2.1 ~~ 1..2    # false, equivalent to 1 &#60;= 2.1 &#60;= 2</pre>

<p>If a <code>*</code> (see the &#34;Whatever&#34; type in S02) occurs on the right side of a range, it is taken to mean &#34;positive infinity&#34; in whatever space the range is operating. A <code>*</code> on the left means &#34;negative infinity&#34; for types that support negative values. If the <code>*</code> occurs on one side but not the other, the type is inferred from the other argument. A star on both sides will match any value that supports the <code>Ordered</code> role.</p>

<pre>    0..*        # 0 .. +Inf
    &#39;a&#39;..*      # &#39;a&#39; .. &#39;zzzzzzzzzzzzzzzzzzzzzzzzzzzzz...&#39;
    *..0        # -Inf .. 0
    *..*        # &#34;-Inf .. +Inf&#34;, really Ordered
    1.2.3..*    # Any version higher than 1.2.3.</pre>

<p>Note: infinite lists are constructed lazily. And even though <code>*..*</code> can&#39;t be constructed at all, it&#39;s still useful as a selector object.</p>
</li>

<li>The unary <code>^</code> operator generates a range from <code>0</code> up to one less than its argument. So <code>^4</code> is short for <code>0..^4</code> or <code>0..3</code>.
<pre>    for ^4 { say $_ } # 0, 1, 2, 3</pre>

<p>If applied to a list, it generates a multidimensional set of subscripts.</p>

<pre>    for ^(3,3) { ... } # (0,0)(0,1)(0,2)(1,0)(1,1)(1,2)(2,0)(2,1)(2,2)</pre>

<p>If applied to a type name, it indicates the metaclass instance instead, so <code>^Moose</code> is short for <code>HOW(Moose)</code> or <code>Moose.HOW</code>. It still kinda means &#34;what is this thing&#39;s domain&#34; in an abstract sort of way.</p>
</li>

<li>The <code>...</code> operator is the &#34;yada, yada, yada&#34; list operator, which is used as the body in function prototypes. It complains bitterly (by calling <code>fail</code>) if it is ever executed. Variant <code>???</code> calls <code>warn</code>, and <code>!!!</code> calls <code>die</code>. The argument is optional, but if provided, is passed onto the <code>fail</code>, <code>warn</code>, or <code>die</code>. Otherwise the system will make up a message for you based on the context, indicating that you tried to execute something that is stubbed out. (This message differs from what <code>fail</code>, <code>warn</code>, and <code>die</code> would say by default, since the latter operators typically point out bad data or programming rather than just an incomplete design.)</li>

<li>In addition to the ordinary <code>.</code> method invocation, there are variants <code>.*</code>, <code>.?</code>, and <code>.+</code> to control how multiple related methods of the same name are handled. The <code>.=</code> operator does inplace modification of the object on the left. The <code>.^</code> operator calls a class metamethod; <code>foo.^bar</code> is short for <code>foo.HOW.bar</code>.</li>

<li>Unary <code>=</code> reads lines from a filehandle or filename, or iterates an iterator, or in general causes a scalar to explode its guts when it would otherwise not. How it does that is context sensitive. For instance, <code>=$iterator</code> is scalar/list sensitive and will produce one value in scalar context but many values in list context. (Use <code>@$iterator</code> to force a fetch of all the values even in scalar context, and <code>$$iterator</code> to force a fetch of a single value even in list context.) On the other hand, <code>=$capture</code> interpolates all parts of the capture that makes sense in the current list context, depending on what controls that list context.</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Smart_matching"
>Smart matching</a></h1>

<a href="#" onclick="return tog_quote(55);">
<div ID="header_shown_55" style="display: none;">
- Hide the snippet from t/blocks/param_signature.t (line 6 ~ line 15) -
</div>
<div ID="header_hidden_55" style="display: block;">
- Show the snippet from t/blocks/param_signature.t (line 6 ~ line 15) -
</div>
</a>
<div ID="hide_55" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;Smart matching&quot;&gt;
# mentions the Code:syntax
# Could use another smart link reference!

diag &quot;Testing for subroutine parameter with signature...&quot;;
ok eval(q{
	sub foo(Code:($a --&gt; $b) &amp;bar, Code:($a, $b --&gt; $c) &amp;baz) { }
	1;
}), 
&quot;Declare subroutine parameters with signature. (Compile-time)&quot;, :todo&lt;feature&gt;;</pre>
</div>


<a href="#" onclick="return tog_quote(35);">
<div ID="header_shown_35" style="display: none;">
- Hide the snippet from t/operators/smartmatch.t (line 189 ~ line 213) -
</div>
<div ID="header_hidden_35" style="display: block;">
- Show the snippet from t/operators/smartmatch.t (line 189 ~ line 213) -
</div>
</a>
<div ID="hide_35" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;S03/Smart matching&gt;
{ 
&nbsp; &nbsp; # representational checks for !~~, rely on ~~ semantics to be correct
&nbsp; &nbsp; # assume negated results

&nbsp; &nbsp; ok(!(&quot;foo&quot; !~~ &quot;foo&quot;), &quot;!(foo ne foo)&quot;);
&nbsp; &nbsp; ok((&quot;bar&quot; !~~ &quot;foo&quot;), &quot;bar ne foo)&quot;);

&nbsp; &nbsp; ok(!((1, 2) !~~ 1), &quot;(1, 2) contains 1&quot;, :todo);
&nbsp; &nbsp; ok(((3, 4, 5) !~~ 2), &quot;(3, 4, 5) doesn't contain 2&quot;);

&nbsp; &nbsp; ok(!(%hash1 !~~ any(%hash3)), &quot;intersecting keys&quot;, :todo);
&nbsp; &nbsp; ok((%hash1 !~~ any(%hash4)), &quot;no intersecting keys&quot;);
};

{
=for Explanation

You may be wondering what the heck is with all these try blocks.
Prior to r12503, this test caused a horrible death of Pugs which
magically went away when used inside an eval. &nbsp;So the try blocks
caught that case.

=cut</pre>
</div>


<p>Here is the current table of smart matches. The list is intended to reflect forms that can be recognized at compile time. If none of these forms is recognized at compile time, it falls through to do MMD to <code>infix:&#60;~~&#62;()</code>, which presumably reflects similar semantics, but can finesse things that aren&#39;t exact type matches. Note that all types are scalarized here. Both <code>~~</code> and <code>given</code>/<code>when</code> provide scalar contexts to their arguments. (You can always hyperize <code>~~</code> explicitly, though.) So both <code>$_</code> and <code>$x</code> here are potentially references to container objects. And since lists promote to arrays in scalar context, there need be no separate entries for lists.</p>

<pre>    $_      $x        Type of Match Implied    Matching Code
    ======  =====     =====================    =============
    Any     Code:($)  scalar sub truth         match if $x($_)
    Hash    Hash      hash keys identical      match if $_.keys.sort &#187;eq&#171; $x.keys.sort</pre>

<a href="#" onclick="return tog_quote(54);">
<div ID="header_shown_54" style="display: none;">
- Hide the snippet from t/operators/smartmatch.t (line 34 ~ line 40) -
</div>
<div ID="header_hidden_54" style="display: block;">
- Show the snippet from t/operators/smartmatch.t (line 34 ~ line 40) -
</div>
</a>
<div ID="hide_54" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;&lt;S03/Smart matching/Hash &quot;hash keys identical&quot;
# &nbsp; if $_.keys.sort »eq« $x.keys.sort&gt;&gt;
{ 
&nbsp; &nbsp; ok eval_elsewhere('(%+hash1 ~~ %+hash2)'), &quot;hash keys identical&quot;, :todo;
&nbsp; &nbsp; ok eval_elsewhere('!(%+hash1 ~~ %+hash4)'), &quot;hash keys differ&quot;;
};</pre>
</div>


<pre>    Hash    any(Hash) hash key intersection    match if $_{any(Hash.keys)}</pre>

<a href="#" onclick="return tog_quote(53);">
<div ID="header_shown_53" style="display: none;">
- Hide the snippet from t/operators/smartmatch.t (line 41 ~ line 46) -
</div>
<div ID="header_hidden_53" style="display: block;">
- Show the snippet from t/operators/smartmatch.t (line 41 ~ line 46) -
</div>
</a>
<div ID="hide_53" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;&lt;S03/Smart matching/Hash any(Hash) &quot;hash key intersection&quot; match&gt;&gt;
{ 
&nbsp; &nbsp; ok((%hash1 ~~ any(%hash3)), &quot;intersecting keys&quot;, :todo);
&nbsp; &nbsp; ok(!(%hash1 ~~ any(%hash4)), &quot;no intersecting keys&quot;);
};</pre>
</div>


<pre>    Hash    Array     hash value slice truth   match if $_{any(@$x)}</pre>

<a href="#" onclick="return tog_quote(52);">
<div ID="header_shown_52" style="display: none;">
- Hide the snippet from t/operators/smartmatch.t (line 47 ~ line 56) -
</div>
<div ID="header_hidden_52" style="display: block;">
- Show the snippet from t/operators/smartmatch.t (line 47 ~ line 56) -
</div>
</a>
<div ID="hide_52" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;&lt;S03/Smart matching/Hash Array &quot;hash value slice truth&quot; &quot;match if&quot;&gt;&gt;
{ 
&nbsp; &nbsp; my @true = (&lt;foo bar&gt;);
&nbsp; &nbsp; my @sort_of = (&lt;foo gorch&gt;);
&nbsp; &nbsp; my @false = (&lt;gorch baz&gt;);
&nbsp; &nbsp; ok((%hash5 ~~ @true), &quot;value slice true&quot;, :todo);
&nbsp; &nbsp; ok((%hash5 ~~ @sort_of), &quot;value slice partly true&quot;, :todo);
&nbsp; &nbsp; ok(!(%hash5 ~~ @false), &quot;value slice false&quot;);
};</pre>
</div>


<pre>    Hash    any(list) hash key slice existence match if exists $_{any(list)}</pre>

<a href="#" onclick="return tog_quote(51);">
<div ID="header_shown_51" style="display: none;">
- Hide the snippet from t/operators/smartmatch.t (line 57 ~ line 62) -
</div>
<div ID="header_hidden_51" style="display: block;">
- Show the snippet from t/operators/smartmatch.t (line 57 ~ line 62) -
</div>
</a>
<div ID="hide_51" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;&lt;S03/Smart matching/Hash any(list) &quot;hash key slice existence&quot; match&gt;&gt;
{ 
&nbsp; &nbsp; ok((%hash1 ~~ any(&lt;foo bar&gt;)), &quot;any key exists (but where is it?)&quot;, :todo);
&nbsp; &nbsp; ok(!(%hash1 ~~ any(&lt;gorch ding&gt;)), &quot;no listed key exists&quot;);
};</pre>
</div>


<pre>    Hash    all(list) hash key slice existence match if exists $_{all(list)}</pre>

<a href="#" onclick="return tog_quote(50);">
<div ID="header_shown_50" style="display: none;">
- Hide the snippet from t/operators/smartmatch.t (line 63 ~ line 70) -
</div>
<div ID="header_hidden_50" style="display: block;">
- Show the snippet from t/operators/smartmatch.t (line 63 ~ line 70) -
</div>
</a>
<div ID="hide_50" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;&lt;S03/Smart matching/Hash all(list) &quot;hash key slice existence&quot; match&gt;&gt;
{ 
&nbsp; &nbsp; ok((%hash1 ~~ all(&lt;foo blah&gt;)), &quot;all keys exist&quot;, :todo);
&nbsp; &nbsp; ok(!(%hash1 ~~ all(&lt;foo edward&gt;)), &quot;not all keys exist&quot;);
};

#Hash &nbsp; &nbsp;Rule &nbsp; &nbsp; &nbsp;hash key grep &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;match if any($_.keys) ~~ /$x/</pre>
</div>


<pre>    Hash    Regex     hash key grep            match if any($_.keys) ~~ /$x/
    Hash    Any       hash entry existence     match if exists $_{$x}</pre>

<a href="#" onclick="return tog_quote(49);">
<div ID="header_shown_49" style="display: none;">
- Hide the snippet from t/operators/smartmatch.t (line 71 ~ line 78) -
</div>
<div ID="header_hidden_49" style="display: block;">
- Show the snippet from t/operators/smartmatch.t (line 71 ~ line 78) -
</div>
</a>
<div ID="hide_49" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;&lt;S03/Smart matching/Hash Any &quot;hash entry existence&quot; &quot;match if exists&quot;&gt;&gt;
{ 
&nbsp; &nbsp; ok((%hash5 ~~ &quot;foo&quot;), &quot;foo exists&quot;, :todo);
&nbsp; &nbsp; ok((%hash5 ~~ &quot;gorch&quot;),
&nbsp; &nbsp; &nbsp; &quot;gorch exists, true although value is false&quot;, :todo);
&nbsp; &nbsp; ok((%hash5 ~~ &quot;wasabi&quot;), &quot;wasabi does not exist&quot;, :todo);
};</pre>
</div>


<pre>    Hash    .{Any}    hash element truth*      match if $_{Any}</pre>

<a href="#" onclick="return tog_quote(48);">
<div ID="header_shown_48" style="display: none;">
- Hide the snippet from t/operators/smartmatch.t (line 79 ~ line 86) -
</div>
<div ID="header_hidden_48" style="display: block;">
- Show the snippet from t/operators/smartmatch.t (line 79 ~ line 86) -
</div>
</a>
<div ID="hide_48" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;&lt;S03/Smart matching/Hash .{Any} &quot;hash element truth*&quot;&gt;&gt;
{ 
&nbsp; &nbsp; my $string is context = &quot;foo&quot;;
&nbsp; &nbsp; ok eval_elsewhere('(%+hash5 ~~ .{$+string})'), 'hash.{Any} truth';
&nbsp; &nbsp; $string = &quot;gorch&quot;;
&nbsp; &nbsp; ok eval_elsewhere('!(%+hash5 ~~ .{$+string})'), 'hash.{Any} untruth';
};</pre>
</div>


<pre>    Hash    .&#60;string&#62; hash element truth*      match if $_&#60;string&#62;</pre>

<a href="#" onclick="return tog_quote(47);">
<div ID="header_shown_47" style="display: none;">
- Hide the snippet from t/operators/smartmatch.t (line 87 ~ line 92) -
</div>
<div ID="header_hidden_47" style="display: block;">
- Show the snippet from t/operators/smartmatch.t (line 87 ~ line 92) -
</div>
</a>
<div ID="hide_47" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;&lt;S03/Smart matching/Hash .&lt;string&gt; &quot;hash element truth*&quot;&gt;&gt;
{ 
&nbsp; &nbsp; ok eval_elsewhere('(%+hash5 ~~ .&lt;foo&gt;)'), &quot;hash&lt;string&gt; truth&quot;;
&nbsp; &nbsp; ok eval_elsewhere('!(%+hash5 ~~ .&lt;gorch&gt;)'), &quot;hash&lt;string&gt; untruth&quot;;
};</pre>
</div>


<pre>    Array   Array     arrays are comparable    match if $_ &#187;~~&#171; $x</pre>

<a href="#" onclick="return tog_quote(46);">
<div ID="header_shown_46" style="display: none;">
- Hide the snippet from t/operators/smartmatch.t (line 93 ~ line 98) -
</div>
<div ID="header_hidden_46" style="display: block;">
- Show the snippet from t/operators/smartmatch.t (line 93 ~ line 98) -
</div>
</a>
<div ID="hide_46" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;&lt;S03/Smart matching/Array Array &quot;arrays are comparable&quot; »~~«&gt;&gt;
{ 
&nbsp; &nbsp; ok(((&quot;blah&quot;, &quot;blah&quot;) ~~ (&quot;blah&quot;, &quot;blah&quot;)), &quot;qw/blah blah/ .eq&quot;);
&nbsp; &nbsp; ok(!((1, 2) ~~ (1, 1)), &quot;1 2 !~~ 1 1&quot;);
};</pre>
</div>


<pre>    Array   any(list) list intersection        match if any(@$_) ~~ any(list)</pre>

<a href="#" onclick="return tog_quote(45);">
<div ID="header_shown_45" style="display: none;">
- Hide the snippet from t/operators/smartmatch.t (line 99 ~ line 108) -
</div>
<div ID="header_hidden_45" style="display: block;">
- Show the snippet from t/operators/smartmatch.t (line 99 ~ line 108) -
</div>
</a>
<div ID="hide_45" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;&lt;S03/Smart matching/Array any(list) &quot;list intersection&quot; any(@$_) &gt;&gt;
{ 
&nbsp; &nbsp; ok(((1, 2) ~~ any(2, 3)),
&nbsp; &nbsp; &nbsp; &quot;there is intersection between (1, 2) and (2, 3)&quot;, :todo);
&nbsp; &nbsp; ok(!((1, 2) ~~ any(3, 4)),
&nbsp; &nbsp; &nbsp; &quot;but none between (1, 2) and (3, 4)&quot;);
};

# Array &nbsp; Rule &nbsp; &nbsp; &nbsp;array grep &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match if any(@$_) ~~ /$x/</pre>
</div>


<pre>    Array   Regex     array grep               match if any(@$_) ~~ /$x/
    Array   Num       array contains number    match if any($_) == $x</pre>

<a href="#" onclick="return tog_quote(44);">
<div ID="header_shown_44" style="display: none;">
- Hide the snippet from t/operators/smartmatch.t (line 109 ~ line 114) -
</div>
<div ID="header_hidden_44" style="display: block;">
- Show the snippet from t/operators/smartmatch.t (line 109 ~ line 114) -
</div>
</a>
<div ID="hide_44" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;&lt;S03/Smart matching/Array Num &quot;array contains number&quot;&gt;&gt;
{ 
&nbsp; &nbsp; ok(((1, 2) ~~ 1), &quot;(1, 2) contains 1&quot;, :todo);
&nbsp; &nbsp; ok(!((3, 4, 5) ~~ 2), &quot;(3, 4, 5) doesn't contain 2&quot;);
};</pre>
</div>


<pre>    Array   Str       array contains string    match if any($_) eq $x</pre>

<a href="#" onclick="return tog_quote(43);">
<div ID="header_shown_43" style="display: none;">
- Hide the snippet from t/operators/smartmatch.t (line 115 ~ line 121) -
</div>
<div ID="header_hidden_43" style="display: block;">
- Show the snippet from t/operators/smartmatch.t (line 115 ~ line 121) -
</div>
</a>
<div ID="hide_43" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;&lt;S03/Smart matching/Array Str &quot;array contains string&quot;&gt;&gt;
{ 
&nbsp; &nbsp; ok(((&quot;foo&quot;, &quot;bar&quot;, &quot;gorch&quot;) ~~ &quot;bar&quot;),
&nbsp; &nbsp; &nbsp; &quot;bar is in qw/foo bar gorch/&quot;, :todo);
&nbsp; &nbsp; ok(!((&quot;x&quot;, &quot;y&quot;, &quot;z&quot;) ~~ &quot;a&quot;), &quot;a is not in qw/x y z/&quot;);
};</pre>
</div>


<pre>    Array   .[number] array element truth*     match if $_[number]</pre>

<a href="#" onclick="return tog_quote(42);">
<div ID="header_shown_42" style="display: none;">
- Hide the snippet from t/operators/smartmatch.t (line 122 ~ line 129) -
</div>
<div ID="header_hidden_42" style="display: block;">
- Show the snippet from t/operators/smartmatch.t (line 122 ~ line 129) -
</div>
</a>
<div ID="hide_42" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;&lt;S03/Smart matching/Array .[number] &quot;array element truth*&quot;&gt;&gt;
{ 
&nbsp; &nbsp; ok eval('((undef, 1, undef) ~~ .[1])'),
&nbsp; &nbsp; &nbsp; &nbsp; &quot;element 1 of (undef, 1, undef) is true&quot;;
&nbsp; &nbsp; ok eval('!((undef, undef) ~~ .[0])'),
&nbsp; &nbsp; &nbsp; &nbsp; &quot;element 0 of (undef, undef) is false&quot;;
};</pre>
</div>


<pre>    Num     NumRange  in numeric range         match if $min &#60;= $_ &#60;= $max</pre>

<a href="#" onclick="return tog_quote(41);">
<div ID="header_shown_41" style="display: none;">
- Hide the snippet from t/operators/smartmatch.t (line 130 ~ line 139) -
</div>
<div ID="header_hidden_41" style="display: block;">
- Show the snippet from t/operators/smartmatch.t (line 130 ~ line 139) -
</div>
</a>
<div ID="hide_41" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;&lt;S03/&quot;Smart matching&quot; /Num NumRange &quot;in numeric range&quot;&gt;&gt;
{ 
&nbsp; &nbsp; ok((5 ~~ 1 .. 10), &quot;5 is in 1 .. 10&quot;, :todo);
&nbsp; &nbsp; ok(!(10 ~~ 1 .. 5), &quot;10 is not in 1 .. 5&quot;);
&nbsp; &nbsp; ok(!(1 ~~ 5 .. 10), &quot;1 is not i n 5 .. 10&quot;);
&nbsp; &nbsp; #ok(!(5 ~~ 5 ^..^ 10), &quot;5 is not in 5 .. 10, exclusive&quot;); # phooey
};

#Str &nbsp; &nbsp; StrRange &nbsp;in string range &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;match if $min le $_ le $max</pre>
</div>


<pre>    Str     StrRange  in string range          match if $min le $_ le $max
    Capture Signature parameter binding        match if $cap can bind to $sig
    Code    Signature signature compatibility* match if $_ is a subset of $x
  Signature Signature signature compatibility  match if $_ is a subset of $x
    Any     Code:()   simple closure truth*    match if $x() (ignoring $_)</pre>

<a href="#" onclick="return tog_quote(40);">
<div ID="header_shown_40" style="display: none;">
- Hide the snippet from t/operators/smartmatch.t (line 140 ~ line 145) -
</div>
<div ID="header_hidden_40" style="display: block;">
- Show the snippet from t/operators/smartmatch.t (line 140 ~ line 145) -
</div>
</a>
<div ID="hide_40" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;&lt;S03/Smart matching/Any Code:() &quot;simple closure truth*&quot;&gt;&gt;
{ 
&nbsp; &nbsp; ok((1 ~~ { 1 }), &quot;closure truth&quot;);
&nbsp; &nbsp; ok((undef ~~ { 1 }), 'ignores $_');
};</pre>
</div>


<pre>    Any     Class     class membership         match if $_.does($x)</pre>

<a href="#" onclick="return tog_quote(39);">
<div ID="header_shown_39" style="display: none;">
- Hide the snippet from t/operators/smartmatch.t (line 146 ~ line 157) -
</div>
<div ID="header_hidden_39" style="display: block;">
- Show the snippet from t/operators/smartmatch.t (line 146 ~ line 157) -
</div>
</a>
<div ID="hide_39" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;&lt;S03/Smart matching/Any Class &quot;class membership&quot; $_.does($x)&gt;&gt;
{ 
&nbsp; &nbsp; class Dog {}
&nbsp; &nbsp; class Cat {}
&nbsp; &nbsp; class Chihuahua is Dog {} # i'm afraid class Pugs will get in the way ;-)

&nbsp; &nbsp; ok eval('(Chihuahua ~~ Dog)'), &quot;chihuahua isa dog&quot;;
&nbsp; &nbsp; ok eval('!(Chihuahua ~~ Cat)'), &quot;chihuahua is not a cat&quot;;
};

#Any &nbsp; &nbsp; Role &nbsp; &nbsp; &nbsp;role playing &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match if \$_.does(\$x)</pre>
</div>


<pre>    Any     Role      role playing             match if $_.does($x)
    Any     Num       numeric equality         match if $_ == $x</pre>

<a href="#" onclick="return tog_quote(38);">
<div ID="header_shown_38" style="display: none;">
- Hide the snippet from t/operators/smartmatch.t (line 158 ~ line 163) -
</div>
<div ID="header_hidden_38" style="display: block;">
- Show the snippet from t/operators/smartmatch.t (line 158 ~ line 163) -
</div>
</a>
<div ID="hide_38" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;&lt;S03/Smart matching/Any Num &quot;numeric equality&quot; match&gt;&gt;
{ 
&nbsp; &nbsp; ok((1 ~~ 1), &quot;one is one&quot;);
&nbsp; &nbsp; ok(!(2 ~~ 1), &quot;two is not one&quot;);
};</pre>
</div>


<pre>    Any     Str       string equality          match if $_ eq $x</pre>

<a href="#" onclick="return tog_quote(37);">
<div ID="header_shown_37" style="display: none;">
- Hide the snippet from t/operators/smartmatch.t (line 164 ~ line 178) -
</div>
<div ID="header_hidden_37" style="display: block;">
- Show the snippet from t/operators/smartmatch.t (line 164 ~ line 178) -
</div>
</a>
<div ID="hide_37" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;&lt;S03/Smart matching/Any Str &quot;string equality&quot; match&gt;&gt;
{ 
&nbsp; &nbsp; ok((&quot;foo&quot; ~~ &quot;foo&quot;), &quot;foo eq foo&quot;);
&nbsp; &nbsp; ok(!(&quot;bar&quot; ~~ &quot;foo&quot;), &quot;!(bar eq foo)&quot;);
};

# no objects, no rules
# ... staring vin diesel and kevin kostner! (blech)
#Any &nbsp; &nbsp; .method &nbsp; method truth* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;match if $_.method
#Any &nbsp; &nbsp; Rule &nbsp; &nbsp; &nbsp;pattern match &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;match if $_ ~~ /$x/
#Any &nbsp; &nbsp; subst &nbsp; &nbsp; substitution match* &nbsp; &nbsp; &nbsp;match if $_ ~~ subst

# i don't understand this one
#Any &nbsp; &nbsp; boolean &nbsp; simple expression truth* match if true given $_</pre>
</div>


<pre>    Any     .method   method truth*            match if $_.method
    Any     Regex     pattern match            match if $_ ~~ /$x/
    Any     subst     substitution match*      match if $_ ~~ subst
    Any     boolean   simple expression truth* match if $x.true given $_
    Any     undef     undefined                match unless defined $_</pre>

<a href="#" onclick="return tog_quote(36);">
<div ID="header_shown_36" style="display: none;">
- Hide the snippet from t/operators/smartmatch.t (line 179 ~ line 188) -
</div>
<div ID="header_hidden_36" style="display: block;">
- Show the snippet from t/operators/smartmatch.t (line 179 ~ line 188) -
</div>
</a>
<div ID="hide_36" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;&lt;S03/Smart matching/Any undef undefined &quot;match unless defined $_&quot; &gt;&gt;
{ 
&nbsp; &nbsp; ok(!(&quot;foo&quot; ~~ undef), &quot;foo is not ~~ undef&quot;);
&nbsp; &nbsp; ok((undef ~~ undef), &quot;undef is&quot;);
};

# does this imply MMD for $_, $x?
#Any &nbsp; &nbsp; Any &nbsp; &nbsp; &nbsp; run-time dispatch &nbsp; &nbsp; &nbsp; &nbsp;match if infix:&lt;~~&gt;($_, $x)</pre>
</div>


<pre>    Any     Whatever  default                  match anything
    Any     Any       run-time dispatch        match if infix:&#60;~~&#62;($_, $x)</pre>

<p>Matches marked with * are non-reversible, typically because <code>~~</code> takes its left side as the topic for the right side, and sets the topic to a private instance of <code>$_</code> for its right side, so <code>$_</code> means something different on either side. Such non-reversible constructs can be made reversible by putting the leading term into a closure to defer the binding of <code>$_</code>. For example:</p>

<pre>    $x ~~ .does(Storable)       # okay
    .does(Storable) ~~ $x       # not okay--gets wrong $_ on left
    { .does(Storable) } ~~ $x   # okay--closure binds its $_ to $x</pre>

<p>Exactly the same consideration applies to <code>given</code> and <code>when</code>:</p>

<pre>    given $x { when .does(Storable) {...} }      # okay
    given .does(Storable) { when $x {...} }      # not okay
    given { .does(Storable) } { when $x {...} }  # okay</pre>

<p>Boolean expressions are those known to return a boolean value, such as comparisons, or the unary <code>?</code> operator. They may reference <code>$_</code> explicitly or implicitly. If they don&#39;t reference <code>$_</code> at all, that&#39;s okay too--in that case you&#39;re just using the switch structure as a more readable alternative to a string of elsifs. Note, however, that this means you can&#39;t write:</p>

<pre>    given $boolean {
        when True  {...}
        when False {...}
    }</pre>

<p>because it will always choose the <code>True</code> case. Instead use something like:</p>

<pre>    given $boolean {
        when .true {...}
        when .not  {...}
    }</pre>

<p>Better, just use an <code>if</code> statement.</p>

<p>The primary use of the <code>~~</code> operator is to return a boolean value in a boolean context. However, for certain operands such as regular expressions, use of the operator within scalar or list context transfers the context to that operand, so that, for instance, a regular expression can return a list of matched substrings, as in Perl 5. The complete list of such operands is TBD.</p>

<p>It has not yet been determined if run-time dispatch of <code>~~</code> will attempt to emulate the compile-time precedence table before reverting to MMD, or just go directly to MMD. There are good arguments for both sides, and we can decide when we see more examples of how it&#39;ll work out.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Meta_operators"
>Meta operators</a></h1>

<p>Perl 6&#39;s operators have been greatly regularized, for instance, by consistently prefixing numeric, stringwise, and boolean operators with <code>+</code>, <code>~</code> and <code>?</code> respectively to indicate whether the bitwise operation is done on a number, a string, or a single bit. But that&#39;s just a naming convention, and if you wanted to add a new bitwise <code>&#172;</code> operator, you&#39;d have the add the <code>+&#172;</code>, <code>~&#172;</code>, and <code>?&#172;</code> operators yourself. Similarly, the carets that exclude the endpoints on ranges are there by convention only.</p>

<p>In contrast to that, Perl 6 has five standard metaoperators for turning a given existing operator into a related operator that is more powerful (or at least differently powerful). These differ from a mere naming convention in that Perl automatically generates these new metaoperators from user-defined operators as well as from builtins. In fact, you&#39;re not generally supposed to define the individual metaoperations--their semantics are supposed to be self-evident by the transformation of the base operator.</p>

<p>Note: Spaces are never allowed between any metaoperator and the operator it&#39;s modifying, because all operators including modified ones have to be recognized by the Longest-Token Rule, which disallows spaces within a token.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Assignment_operators"
>Assignment operators</a></h2>

<p>These are already familiar to C and Perl programmers. (Though the <code>.=</code> operator now means to call a mutating method on the object on the left, and <code>~=</code> is string concatenation.) Most non-relational infix operators may be turned into their corresponding assignment operator by suffixing with <code>=</code>. The limitation is actually based on whether the left side can function both as an rvalue and an lvalue by the usual correspondence:</p>

<pre>    A op= B;
    A = A op B;</pre>

<p>Existing forms ending in <code>=</code> may not be modified with this metaoperator.</p>

<p>Regardless of the precedence of the base operator, the precedence of any assignment operators is forced to be the same as that of ordinary assignment.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Negated_relational_operators"
>Negated relational operators</a></h2>

<p>Any infix relational operator may be transformed into its negative by prefixing with <code>!</code>. A couple of these have traditional shortcuts:</p>

<pre>    Full form   Shortcut
    ---------   --------
    !==         !=
    !eq         ne</pre>

<p>but most of them do not:</p>

<pre>    !~~
    !&#60;
    !&#62;=
    !ge
    !===
    !eqv
    !=:=</pre>

<p>To avoid visual confusion with the <code>!!</code> operator, you may not modify any operator already beginning with <code>!</code>.</p>

<p>The precedence of any negated operator is the same as the base operator.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Hyper_operators"
>Hyper operators</a></h2>

<p>The Unicode characters <code>&#187;</code> (<code>\x[BB]</code>) and <code>&#171;</code> (<code>\x[AB]</code>) and their ASCII digraphs <code>&#62;&#62;</code> and <code>&#60;&#60;</code> are used to denote &#34;list operations&#34;, which operate on each element of two lists (or arrays) and return a list (or array) of the results. Spaces are not allowed on the &#34;pointy&#34; end of each &#34;hyper&#34;, but are allowed on the blunt end (except for postfix operators, which must still follow postfix spacing rules, but do allow for an additional dot before the &#34;hyper&#34;).</p>

<p>The precedence of any hyperoperator is the same as its base operator. This means that you must parenthesize your lists for most operators. For example:</p>

<pre>     (1,1,2,3,5) &#187;+&#171; (1,2,3,5,8);  # (2,3,5,8,13)</pre>

<p>If either argument is insufficiently dimensioned, Perl &#34;upgrades&#34; it:</p>

<pre>     (3,8,2,9,3,8) &#62;&#62;-&#60;&#60; 1;          # (2,7,1,8,2,7)</pre>

<p>In fact, this is the <i>only</i> form that will work for an unordered type such as a <code>Bag</code>:</p>

<pre>     Bag(3,8,2,9,3,8) &#62;&#62;-&#60;&#60; 1;       # Bag(2,7,1,8,2,7) === Bag(1,2,2,7,7,8)</pre>

<p>When using a unary operator, only put the &#34;hyper&#34; on the side of the single operand:</p>

<pre>     @negatives = -&#171; @positives;

     @positions&#187;++;            # Increment all positions

     @positions.&#187;++;           # Same thing, dot form
     @positions&#187;.++;           # Same thing, dot form
     @positions.&#187;.++;          # Same thing, dot form
     @positions\  .&#187;\  .++;    # Same thing, long dot form

     @objects.&#187;.run();
     (&#34;f&#34;,&#34;oo&#34;,&#34;bar&#34;).&#62;&#62;.chars;   # (1,2,3)</pre>

<p>Note that method calls are really postfix operators, not infix, so you shouldn&#39;t put a <code>&#171;</code> after the dot.</p>

<p>Hyper operators are defined recursively on arrays, so:</p>

<pre>    -&#171; [[1, 2], 3]               #    [-&#171;[1, 2], -&#171;3]
                                 # == [[-1, -2], -3]
    [[1, 2], 3] &#187;+&#171; [4, [5, 6]]  #    [[1,2] &#187;+&#171; 4, 3 &#187;+&#171; [5, 6]]
                                 # == [[5, 6], [8, 9]]</pre>

<p>More generally, hyper operators work recursively for any object matching the <code>Each</code> role even if the object itself doesn&#39;t support the operator in question:</p>

<pre>    Bag(3,8,[2,Seq(9,3)],8) &#62;&#62;-&#60;&#60; 1;         # Bag(2,7,[1,Seq(8,2)],7)
    Seq(3,8,[2,Seq(9,3)],8) &#62;&#62;-&#60;&#60; (1,1,2,1); # Seq(2,7,[0,Seq(7,1)],7)</pre>

<p>In particular, tree node types with <code>Each</code> semantics enable visitation:</p>

<pre>    $tree.&#187;.foo;        # short for $tree.foo, $tree.each: { .&#187;.foo }</pre>

<p>If not all nodes support the operation, you need a form of it that specifies the call is optional:</p>

<pre>    $tree.&#187;.?foo;       # short for $tree.?foo, $tree.each: { .&#187;.?foo }
    $tree.&#187;.*foo;       # short for $tree.*foo, $tree.each: { .&#187;.*foo }</pre>

<p>You are not allowed to define your own hyper operators, because they are supposed to have consistent semantics derivable entirely from the modified scalar operator. If you&#39;re looking for a mathematical vector product, this isn&#39;t where you&#39;ll find it. A hyperoperator is one of the ways that you can promise to the optimizer that your code is parallelizable. (The tree visitation above is allowed to have side effects, but it is erroneous for the meaning of those side effects to depend on the order of visitation. [Conjecture: we could allow dependencies that assume top-down visitation and only leaves sibling calls unordered.])</p>

<p>Even in the absence of hardware that can do parallel processing, hyperoperators may be faster than the corresponding scalar operators if they can factor out looping overhead to lower-level code, or can apply loop-unrolling optimizations, or can factor out some or all of the MMD dispatch overhead, based on the known types of the operands (and also based on the fact that hyper operators promise no interaction among the &#34;iterations&#34;, whereas the corresponding scalar operator in a loop cannot make the same promise unless all the operations within the loop are known to be side-effect free.)</p>

<p>In particular, infix hyperops on two <code>int</code> or <code>num</code> arrays need only do a single MMD dispatch to find the correct function to call for all pairs, and can further bypass any type-checking or type-coercion entry points to such functions when there are known to be low-level entry points of the appropriate type. (And similarly for unary <code>int</code> or <code>num</code> ops.)</p>

<p>Application-wide analysis of finalizable object types may also enable such optimizations to be applied to <code>Int</code>, <code>Num</code>, and such. In the absence of that, run-time analysis of partial MMD dispatch may save some MMD searching overhead. Or particular object arrays might even keep track of their own run-time type purity and cache partial MMD dispatch tables when they know they&#39;re likely to be used in hyperops.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Reduction_operators"
>Reduction operators</a></h2>

<a href="#" onclick="return tog_quote(11);">
<div ID="header_shown_11" style="display: none;">
- Hide the snippet from t/blocks/multi_sub.t (line 70 ~ line 87) -
</div>
<div ID="header_hidden_11" style="display: block;">
- Show the snippet from t/blocks/multi_sub.t (line 70 ~ line 87) -
</div>
</a>
<div ID="hide_11" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;Reduction operators&quot;&gt;

proto prefix:&lt;[+]&gt; (*@args) {
&nbsp; &nbsp; my $accum = 0;
&nbsp; &nbsp; $accum += $_ for @args;
&nbsp; &nbsp; return $accum * 2; # * 2 is intentional here
}

is ([+] 1,2,3), 12, &quot;[+] overloaded by proto definition&quot;;

# more similar tests

proto prefix:&lt;moose&gt; ($arg) { $arg + 1 }
is (moose 3), 4, &quot;proto definition of prefix:&lt;moose&gt; works&quot;;

proto prefix:&lt;elk&gt; ($arg) {...}
multi prefix:&lt;elk&gt; ($arg) { $arg + 1 }
is (elk 3), 4, &quot;multi definition of prefix:&lt;elk&gt; works&quot;;</pre>
</div>


<a href="#" onclick="return tog_quote(10);">
<div ID="header_shown_10" style="display: none;">
- Hide the snippet from t/operators/reduce-metaop.t (line 5 ~ line 125) -
</div>
<div ID="header_hidden_10" style="display: block;">
- Show the snippet from t/operators/reduce-metaop.t (line 5 ~ line 125) -
</div>
</a>
<div ID="hide_10" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;Reduction operators&quot;&gt;

=head1 DESCRIPTION

This test tests the C&lt;[...]&gt; reduce metaoperator.

Reference:
L&lt;<a href="http://groups.google.de/group/perl.perl6.language/msg/bd9eb275d5da2eda">&quot;http://groups.google.de/group/perl.perl6.language/msg/bd9eb275d5da2eda&quot;</a>&gt;

=cut


# [...] reduce metaoperator
{
&nbsp; my @array = &lt;5 -3 7 0 1 -9&gt;;
&nbsp; my $sum &nbsp; = 5 + -3 + 7 + 0 + 1 + -9; # laziness :)

&nbsp; is(([+] @array), &nbsp; &nbsp; &nbsp;$sum, &quot;[+] works&quot;);
&nbsp; is(([*] &nbsp;1,2,3), &nbsp; &nbsp;(1*2*3), &quot;[*] works&quot;);
&nbsp; is(([-] &nbsp;1,2,3), &nbsp; &nbsp;(1-2-3), &quot;[-] works&quot;);
&nbsp; is(([/] &nbsp;12,4,3), &nbsp;(12/4/3), &quot;[/] works&quot;);
&nbsp; is(([**] 2,2,3), &nbsp;(2**2**3), &quot;[**] works&quot;);

&nbsp; is((~ [\+] @array), &quot;5 2 9 9 10 1&quot;, &quot;[\\+] works&quot;);
&nbsp; is((~ [\-] 1, 2, 3), &quot;1 -1 -4&quot;, &nbsp; &nbsp; &nbsp;&quot;[\\-] works&quot;);
}

{
&nbsp; is ([~] &lt;a b c d&gt;), &quot;abcd&quot;, &quot;[~] works&quot;;

&nbsp; is (~ [\~] &lt;a b c d&gt;), &quot;a ab abc abcd&quot;, &quot;[\\~] works&quot;;
}

{
&nbsp; &nbsp; ok ( &nbsp; &nbsp;[&lt;] &nbsp;1, 2, 3, 4), &quot;[&lt;] works (1)&quot;;
&nbsp; &nbsp; ok (not [&lt;] &nbsp;1, 3, 2, 4), &quot;[&lt;] works (2)&quot;;
&nbsp; &nbsp; ok ( &nbsp; &nbsp;[&gt;] &nbsp;4, 3, 2, 1), &quot;[&gt;] works (1)&quot;;
&nbsp; &nbsp; ok (not [&gt;] &nbsp;4, 2, 3, 1), &quot;[&gt;] works (2)&quot;;
&nbsp; &nbsp; ok ( &nbsp; &nbsp;[==] 4, 4, 4), &nbsp; &nbsp;&quot;[==] works (1)&quot;;
&nbsp; &nbsp; ok (not [==] 4, 5, 4), &nbsp; &nbsp;&quot;[==] works (2)&quot;;
&nbsp; &nbsp; ok ( &nbsp; &nbsp;[!=] 4, 5, 6), &nbsp; &nbsp;&quot;[!=] works (1)&quot;;
&nbsp; &nbsp; ok (not [!=] 4, 4, 4), &nbsp; &nbsp;&quot;[!=] works (2)&quot;;

&nbsp; &nbsp; # these all fail now, until produced chains are figured out and implemented
&nbsp; &nbsp; is ([~] [\&lt;] &nbsp;1, 2, 3, 4), &quot;1 1 1 1&quot;, &quot;[\\&lt;] works (1)&quot;, :todo&lt;unspecced&gt;;
&nbsp; &nbsp; is ([~] [\&lt;] &nbsp;1, 3, 2, 4), &quot;1 1 0 0&quot;, &quot;[\\&lt;] works (2)&quot;, :todo&lt;unspecced&gt;;
&nbsp; &nbsp; is ([~] [\&gt;] &nbsp;4, 3, 2, 1), &quot;1 1 1 1&quot;, &quot;[\\&gt;] works (1)&quot;, :todo&lt;unspecced&gt;;
&nbsp; &nbsp; is ([~] [\&gt;] &nbsp;4, 2, 3, 1), &quot;1 1 0 0&quot;, &quot;[\\&gt;] works (2)&quot;, :todo&lt;unspecced&gt;;
&nbsp; &nbsp; is ([~] [\==] &nbsp;4, 4, 4), &nbsp; &quot;1 1 1&quot;, &nbsp; &quot;[\\==] works (1)&quot;, :todo&lt;unspecced&gt;;
&nbsp; &nbsp; is ([~] [\==] &nbsp;4, 5, 4), &nbsp; &quot;1 0 0&quot;, &nbsp; &quot;[\\==] works (2)&quot;, :todo&lt;unspecced&gt;;
&nbsp; &nbsp; is ([~] [\!=] &nbsp;4, 5, 6), &nbsp; &quot;1 1 1&quot;, &nbsp; &quot;[\\!=] works (1)&quot;, :todo&lt;unspecced&gt;;
&nbsp; &nbsp; is ([~] [\!=] &nbsp;4, 5, 4), &nbsp; &quot;1 0 0&quot;, &nbsp; &quot;[\\!=] works (2)&quot;, :todo&lt;unspecced&gt;;
}

{
&nbsp; my @array = (undef, undef, 3, undef, 5);
&nbsp; is ([//] &nbsp;@array), 3, &quot;[//] works&quot;;
&nbsp; is ([err] @array), 3, &quot;[err] works&quot;;
}

{
&nbsp; my @array = (undef, undef, 0, 3, undef, 5);
&nbsp; is ([||] @array), 3, &quot;[||] works&quot;;
&nbsp; is ([or] @array), 3, &quot;[or] works&quot;;

&nbsp; # undefs as well as [//] should work too, but testing it like
&nbsp; # this would presumably emit warnings when we have them.
&nbsp; is (~ [\||] 0, 0, 3, 4, 5), &quot;0 0 3 3 3&quot;, &quot;[\\||] works&quot;;
}

{
&nbsp; my $hash = {a =&gt; {b =&gt; {c =&gt; {d =&gt; 42, e =&gt; 23}}}};
&nbsp; is try { [.{}] $hash, &lt;a b c d&gt; }, 42, '[.{}] works';
}

{
&nbsp; my $hash = {a =&gt; {b =&gt; 42}};
&nbsp; is ([.{}] $hash, &lt;a b&gt;), 42, '[.{}] works two levels deep';
}

{
&nbsp; my $arr = [[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]];
&nbsp; is ([.[]] $arr, 1, 0, 2), 9, '[.[]] works';
}

{
&nbsp; # 18:45 &lt; autrijus&gt; hm, I found a way to easily do linked list consing in Perl6
&nbsp; # 18:45 &lt; autrijus&gt; [=&gt;] 1..10;
&nbsp; my $list = [=&gt;] 1,2,3;
&nbsp; is $list.key, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1, &quot;[=&gt;] works (1)&quot;;
&nbsp; is try{$list.value.key}, &nbsp; 2, &quot;[=&gt;] works (2)&quot;;
&nbsp; is try{$list.value.value}, 3, &quot;[=&gt;] works (3)&quot;;
}

{
&nbsp; my @array = &lt;5 -3 7 0 1 -9&gt;;
&nbsp; is ([,] @array), @array, &quot;[,] works (a noop)&quot;;
}

# Following two tests taken verbatim from former t/operators/reduce.t
lives_ok({my @foo = [1..3] &gt;&gt;+&lt;&lt; [1..3] &gt;&gt;+&lt;&lt; [1..3]},'Sanity Check');
lives_ok({my @foo = [&gt;&gt;+&lt;&lt;] ([1..3],[1..3],[1..3])},'Parse [&gt;&gt;+&lt;&lt;]');

# Check that user defined infix ops work with [...], too.
sub infix:&lt;more_than_plus&gt;(Int $a, Int $b) { $a + $b + 1 }
is(try { [more_than_plus] 1, 2, 3 }, 8, &quot;[...] reduce metaop works on user defined ops&quot;, :todo&lt;bug&gt;);

{
&nbsp; my $arr = [ 42, [ 23 ] ];
&nbsp; $arr[1][1] = $arr;

&nbsp; is try { [.[]] $arr, 1, 1, 1, 1, 1, 0 }, 23, '[.[]] works with infinite data structures';
}

{
&nbsp; my $hash = {a =&gt; {b =&gt; 42}};
&nbsp; $hash&lt;a&gt;&lt;c&gt; = $hash;

&nbsp; is try { [.{}] $hash, &lt;a c a c a b&gt; }, 42, '[.{}] works with infinite data structures';
}</pre>
</div>


<p>The fourth metaoperator in Perl 6 is the reduction operator. Any infix operator (except for non-associating operators) can be surrounded by square brackets in term position to create a list operator that reduces using that operation:</p>

<pre>    [+] 1, 2, 3;      # 1 + 2 + 3 = 6
    my @a = (5,6);
    [*] @a;           # 5 * 6 = 30</pre>

<p>As with all the metaoperators, space is not allowed inside. The whole thing parses as a single token.</p>

<p>A reduction operator has the same precedence as a list operator. In fact, a reduction operator really is a list operator, and is invoked as one. Hence, you can implement a reduction operator in one of two ways. Either you can write an explicit list operator:</p>

<pre>    proto prefix:&#60;[+]&#62; (*@args) {
        my $accum = 0;
        while (@args) {
            $accum += @args.shift();
        }
        return $accum;
    }</pre>

<p>or you can let the system autogenerate one for you based on the corresponding infix operator, probably by currying:</p>

<pre>    # (examples, actual system may define prefix:[**] instead)
    &#38;prefix:&#60;[*]&#62; ::= &#38;reduce.assuming(&#38;infix:&#60;*&#62;, 1);
    &#38;prefix:&#60;[**]&#62; ::= &#38;reducerev.assuming(&#38;infix:&#60;**&#62;);</pre>

<p>As a special form of name, the non-prefix notation, as in</p>

<pre>    proto [foo] (*@args) {
        ...
    }</pre>

<p>or</p>

<pre>    &#38;[foo] ::= ...</pre>

<p>defines both the <code>[foo]</code> reduce operator and the <code>foo</code> infix operator. Where appropriate, use of the infix form may be optimized like this:</p>

<pre>    # Original          # Optimized
    $a foo $b           # [foo] $a, $b
    $a foo $b foo $c    # [foo] $a, $b, $c</pre>

<p>If the reduction operator is defined separately from the infix operator, it must associate the same way as the operator used:</p>

<pre>    [-] 4, 3, 2;      # 4-3-2 = (4-3)-2 = -1
    [**] 4, 3, 2;     # 4**3**2 = 4**(3**2) = 262144</pre>

<p>For list-associating operators (like <code>&#60;</code>), all arguments are taken together, just as if you had written it out explicitly:</p>

<pre>    [&#60;] 1, 3, 5;      # 1 &#60; 3 &#60; 5</pre>

<p>If fewer than two arguments are given, a dispatch is still attempted with whatever arguments are given, and it is up to the receiver of that dispatch to deal with fewer than two arguments. Note that the proto list operator definition is the most general, so you are allowed to define different ways to handle the one argument case depending on type:</p>

<pre>    multi prefix:&#60;[foo]&#62; (Int $x) { 42 }
    multi prefix:&#60;[foo]&#62; (Str $x) { fail &#34;Can&#39;t foo a single Str&#34; }</pre>

<p>However, the zero argument case cannot be defined this way, since there is no type information to dispatch on. Operators that wish to specify an identity value should do so by specifying a multi variant that takes zero arguments:</p>

<pre>    multi prefix:&#60;[foo]&#62; () { 0 }</pre>

<p>Among the builtin operators, <code>[+]()</code> returns 0 and <code>[*]()</code> returns 1, for instance.</p>

<a href="#" onclick="return tog_quote(9);">
<div ID="header_shown_9" style="display: none;">
- Hide the snippet from t/operators/reduce-metaop.t (line 126 ~ line 146) -
</div>
<div ID="header_hidden_9" style="display: block;">
- Show the snippet from t/operators/reduce-metaop.t (line 126 ~ line 146) -
</div>
</a>
<div ID="hide_9" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;Reduction operators&quot;/&quot;Among the builtin operators, [+]() returns 0 and [*]() returns 1&quot;&gt;

is( [*](), 1, &quot;[*]() returns 1&quot;);
is( [+](), 0, &quot;[+]() returns 0&quot;);

{
&nbsp; my ($a, $b);

&nbsp; ok ([=] $a, $b, 3), '[=] evaluates successfully', :todo&lt;feature&gt;;
&nbsp; is($a, 3, '[=] assigns successfully (1)', :todo&lt;feature&gt;);
&nbsp; is($b, 3, '[=] assigns successfully (2)', :todo&lt;feature&gt;);

&nbsp; ok try { ([=] $a, $b, 4) = 5 }, '[=] lvalue context restored (1)';
&nbsp; is($a, 5, '[=] lvalue context restored (2)', :todo&lt;feature&gt;);
&nbsp; is($b, 4, '[=] lvalue context restored (3)', :todo&lt;feature&gt;);

&nbsp; dies_ok { [=] &quot;this_is_a_constant&quot;, 42 },
&nbsp; &nbsp; &nbsp; &quot;[=] can't assign to constants (1)&quot;, :todo&lt;feature&gt;;
&nbsp; dies_ok { [=] $a, $b, &quot;this_is_a_constant&quot;, 42 },
&nbsp; &nbsp; &nbsp; &quot;[=] can't assign to constants (2)&quot;, :todo&lt;feature&gt;;
}</pre>
</div>


<p>By default, if there is one argument, the built-in reduce operators return that one argument. However, this default doesn&#39;t make sense for operators like <code>&#60;</code> that don&#39;t return the same type as they take, so these kinds of operators overload the single-argument case to return something more meaningful. All the comparison operators return a boolean for either 1 or 0 arguments. Negated operators return <code>Bool::False</code>, and all the rest return <code>Bool::True</code>.</p>

<p>You can also make a reduce operator of the comma operator. This is just the list operator form of the <code>circumfix:&#60;[ ]&#62;</code> anonymous array composer:</p>

<pre>    [1,2,3]     # make new Array: 1,2,3
    [,] 1,2,3   # same thing</pre>

<p>You may also reduce using the semicolon second-dimension separator:</p>

<pre>    [[;] 1,2,3]   # equivalent to [1;2;3]</pre>

<p>Builtin reduce operators return the following identity values:</p>

<a href="#" onclick="return tog_quote(7);">
<div ID="header_shown_7" style="display: none;">
- Hide the snippet from t/operators/reduce_le1arg.t (line 7 ~ line 60) -
</div>
<div ID="header_hidden_7" style="display: block;">
- Show the snippet from t/operators/reduce_le1arg.t (line 7 ~ line 60) -
</div>
</a>
<div ID="hide_7" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Reduction operators/&quot;Builtin reduce operators return the following identity values&quot;&gt;
# L&lt;S03/Reduction operators/&quot;[¥]() &nbsp; &nbsp; &nbsp; # []&quot;&gt;

is ([**] ()), 1, &quot;[**] () eq 1 (arguably nonsensical)&quot;;
is ([*] ()), 1, &quot;[*] () eq 1&quot;;
dies_ok( { [/] () }, &quot;[/] () should fail&quot;);
dies_ok( { [%] () }, &quot;[%] () should fail&quot;);
dies_ok( { [x] () }, &quot;[x] () should fail&quot;);
dies_ok( { [xx] () }, &quot;[xx] () should fail&quot;);
is ([+&amp;] ()), +^0, &quot;[+&amp;] () eq +^0&quot;;
dies_ok( { [+&lt;] () }, &quot;[+&lt;] () should fail&quot;);
dies_ok( { [+&gt;] () }, &quot;[+&gt;] () should fail&quot;);
dies_ok( { [~&amp;] () }, &quot;[~&amp;] () should fail&quot;);
dies_ok( { [~&lt;] () }, &quot;[~&lt;] () should fail&quot;);
dies_ok( { [~&gt;] () }, &quot;[~&gt;] () should fail&quot;);
is ([+] ()), 0, &quot;[+] () eq 0&quot;;
is ([-] ()), 0, &quot;[-] () eq 0&quot;;
is ([~] ()), '', &quot;[~] () eq ''&quot;;
is ([+|] ()), 0, &quot;[+|] () eq 0&quot;;
is ([+^] ()), 0, &quot;[+^] () eq 0&quot;;
is ([~|] ()), '', &quot;[~|] () eq ''&quot;;
is ([~^] ()), '', &quot;[~^] () eq ''&quot;;
is ([&amp;] ()).perl, all().perl, &quot;[&amp;] () eq all()&quot;;
is ([|] ()).perl, any().perl, &quot;[|] () eq any()&quot;;
is ([^] ()).perl, one().perl, &quot;[^] () eq one()&quot;;
is ([!==] ()), Bool::False, &quot;[!==] () eq False&quot;;
is ([==] ()), Bool::True, &quot;[==] () eq True&quot;;
is ([&lt;] ()), Bool::True, &quot;[&lt;] () eq True&quot;;
is ([&lt;=] ()), Bool::True, &quot;[&lt;=] () eq True&quot;;
is ([&gt;] ()), Bool::True, &quot;[&gt;] () eq True&quot;;
is ([&gt;=] ()), Bool::True, &quot;[&gt;=] () eq True&quot;;
is ([~~] ()), Bool::True, &quot;[~~] () eq True&quot;;
is ([!~~] ()), Bool::False, &quot;[!~~] () eq False&quot;;
is ([eq] ()), Bool::True, &quot;[eq] () eq True)&quot;;
is ([!eq] ()), Bool::False, &quot;[!eq] () eq False&quot;;
is ([lt] ()), Bool::True, &quot;[lt] () eq True&quot;;
is ([le] ()), Bool::True, &quot;[le] () eq True&quot;;
is ([gt] ()), Bool::True, &quot;[gt] () eq True&quot;;
is ([ge] ()), Bool::True, &quot;[ge] () eq True&quot;;
is ([=:=] ()), Bool::True, &quot;[=:=] () eq True&quot;;
is ([!=:=] ()), Bool::False, &quot;[!=:=] () eq False&quot;;
is ([===] ()), Bool::True, &quot;[===] () eq True&quot;;
is ([!===] ()), Bool::False, &quot;[!===] () eq False&quot;;
is ([eqv] ()), Bool::True, &quot;[eqv] () eq True&quot;;
is ([!eqv] ()), Bool::False, &quot;[!eqv] () eq False&quot;;
is ([&amp;&amp;] ()), Bool::True, &quot;[&amp;&amp;] () eq True&quot;;
is ([||] ()), Bool::False, &quot;[||] () eq False&quot;;
is ([^^] ()), Bool::False, &quot;[^^] () eq False&quot;;
is (defined ([//] ())), Bool::False, &quot;[//] () not defined&quot;;
is (defined ([=] ())), Bool::False, &quot;[=] () not defined&quot;;
is ([,] ()), (), &quot;[,] () eq ()&quot;;
is ([¥] ()), [], &quot;[¥] () eq []&quot;;

# need to add one elems list cases</pre>
</div>


<pre>    [**]()      # 1     (arguably nonsensical)
    [*]()       # 1
    [/]()       # fail  (reduce is nonsensical)
    [%]()       # fail  (reduce is nonsensical)
    [x]()       # fail  (reduce is nonsensical)
    [xx]()      # fail  (reduce is nonsensical)
    [+&#38;]()      # -1    (from +^0, the 2&#39;s complement in arbitrary precision)
    [+&#60;]()      # fail  (reduce is nonsensical)
    [+&#62;]()      # fail  (reduce is nonsensical)
    [~&#38;]()      # fail  (sensical but 1&#39;s length indeterminate)
    [~&#60;]()      # fail  (reduce is nonsensical)
    [~&#62;]()      # fail  (reduce is nonsensical)
    [+]()       # 0
    [-]()       # 0
    [~]()       # &#39;&#39;
    [+|]()      # 0
    [+^]()      # 0
    [~|]()      # &#39;&#39;    (length indeterminate but 0&#39;s default)
    [~^]()      # &#39;&#39;    (length indeterminate but 0&#39;s default)
    [&#38;]()       # all()
    [|]()       # any()
    [^]()       # one()
    [!==]()     # Bool::False   (also for 1 arg)
    [==]()      # Bool::True    (also for 1 arg)
    [&#60;]()       # Bool::True    (also for 1 arg)
    [&#60;=]()      # Bool::True    (also for 1 arg)
    [&#62;]()       # Bool::True    (also for 1 arg)
    [&#62;=]()      # Bool::True    (also for 1 arg)
    [~~]()      # Bool::True    (also for 1 arg)
    [!~~]()     # Bool::False   (also for 1 arg)
    [eq]()      # Bool::True    (also for 1 arg)
    [!eq]()     # Bool::False   (also for 1 arg)
    [lt]()      # Bool::True    (also for 1 arg)
    [le]()      # Bool::True    (also for 1 arg)
    [gt]()      # Bool::True    (also for 1 arg)
    [ge]()      # Bool::True    (also for 1 arg)
    [=:=]()     # Bool::True    (also for 1 arg)
    [!=:=]()    # Bool::False   (also for 1 arg)
    [===]()     # Bool::True    (also for 1 arg)
    [!===]()    # Bool::False   (also for 1 arg)
    [eqv]()     # Bool::True    (also for 1 arg)
    [!eqv]()    # Bool::False   (also for 1 arg)
    [&#38;&#38;]()      # Bool::True
    [||]()      # Bool::False
    [^^]()      # Bool::False
    [//]()      # undef
    [=]()       # undef    (same for all assignment operators)
    [,]()       # []
    [&#165;]()       # []</pre>

<a href="#" onclick="return tog_quote(8);">
<div ID="header_shown_8" style="display: none;">
- Hide the snippet from t/operators/reduce_le1arg.t (line 8 ~ line 60) -
</div>
<div ID="header_hidden_8" style="display: block;">
- Show the snippet from t/operators/reduce_le1arg.t (line 8 ~ line 60) -
</div>
</a>
<div ID="hide_8" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Reduction operators/&quot;[¥]() &nbsp; &nbsp; &nbsp; # []&quot;&gt;

is ([**] ()), 1, &quot;[**] () eq 1 (arguably nonsensical)&quot;;
is ([*] ()), 1, &quot;[*] () eq 1&quot;;
dies_ok( { [/] () }, &quot;[/] () should fail&quot;);
dies_ok( { [%] () }, &quot;[%] () should fail&quot;);
dies_ok( { [x] () }, &quot;[x] () should fail&quot;);
dies_ok( { [xx] () }, &quot;[xx] () should fail&quot;);
is ([+&amp;] ()), +^0, &quot;[+&amp;] () eq +^0&quot;;
dies_ok( { [+&lt;] () }, &quot;[+&lt;] () should fail&quot;);
dies_ok( { [+&gt;] () }, &quot;[+&gt;] () should fail&quot;);
dies_ok( { [~&amp;] () }, &quot;[~&amp;] () should fail&quot;);
dies_ok( { [~&lt;] () }, &quot;[~&lt;] () should fail&quot;);
dies_ok( { [~&gt;] () }, &quot;[~&gt;] () should fail&quot;);
is ([+] ()), 0, &quot;[+] () eq 0&quot;;
is ([-] ()), 0, &quot;[-] () eq 0&quot;;
is ([~] ()), '', &quot;[~] () eq ''&quot;;
is ([+|] ()), 0, &quot;[+|] () eq 0&quot;;
is ([+^] ()), 0, &quot;[+^] () eq 0&quot;;
is ([~|] ()), '', &quot;[~|] () eq ''&quot;;
is ([~^] ()), '', &quot;[~^] () eq ''&quot;;
is ([&amp;] ()).perl, all().perl, &quot;[&amp;] () eq all()&quot;;
is ([|] ()).perl, any().perl, &quot;[|] () eq any()&quot;;
is ([^] ()).perl, one().perl, &quot;[^] () eq one()&quot;;
is ([!==] ()), Bool::False, &quot;[!==] () eq False&quot;;
is ([==] ()), Bool::True, &quot;[==] () eq True&quot;;
is ([&lt;] ()), Bool::True, &quot;[&lt;] () eq True&quot;;
is ([&lt;=] ()), Bool::True, &quot;[&lt;=] () eq True&quot;;
is ([&gt;] ()), Bool::True, &quot;[&gt;] () eq True&quot;;
is ([&gt;=] ()), Bool::True, &quot;[&gt;=] () eq True&quot;;
is ([~~] ()), Bool::True, &quot;[~~] () eq True&quot;;
is ([!~~] ()), Bool::False, &quot;[!~~] () eq False&quot;;
is ([eq] ()), Bool::True, &quot;[eq] () eq True)&quot;;
is ([!eq] ()), Bool::False, &quot;[!eq] () eq False&quot;;
is ([lt] ()), Bool::True, &quot;[lt] () eq True&quot;;
is ([le] ()), Bool::True, &quot;[le] () eq True&quot;;
is ([gt] ()), Bool::True, &quot;[gt] () eq True&quot;;
is ([ge] ()), Bool::True, &quot;[ge] () eq True&quot;;
is ([=:=] ()), Bool::True, &quot;[=:=] () eq True&quot;;
is ([!=:=] ()), Bool::False, &quot;[!=:=] () eq False&quot;;
is ([===] ()), Bool::True, &quot;[===] () eq True&quot;;
is ([!===] ()), Bool::False, &quot;[!===] () eq False&quot;;
is ([eqv] ()), Bool::True, &quot;[eqv] () eq True&quot;;
is ([!eqv] ()), Bool::False, &quot;[!eqv] () eq False&quot;;
is ([&amp;&amp;] ()), Bool::True, &quot;[&amp;&amp;] () eq True&quot;;
is ([||] ()), Bool::False, &quot;[||] () eq False&quot;;
is ([^^] ()), Bool::False, &quot;[^^] () eq False&quot;;
is (defined ([//] ())), Bool::False, &quot;[//] () not defined&quot;;
is (defined ([=] ())), Bool::False, &quot;[=] () not defined&quot;;
is ([,] ()), (), &quot;[,] () eq ()&quot;;
is ([¥] ()), [], &quot;[¥] () eq []&quot;;

# need to add one elems list cases</pre>
</div>


<p>User-defined operators may define their own identity values, but there is no explicit identity property. The value is implicit in the behavior of the 0-arg reduce, so mathematical code wishing to find the identity value for an operation can call <code>prefix:{&#34;[$opname]&#34;}()</code> to discover it.</p>

<p>To call some other non-infix function as a reduce operator, you may define an alias in infix form. The infix form will parse the right argument as a scalar even if the aliased function would have parsed it as a list:</p>

<pre>    &#38;infix:&#60;dehash&#62; ::= postcircumfix:&#60;{ }&#62;;
    $x = [dehash] $a,&#39;foo&#39;,&#39;bar&#39;;  # $a&#60;foo&#62;&#60;bar&#62;, not $a&#60;foo bar&#62;</pre>

<p>Alternately, just define your own <code>prefix:&#60;[dehash]&#62;</code> routine.</p>

<p>Note that, because a reduce is a list operator, the argument list is evaluated in list context. Therefore the following would be incorrect:</p>

<pre>    $x = [dehash] %a,&#39;foo&#39;,&#39;bar&#39;;</pre>

<p>You&#39;d instead have to say one of:</p>

<pre>    $x = [dehash] \%a,&#39;foo&#39;,&#39;bar&#39;;
    $x = [dehash] %a&#60;foo&#62;,&#39;bar&#39;;</pre>

<p>On the plus side, this works without a star:</p>

<pre>    @args = (\%a,&#39;foo&#39;,&#39;bar&#39;);
    $x = [dehash] @args;</pre>

<p>Likewise, from the fact that list context flattens inner arrays and lists, it follows that a reduced assignment does no special syntactic dwimmery, and hence only scalar assignments are supported. Therefore</p>

<pre>    [=] $x, @y, $z, 0
    [+=] $x, @y, $z, 1</pre>

<p>are equivalent to</p>

<pre>    $x = @y[0] = @y[1] = @y[2] ... @y[-1] = $z = 0
    $x += @y[0] += @y[1] += @y[2] ... @y[-1] += $z += 1</pre>

<p>rather than</p>

<pre>    $x = @y = $z = 0;
    $x += @y += $z += 1;</pre>

<p>(And, in fact, the latter are already easy to express anyway, and more obviously nonsensical.)</p>

<p>A reduce operator returns only a scalar result regardless of context. To return all intermediate results, backslash the operator:</p>

<pre>    say [\+] 1..*  #  (1, 3, 6, 10, 15, ...)</pre>

<p>The visual picture of a triangle is not accidental. To produce a triangular list of lists, you can use a &#34;triangular comma&#34;:</p>

<pre>    [\,] 1..5
    [1],
    [1,2],
    [1,2,3],
    [1,2,3,4],
    [1,2,3,4,5]</pre>

<p>If there is ambiguity between a triangular reduce and an infix operator beginning with backslash, the infix operator is chosen, and an extra backslash indicates the corresponding triangular reduce. As a consequence, defining an infix operator beginning with backslash, <code>infix:&#60;\x&#62;</code> say, will make it impossible to write certain triangular reduction operators, since <code>[\x]</code> would mean the normal reduction of <code>infix:&#60;\x&#62;</code> operator, not the triangular reduction of <code>infix:&#60;x&#62;</code>. This is deemed to be an insignificant problem.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Cross_operators"
>Cross operators</a></h1>

<p>The final metaoperator is the cross metaoperator. It is formed syntactically by placing an infix operator between two <code>X</code> characters. It applies the modified operator across all permutations of its list arguments. All cross operators are of list infix precedence, and are list associative.</p>

<a href="#" onclick="return tog_quote(6);">
<div ID="header_shown_6" style="display: none;">
- Hide the snippet from t/operators/cross-metaop.t (line 6 ~ line 8) -
</div>
<div ID="header_hidden_6" style="display: block;">
- Show the snippet from t/operators/cross-metaop.t (line 6 ~ line 8) -
</div>
</a>
<div ID="hide_6" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Cross operators/formed syntactically by placing&gt;
ok eval('&lt;a b&gt; X,X &lt;c d&gt;'), 'cross metaoperator parses', :todo&lt;feature&gt;;</pre>
</div>


<p>The string concatenating form is:</p>

<a href="#" onclick="return tog_quote(5);">
<div ID="header_shown_5" style="display: none;">
- Hide the snippet from t/operators/cross-metaop.t (line 9 ~ line 12) -
</div>
<div ID="header_hidden_5" style="display: block;">
- Show the snippet from t/operators/cross-metaop.t (line 9 ~ line 12) -
</div>
</a>
<div ID="hide_5" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Cross operators/&quot;string concatenating form is&quot;&gt;
is eval('&lt;a b&gt; X~X &lt;1 2&gt;'), &lt;a1 a2 b1 b2&gt;,
&nbsp; &nbsp; 'cross-concat produces expected result', :todo&lt;feature&gt;;</pre>
</div>


<pre>    &#60;a b&#62; X~X &#60;1 2&#62;           #  &#39;a1&#39;, &#39;a2&#39;, &#39;b1&#39;, &#39;b2&#39;</pre>

<p>The <code>X~X</code> operator desugars to something like:</p>

<a href="#" onclick="return tog_quote(4);">
<div ID="header_shown_4" style="display: none;">
- Hide the snippet from t/operators/cross-metaop.t (line 13 ~ line 16) -
</div>
<div ID="header_hidden_4" style="display: block;">
- Show the snippet from t/operators/cross-metaop.t (line 13 ~ line 16) -
</div>
</a>
<div ID="hide_4" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Cross operators/desugars to something like&gt;
is eval('[~]«( &lt;a b&gt; X,X &lt;1 2&gt; )'), &lt;a1 a2 b1 b2&gt;,
&nbsp; &nbsp; 'X,X works with hyperconcat', :todo&lt;feature&gt;;</pre>
</div>


<pre>    [~]&#171;( &#60;a b&#62; X,X &#60;1 2&#62; )  #  &#39;a1&#39;, &#39;a2&#39;, &#39;b1&#39;, &#39;b2&#39;</pre>

<p>The list concatenating form, <code>X,X</code>, when used like this:</p>

<a href="#" onclick="return tog_quote(3);">
<div ID="header_shown_3" style="display: none;">
- Hide the snippet from t/operators/cross-metaop.t (line 17 ~ line 33) -
</div>
<div ID="header_hidden_3" style="display: block;">
- Show the snippet from t/operators/cross-metaop.t (line 17 ~ line 33) -
</div>
</a>
<div ID="hide_3" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Cross operators/list concatenating form when used like this&gt;
my @result = eval '&lt;a b&gt; X,X 1,2 X,X &lt;x y&gt;';
is @result.elems, 8, 'chained cross-comma produces correct number of elements',
&nbsp; &nbsp; :todo&lt;feature&gt;;
my @expected = (
&nbsp; &nbsp; ['a', 1, 'x'],
&nbsp; &nbsp; ['a', 1, 'y'],
&nbsp; &nbsp; ['a', 2, 'x'],
&nbsp; &nbsp; ['a', 2, 'y'],
&nbsp; &nbsp; ['b', 1, 'x'],
&nbsp; &nbsp; ['b', 1, 'y'],
&nbsp; &nbsp; ['b', 2, 'x'],
&nbsp; &nbsp; ['b', 2, 'y'],
);
is @result, @expected,
&nbsp; &nbsp; 'chained cross-comma produces correct results', :todo&lt;feature&gt;;</pre>
</div>


<pre>    &#60;a b&#62; X,X 1,2 X,X &#60;x y&#62;</pre>

<p>produces</p>

<pre>    [&#39;a&#39;, 1, &#39;x&#39;],
    [&#39;a&#39;, 1, &#39;y&#39;],
    [&#39;a&#39;, 2, &#39;x&#39;],
    [&#39;a&#39;, 2, &#39;y&#39;],
    [&#39;b&#39;, 1, &#39;x&#39;],
    [&#39;b&#39;, 1, &#39;y&#39;],
    [&#39;b&#39;, 2, &#39;x&#39;],
    [&#39;b&#39;, 2, &#39;y&#39;]</pre>

<p>The string and list forms are common enough to have shortcuts, <code>X</code> and <code>XX</code> respectively. See below.</p>

<p>For the general form, any existing, non-mutating infix operator may be used.</p>

<a href="#" onclick="return tog_quote(2);">
<div ID="header_shown_2" style="display: none;">
- Hide the snippet from t/operators/cross-metaop.t (line 34 ~ line 36) -
</div>
<div ID="header_hidden_2" style="display: block;">
- Show the snippet from t/operators/cross-metaop.t (line 34 ~ line 36) -
</div>
</a>
<div ID="hide_2" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Cross operators/any existing non-mutating infix operator&gt;
is eval('(1,2 X*X 3,4)'), (3,4,6,8), 'cross-product works', :todo&lt;feature&gt;;</pre>
</div>


<pre>    1,2 X*X 3,4               # 3,4,6,8</pre>

<p>(Note that <code>&#60;==</code> and <code>==&#62;</code> are considered mutating, as well as all assignment operators.)</p>

<p>If the underlying operator is non-associating, so is the metaoperator:</p>

<a href="#" onclick="return tog_quote(1);">
<div ID="header_shown_1" style="display: none;">
- Hide the snippet from t/operators/cross-metaop.t (line 37 ~ line 39) -
</div>
<div ID="header_hidden_1" style="display: block;">
- Show the snippet from t/operators/cross-metaop.t (line 37 ~ line 39) -
</div>
</a>
<div ID="hide_1" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Cross operators/underlying operator non-associating&gt;
dies_ok '@result XcmpX @expected XcmpX &lt;1 2&gt;',
&nbsp; &nbsp; 'non-associating ops cannot be cross-ops';</pre>
</div>


<pre>    @a XcmpX @b XcmpX @c       # ILLEGAL
    @a XeqX @b XeqX @c         # ok</pre>

<p>In fact, though the <code>X</code> operators are all list associative syntactically, the underlying operator is always applied with its own associativity, just as the corresponding reduce operator would do.</p>

<p>Note that only the first term of an <code>X</code> operator may reasonably be an infinite list.</p>

<p>Multidimensional lists should be handled properly.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Junctive_operators"
>Junctive operators</a></h1>

<a href="#" onclick="return tog_quote(73);">
<div ID="header_shown_73" style="display: none;">
- Hide the snippet from t/junction/associative.t (line 12 ~ line 39) -
</div>
<div ID="header_hidden_73" style="display: block;">
- Show the snippet from t/junction/associative.t (line 12 ~ line 39) -
</div>
</a>
<div ID="hide_73" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S03/&quot;Junctive operators&quot;&gt;

=cut

{ # L&lt;S09/&quot;Junctions&quot;&gt;

&nbsp; &nbsp; is('1 2 3', ~((1|2)|3).values, &quot;Left-associative any, | operator&quot;);
&nbsp; &nbsp; is('1 2 3', ~(1|(2|3)).values, &quot;Right-associative any, | operator&quot;);

&nbsp; &nbsp; is('1 2 3', ~any(any(1,2),3).values, &quot;Left-associative any()&quot;);
&nbsp; &nbsp; is('1 2 3', ~any(1,any(2,3)).values, &quot;Right-associative any()&quot;);

&nbsp; &nbsp; is('1 2 3', ~((1&amp;2)&amp;3).values, &quot;Left-associative all, &amp; operator&quot;);
&nbsp; &nbsp; is('1 2 3', ~(1&amp;(2&amp;3)).values, &quot;Right-associative all, &amp; operator&quot;);

&nbsp; &nbsp; is('1 2 3', ~all(all(1,2),3).values, &quot;Left-associative all()&quot;);
&nbsp; &nbsp; is('1 2 3', ~all(1,all(2,3)).values, &quot;Right-associative all()&quot;);

&nbsp; &nbsp; isnt('1 2 3', ~((1^2)^3).values, &quot;Left-associative one, ^ operator&quot;);
&nbsp; &nbsp; isnt('1 2 3', ~(1^(2^3)).values, &quot;Right-associative one, ^ operator&quot;);

&nbsp; &nbsp; isnt('1 2 3', ~one(one(1,2),3).values, &quot;Left-associative one()&quot;);
&nbsp; &nbsp; isnt('1 2 3', ~one(1,one(2,3)).values, &quot;Right-associative one()&quot;);

&nbsp; &nbsp; is('1 2 3', ~none(none(1,2),3).values, &quot;Left-associative none()&quot;);
&nbsp; &nbsp; is('1 2 3', ~none(1,none(2,3)).values, &quot;Right-associative none()&quot;);

}</pre>
</div>


<a href="#" onclick="return tog_quote(72);">
<div ID="header_shown_72" style="display: none;">
- Hide the snippet from t/junction/misc_junctions.t (line 13 ~ line 144) -
</div>
<div ID="header_hidden_72" style="display: block;">
- Show the snippet from t/junction/misc_junctions.t (line 13 ~ line 144) -
</div>
</a>
<div ID="hide_72" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S03/&quot;Junctive operators&quot;&gt;

=cut

{ # L&lt;S09/&quot;Junctions&quot;&gt;

&nbsp; &nbsp; # initalize them all to empty strings
&nbsp; &nbsp; my $a = '';
&nbsp; &nbsp; my $b = '';
&nbsp; &nbsp; my $c = '';
&nbsp; &nbsp; 
&nbsp; &nbsp; # make sure they all match to an empty string
&nbsp; &nbsp; ok('' eq ($a &amp; $b &amp; $c), 'junction of ($a &amp; $b &amp; $c) matches and empty string');
&nbsp; &nbsp; ok('' eq all($a, $b, $c), 'junction of all($a, $b, $c) matches and empty string'); &nbsp; 
&nbsp; &nbsp; 
&nbsp; &nbsp; # give $a a value
&nbsp; &nbsp; $a = 'a'; &nbsp;
&nbsp; &nbsp; 
&nbsp; &nbsp; # make sure that at least one of them matches 'a' 
&nbsp; &nbsp; ok('a' eq ($b | $c | $a), 'junction of ($b | $c | $a) matches at least one &quot;a&quot;');
&nbsp; &nbsp; ok('a' eq any($b, $c, $a), 'junction of any($b, $c, $a) matches at least one &quot;a&quot;'); &nbsp; 

&nbsp; &nbsp; ok('' eq ($b | $c | $a), 'junction of ($b | $c | $a) matches at least one empty string');
&nbsp; &nbsp; ok('' eq any($b, $c, $a), 'junction of any($b, $c, $a) matches at least one empty string');
&nbsp; &nbsp; 
&nbsp; &nbsp; # make sure that ~only~ one of them matches 'a'
&nbsp; &nbsp; ok('a' eq ($b ^ $c ^ $a), 'junction of ($b ^ $c ^ $a) matches at ~only~ one &quot;a&quot;');
&nbsp; &nbsp; ok('a' eq one($b, $c, $a), 'junction of one($b, $c, $a) matches at ~only~ one &quot;a&quot;');
&nbsp; &nbsp; 
&nbsp; &nbsp; # give $b a value
&nbsp; &nbsp; $b = 'a';
&nbsp; &nbsp; 
&nbsp; &nbsp; # now this will fail
&nbsp; &nbsp; ok('a' ne ($b ^ $c ^ $a), 'junction of ($b ^ $c ^ $a) matches at more than one &quot;a&quot;'); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;

&nbsp; &nbsp; # change $b and give $c a value
&nbsp; &nbsp; $b = 'b';
&nbsp; &nbsp; $c = 'c';
&nbsp; &nbsp; 
&nbsp; &nbsp; ok('a' eq ($b ^ $c ^ $a), 'junction of ($b ^ $c ^ $a) matches at ~only~ one &quot;a&quot;');
&nbsp; &nbsp; ok('b' eq ($a ^ $b ^ $c), 'junction of ($a ^ $b ^ $c) matches at ~only~ one &quot;b&quot;');
&nbsp; &nbsp; ok('c' eq ($c ^ $a ^ $b), 'junction of ($c ^ $a ^ $b) matches at ~only~ one &quot;c&quot;'); &nbsp;

&nbsp; &nbsp; ok('a' eq ($b | $c | $a), 'junction of ($b | $c | $a) matches at least one &quot;a&quot;');
&nbsp; &nbsp; ok('b' eq ($a | $b | $c), 'junction of ($a | $b | $c) matches at least one &quot;b&quot;');
&nbsp; &nbsp; ok('c' eq ($c | $a | $b), 'junction of ($c | $a | $b) matches at least one &quot;c&quot;'); 
&nbsp; &nbsp; 
&nbsp; &nbsp; # test junction to junction
&nbsp; &nbsp; 
&nbsp; &nbsp; ok(('a' | 'b' | 'c') eq ($a &amp; $b &amp; $c), 'junction (&quot;a&quot; | &quot;b&quot; | &quot;c&quot;) matches junction ($a &amp; $b &amp; $c)'); &nbsp; &nbsp;
&nbsp; &nbsp; ok(('a' &amp; 'b' &amp; 'c') eq ($a | $b | $c), 'junction (&quot;a&quot; &amp; &quot;b&quot; &amp; &quot;c&quot;) matches junction ($a | $b | $c)'); 
&nbsp; &nbsp; 
&nbsp; &nbsp; # mix around variables and literals
&nbsp; &nbsp; 
&nbsp; &nbsp; ok(($a &amp; 'b' &amp; 'c') eq ('a' | $b | $c), 'junction ($a &amp; &quot;b&quot; &amp; &quot;c&quot;) matches junction (&quot;a&quot; | $b | $c)'); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; ok(($a &amp; 'b' &amp; $c) eq ('a' | $b | 'c'), 'junction ($a &amp; &quot;b&quot; &amp; $c) matches junction (&quot;a&quot; | $b | &quot;c&quot;)'); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; 
}

# same tests, but with junctions as variables
{
&nbsp; &nbsp; &nbsp; &nbsp; # initalize them all to empty strings
&nbsp; &nbsp; my $a = '';
&nbsp; &nbsp; my $b = '';
&nbsp; &nbsp; my $c = '';
&nbsp; &nbsp; 
&nbsp; &nbsp; my $all_of_them = $a &amp; $b &amp; $c;
&nbsp; &nbsp; ok('' eq $all_of_them, 'junction variable of ($a &amp; $b &amp; $c) matches and empty string');
&nbsp; &nbsp; 
&nbsp; &nbsp; $a = 'a'; &nbsp;
&nbsp; &nbsp; 
&nbsp; &nbsp; my $any_of_them = $b | $c | $a;
&nbsp; &nbsp; ok('a' eq $any_of_them, 'junction variable of ($b | $c | $a) matches at least one &quot;a&quot;'); &nbsp;
&nbsp; &nbsp; ok('' eq $any_of_them, 'junction variable of ($b | $c | $a) matches at least one empty string');
&nbsp; &nbsp; 
&nbsp; &nbsp; my $one_of_them = $b ^ $c ^ $a;
&nbsp; &nbsp; ok('a' eq $one_of_them, 'junction variable of ($b ^ $c ^ $a) matches at ~only~ one &quot;a&quot;');
&nbsp; &nbsp; 
&nbsp; &nbsp; $b = 'a';
&nbsp; &nbsp; 
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; my $one_of_them = $b ^ $c ^ $a;
&nbsp; &nbsp; &nbsp; &nbsp; ok('a' ne $one_of_them, 'junction variable of ($b ^ $c ^ $a) matches at more than one &quot;a&quot;'); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; }
&nbsp; &nbsp; 
&nbsp; &nbsp; $b = 'b';
&nbsp; &nbsp; $c = 'c';
&nbsp; &nbsp; 
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; my $one_of_them = $b ^ $c ^ $a; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; ok('a' eq $one_of_them, 'junction of ($b ^ $c ^ $a) matches at ~only~ one &quot;a&quot;');
&nbsp; &nbsp; &nbsp; &nbsp; ok('b' eq $one_of_them, 'junction of ($a ^ $b ^ $c) matches at ~only~ one &quot;b&quot;');
&nbsp; &nbsp; &nbsp; &nbsp; ok('c' eq $one_of_them, 'junction of ($c ^ $a ^ $b) matches at ~only~ one &quot;c&quot;'); &nbsp;
&nbsp; &nbsp; }

&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; my $any_of_them = $b | $c | $a;
&nbsp; &nbsp; &nbsp; &nbsp; ok('a' eq $any_of_them, 'junction of ($b | $c | $a) matches at least one &quot;a&quot;');
&nbsp; &nbsp; &nbsp; &nbsp; ok('b' eq $any_of_them, 'junction of ($a | $b | $c) matches at least one &quot;b&quot;');
&nbsp; &nbsp; &nbsp; &nbsp; ok('c' eq $any_of_them, 'junction of ($c | $a | $b) matches at least one &quot;c&quot;'); 
&nbsp; &nbsp; }

}

{
&nbsp; &nbsp; my $j = 1 | 2;
&nbsp; &nbsp; $j = 5;
&nbsp; &nbsp; is($j, 5, 'reassignment of junction variable');
}

{
&nbsp; &nbsp; my ($j,$k,$l);

&nbsp; &nbsp; $j = 1|2;
&nbsp; &nbsp; is(WHAT($j),'Junction', 'basic junction type reference test');

&nbsp; &nbsp; $k=$j;
&nbsp; &nbsp; is(WHAT($k),'Junction', 'assignment preserves reference');

&nbsp; &nbsp; # XXX does this next one make any sense?
&nbsp; &nbsp; $l=\$j;
&nbsp; &nbsp; is(WHAT($l),'Junction', 'hard reference to junction');
}


=pod

Tests junction examples from Synopsis 03 

j() is used to convert a junction to canonical string form, currently
just using .perl until a better approach presents itself.</pre>
</div>


<a href="#" onclick="return tog_quote(71);">
<div ID="header_shown_71" style="display: none;">
- Hide the snippet from t/junction/misc_junctions.t (line 145 ~ line 152) -
</div>
<div ID="header_hidden_71" style="display: block;">
- Show the snippet from t/junction/misc_junctions.t (line 145 ~ line 152) -
</div>
</a>
<div ID="hide_71" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S03/&quot;Junctive operators&quot;&gt;

=cut

# Canonical stringification of a junction
sub j (Junction $j) { return $j.perl }

{</pre>
</div>


<p><code>|</code>, <code>&#38;</code>, and <code>^</code> are no longer bitwise operators (see <a href="#Changes_to_Perl_5_operators" class="podlinkpod"
>&#34;Changes to Perl 5 operators&#34;</a>) but now serve a much higher cause: they are now the junction constructors.</p>

<p>A junction is a single value that is equivalent to multiple values. They thread through operations, returning another junction representing the result:</p>

<a href="#" onclick="return tog_quote(70);">
<div ID="header_shown_70" style="display: none;">
- Hide the snippet from t/junction/misc_junctions.t (line 153 ~ line 162) -
</div>
<div ID="header_hidden_70" style="display: block;">
- Show the snippet from t/junction/misc_junctions.t (line 153 ~ line 162) -
</div>
</a>
<div ID="hide_70" style="display:none; border:1px solid">
<pre style="margin-left: 6px">&nbsp; &nbsp; # L&lt;S03/&quot;Junctive operators&quot; /They thread through operations/&gt;
&nbsp; &nbsp; my ($got, $want);
&nbsp; &nbsp; $got = ((1|2|3)+4);
&nbsp; &nbsp; $want = (5|6|7);
&nbsp; &nbsp; is( j($got), j($want), 'thread + returning junctive result');

&nbsp; &nbsp; $got = ((1|2) + (3&amp;4));
&nbsp; &nbsp; $want = ((4|5) &amp; (5|6));
&nbsp; &nbsp; is( j($got), j($want), 'thread + returning junctive combination of results');</pre>
</div>


<a href="#" onclick="return tog_quote(66);">
<div ID="header_shown_66" style="display: none;">
- Hide the snippet from t/junction/misc_junctions.t (line 215 ~ line 286) -
</div>
<div ID="header_hidden_66" style="display: block;">
- Show the snippet from t/junction/misc_junctions.t (line 215 ~ line 286) -
</div>
</a>
<div ID="hide_66" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S03/&quot;Junctive operators&quot; /They thread through operations/&gt;

On Fri, 2005-02-11 at 10:46 +1100, Damian Conway wrote:
&gt; Subject: Re: Fwd: Junctive puzzles.
&gt;
&gt; Junctions have an associated boolean predicate that's preserved across 
&gt; operations on the junction. Junctions also implicitly distribute across 
&gt; operations, and rejunctify the results.

=cut

{
&nbsp; &nbsp; my @subs = (sub {3}, sub {2});

&nbsp; &nbsp; my ($got, $want);

&nbsp; &nbsp; is(j(any(@subs)()), j(3|2), '.() on any() junction of subs');

&nbsp; &nbsp; $want = (3&amp;2);
&nbsp; &nbsp; $got = all(@subs)();
&nbsp; &nbsp; is(j($got), j($want), '.() on all() junction of subs');

&nbsp; &nbsp; $want = (3^2);
&nbsp; &nbsp; $got = one(@subs)();
&nbsp; &nbsp; is(j($got), j($want), '.() on one() junction of subs');

&nbsp; &nbsp; $want = none(3,2);
&nbsp; &nbsp; $got = none(@subs)();
&nbsp; &nbsp; is(j($got), j($want), '.() on none() junction of subs');

&nbsp; &nbsp; $want = one( any(3,2), all(3,2) );
&nbsp; &nbsp; $got = one( any(@subs), all(@subs) )();
&nbsp; &nbsp; is(j($got), j($want), '.() on complex junction of subs');

&nbsp; &nbsp; # Avoid future constant folding
&nbsp; &nbsp; #my $rand = rand;
&nbsp; &nbsp; #my $zero = int($rand-$rand);
&nbsp; &nbsp; #my @subs = (sub {3+$zero}, sub {2+$zero});
}

# Check functional and operator versions produce the same structure
{
&nbsp; &nbsp; is(j((1|2)^(3&amp;4)), j(one(any(1,2),all(3,4))),
&nbsp; &nbsp; &nbsp; &nbsp; '((1|2)^(3&amp;4)) equiv to one(any(1,2),all(3,4))');

&nbsp; &nbsp; is(j((1|2)&amp;(3&amp;4)), j(all(any(1,2),all(3,4))), 
&nbsp; &nbsp; &nbsp; &nbsp; '((1|2)&amp;(3&amp;4)) equiv to all(any(1,2),all(3,4))');

&nbsp; &nbsp; is(j((1|2)|(3&amp;4)), j(any(any(1,2),all(3,4))),
&nbsp; &nbsp; &nbsp; &nbsp; '((1|2)|(3&amp;4)) equiv to any(any(1,2),all(3,4))');
}

is(none(1).pick, undef, 'none(1).pick should be undef');
is(none(1,1).pick, undef, 'none(1,1).pick should be undef');

is(one(1).pick, 1, 'one(1).pick should be 1');
is(one(1,1).pick, undef, 'one(1,1).pick should be undef');

is(all(1).pick, 1, 'all(1).pick should be 1');
is(all(1,1).pick, 1, 'all(1,1).pick should be 1');
is(all(1,2).pick, undef, 'all(1,2).pick should be undef');

# junction in boolean context
ok(?(0&amp;0) == ?(0&amp;&amp;0), 'boolean context');
ok(?(0&amp;1) == ?(0&amp;&amp;1), 'boolean context');
ok(?(1&amp;1) == ?(1&amp;&amp;1), 'boolean context');
ok(?(1&amp;0) == ?(1&amp;&amp;0), 'boolean context');
ok(!(?(0&amp;0) != ?(0&amp;&amp;0)), 'boolean context');
ok(!(?(0&amp;1) != ?(0&amp;&amp;1)), 'boolean context');
ok(!(?(1&amp;1) != ?(1&amp;&amp;1)), 'boolean context');
ok(!(?(1&amp;0) != ?(1&amp;&amp;0)), 'boolean context');</pre>
</div>


<pre>     (1|2|3) + 4;                            # 5|6|7
     (1|2) + (3&#38;4);                          # (4|5) &#38; (5|6)</pre>

<p>Note how when two junctions are applied through an operator, the result is a junction representing the operator applied to each combination of values.</p>

<p>Junctions come with the functional variants <code>any</code>, <code>all</code>, <code>one</code>, and <code>none</code>.</p>

<p>This opens doors for constructions like:</p>

<a href="#" onclick="return tog_quote(69);">
<div ID="header_shown_69" style="display: none;">
- Hide the snippet from t/junction/misc_junctions.t (line 163 ~ line 183) -
</div>
<div ID="header_hidden_69" style="display: block;">
- Show the snippet from t/junction/misc_junctions.t (line 163 ~ line 183) -
</div>
</a>
<div ID="hide_69" style="display:none; border:1px solid">
<pre style="margin-left: 6px">&nbsp; &nbsp; # L&lt;S03/&quot;Junctive operators&quot; /This opens doors for constructions like/&gt;
&nbsp; &nbsp; # unless $roll == any(1..6) { print &quot;Invalid roll&quot; }
&nbsp; &nbsp; my ($roll, $note);
&nbsp; &nbsp; $roll = 3; $note = '';
&nbsp; &nbsp; unless $roll == any(1..6) { $note = &quot;Invalid roll&quot;; };
&nbsp; &nbsp; is($note, &quot;&quot;, 'any() junction threading ==');

&nbsp; &nbsp; $roll = 7; $note = '';
&nbsp; &nbsp; unless $roll == any(1..6) { $note = &quot;Invalid roll&quot;; };
&nbsp; &nbsp; is($note, &quot;Invalid roll&quot;, 'any() junction threading ==');

&nbsp; &nbsp; # if $roll == 1|2|3 { print &quot;Low roll&quot; }
&nbsp; &nbsp; $roll = 4; $note = '';
&nbsp; &nbsp; if $roll == 1|2|3 { $note = &quot;Low roll&quot; }
&nbsp; &nbsp; is($note, &quot;&quot;, '| junction threading ==');

&nbsp; &nbsp; $roll = 2; $note = '';
&nbsp; &nbsp; if $roll == 1|2|3 { $note = &quot;Low roll&quot; }
&nbsp; &nbsp; is($note, &quot;Low roll&quot;, '| junction threading ==');</pre>
</div>


<pre>     unless $roll == any(1..6) { print &#34;Invalid roll&#34; }

     if $roll == 1|2|3 { print &#34;Low roll&#34; }</pre>

<p>Junctions work through subscripting:</p>

<a href="#" onclick="return tog_quote(68);">
<div ID="header_shown_68" style="display: none;">
- Hide the snippet from t/junction/misc_junctions.t (line 184 ~ line 198) -
</div>
<div ID="header_hidden_68" style="display: block;">
- Show the snippet from t/junction/misc_junctions.t (line 184 ~ line 198) -
</div>
</a>
<div ID="hide_68" style="display:none; border:1px solid">
<pre style="margin-left: 6px">&nbsp; &nbsp; # L&lt;S03/&quot;Junctive operators&quot; /Junctions work through subscripting/&gt;
&nbsp; &nbsp; my ($got, @foo);
&nbsp; &nbsp; $got = ''; @foo = ();
&nbsp; &nbsp; $got ~= 'y' if try { @foo[any(1,2,3)] };
&nbsp; &nbsp; is($got, '', &quot;junctions work through subscripting, 0 matches&quot;);

&nbsp; &nbsp; $got = ''; @foo = (0,1);
&nbsp; &nbsp; $got ~= 'y' if try { @foo[any(1,2,3)] };
&nbsp; &nbsp; is($got, '', &quot;junctions work through subscripting, 1 match&quot;);

&nbsp; &nbsp; $got = ''; @foo = (1,1,1);
&nbsp; &nbsp; $got ~= 'y' if try { @foo[any(1,2,3)] };
&nbsp; &nbsp; is($got, '', &quot;junctions work through subscripting, 3 matches&quot;);</pre>
</div>


<pre>    print if @foo[any(1,2,3)]</pre>

<p>Junctions are specifically unordered. So if you say</p>

<a href="#" onclick="return tog_quote(67);">
<div ID="header_shown_67" style="display: none;">
- Hide the snippet from t/junction/misc_junctions.t (line 199 ~ line 214) -
</div>
<div ID="header_hidden_67" style="display: block;">
- Show the snippet from t/junction/misc_junctions.t (line 199 ~ line 214) -
</div>
</a>
<div ID="hide_67" style="display:none; border:1px solid">
<pre style="margin-left: 6px">&nbsp; &nbsp; # L&lt;S03/&quot;Junctive operators&quot; /Junctions are specifically unordered/&gt;
&nbsp; &nbsp; # Compiler *can* reorder and parallelize but *may not* so don't test
&nbsp; &nbsp; # for all(@foo) {...}; &nbsp;

&nbsp; &nbsp; # Not sure what is expected
&nbsp; &nbsp; #my %got = ('1' =&gt; 1); # Hashes are unordered too
&nbsp; &nbsp; #@foo = (2,3,4);
&nbsp; &nbsp; #for all(@foo) { %got{$_} = 1; };
&nbsp; &nbsp; #is( %got.keys.sort.join(','), '1,2,3,4',
&nbsp; &nbsp; # &nbsp; &nbsp;'for all(...) { ...} as parallelizable');
}

=pod

These are implemented but still awaiting clarification on p6l.</pre>
</div>


<pre>    for all(@foo) {...}</pre>

<p>it indicates to the compiler that there is no coupling between loop iterations and they can be run in any order or even in parallel.</p>

<p>Use of negative operators with syntactically recognizable junctions may produce a warning on code that works differently in English than in Perl. Instead of writing</p>

<pre>    if $a != 1 | 2 | 3 {...}</pre>

<p>you need to write</p>

<pre>    if not $a == 1 | 2 | 3 {...}</pre>

<p>However, this is only a syntactic warning, and</p>

<pre>    if $a != $b {...}</pre>

<p>will not complain if $b happens to contain a junction at runtime.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Chained_comparisons"
>Chained comparisons</a></h1>

<a href="#" onclick="return tog_quote(18);">
<div ID="header_shown_18" style="display: none;">
- Hide the snippet from t/operators/listquote.t (line 38 ~ line 76) -
</div>
<div ID="header_hidden_18" style="display: block;">
- Show the snippet from t/operators/listquote.t (line 38 ~ line 76) -
</div>
</a>
<div ID="hide_18" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;Chained comparisons&quot;&gt;

my $s = join 'a', &lt;x y z&gt;;
is($s, &quot;xayaz&quot;, 'list context &lt;list&gt;');

my $s = join |&lt;&lt; &lt;a x y z&gt;;
is($s, &quot;xayaz&quot;, 'listop |&lt;&lt; &lt;list&gt;', :todo&lt;bug&gt;);

my $x = try { [1,2,3].join&lt;a b c&gt; };
ok($!, '.join&lt;abc&gt; parses but semantic error');
is($x, try { [1,2,3].join()&lt;a b c&gt; }, '.join()&lt;a b c&gt; not treated as argument');

my @y = try { {:a&lt;1&gt;, :b(2)}&lt;a b c&gt; };
is(@y, [1,2,undef], '{...}&lt;a b c&gt; is hash subscript');

eval '{:a&lt;1&gt;, :b(2)} &lt;a b c&gt;';
ok($!, '{...} &lt;...&gt; parsefail');

ok((1 | 3) &lt; 3, '(...) &lt; 3 no parsefail');

eval '(1 | 3)&lt;3';
ok($!, '()&lt;3 parsefail', :todo&lt;bug&gt;);

eval 'print &lt; 3';
ok($!, 'print &lt; 3 parsefail');

my $z = eval 'reverse&lt;1 2 3&gt;';
ok($!, 'reverse&lt;1 2 3&gt; parsefail', :todo&lt;bug&gt;);

eval ':foo &lt;1 2 3&gt;';
ok($!, ':foo &lt;1 2 3&gt; parsefail');

my $r = eval ':foo &lt;3';
is($r, Bool::True, ':foo &lt;3 is comparison');

my $p = eval ':foo&lt;1 2 3&gt;';
is($p, ~('foo' =&gt; (1,2,3)), ':foo&lt;1 2 3&gt; is pair of list');

=cut</pre>
</div>


<a href="#" onclick="return tog_quote(17);">
<div ID="header_shown_17" style="display: none;">
- Hide the snippet from t/operators/relational.t (line 43 ~ line 52) -
</div>
<div ID="header_hidden_17" style="display: block;">
- Show the snippet from t/operators/relational.t (line 43 ~ line 52) -
</div>
</a>
<div ID="hide_17" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;Chained comparisons&quot;&gt;

# this works ...
is(5 &gt; 1 &lt; 10, 5 &gt; 1 &amp;&amp; 1 &lt; 10, 'multi-way comp 5 &gt; 1 &lt; 10 works');

# however this doesn't which makes 
# me think these are not implemented
is(5 &lt; 1 &lt; 10, 5 &lt; 1 &amp;&amp; 1 &lt; 10, 'multi-way comp 5 &lt; 1 &lt; 10 works');

## NOTE: these tests moved here from t/03operator.t </pre>
</div>


<a href="#" onclick="return tog_quote(16);">
<div ID="header_shown_16" style="display: none;">
- Hide the snippet from t/operators/relational.t (line 53 ~ line 92) -
</div>
<div ID="header_hidden_16" style="display: block;">
- Show the snippet from t/operators/relational.t (line 53 ~ line 92) -
</div>
</a>
<div ID="hide_16" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;Chained comparisons&quot;&gt;

ok(5 &gt; 4 &gt; 3, &quot;chained comparison&quot;);
ok(3 &lt; 4 &lt; 5, &quot;chained comparison&quot;);
ok(5 == 5 &gt; -5, &quot;chained comparison with equality&quot;);
ok(!(3 &gt; 4 &lt; 5), &quot;chained n &gt; n &lt; n comparison&quot;);
ok(5 &lt;= 5 &gt; -5, &quot;chained comparison with &lt;=&quot;);
ok(-5 &lt; 5 &gt;= 5, &quot;chained comparison with &gt;=&quot;);

## For Strings: &lt;, &lt;=, &lt;=&gt;, &gt;=, &gt;

# less than

ok('a' lt 'b', 'a is less than b');
ok(!('b' lt 'a'), 'b is ~not~ less than a');

# greater than

ok('b' gt 'a', 'b is greater than a');
ok(!('a' gt 'b'), 'a is ~not~ greater than b');

# less than or equal to

ok('a' le 'b', 'a is less than or equal to b');
ok('a' le 'a', 'a is less than or equal to a');
ok(!('b' le 'a'), 'b is ~not~ less than or equal to a');

# greater than or eqaul to

ok('b' ge 'a', 'b is greater than or equal to a');
ok('b' ge 'b', 'b is greater than or equal to b');
ok(!('b' ge 'c'), 'b is ~not~ greater than or equal to c');

# cmp

is('a' cmp 'a', 0, &nbsp;'a is equal to a');
is('a' cmp 'b', -1, 'a is less than b');
is('b' cmp 'a', 1, &nbsp;'b is greater than a');

## Multiway comparisons (RFC 025)</pre>
</div>


<a href="#" onclick="return tog_quote(15);">
<div ID="header_shown_15" style="display: none;">
- Hide the snippet from t/operators/relational.t (line 93 ~ line 102) -
</div>
<div ID="header_hidden_15" style="display: block;">
- Show the snippet from t/operators/relational.t (line 93 ~ line 102) -
</div>
</a>
<div ID="hide_15" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;Chained comparisons&quot;&gt;

# this works ...
is('e' gt 'a' lt 'j', 'e' gt 'a' &amp;&amp; 'a' lt 'j', 'multi-way comp e gt a lt j works');

# however this doesn't which makes 
# me think these are not implemented
is('e' lt 'a' lt 'j', 'e' lt 'a' &amp;&amp; 'a' lt 'j', 'multi-way comp e lt a lt j works');

## NOTE: these tests moved here from t/03operator.t </pre>
</div>


<a href="#" onclick="return tog_quote(14);">
<div ID="header_shown_14" style="display: none;">
- Hide the snippet from t/operators/relational.t (line 103 ~ line 110) -
</div>
<div ID="header_hidden_14" style="display: block;">
- Show the snippet from t/operators/relational.t (line 103 ~ line 110) -
</div>
</a>
<div ID="hide_14" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;Chained comparisons&quot;&gt;

ok(&quot;5&quot; gt &quot;4&quot; gt &quot;3&quot;, &quot;5 gt 4 gt 3 chained str comparison&quot;);
ok(&quot;3&quot; lt &quot;4&quot; lt &quot;5&quot;, &quot;3 lt 4 gt 5 chained str comparison&quot;);
ok(!(&quot;3&quot; gt &quot;4&quot; lt &quot;5&quot;), &quot;!(3 gt 4 lt 5) chained str comparison&quot;);
ok(&quot;5&quot; eq &quot;5&quot; gt &quot;0&quot;, '&quot;5&quot; eq &quot;5&quot; gt &quot;0&quot; chained str comparison with equality');
ok(&quot;5&quot; le &quot;5&quot; gt &quot;0&quot;, &quot;5 le 5 gt 0 chained str comparison with le&quot;);
ok(&quot;0&quot; lt &quot;5&quot; ge &quot;5&quot;, &quot;0 lt 5 ge 5 chained comparison with ge&quot;);</pre>
</div>


<p>Perl 6 supports the natural extension to the comparison operators, allowing multiple operands:</p>

<pre>    if 1 &#60; $a &#60; 100 { say &#34;Good, you picked a number *between* 1 and 100.&#34; }

    if 3 &#60; $roll &#60;= 6              { print &#34;High roll&#34; }

    if 1 &#60;= $roll1 == $roll2 &#60;= 6  { print &#34;Doubles!&#34; }</pre>

<p>A chain of comparisons short-circuits if the first comparison fails:</p>

<pre>    1 &#62; 2 &#62; die(&#34;this is never reached&#34;);</pre>

<p>Each argument in the chain will evaluate at most once:</p>

<pre>    1 &#62; $x++ &#62; 2    # $x increments exactly once</pre>

<p>Note: any operator beginning with <code>&#60;</code> must have whitespace in front of it, or it will be interpreted as a hash subscript instead.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Binding"
>Binding</a></h1>

<a href="#" onclick="return tog_quote(62);">
<div ID="header_shown_62" style="display: none;">
- Hide the snippet from t/operators/binding/arrays.t (line 5 ~ line 222) -
</div>
<div ID="header_hidden_62" style="display: block;">
- Show the snippet from t/operators/binding/arrays.t (line 5 ~ line 222) -
</div>
</a>
<div ID="hide_62" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;Binding&quot;&gt;

plan 46;

# Binding of array elements.
# See thread &quot;Binding of array elements&quot; on p6l started by Ingo Blechschmidt:
# L&lt;<a href="http://www.nntp.perl.org/group/perl.perl6.language/22915">&quot;http://www.nntp.perl.org/group/perl.perl6.language/22915&quot;</a>&gt;
{
&nbsp; my @array &nbsp;= &lt;a b c&gt;;
&nbsp; my $var &nbsp; &nbsp;= &quot;d&quot;;

&nbsp; try { @array[1] := $var };
&nbsp; is @array[1], &quot;d&quot;, &quot;basic binding of an array element (1)&quot;, :todo&lt;feature&gt;;
&nbsp; unless @array[1] eq &quot;d&quot; {
&nbsp; &nbsp; skip_rest &quot;Skipping binding of array elements tests (not yet implemented in the normal runcore)&quot;;
&nbsp; &nbsp; exit;
&nbsp; }

&nbsp; $var = &quot;e&quot;;
&nbsp; is @array[1], &quot;e&quot;, &quot;basic binding of an array element (2)&quot;;

&nbsp; @array[1] = &quot;f&quot;;
&nbsp; is $var, &nbsp; &nbsp; &nbsp;&quot;f&quot;, &quot;basic binding of an array element (3)&quot;;
}

{
&nbsp; my @array &nbsp;= &lt;a b c&gt;;
&nbsp; my $var &nbsp; &nbsp;= &quot;d&quot;;

&nbsp; @array[1] := $var;
&nbsp; $var &nbsp; &nbsp; &nbsp; = &quot;e&quot;;
&nbsp; is @array[1], &quot;e&quot;, &nbsp;&quot;binding of array elements works with .delete (1)&quot;;

&nbsp; @array.delete(1);
&nbsp; # $var unchanged, but assigning to $var doesn't modify @array any
&nbsp; # longer; similarily, changing @array[1] doesn't modify $var now
&nbsp; is $var, &nbsp; &nbsp;&quot;e&quot;, &nbsp; &nbsp;&quot;binding of array elements works with .delete (2)&quot;;
&nbsp; is ~@array, &quot;a &nbsp;c&quot;, &quot;binding of array elements works with .delete (3)&quot;;

&nbsp; $var &nbsp; &nbsp; &nbsp;= &quot;f&quot;;
&nbsp; @array[1] = &quot;g&quot;;
&nbsp; is $var, &nbsp; &nbsp; &nbsp;&quot;f&quot;, &nbsp;&quot;binding of array elements works with .delete (4)&quot;;
&nbsp; is @array[1], &quot;g&quot;, &nbsp;&quot;binding of array elements works with .delete (5)&quot;;
}

{
&nbsp; my @array &nbsp;= &lt;a b c&gt;;
&nbsp; my $var &nbsp; &nbsp;= &quot;d&quot;;

&nbsp; @array[1] := $var;
&nbsp; $var &nbsp; &nbsp; &nbsp; = &quot;e&quot;;
&nbsp; is @array[1], &quot;e&quot;, &quot;binding of array elements works with resetting the array (1)&quot;;

&nbsp; @array = ();
&nbsp; # $var unchanged, but assigning to $var doesn't modify @array any
&nbsp; # longer; similarily, changing @array[1] doesn't modify $var now
&nbsp; is $var, &nbsp; &nbsp;&quot;e&quot;, &nbsp; &quot;binding of array elements works with resetting the array (2)&quot;;
&nbsp; is ~@array, &quot;&quot;, &nbsp; &nbsp;&quot;binding of array elements works with resetting the array (3)&quot;;

&nbsp; $var &nbsp; &nbsp; &nbsp;= &quot;f&quot;;
&nbsp; @array[1] = &quot;g&quot;;
&nbsp; is $var, &nbsp; &nbsp; &nbsp;&quot;f&quot;, &quot;binding of array elements works with resetting the array (4)&quot;;
&nbsp; is @array[1], &quot;g&quot;, &quot;binding of array elements works with resetting the array (5)&quot;;
}

{
&nbsp; my @array &nbsp;= &lt;a b c&gt;;
&nbsp; my $var &nbsp; &nbsp;= &quot;d&quot;;

&nbsp; @array[1] := $var;
&nbsp; $var &nbsp; &nbsp; &nbsp; = &quot;e&quot;;
&nbsp; is @array[1], &quot;e&quot;, &nbsp; &quot;binding of array elements works with rebinding the array (1)&quot;;

&nbsp; my @other_array = &lt;x y z&gt;;
&nbsp; @array := @other_array;
&nbsp; # $var unchanged, but assigning to $var doesn't modify @array any
&nbsp; # longer; similarily, changing @array[1] doesn't modify $var now
&nbsp; is $var, &nbsp; &nbsp;&quot;e&quot;, &nbsp; &nbsp; &quot;binding of array elements works with rebinding the array (2)&quot;;
&nbsp; is ~@array, &quot;x y z&quot;, &quot;binding of array elements works with rebinding the array (3)&quot;;

&nbsp; $var &nbsp; &nbsp; &nbsp;= &quot;f&quot;;
&nbsp; @array[1] = &quot;g&quot;;
&nbsp; is $var, &nbsp; &nbsp; &nbsp;&quot;f&quot;, &nbsp; &quot;binding of array elements works with rebinding the array (4)&quot;;
&nbsp; is @array[1], &quot;g&quot;, &nbsp; &quot;binding of array elements works with rebinding the array (5)&quot;;
}

{
&nbsp; my sub foo (@arr) { @arr[1] = &quot;new_value&quot; }

&nbsp; my @array &nbsp;= &lt;a b c&gt;;
&nbsp; my $var &nbsp; &nbsp;= &quot;d&quot;;
&nbsp; @array[1] := $var;

&nbsp; foo @array;
&nbsp; is $var, &nbsp; &nbsp;&quot;new_value&quot;, &nbsp; &nbsp; &quot;passing an array to a sub expecting an array behaves correctly (1)&quot;;
&nbsp; is ~@array, &quot;a new_value c&quot;, &quot;passing an array to a sub expecting an array behaves correctly (2)&quot;;
}

{
&nbsp; my sub foo (Array $arr) { $arr[1] = &quot;new_value&quot; }

&nbsp; my @array &nbsp;= &lt;a b c&gt;;
&nbsp; my $var &nbsp; &nbsp;= &quot;d&quot;;
&nbsp; @array[1] := $var;

&nbsp; foo @array;
&nbsp; is $var, &nbsp; &nbsp;&quot;new_value&quot;, &nbsp; &nbsp; &quot;passing an array to a sub expecting an arrayref behaves correctly (1)&quot;;
&nbsp; is ~@array, &quot;a new_value c&quot;, &quot;passing an array to a sub expecting an arrayref behaves correctly (2)&quot;;
}

{
&nbsp; my sub foo (*@args) { @args[1] = &quot;new_value&quot; }

&nbsp; my @array &nbsp;= &lt;a b c&gt;;
&nbsp; my $var &nbsp; &nbsp;= &quot;d&quot;;
&nbsp; @array[1] := $var;

&nbsp; foo @array;
&nbsp; is $var, &nbsp; &nbsp;&quot;new_value&quot;, &nbsp; &nbsp; &quot;passing an array to a slurpying sub behaves correctly (1)&quot;;
&nbsp; is ~@array, &quot;a new_value c&quot;, &quot;passing an array to a slurpying sub behaves correctly (2)&quot;;
}

{
&nbsp; my sub foo (*@args) { push @args, &quot;new_value&quot; }

&nbsp; my @array &nbsp;= &lt;a b c&gt;;
&nbsp; my $var &nbsp; &nbsp;= &quot;d&quot;;
&nbsp; @array[1] := $var;

&nbsp; foo @array;
&nbsp; is $var, &nbsp; &nbsp;&quot;d&quot;, &nbsp; &nbsp; &quot;passing an array to a slurpying sub behaves correctly (3)&quot;;
&nbsp; is ~@array, &quot;a d c&quot;, &quot;passing an array to a slurpying sub behaves correctly (4)&quot;;
}

# Binding of not yet existing elements should autovivify
{
&nbsp; my @array;
&nbsp; my $var &nbsp; &nbsp;= &quot;d&quot;;

&nbsp; lives_ok { @array[1] := $var },
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;binding of not yet existing elements should autovivify (1)&quot;;
&nbsp; is @array[1], &quot;d&quot;, &quot;binding of not yet existing elements should autovivify (2)&quot;;

&nbsp; $var = &quot;e&quot;;
&nbsp; is @array[1], &quot;e&quot;, &quot;binding of not yet existing elements should autovivify (3)&quot;;
&nbsp; is $var, &nbsp; &nbsp; &nbsp;&quot;e&quot;, &quot;binding of not yet existing elements should autovivify (4)&quot;;
}

# Binding with .splice
{
&nbsp; my @array &nbsp;= &lt;a b c&gt;;
&nbsp; my $var &nbsp; &nbsp;= &quot;d&quot;;

&nbsp; @array[1] := $var;
&nbsp; $var &nbsp; &nbsp; &nbsp; = &quot;e&quot;;
&nbsp; is @array[1], &quot;e&quot;, &nbsp;&quot;binding of array elements works with splice (1)&quot;;

&nbsp; splice @array, 1, 1, ();
&nbsp; # $var unchanged, but assigning to $var doesn't modify @array any
&nbsp; # longer; similarily, changing @array[1] doesn't modify $var now
&nbsp; is $var, &nbsp; &nbsp;&quot;e&quot;, &nbsp; &nbsp;&quot;binding of array elements works with splice (2)&quot;;
&nbsp; is ~@array, &quot;a &nbsp;c&quot;, &quot;binding of array elements works with splice (3)&quot;;

&nbsp; $var &nbsp; &nbsp; &nbsp;= &quot;f&quot;;
&nbsp; @array[1] = &quot;g&quot;;
&nbsp; is $var, &nbsp; &nbsp; &nbsp;&quot;f&quot;, &nbsp;&quot;binding of array elements works with splice (4)&quot;;
&nbsp; is @array[1], &quot;g&quot;, &nbsp;&quot;binding of array elements works with splice (5)&quot;;
}

# Assignment (not binding) creates new containers
{
&nbsp; my @array &nbsp;= &lt;a b c&gt;;
&nbsp; my $var &nbsp; &nbsp;= &quot;d&quot;;

&nbsp; @array[1] := $var;
&nbsp; $var &nbsp; &nbsp; &nbsp; = &quot;e&quot;;
&nbsp; is @array[1], &quot;e&quot;, &nbsp; &nbsp; &nbsp; &quot;array assignment creates new containers (1)&quot;;

&nbsp; my @new_array = @array;
&nbsp; $var &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= &quot;f&quot;;
&nbsp; # @array[$idx] and $var are now &quot;f&quot;, but @new_array is unchanged.
&nbsp; is $var, &nbsp; &nbsp; &nbsp; &nbsp;&quot;f&quot;, &nbsp; &nbsp; &quot;array assignment creates new containers (2)&quot;;
&nbsp; is ~@array, &nbsp; &nbsp; &quot;a f c&quot;, &quot;array assignment creates new containers (3)&quot;;
&nbsp; is ~@new_array, &quot;a e c&quot;, &quot;array assignment creates new containers (4)&quot;;
}

# Binding does not create new containers
{
&nbsp; my @array &nbsp;= &lt;a b c&gt;;
&nbsp; my $var &nbsp; &nbsp;= &quot;d&quot;;

&nbsp; @array[1] := $var;
&nbsp; $var &nbsp; &nbsp; &nbsp; = &quot;e&quot;;
&nbsp; is @array[1], &quot;e&quot;, &nbsp; &nbsp; &nbsp; &quot;array binding does not create new containers (1)&quot;;

&nbsp; my @new_array := @array;
&nbsp; $var &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = &quot;f&quot;;
&nbsp; # @array[$idx] and $var are now &quot;f&quot;, but @new_array is unchanged.
&nbsp; is $var, &nbsp; &nbsp; &nbsp; &nbsp;&quot;f&quot;, &nbsp; &nbsp; &quot;array binding does not create new containers (2)&quot;;
&nbsp; is ~@array, &nbsp; &nbsp; &quot;a f c&quot;, &quot;array binding does not create new containers (3)&quot;;
&nbsp; is ~@new_array, &quot;a f c&quot;, &quot;array binding does not create new containers (4)&quot;;
}

# Binding @array := $arrayref.
# See
# http://colabti.de/irclogger/irclogger_log/perl6?date=2005-11-06,Sun&amp;sel=388#l564
# and consider the magic behind parameter binding (which is really normal
# binding).
{
&nbsp; my $arrayref &nbsp;= [&lt;a b c&gt;];
&nbsp; my @array &nbsp; &nbsp;:= $arrayref;

&nbsp; is +@array, 3, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'binding @array := $arrayref works (1)';

&nbsp; @array[1] = &quot;B&quot;;
&nbsp; is ~$arrayref, &quot;a B c&quot;, 'binding @array := $arrayref works (2)';
&nbsp; is ~@array, &nbsp; &nbsp;&quot;a B c&quot;, 'binding @array := $arrayref works (3)';
}</pre>
</div>


<a href="#" onclick="return tog_quote(61);">
<div ID="header_shown_61" style="display: none;">
- Hide the snippet from t/operators/binding/attributes.t (line 4 ~ line 77) -
</div>
<div ID="header_hidden_61" style="display: block;">
- Show the snippet from t/operators/binding/attributes.t (line 4 ~ line 77) -
</div>
</a>
<div ID="hide_61" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;Binding&quot;&gt;

plan 12;

# Tests for binding public and private instance and class attributes

# Public instance attributes
{
&nbsp; &nbsp; my $var = 42;
&nbsp; &nbsp; class Klass1 { has $.x; method bind { $.x := $var } }

&nbsp; &nbsp; my $obj1 = Klass1.new;
&nbsp; &nbsp; try { $obj1.bind() };

&nbsp; &nbsp; is $obj1.x, 42, &quot;binding public instance attribute (1)&quot;, :todo&lt;bug&gt;;
&nbsp; &nbsp; $var = 23;
&nbsp; &nbsp; is $obj1.x, 23, &quot;binding public instance attribute (2)&quot;, :todo&lt;bug&gt;;
&nbsp; &nbsp; $obj1.x = 19;
&nbsp; &nbsp; is $var, &nbsp; &nbsp;19, &quot;binding public instance attribute (3)&quot;, :todo&lt;bug&gt;;
}

# Private instance attributes
{
&nbsp; &nbsp; my $var = 42;
&nbsp; &nbsp; class Klass2 {
&nbsp; &nbsp; &nbsp; &nbsp; has $x;
&nbsp; &nbsp; &nbsp; &nbsp; method bind { $x := $var }
&nbsp; &nbsp; &nbsp; &nbsp; method get_x { try { $x } }
&nbsp; &nbsp; &nbsp; &nbsp; method set_x ($new_x) { try { $x = $new_x } }
&nbsp; &nbsp; }

&nbsp; &nbsp; my $obj2 = Klass2.new;
&nbsp; &nbsp; try { $obj2.bind() };

&nbsp; &nbsp; is $obj2.get_x, 42, &quot;binding private instance attribute (1)&quot;, :todo&lt;bug&gt;;
&nbsp; &nbsp; $var = 23;
&nbsp; &nbsp; is $obj2.get_x, 23, &quot;binding private instance attribute (2)&quot;, :todo&lt;bug&gt;;
&nbsp; &nbsp; $obj2.set_x(19);
&nbsp; &nbsp; is $var, &nbsp; &nbsp;19, &nbsp; &nbsp; &quot;binding private instance attribute (3)&quot;, :todo&lt;bug&gt;;
}

# Public class attributes
{
&nbsp; &nbsp; my $var = 42;
&nbsp; &nbsp; class Klass3 { our $.x; method bind { $.x := $var } }

&nbsp; &nbsp; try { Klass3.bind() };

&nbsp; &nbsp; is try { Klass3.x }, 42, &quot;binding public class attribute (1)&quot;, :todo&lt;bug&gt;;
&nbsp; &nbsp; $var = 23;
&nbsp; &nbsp; is try { Klass3.x }, 23, &quot;binding public class attribute (2)&quot;, :todo&lt;bug&gt;;
&nbsp; &nbsp; try { Klass3.x = 19 };
&nbsp; &nbsp; is $var, &nbsp; &nbsp;19, &nbsp;&quot;binding public class attribute (3)&quot;, :todo&lt;bug&gt;;
}

# Private class attributes
{
&nbsp; &nbsp; my $var = 42;
&nbsp; &nbsp; class Klass4 {
&nbsp; &nbsp; &nbsp; &nbsp; our $x;
&nbsp; &nbsp; &nbsp; &nbsp; method bind { $x := $var }
&nbsp; &nbsp; &nbsp; &nbsp; method get_x { $x }
&nbsp; &nbsp; &nbsp; &nbsp; method set_x ($new_x) { $x = $new_x }
&nbsp; &nbsp; }

&nbsp; &nbsp; try { Klass4.bind() };

&nbsp; &nbsp; is Klass4.get_x, 42, &quot;binding private class attribute (1)&quot;;
&nbsp; &nbsp; $var = 23;
&nbsp; &nbsp; is Klass4.get_x, 23, &quot;binding private class attribute (2)&quot;;
&nbsp; &nbsp; Klass4.set_x(19);
&nbsp; &nbsp; is $var, &nbsp; &nbsp;19, &nbsp; &nbsp; &nbsp;&quot;binding private class attribute (3)&quot;;
}</pre>
</div>


<a href="#" onclick="return tog_quote(60);">
<div ID="header_shown_60" style="display: none;">
- Hide the snippet from t/operators/binding/hashes.t (line 5 ~ line 181) -
</div>
<div ID="header_hidden_60" style="display: block;">
- Show the snippet from t/operators/binding/hashes.t (line 5 ~ line 181) -
</div>
</a>
<div ID="hide_60" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;Binding&quot;&gt;

plan 37;

# Binding of hash elements.
# See thread &quot;Binding of array elements&quot; on p6l started by Ingo Blechschmidt:
# L&lt;<a href="http://www.nntp.perl.org/group/perl.perl6.language/22915">&quot;http://www.nntp.perl.org/group/perl.perl6.language/22915&quot;</a>&gt;
{
&nbsp; my %hash &nbsp;= (:a&lt;x&gt;, :b&lt;y&gt;, :c&lt;z&gt;);
&nbsp; my $var &nbsp; = &quot;d&quot;;

&nbsp; try { %hash&lt;b&gt; := $var };
&nbsp; is %hash&lt;b&gt;, &quot;d&quot;, &quot;basic binding of a hash element (1)&quot;, :todo&lt;feature&gt;;
&nbsp; unless %hash&lt;b&gt; eq &quot;d&quot; {
&nbsp; &nbsp; skip_rest &quot;Skipping binding of hash elements tests (not yet implemented in the normal runcore)&quot;;
&nbsp; &nbsp; exit;
&nbsp; }

&nbsp; $var = &quot;e&quot;;
&nbsp; is %hash&lt;b&gt;, &quot;e&quot;, &quot;basic binding of a hash element (2)&quot;;

&nbsp; %hash&lt;b&gt; = &quot;f&quot;;
&nbsp; is $var, &nbsp; &nbsp; &quot;f&quot;, &quot;basic binding of a hash element (3)&quot;;
}

{
&nbsp; my %hash &nbsp;= (:a&lt;x&gt;, :b&lt;y&gt;, :c&lt;z&gt;);
&nbsp; my $var &nbsp; = &quot;d&quot;;

&nbsp; %hash&lt;b&gt; := $var;
&nbsp; $var &nbsp; &nbsp; &nbsp;= &quot;e&quot;;
&nbsp; is %hash&lt;b&gt;, &quot;e&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;binding of hash elements works with .delete (1)&quot;;

&nbsp; %hash.delete(&quot;b&quot;);
&nbsp; # $var unchanged, but assigning to $var doesn't modify @hash any
&nbsp; # longer; similarily, changing @hash[1] doesn't modify $var now
&nbsp; is $var, &nbsp; &quot;e&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;binding of hash elements works with .delete (2)&quot;;
&nbsp; is ~%hash.values.sort, &quot;x z&quot;, &quot;binding of hash elements works with .delete (3)&quot;;

&nbsp; $var &nbsp; &nbsp; = &quot;f&quot;;
&nbsp; %hash&lt;b&gt; = &quot;g&quot;;
&nbsp; is $var, &nbsp; &nbsp; &quot;f&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;binding of hash elements works with .delete (4)&quot;;
&nbsp; is %hash&lt;b&gt;, &quot;g&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;binding of hash elements works with .delete (5)&quot;;
}

{
&nbsp; my %hash &nbsp;= (:a&lt;x&gt;, :b&lt;y&gt;, :c&lt;z&gt;);
&nbsp; my $var &nbsp; = &quot;d&quot;;

&nbsp; %hash&lt;b&gt; := $var;
&nbsp; $var &nbsp; &nbsp; &nbsp;= &quot;e&quot;;
&nbsp; is %hash&lt;b&gt;, &quot;e&quot;, &quot;binding of hash elements works with resetting the hash (1)&quot;;

&nbsp; %hash = ();
&nbsp; # $var unchanged, but assigning to $var doesn't modify @hash any
&nbsp; # longer; similarily, changing @hash[1] doesn't modify $var now
&nbsp; is $var, &nbsp; &quot;e&quot;, &nbsp; &quot;binding of hash elements works with resetting the hash (2)&quot;;
&nbsp; is ~%hash, &quot;&quot;, &nbsp; &nbsp;&quot;binding of hash elements works with resetting the hash (3)&quot;;

&nbsp; $var &nbsp; &nbsp; = &quot;f&quot;;
&nbsp; %hash&lt;b&gt; = &quot;g&quot;;
&nbsp; is $var, &nbsp; &nbsp; &quot;f&quot;, &quot;binding of hash elements works with resetting the hash (4)&quot;;
&nbsp; is %hash&lt;b&gt;, &quot;g&quot;, &quot;binding of hash elements works with resetting the hash (5)&quot;;
}

{
&nbsp; my %hash &nbsp;= (:a&lt;x&gt;, :b&lt;y&gt;, :c&lt;z&gt;);
&nbsp; my $var &nbsp; = &quot;d&quot;;

&nbsp; %hash&lt;b&gt; := $var;
&nbsp; $var &nbsp; &nbsp; &nbsp;= &quot;e&quot;;
&nbsp; is %hash&lt;b&gt;, &quot;e&quot;, &quot;binding of hash elements works with rebinding the hash (1)&quot;;

&nbsp; my %other_hash = (:p&lt;q&gt;, :r&lt;s&gt;, :t&lt;u&gt;);
&nbsp; %hash := %other_hash;
&nbsp; # $var unchanged, but assigning to $var doesn't modify @hash any
&nbsp; # longer; similarily, changing @hash[1] doesn't modify $var now
&nbsp; is $var, &nbsp; &nbsp;&quot;e&quot;, &nbsp;&quot;binding of hash elements works with rebinding the hash (2)&quot;;
&nbsp; is ~%hash.values.sort, &quot;q s u&quot;,
&nbsp; &nbsp; &quot;binding of hash elements works with rebinding the hash (3)&quot;;

&nbsp; $var &nbsp; &nbsp; = &quot;f&quot;;
&nbsp; %hash&lt;b&gt; = &quot;g&quot;;
&nbsp; is $var, &nbsp; &nbsp; &quot;f&quot;, &quot;binding of hash elements works with rebinding the hash (4)&quot;;
&nbsp; is %hash&lt;b&gt;, &quot;g&quot;, &quot;binding of hash elements works with rebinding the hash (5)&quot;;
}

{
&nbsp; my sub foo (%h) { %h&lt;b&gt; = &quot;new_value&quot; }

&nbsp; my %hash &nbsp;= (:a&lt;x&gt;, :b&lt;y&gt;, :c&lt;z&gt;);
&nbsp; my $var &nbsp; = &quot;d&quot;;
&nbsp; %hash&lt;b&gt; := $var;

&nbsp; foo %hash;
&nbsp; is $var, &nbsp; &nbsp;&quot;new_value&quot;, &nbsp; &nbsp; &quot;passing a hash to a sub expecting a hash behaves correctly (1)&quot;;
&nbsp; is ~%hash.values.sort, &quot;new_value x z&quot;,
&nbsp; &nbsp; &quot;passing a hash to a sub expecting a hash behaves correctly (2)&quot;;
}

{
&nbsp; my sub foo (Hash $h) { $h&lt;b&gt; = &quot;new_value&quot; }

&nbsp; my %hash &nbsp;= (:a&lt;x&gt;, :b&lt;y&gt;, :c&lt;z&gt;);
&nbsp; my $var &nbsp; = &quot;d&quot;;
&nbsp; %hash&lt;b&gt; := $var;

&nbsp; foo %hash;
&nbsp; is $var, &quot;new_value&quot;,
&nbsp; &nbsp; &quot;passing a hash to a sub expecting a hashref behaves correctly (1)&quot;;
&nbsp; is ~%hash.values.sort, &quot;new_value x z&quot;,
&nbsp; &nbsp; &quot;passing a hash to a sub expecting a hashref behaves correctly (2)&quot;;
}

# Binding of not yet existing elements should autovivify
{
&nbsp; my %hash;
&nbsp; my $var = &quot;d&quot;;

&nbsp; lives_ok { %hash&lt;b&gt; := $var },
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;binding of not yet existing elements should autovivify (1)&quot;;
&nbsp; is %hash&lt;b&gt;, &quot;d&quot;, &quot;binding of not yet existing elements should autovivify (2)&quot;;

&nbsp; $var = &quot;e&quot;;
&nbsp; is %hash&lt;b&gt;, &quot;e&quot;, &quot;binding of not yet existing elements should autovivify (3)&quot;;
&nbsp; is $var, &nbsp; &nbsp; &quot;e&quot;, &quot;binding of not yet existing elements should autovivify (4)&quot;;
}

# Assignment (not binding) creates new containers
{
&nbsp; my %hash &nbsp;= (:a&lt;x&gt;, :b&lt;y&gt;, :c&lt;z&gt;);
&nbsp; my $var &nbsp; = &quot;d&quot;;

&nbsp; %hash&lt;b&gt; := $var;
&nbsp; $var &nbsp; &nbsp; &nbsp;= &quot;e&quot;;
&nbsp; is %hash&lt;b&gt;, &quot;e&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;hash assignment creates new containers (1)&quot;;

&nbsp; my %new_hash = %hash;
&nbsp; $var &nbsp; &nbsp; &nbsp; &nbsp; = &quot;f&quot;;
&nbsp; # %hash&lt;b&gt; and $var are now &quot;f&quot;, but %new_hash is unchanged.
&nbsp; is $var, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;f&quot;, &nbsp; &nbsp; &quot;hash assignment creates new containers (2)&quot;;
&nbsp; is ~%hash\ &nbsp; .values.sort, &quot;f x z&quot;, &quot;hash assignment creates new containers (3)&quot;;
&nbsp; is ~%new_hash.values.sort, &quot;e x z&quot;, &quot;hash assignment creates new containers (4)&quot;;
}

# Binding does not create new containers
{
&nbsp; my %hash &nbsp;= (:a&lt;x&gt;, :b&lt;y&gt;, :c&lt;z&gt;);
&nbsp; my $var &nbsp; = &quot;d&quot;;

&nbsp; %hash&lt;b&gt; := $var;
&nbsp; $var &nbsp; &nbsp; &nbsp;= &quot;e&quot;;
&nbsp; is %hash&lt;b&gt;, &quot;e&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;hash binding does not create new containers (1)&quot;;

&nbsp; my %new_hash := %hash;
&nbsp; $var &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= &quot;f&quot;;
&nbsp; # %hash&lt;b&gt; and $var are now &quot;f&quot;, but %new_hash is unchanged.
&nbsp; is $var, &nbsp; &nbsp; &nbsp; &nbsp;&quot;f&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;hash binding does not create new containers (2)&quot;;
&nbsp; is ~%hash\ &nbsp; .values.sort, &quot;f x z&quot;, &quot;hash binding does not create new containers (3)&quot;;
&nbsp; is ~%new_hash.values.sort, &quot;f x z&quot;, &quot;hash binding does not create new containers (4)&quot;;
}

# Binding %hash := $hashref.
# See
# http://colabti.de/irclogger/irclogger_log/perl6?date=2005-11-06,Sun&amp;sel=388#l564
# and consider the magic behind parameter binding (which is really normal
# binding).
{
&nbsp; my $hashref = { a =&gt; &quot;a&quot;, b =&gt; &quot;b&quot; };
&nbsp; my %hash &nbsp; := $hashref;

&nbsp; is +%hash, 2, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'binding %hash := $hashref works (1)';

&nbsp; %hash&lt;b&gt; = &quot;c&quot;;
&nbsp; is ~$hashref.values.sort, &quot;a c&quot;, 'binding %hash := $hashref works (2)';
&nbsp; is ~%hash\ &nbsp;.values.sort, &quot;a c&quot;, 'binding %hash := $hashref works (3)';
}</pre>
</div>


<a href="#" onclick="return tog_quote(59);">
<div ID="header_shown_59" style="display: none;">
- Hide the snippet from t/operators/binding/nested.t (line 5 ~ line 340) -
</div>
<div ID="header_hidden_59" style="display: block;">
- Show the snippet from t/operators/binding/nested.t (line 5 ~ line 340) -
</div>
</a>
<div ID="hide_59" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;Binding&quot;&gt;

# Tests for binding multidimensional structures.

plan 43;

# Nested refs as RHS in a binding operation
{
&nbsp; &nbsp; my $struct = [
&nbsp; &nbsp; &nbsp; &nbsp; &quot;ignored&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key =&gt; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignored =&gt; 23,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subkey &nbsp;=&gt; [
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;ignored&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 42,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ],
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignored =&gt; 19,
&nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; ];

&nbsp; &nbsp; is $struct[1]&lt;key&gt;&lt;subkey&gt;[1], 42, &quot;basic sanity (1)&quot;;

&nbsp; &nbsp; my $abbrev := $struct[1]&lt;key&gt;&lt;subkey&gt;[1];
&nbsp; &nbsp; is $abbrev, 42,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;using a multidimensional structure as RHS in a binding op works (1)&quot;;

&nbsp; &nbsp; $struct[1]&lt;key&gt;&lt;subkey&gt;[1] = 43;
&nbsp; &nbsp; is $abbrev, 43,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;using a multidimensional structure as RHS in a binding op works (2)&quot;;

&nbsp; &nbsp; $abbrev = 44;
&nbsp; &nbsp; is $struct[1]&lt;key&gt;&lt;subkey&gt;[1], 44,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;using a multidimensional structure as RHS in a binding op works (3)&quot;;
}

# Nested refs as LHS in a binding operation
{
&nbsp; &nbsp; my $struct = [
&nbsp; &nbsp; &nbsp; &nbsp; &quot;ignored&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key =&gt; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignored =&gt; 23,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subkey &nbsp;=&gt; [
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;ignored&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 42,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ],
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignored =&gt; 19,
&nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; ];

&nbsp; &nbsp; is $struct[1]&lt;key&gt;&lt;subkey&gt;[1], 42, &quot;basic sanity (2)&quot;;

&nbsp; &nbsp; my $abbrev = 30;
&nbsp; &nbsp; try { $struct[1]&lt;key&gt;&lt;subkey&gt;[1] := $abbrev };
&nbsp; &nbsp; is $abbrev, 30,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;using a multidimensional structure as LHS in a binding op works (1)&quot;;

&nbsp; &nbsp; $struct[1]&lt;key&gt;&lt;subkey&gt;[1] = 31;
&nbsp; &nbsp; is $abbrev, 31,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;using a multidimensional structure as LHS in a binding op works (2)&quot;, :todo&lt;bug&gt;;

&nbsp; &nbsp; $abbrev = 32;
&nbsp; &nbsp; is $struct[1]&lt;key&gt;&lt;subkey&gt;[1], 32,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;using a multidimensional structure as LHS in a binding op works (3)&quot;, :todo&lt;bug&gt;;
}

# Evil more evil structure: with an embedded &quot;is rw&quot; sub!
# As RHS...
{
&nbsp; &nbsp; my $innerstruct = {
&nbsp; &nbsp; &nbsp; &nbsp; ignored =&gt; 23,
&nbsp; &nbsp; &nbsp; &nbsp; subkey &nbsp;=&gt; [
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;ignored&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 42,
&nbsp; &nbsp; &nbsp; &nbsp; ],
&nbsp; &nbsp; };

&nbsp; &nbsp; my sub get_innerstruct () is rw { $innerstruct }

&nbsp; &nbsp; my $struct = [
&nbsp; &nbsp; &nbsp; &nbsp; &quot;ignored&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key &nbsp; &nbsp; =&gt; &amp;get_innerstruct,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignored =&gt; 19,
&nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; ];

&nbsp; &nbsp; is $struct[1]&lt;key&gt;()&lt;subkey&gt;[1], 42, &quot;basic sanity (3)&quot;;

&nbsp; &nbsp; my $abbrev := $struct[1]&lt;key&gt;()&lt;subkey&gt;[1];
&nbsp; &nbsp; is $abbrev, 42,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;using a multidimensional structure with an embedded sub as RHS works (1)&quot;;

&nbsp; &nbsp; $struct[1]&lt;key&gt;()&lt;subkey&gt;[1] = 43;
&nbsp; &nbsp; is $abbrev, 43,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;using a multidimensional structure with an embedded sub as RHS works (2)&quot;;

&nbsp; &nbsp; $abbrev = 44;
&nbsp; &nbsp; is $struct[1]&lt;key&gt;()&lt;subkey&gt;[1], 44,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;using a multidimensional structure with an embedded sub as RHS works (3)&quot;;
}

# ...and as LHS
{
&nbsp; &nbsp; my $innerstruct = {
&nbsp; &nbsp; &nbsp; &nbsp; ignored =&gt; 23,
&nbsp; &nbsp; &nbsp; &nbsp; subkey &nbsp;=&gt; [
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;ignored&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 42,
&nbsp; &nbsp; &nbsp; &nbsp; ],
&nbsp; &nbsp; };

&nbsp; &nbsp; my sub get_innerstruct () is rw { $innerstruct }

&nbsp; &nbsp; my $struct = [
&nbsp; &nbsp; &nbsp; &nbsp; &quot;ignored&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key &nbsp; &nbsp; =&gt; &amp;get_innerstruct,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignored =&gt; 19,
&nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; ];

&nbsp; &nbsp; is $struct[1]&lt;key&gt;()&lt;subkey&gt;[1], 42, &quot;basic sanity (4)&quot;;

&nbsp; &nbsp; my $abbrev = 30;
&nbsp; &nbsp; try { $struct[1]&lt;key&gt;()&lt;subkey&gt;[1] := $abbrev };
&nbsp; &nbsp; is $abbrev, 30,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;using a multidimensional structure with an embedded sub as LHS works (1)&quot;;

&nbsp; &nbsp; $struct[1]&lt;key&gt;()&lt;subkey&gt;[1] = 31;
&nbsp; &nbsp; is $abbrev, 31,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;using a multidimensional structure with an embedded sub as LHS works (2)&quot;, :todo&lt;bug&gt;;

&nbsp; &nbsp; $abbrev = 32;
&nbsp; &nbsp; is $struct[1]&lt;key&gt;()&lt;subkey&gt;[1], 32,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;using a multidimensional structure with an embedded sub as LHS works (3)&quot;, :todo&lt;bug&gt;;
}

# Binding should cope with a subtree being redefined.
# As RHS...
{
&nbsp; &nbsp; my $struct = [
&nbsp; &nbsp; &nbsp; &nbsp; &quot;ignored&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key =&gt; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignored =&gt; 23,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subkey &nbsp;=&gt; [
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;ignored&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 42,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ],
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignored =&gt; 19,
&nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; ];

&nbsp; &nbsp; is $struct[1]&lt;key&gt;&lt;subkey&gt;[1], 42, &quot;basic sanity (5)&quot;;

&nbsp; &nbsp; my $abbrev := $struct[1]&lt;key&gt;&lt;subkey&gt;[1];
&nbsp; &nbsp; is $abbrev, 42,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;RHS binding should cope with a subtree being redefined (1)&quot;;

&nbsp; &nbsp; $struct[1]&lt;key&gt;&lt;subkey&gt;[1] = 43;
&nbsp; &nbsp; is $abbrev, 43,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;RHS binding should cope with a subtree being redefined (2)&quot;;

&nbsp; &nbsp; $struct[1] = &quot;foo&quot;;
&nbsp; &nbsp; is $struct[1], &quot;foo&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;RHS binding should cope with a subtree being redefined (3)&quot;;
&nbsp; &nbsp; is $abbrev, 43,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;RHS binding should cope with a subtree being redefined (4)&quot;;

&nbsp; &nbsp; $abbrev = 44;
&nbsp; &nbsp; is $abbrev, 44,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;RHS binding should cope with a subtree being redefined (5)&quot;;
&nbsp; &nbsp; is $struct[1], &quot;foo&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;RHS binding should cope with a subtree being redefined (6)&quot;;
}

# ...and as LHS
{
&nbsp; &nbsp; my $struct = [
&nbsp; &nbsp; &nbsp; &nbsp; &quot;ignored&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key =&gt; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignored =&gt; 23,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subkey &nbsp;=&gt; [
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;ignored&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 42,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ],
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignored =&gt; 19,
&nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; ];

&nbsp; &nbsp; is $struct[1]&lt;key&gt;&lt;subkey&gt;[1], 42, &quot;basic sanity (6)&quot;;

&nbsp; &nbsp; my $abbrev = 42;
&nbsp; &nbsp; try { $struct[1]&lt;key&gt;&lt;subkey&gt;[1] := $abbrev };
&nbsp; &nbsp; is $abbrev, 42,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;LHS binding should cope with a subtree being redefined (1)&quot;;

&nbsp; &nbsp; $struct[1]&lt;key&gt;&lt;subkey&gt;[1] = 43;
&nbsp; &nbsp; is $abbrev, 43,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;LHS binding should cope with a subtree being redefined (2)&quot;, :todo&lt;bug&gt;;

&nbsp; &nbsp; $struct[1] = &quot;foo&quot;;
&nbsp; &nbsp; is $struct[1], &quot;foo&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;LHS binding should cope with a subtree being redefined (3)&quot;;
&nbsp; &nbsp; is $abbrev, 43,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;LHS binding should cope with a subtree being redefined (4)&quot;, :todo&lt;bug&gt;;

&nbsp; &nbsp; $abbrev = 44;
&nbsp; &nbsp; is $abbrev, 44,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;LHS binding should cope with a subtree being redefined (5)&quot;;
&nbsp; &nbsp; is $struct[1], &quot;foo&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;LHS binding should cope with a subtree being redefined (6)&quot;;
}

# Tests for binding an element of a structure to an element of another
# structure.
{
&nbsp; &nbsp; my $foo = [
&nbsp; &nbsp; &nbsp; &nbsp; &quot;ignored&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key =&gt; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignored =&gt; 1,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subkey &nbsp;=&gt; [
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;ignored&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ],
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignored =&gt; 3,
&nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; ];

&nbsp; &nbsp; my $bar = [
&nbsp; &nbsp; &nbsp; &nbsp; &quot;ignored&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key =&gt; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignored =&gt; 4,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subkey &nbsp;=&gt; [
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;ignored&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ],
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignored =&gt; 6,
&nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; ];

&nbsp; &nbsp; try { $bar[1]&lt;key&gt;&lt;subkey&gt; := $foo[1]&lt;key&gt; };
&nbsp; &nbsp; is try{ $bar[1]&lt;key&gt;&lt;subkey&gt;&lt;subkey&gt;[1] }, 2,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;binding an element of a structure to an element of another structure works (1)&quot;, :todo&lt;bug&gt;;

&nbsp; &nbsp; try { $foo[1]&lt;key&gt;&lt;subkey&gt;[1] = 7 };
&nbsp; &nbsp; is try{ $bar[1]&lt;key&gt;&lt;subkey&gt;&lt;subkey&gt;[1] }, 7,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;binding an element of a structure to an element of another structure works (2)&quot;, :todo&lt;bug&gt;;

&nbsp; &nbsp; try { $bar[1]&lt;key&gt;&lt;subkey&gt;&lt;subkey&gt;[1] = 8 };
&nbsp; &nbsp; is try { $foo[1]&lt;key&gt;&lt;subkey&gt;[1] }, 8,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;binding an element of a structure to an element of another structure works (3)&quot;, :todo&lt;bug&gt;;
}

# Tests for binding an element of a structure to an element of *the same*
# structure, effectively creating an infinite structure.
{
&nbsp; &nbsp; my $struct = [
&nbsp; &nbsp; &nbsp; &nbsp; &quot;ignored&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key =&gt; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foo &nbsp; &nbsp;=&gt; &quot;bar&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subkey =&gt; [
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;ignored&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 100,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ],
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignored =&gt; 200,
&nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; ];

&nbsp; &nbsp; try { $struct[1]&lt;key&gt;&lt;subkey&gt;[1] := $struct[1]&lt;key&gt; };
&nbsp; &nbsp; is try { $struct[1]&lt;key&gt;&lt;subkey&gt;[1]&lt;foo&gt; }, &quot;bar&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;binding an element of a structure to an element of the same structure works (1)&quot;, :todo&lt;bug&gt;;

&nbsp; &nbsp; try { $struct[1]&lt;key&gt;&lt;subkey&gt;[1]&lt;foo&gt; = &quot;new_value&quot; };
&nbsp; &nbsp; is $struct[1]&lt;key&gt;&lt;foo&gt;, &quot;new_value&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;binding an element of a structure to an element of the same structure works (2)&quot;, :todo&lt;bug&gt;;

&nbsp; &nbsp; $struct[1]&lt;key&gt;&lt;foo&gt; = &quot;very_new_value&quot;;
&nbsp; &nbsp; is try { $struct[1]&lt;key&gt;&lt;subkey&gt;[1]&lt;foo&gt; }, &quot;very_new_value&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;binding an element of a structure to an element of the same structure works (3)&quot;, :todo&lt;bug&gt;;

&nbsp; &nbsp; $struct[1]&lt;key&gt;&lt;subkey&gt;[1] = 23;
&nbsp; &nbsp; is $struct[1]&lt;key&gt;, 23,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;binding an element of a structure to an element of the same structure works (4)&quot;, :todo&lt;bug&gt;;
}

# Test that rebinding to some other value really breaks up the binding.
{
&nbsp; &nbsp; my $struct = [
&nbsp; &nbsp; &nbsp; &nbsp; &quot;ignored&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key =&gt; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignored =&gt; 23,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subkey &nbsp;=&gt; [
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;ignored&quot;,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 42,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ],
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ignored =&gt; 19,
&nbsp; &nbsp; &nbsp; &nbsp; },
&nbsp; &nbsp; ];

&nbsp; &nbsp; is $struct[1]&lt;key&gt;&lt;subkey&gt;[1], 42, &quot;basic sanity (7)&quot;;

&nbsp; &nbsp; my $abbrev := $struct[1]&lt;key&gt;&lt;subkey&gt;[1];
&nbsp; &nbsp; is $abbrev, 42,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;rebinding to some other value destroys the previous binding (1)&quot;;

&nbsp; &nbsp; $struct[1]&lt;key&gt;&lt;subkey&gt;[1] = 43;
&nbsp; &nbsp; is $abbrev, 43,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;rebinding to some other value destroys the previous binding (2)&quot;;

&nbsp; &nbsp; $abbrev = 44;
&nbsp; &nbsp; is $struct[1]&lt;key&gt;&lt;subkey&gt;[1], 44,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;rebinding to some other value destroys the previous binding (3)&quot;;

&nbsp; &nbsp; $abbrev := 45;
&nbsp; &nbsp; is $abbrev, 45,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;rebinding to some other value destroys the previous binding (4)&quot;;
&nbsp; &nbsp; is $struct[1]&lt;key&gt;&lt;subkey&gt;[1], 44,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;rebinding to some other value destroys the previous binding (5)&quot;;
}</pre>
</div>


<a href="#" onclick="return tog_quote(58);">
<div ID="header_shown_58" style="display: none;">
- Hide the snippet from t/operators/binding/scalars.t (line 9 ~ line 14) -
</div>
<div ID="header_hidden_58" style="display: block;">
- Show the snippet from t/operators/binding/scalars.t (line 9 ~ line 14) -
</div>
</a>
<div ID="hide_58" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S03/&quot;Binding&quot;&gt;

=cut

plan 28;</pre>
</div>


<a href="#" onclick="return tog_quote(56);">
<div ID="header_shown_56" style="display: none;">
- Hide the snippet from t/operators/binding/subs.t (line 5 ~ line 85) -
</div>
<div ID="header_hidden_56" style="display: block;">
- Show the snippet from t/operators/binding/subs.t (line 5 ~ line 85) -
</div>
</a>
<div ID="hide_56" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;Binding&quot;&gt;

# Tests for binding the return value of subroutines (both as RHS and LHS).

plan 8;

{
&nbsp; &nbsp; my sub foo { 42 }

&nbsp; &nbsp; my $var := foo();
&nbsp; &nbsp; is $var, 42,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;binding a var to the return value of a sub (a constant) works (1)&quot;;

&nbsp; &nbsp; dies_ok { $var = 23 },
&nbsp; &nbsp; &nbsp; &nbsp; &quot;binding a var to the return value of a sub (a constant) works (2)&quot;;
}

=begin unspecced

{
&nbsp; &nbsp; my sub foo { 42 }

&nbsp; &nbsp; dies_ok { foo() := 23 },
&nbsp; &nbsp; &nbsp; &nbsp; &quot;using the constant return value of a sub as the LHS in a binding operation dies&quot;;
}

There're two ways one can argue:
* 42 is constant, and rebinding constants doesn't work, so foo() := 23 should
&nbsp; die.
* 42 is constant, but the implicit return() packs the constant 42 into a
&nbsp; readonly 42, and readonly may be rebound.
&nbsp; To clear the terminology,
&nbsp; &nbsp; 42 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 42 is a constant
&nbsp; &nbsp; sub foo ($a) {...} &nbsp;# $a is a readonly

=end unspecced

=cut

{
&nbsp; &nbsp; my sub foo { my $var = 42; $var }

&nbsp; &nbsp; my $var := foo();
&nbsp; &nbsp; is $var, 42,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;binding a var to the return value of a sub (a variable) works (1)&quot;;

&nbsp; &nbsp; dies_ok { $var = 23 },
&nbsp; &nbsp; &nbsp; &nbsp; &quot;binding a var to the return value of a sub (a variable) works (2)&quot;, :todo&lt;bug&gt;;
}

{
&nbsp; &nbsp; my sub foo is rw { my $var = 42; $var }

&nbsp; &nbsp; my $var := foo();
&nbsp; &nbsp; is $var, 42,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;binding a var to the return value of an 'is rw' sub (a variable) works (1)&quot;;

&nbsp; &nbsp; lives_ok { $var = 23 },
&nbsp; &nbsp; &nbsp; &nbsp; &quot;binding a var to the return value of an 'is rw' sub (a variable) works (2)&quot;;
&nbsp; &nbsp; is $var, 23,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;binding a var to the return value of an 'is rw' sub (a variable) works (3)&quot;;
}

{
&nbsp; &nbsp; my sub foo is rw { my $var = 42; $var }

&nbsp; &nbsp; lives_ok { foo() := 23 },
&nbsp; &nbsp; &nbsp; &nbsp; &quot;using the variable return value of an 'is rw' sub as the LHS in a binding operation works&quot;, :todo&lt;bug&gt;;
}

=for discussion

Should the constant return value be autopromoted to a var? Or should it stay a
constant?

{
&nbsp; &nbsp; my sub foo is rw { 42 }

&nbsp; &nbsp; dies_ok/lives_ok { foo() := 23 },
&nbsp; &nbsp; &nbsp; &nbsp; &quot;using the constant return value of an 'is rw' sub as the LHS in a binding operation behaves correctly&quot;;
}</pre>
</div>


<p>A new form of assignment is present in Perl 6, called <i>binding</i>, used in place of typeglob assignment. It is performed with the <code>:=</code> operator. Instead of replacing the value in a container like normal assignment, it replaces the container itself. For instance:</p>

<a href="#" onclick="return tog_quote(57);">
<div ID="header_shown_57" style="display: none;">
- Hide the snippet from t/operators/binding/scalars.t (line 15 ~ line 124) -
</div>
<div ID="header_hidden_57" style="display: block;">
- Show the snippet from t/operators/binding/scalars.t (line 15 ~ line 124) -
</div>
</a>
<div ID="hide_57" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;Binding&quot; /replaces the container itself\. &nbsp;For instance:/&gt;
# Basic scalar binding tests
{
&nbsp; my $x = 'Just Another';
&nbsp; is($x, 'Just Another', 'normal assignment works');

&nbsp; my $y := $x;
&nbsp; is($y, 'Just Another', 'y is now bound to x');

&nbsp; ok($y =:= $x, 'y is bound to x (we checked with the =:= identity op)');

&nbsp; my $z = $x;
&nbsp; is($z, 'Just Another', 'z is not bound to x');

&nbsp; ok(!($z =:= $x), 'z is not bound to x (we checked with the =:= identity op)');

&nbsp; $y = 'Perl Hacker';
&nbsp; is($y, 'Perl Hacker', 'y has been changed to &quot;Perl Hacker&quot;');
&nbsp; is($x, 'Perl Hacker', 'x has also been changed to &quot;Perl Hacker&quot;');

&nbsp; is($z, 'Just Another', 'z is still &quot;Just Another&quot; because it was not bound to x');
}

# Binding and $CALLER::
{
&nbsp; sub bar {
&nbsp; &nbsp; return $CALLER::a eq $CALLER::b;
&nbsp; }

&nbsp; sub foo {
&nbsp; &nbsp; my $a is context = &quot;foo&quot;;
&nbsp; &nbsp; my $b is context := $a;
&nbsp; &nbsp; return bar(); # &amp;&amp; bar2();
&nbsp; }

&nbsp; ok(foo(), &quot;CALLER resolves bindings in caller's dynamic scope&quot;);
}

# Binding to swap
{
&nbsp; my $a = &quot;a&quot;;
&nbsp; my $b = &quot;b&quot;;

&nbsp; ($a, $b) := ($b, $a);
&nbsp; is($a, 'b', '$a has been changed to &quot;b&quot;');
&nbsp; is($b, 'a', '$b has been changed to &quot;a&quot;');

&nbsp; $a = &quot;c&quot;;
&nbsp; is($a, 'c', 'binding to swap didn\'t make the vars readonly');
}

# More tests for binding a list
{
&nbsp; my $a = &quot;a&quot;;
&nbsp; my $b = &quot;b&quot;;
&nbsp; my $c = &quot;c&quot;;

&nbsp; ($a, $b) := ($c, $c);
&nbsp; is($a, 'c', 'binding a list literal worked (1)');
&nbsp; is($b, 'c', 'binding a list literal worked (2)');

&nbsp; $c = &quot;d&quot;;
&nbsp; is($a, 'd', 'binding a list literal really worked (1)');
&nbsp; is($b, 'd', 'binding a list literal really worked (2)');
}

# Binding subroutine parameters
# XXX! When executed in interactive Pugs, the following test works!
{
&nbsp; my $a;
&nbsp; my $b = sub($arg) { $a := $arg };
&nbsp; my $val = 42;

&nbsp; $b($val);
&nbsp; is $a, 42, &quot;bound readonly sub param was bound correctly (1)&quot;;
&nbsp; $val++;
&nbsp; is $a, 43, &quot;bound readonly sub param was bound correctly (2)&quot;;

&nbsp; dies_ok { $a = 23 },
&nbsp; &nbsp; &quot;bound readonly sub param remains readonly (1)&quot;;
&nbsp; is $a, 43,
&nbsp; &nbsp; &quot;bound readonly sub param remains readonly (2)&quot;;
&nbsp; is $val, 43,
&nbsp; &nbsp; &quot;bound readonly sub param remains readonly (3)&quot;;
}

{
&nbsp; my $a;
&nbsp; my $b = sub($arg is rw) { $a := $arg };
&nbsp; my $val = 42;

&nbsp; $b($val);
&nbsp; is $a, 42, &quot;bound rw sub param was bound correctly (1)&quot;;
&nbsp; $val++;
&nbsp; is $a, 43, &quot;bound rw sub param was bound correctly (2)&quot;;

&nbsp; lives_ok { $a = 23 }, &quot;bound rw sub param remains rw (1)&quot;;
&nbsp; is $a, 23, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;bound rw sub param remains rw (2)&quot;;
&nbsp; is $val, 23, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;bound rw sub param remains rw (3)&quot;;
}

# := actually takes subroutine parameter list
{
&nbsp; my $a;
&nbsp; eval '(:$a) := (:a&lt;foo&gt;)';
&nbsp; is($a, &quot;foo&quot;, &quot;bound keyword&quot;, :todo);
&nbsp; my @tail;
&nbsp; eval '($a, *@tail) := (1, 2, 3)';
&nbsp; ok($a == 1 and ~@tail eq '2 3', 'bound slurpy', :todo);
}</pre>
</div>


<pre>    my $x = &#39;Just Another&#39;;
    my $y := $x;
    $y = &#39;Perl Hacker&#39;;</pre>

<p>After this, both <code>$x</code> and <code>$y</code> contain the string <code>&#34;Perl Hacker&#34;</code>, since they are really just two different names for the same variable.</p>

<p>There is another variant, spelled <code>::=</code>, that does the same thing at compile time.</p>

<p>There is also an identity test, <code>=:=</code>, which tests whether two names are bound to the same underlying variable. <code>$x =:= $y</code> would return true in the above example.</p>

<p>The binding fails if the type of the variable being bound is sufficiently inconsistent with the type of the current declaration.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Declarators"
>Declarators</a></h1>

<a href="#" onclick="return tog_quote(13);">
<div ID="header_shown_13" style="display: none;">
- Hide the snippet from t/var/chained.t (line 4 ~ line 39) -
</div>
<div ID="header_hidden_13" style="display: block;">
- Show the snippet from t/var/chained.t (line 4 ~ line 39) -
</div>
</a>
<div ID="hide_13" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/&quot;Declarators&quot;&gt;
# This section describes declarators like my, our, etc
# Note that the usage of declarators on the RHS is not spec'ed yet,
# but works like Perl 5. Also note that the list if declarators here
# does not match the list described in the referenced specs. 

plan 8;

# sanity: declarations and very simple use (scoping tests come later)
# we take care to use different names to avoid other *kinds* of insanity.

is((try { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;my $a1 = my &nbsp; &nbsp;$b1 = 42; $b1++; ($a1, $b1) }).perl, '(\\42, \\43)', &quot;chained my&quot;);
is((try { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;my $a2 = our &nbsp; $b2 = 42; $b2++; ($a2, $b2) }).perl, '(\\42, \\43)', &quot;chained my, our&quot;);
is((try { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;my $a3 = let &nbsp; $b3 = 42; $b3++; ($a3, $b3) }).perl, '(\\42, \\43)', &quot;chained my, let&quot;);
is((try { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;my $a4 = env &nbsp; $b4 = 42; $b4++; ($a4, $b4) }).perl, '(\\42, \\43)', &quot;chained my, env&quot;);
is((try { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;my $a5 = state $b5 = 42; $b5++; ($a5, $b5) }).perl, '(\\42, \\43)', &quot;chained my, state&quot;);
is((try { my $b6 = 10; my $a6 = temp &nbsp;$b6 = 42; $b6++; ($a6, $b6) }).perl, '(\\42, \\43)', &quot;chained my, temp&quot;, :todo&lt;bug&gt;);

# scoping

is((try {
&nbsp; &nbsp; my $sa1 = 10;
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; my $sa1 = our $sb1 = 42;
&nbsp; &nbsp; }
&nbsp; &nbsp; ($sa1, $sb1);
&nbsp; }).perl, '(\\10, \\42)', &quot;scoping my, our&quot;);

dies_ok {
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; our $sa2 = my $sb2 = 42;
&nbsp; &nbsp; }
&nbsp; &nbsp; ($sa2, $sb2);
&nbsp; }, &quot;scoping our, my ('our' doesn't leak)&quot;;

# XXX: add more!</pre>
</div>


<p>The list of variable declarators has expanded from <code>my</code> and <code>our</code> to include:</p>

<pre>    my $foo             # ordinary lexically scoped variable
    our $foo            # lexically scoped alias to package variable
    has $foo            # object attribute
    state $foo          # persistent lexical (cloned with closures)
    constant $foo       # lexically scoped compile-time constant</pre>

<p>Variable declarators such as <code>my</code> now take a <i>signature</i> as their argument. (The syntax of function signatures is described more fully in S06.) The parentheses around the signature may be omitted for a simple declaration that declares a single variable, along with its associated type and traits. Parentheses must always be used when declaring multiple parameters:</p>

<pre>    my $a;              # okay
    my ($b, $c);        # okay
    my $b, $c;          # wrong: &#34;Use of undeclared variable: $c&#34;</pre>

<p>Types occurring between the declarator and the signature are distributed into each variable:</p>

<pre>    my Dog ($b, $c);
    my (Dog $b, Dog $c);    # same thing</pre>

<p>[XXX the following probably belongs in S06.] The syntax for constructing a <code>Signature</code> object when the parser isn&#39;t already expecting one is:</p>

<pre>    :(Dog $a, *@c)</pre>

<p>This might be used like this:</p>

<pre>    my $sig = :(Dog $a, *@c);</pre>

<p>Signatures are expected after declarators such as <code>my</code>, <code>sub</code>, <code>method</code>, <code>rule</code>, etc. In such declarators the colon may be omitted. But it&#39;s also legal to use it:</p>

<pre>    my :($b, $c);               # okay
    sub foo :($a,$b) {...}      # okay</pre>

<p>The <code>-&#62;</code> &#34;pointy block&#34; token also introduces a signature, but in this case you must omit both the colon and the parens. For instance, if you&#39;re defining the &#34;loop variable&#34; of a loop block:</p>

<pre>    for @dogpound -&#62; Dog $fido { ... }</pre>

<p>If a signature is assigned to (whether declared or colon form), the signature is converted to a list of lvalue variables and the ordinary rules of assignment apply, except that the evaluation of the right side and the assignment happens at time determined by the declarator. (With <code>my</code> this is always when an ordinary assignment would happen.) If the signature is too complicated to convert to an assignment, a compile-time error occurs. Assignment to a signature makes the same scalar/list distinction as ordinary assignment, so</p>

<pre>    my $a = foo();      # foo in scalar context
    my ($a) = foo();    # foo in list context</pre>

<p>If a signature is bound to an argument list, then the binding of the arguments proceeds as if the signature were the formal parameters for a function, except that, unlike in a function call, the parameters are bound <code>rw</code> by default rather than <code>readonly</code>. See Binding above.</p>

<p>Note that <code>temp</code> and <code>let</code> are <i>not</i> variable declarators, because their effects only take place at runtime. Therefore, they take an ordinary lvalue object as their argument. See S04 for more details.</p>

<p>There are a number of other declarators that are not variable declarators. These include both type declarators:</p>

<pre>    package Foo
    module Foo
    class Foo
    role Foo
    subset Foo</pre>

<p>and code declarators:</p>

<pre>    sub foo
    method foo
    submethod foo
    multi foo
    proto foo
    macro foo
    quote qX
    regex foo
    rule foo
    token foo</pre>

<p>These all have their uses and are explained in subsequent Synopses.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Argument_List_Interpolating"
>Argument List Interpolating</a></h1>

<p>Perl 5 forced interpolation of a function&#39;s argument list by use of the <code>&#38;</code> prefix. That option is no longer available in Perl 6, so instead the <code>|</code> prefix operator serves as an interpolator, by casting its operand to a <code>Capture</code> object and inserting the capture&#39;s parts into the current argument list. This operator can be used to interpolate an <code>Array</code> or <code>Hash</code> into the current call, as positional and named arguments respectively.</p>

<a href="#" onclick="return tog_quote(34);">
<div ID="header_shown_34" style="display: none;">
- Hide the snippet from t/blocks/splatty_in_caller_position.t (line 7 ~ line 29) -
</div>
<div ID="header_hidden_34" style="display: block;">
- Show the snippet from t/blocks/splatty_in_caller_position.t (line 7 ~ line 29) -
</div>
</a>
<div ID="hide_34" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Argument List Interpolating/&quot;interpolate&quot;&gt;

# try to flatten the args for baz() to match

sub baz ($a, $b) { return &quot;a: $a b: $b&quot;}
sub invoke (*@args) { baz(|@args) }

my $val;
lives_ok {
&nbsp; &nbsp; $val = invoke(1, 2);
}, '... slurpy args flattening and matching parameters';

is($val, 'a: 1 b: 2', '... slurpy args flattening and matching parameters');

# try to flatten the args for the anon sub to match

sub invoke2 ($f, *@args) { $f(|@args) }; 
is(try { invoke2(sub ($a, $b) { return &quot;a: $a b: $b&quot;}, 1, 2) }, 'a: 1 b: 2', 
&nbsp; &nbsp; '... slurpy args flattening and matching parameters');

dies_ok {
&nbsp; &nbsp; invoke2(sub ($a, $b) { return &quot;a: $a b: $b&quot;}, 1, 2, 3);
}, '... slurpy args flattening and not matching because of too many parameters'; &nbsp;</pre>
</div>


<p>Note that the resulting arguments still must comply with the subroutine&#39;s signature, but the presence of <code>|</code> defers that test until run time for that argument (and for any subsequent arguments):</p>

<pre>    my @args := @foo, @bar;
    push |@args;</pre>

<p>is equivalent to:</p>

<pre>    push @foo: @bar;</pre>

<p>which is just another way to write:</p>

<pre>    @foo.push(@bar);</pre>

<p>Unlike <code>[,]</code>, <code>|</code> does not flatten its argument, but instead directly converts its argument into a <code>Capture</code>:</p>

<pre>    my @args = \$x, 1, 2, 3;
    say [,] @args;  # say($x: 1, 2, 3);
    say |@args;     # say(\$x, 1, 2, 3);</pre>

<p>Because of this, <code>|%args</code> always produces named arguments, and <code>|@args</code> always produces positional arguments.</p>

<p>In list context, a <code>Scalar</code> holding an <code>Array</code> object does not flatten. Hence</p>

<pre>    $bar = @bar;
    @foo.push($bar);</pre>

<p>merely pushes a single <code>Array</code> object onto <code>@foo</code>. You can explicitly flatten it in one of these ways:</p>

<pre>    @foo.push(@$bar);
    @foo.push($bar[]);
    @foo.push(|$bar);</pre>

<p>Those three forms work because the slurpy array in <code>push</code>&#39;s signature flattens the <code>Array</code> object into a list argument.</p>

<p>Note that the first two forms also allow you to specify list context on assignment:</p>

<pre>    @$bar = 1,2,3;
    $bar[] = 1,2,3;</pre>

<p>For long lvalue expressions, the second form can keep the &#34;arrayness&#34; of the lvalue close to the assignment operator:</p>

<pre>    $foo.bar.baz.bletch.whatever.attr[] = 1,2,3;</pre>

<p>Otherwise you&#39;d have to write:</p>

<pre>    @($foo.bar.baz.bletch.whatever.attr) = 1,2,3;</pre>

<p>and remember the <code>@</code> at the front until you get to the <code>=</code>.</p>

<p>The empty <code>[]</code> and <code>.[]</code> postfix operators are interpreted as zero-dimensional slices returning the entire array, not null slices returning no elements. Likewise for <code>{}</code> and <code>.{}</code> on hashes, as well as the <code>&#60;&#62;</code>, <code>.&#60;&#62;</code>, <code>&#171;&#187;</code>, and <code>.&#171;&#187;</code> constant and interpolating slice subscripting forms.</p>

<p>The <code>|</code> operator interpolates lazily for <code>Array</code> and <code>Range</code> objects. To get an immediate interpolation like Perl 5 does, add the <code>eager</code> list operator:</p>

<pre>    func(|(1..Inf));       # works fine
    func(|eager 1..Inf);   # never terminates (well, actually...)</pre>

<p>To interpolate a function&#39;s return value, you can say:</p>

<pre>    push |func();</pre>

<p>Within such an argument list, function return values are automatically exploded into their various parts, as if you&#39;d said:</p>

<pre>    my $capture = \(func());
    push $$capture: @$capture, %$capture;</pre>

<p>or some such. The <code>|</code> then handles the various zones appropriately depending on the context. An invocant only makes sense as the first argument to the outer function call. An invocant inserted anywhere else just becomes a positional argument at the front of its list, as if its colon changed back to a comma.</p>

<p>If you already have a capture variable, you can interpolate all of its bits at once using the <code>prefix:&#60;|&#62;</code> operator:</p>

<pre>    my \$capture := func();
    push |$capture;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Feed_operators"
>Feed operators</a></h1>

<a href="#" onclick="return tog_quote(12);">
<div ID="header_shown_12" style="display: none;">
- Hide the snippet from t/operators/feed.t (line 12 ~ line 57) -
</div>
<div ID="header_hidden_12" style="display: block;">
- Show the snippet from t/operators/feed.t (line 12 ~ line 57) -
</div>
</a>
<div ID="hide_12" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S03/&quot;Feed operators&quot;&gt;

=cut

plan 7;

{
&nbsp; &nbsp; my @a = (1, 2);
&nbsp; &nbsp; my (@b, @c);
&nbsp; &nbsp; 
&nbsp; &nbsp; eval '@a ==&gt; @b';
&nbsp; &nbsp; #eval '@c &lt;== @a'; # this yields the error:
&nbsp; &nbsp; #Fail: cannot cast into a handle: VList [VInt 1,VInt 2]

&nbsp; &nbsp; is(~@b, ~@a, &quot;ltr feed as simple assignment&quot;, :todo);
&nbsp; &nbsp; is(~@c, ~@a, &quot;rtl feed as simple assignment&quot;, :todo);
};

{
&nbsp; &nbsp; my @a = (1 .. 5);
&nbsp; &nbsp; my @e = (2, 4);

&nbsp; &nbsp; my (@b, @c);
&nbsp; &nbsp; eval '@a ==&gt; grep { ($_ % 2) == 0 } ==&gt; @b';
&nbsp; &nbsp; #eval '@c &lt;== grep { ($_ % 2) == 0 } &lt;== @a';

&nbsp; &nbsp; is(~@b, ~@e, &quot;array ==&gt; grep ==&gt; result&quot;, :todo);
&nbsp; &nbsp; is(~@c, ~@e, &quot;result &lt;== grep &lt;== array&quot;, :todo);
};

{
&nbsp; &nbsp; my ($got_x, $got_y, @got_z);
&nbsp; &nbsp; sub foo ($x, $y?, *@z) {
&nbsp; &nbsp; &nbsp; &nbsp; $got_x = $x;
&nbsp; &nbsp; &nbsp; &nbsp; $got_y = $y;
&nbsp; &nbsp; &nbsp; &nbsp; @got_z = @z;
&nbsp; &nbsp; }

&nbsp; &nbsp; my @a = (1 .. 5);

&nbsp; &nbsp; eval '@a ==&gt; foo &quot;x&quot;';

&nbsp; &nbsp; is($got_x, &quot;x&quot;, &quot;x was passed as explicit param&quot;, :todo);
&nbsp; &nbsp; is($got_y, undef, &quot;optional param y was not bound to fed list&quot;);
&nbsp; &nbsp; is(~@got_z, ~@a, '...slurpy array *@z got it', :todo);
};</pre>
</div>


<p>The new operators <code>==&#62;</code> and <code>&#60;==</code> are akin to UNIX pipes, but work with functions that accept and return lists. Since these lists are composed of discrete objects and not liquids, we call these <i>feed</i> operators rather than pipes. For example,</p>

<pre>     @result = map { floor($^x / 2) },
                 grep { /^ \d+ $/ },
                   @data;</pre>

<p>can also now be written with rightward feeds as:</p>

<pre>     @data ==&#62; grep { /^ \d+ $/ }
           ==&#62; map { floor($^x / 2) }
           ==&#62; @result;</pre>

<p>or with leftward feeds as:</p>

<pre>     @result &#60;== map { floor($^x / 2) }
             &#60;== grep { /^ \d+ $/ }
             &#60;== @data;</pre>

<p>Either form more clearly indicates the flow of data. See S06 for more of the (less-than-obvious) details on these two operators.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Invocant_marker"
>Invocant marker</a></h1>

<p>An appended <code>:</code> marks the invocant when using the indirect-object syntax for Perl 6 method calls. The following two statements are equivalent:</p>

<pre>    $hacker.feed(&#39;Pizza and cola&#39;);
    feed $hacker: &#39;Pizza and cola&#39;;</pre>

<p>A colon may also be used on an ordinary method call to indicate that it should be parsed as a list operator:</p>

<pre>    $hacker.feed: &#39;Pizza and cola&#39;;</pre>

<p>This colon is a separate token. A colon prefixing an adverb is not a separate token. Therefore, under the longest-token rule,</p>

<pre>    $hacker.feed:xxx(&#39;Pizza and cola&#39;);</pre>

<p>is tokenized as an adverb applying to the method:</p>

<pre>    $hacker.feed :xxx(&#39;Pizza and cola&#39;);</pre>

<p>not as an xxx sub in the argument list of .feed:</p>

<pre>    $hacker.feed: xxx(&#39;Pizza and cola&#39;);  # wrong</pre>

<p>If you want both meanings of colon, you have to put it twice:</p>

<pre>    $hacker.feed: :xxx(&#39;Pizza and cola&#39;), 1,2,3;</pre>

<p>(For similar reasons it&#39;s required to put whitespace after the colon of a label.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Traversing_arrays_in_parallel"
>Traversing arrays in parallel</a></h1>

<a href="#" onclick="return tog_quote(78);">
<div ID="header_shown_78" style="display: none;">
- Hide the snippet from t/builtins/lists/zip.t (line 9 ~ line 83) -
</div>
<div ID="header_hidden_78" style="display: block;">
- Show the snippet from t/builtins/lists/zip.t (line 9 ~ line 83) -
</div>
</a>
<div ID="hide_78" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S03/&quot;Traversing arrays in parallel&quot;&gt;
L&lt;S29/Container/&quot;=item zip&quot;&gt;

=cut

plan 12;

{
&nbsp; &nbsp; my @a = (0, 2, 4);
&nbsp; &nbsp; my @b = (1, 3, 5);

&nbsp; &nbsp; my @e = (0 .. 5);

&nbsp; &nbsp; my @z; @z = zip(@a; @b);
&nbsp; &nbsp; my @y; @y = (@a ¥ @b);
&nbsp; &nbsp; my @x; @x = (@a Y @b);

&nbsp; &nbsp; is(~@z, ~@e, &quot;simple zip&quot;);
&nbsp; &nbsp; is(~@y, ~@e, &quot;also with yen char&quot;);
&nbsp; &nbsp; is(~@x, ~@e, &quot;also with Y char&quot;);
};

{
&nbsp; &nbsp; my @a = (0, 3);
&nbsp; &nbsp; my @b = (1, 4);
&nbsp; &nbsp; my @c = (2, 5);

&nbsp; &nbsp; my @e = (0 .. 5);

&nbsp; &nbsp; my @z; @z = zip(@a; @b; @c);
&nbsp; &nbsp; my @y; @y = (@a ¥ @b ¥ @c);
&nbsp; &nbsp; my @x; @x = (@a Y @b Y @c);

&nbsp; &nbsp; is(~@z, ~@e, &quot;zip of 3 arrays&quot;);
&nbsp; &nbsp; is(~@y, ~@e, &quot;also with yen char&quot;);
&nbsp; &nbsp; is(~@x, ~@e, &quot;also with Y char&quot;);
};

{
&nbsp; &nbsp; my @a = (0, 4);
&nbsp; &nbsp; my @b = (2, 6);
&nbsp; &nbsp; my @c = (1, 3, 5, 7);

&nbsp; &nbsp; # [((0, 2), 1), ((4, 6), 3), (undef, 5), (undef, 7)]
&nbsp; &nbsp; my $todo = 'Seq(Seq(0,2),1), Seq(Seq(0,2),1), Seq(undef,5), Seq(undef,7)';
&nbsp; &nbsp; my @e = eval $todo;

&nbsp; &nbsp; my @z; @z = zip(zip(@a; @b); @c);
&nbsp; &nbsp; my @y; @y = ((@a ¥ @b) ¥ @c);
&nbsp; &nbsp; my @x; @x = ((@a Y @b) Y @c);

&nbsp; &nbsp; is(~@z, ~@e, &quot;zip of zipped arrays with other array&quot;, :todo&lt;feature&gt;,
&nbsp; &nbsp; &nbsp; &nbsp; :depends&lt;Seq&gt;);
&nbsp; &nbsp; is(~@y, ~@e, &quot;also as ¥&quot;, :todo&lt;feature&gt;, :depends&lt;Seq&gt;);
&nbsp; &nbsp; is(~@x, ~@e, &quot;also as Y&quot;, :todo&lt;feature&gt;, :depends&lt;Seq&gt;);
};

{
&nbsp; &nbsp; my @a = (0, 2);
&nbsp; &nbsp; my @b = (1, 3, 5);
&nbsp; &nbsp; my @e = (0, 1, 2, 3, undef, 5);

&nbsp; &nbsp; my @z = (@a ¥ @b);
&nbsp; &nbsp; is(@z, @e, &quot;zip uses length of longest&quot;);
}

{
&nbsp; &nbsp; my @a;
&nbsp; &nbsp; my @b;

&nbsp; &nbsp; (@a ¥ @b) = (1, 2, 3, 4);
&nbsp; &nbsp; # XXX - The arrays below are most likely Seq's
&nbsp; &nbsp; is(@a, [1, 3], &quot;first half of two zipped arrays as lvalues&quot;, :todo);
&nbsp; &nbsp; is(@b, [2, 4], &quot;second half of the lvalue zip&quot;, :todo);
}</pre>
</div>


<p>In order to support parallel iteration over multiple arrays, Perl 6 has a <code>zip</code> function that builds <code>Seq</code> objects from the elements of two or more arrays.</p>

<pre>    for zip(@names; @codes) -&#62; [$name, $zip] {
        print &#34;Name: $name;   Zip code: $zip\n&#34;;
    }</pre>

<p><code>zip</code> has an infix synonym, the Unicode operator <code>&#165;</code>, and its ASCII equivalent <code>Y</code>.</p>

<p>To read arrays in parallel like <code>zip</code> but just sequence the values rather than generating tuples, use <code>each</code> instead of <code>zip</code>.</p>

<pre>    for each(@names; @codes) -&#62; $name, $zip {
        print &#34;Name: $name;   Zip code: $zip\n&#34;;
    }</pre>

<p>The <code>each</code> function reads to the end of the longest list, not counting lists that are known to be infinite such as <code>0..Inf</code>. Missing values are replaced with <code>undef</code>. In contrast, use <code>roundrobin</code> if you just wish to skip missing entries:</p>

<pre>    for roundrobin(@queue1; @queue2; @queue3) -&#62; $next {
        ...
    }</pre>

<p>To read arrays serially rather than in parallel, use <code>cat(@x;@y)</code>. This wins a &#34;useless use of cat award&#34; in this case since you could always just write <code>(@x,@y)</code> to mean the same thing. But sometimes it&#39;s nice to be explicit about that:</p>

<pre>    @foo := [[1,2,3],[4,5,6]]; say cat([;] @foo); # 1,2,3,4,5,6</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Crossing_arrays"
>Crossing arrays</a></h1>

<p>In contrast to the zip operator, the <code>XX</code> operator returns all the permutations of its sublists. Hence you may say:</p>

<pre>    &#60;a b&#62; XX &#60;1 2&#62;</pre>

<p>and you end up with</p>

<pre>    [&#39;a&#39;, &#39;1&#39;], [&#39;a&#39;, &#39;2&#39;], [&#39;b&#39;, &#39;1&#39;], [&#39;b&#39;, &#39;2&#39;]</pre>

<p>The <code>X</code> variant crosses the arrays but concatenates strings:</p>

<pre>    &#60;a b&#62; X &#60;1 2&#62;</pre>

<p>produces</p>

<pre>    &#39;a1&#39;, &#39;a2&#39;, &#39;b1&#39;, &#39;b2&#39;</pre>

<p>The resemblance to <code>x</code> and <code>xx</code> is not entirely accidental.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Minimal_whitespace_DWIMmery"
>Minimal whitespace DWIMmery</a></h1>

<p>Whitespace is no longer allowed before the opening bracket of an array or hash subscript, or the opening parenthesis of an argument list. That is:</p>

<pre>    @deadbeef[$x]         # okay
    @a       [$b]         # WRONG
    %monsters{&#39;cookie&#39;}   # okay
    %people  {&#39;john&#39;}     # WRONG
    saymewant(&#39;cookie&#39;)   # okay
    mewant   (&#39;cookie&#39;)   # WRONG</pre>

<p>One of the several useful side-effects of this restriction is that parentheses are no longer required around the condition of control constructs:</p>

<pre>    if $value eq $target {
        print &#34;Bullseye!&#34;;
    }
    while $i &#60; 10 { $i++ }</pre>

<p>It is, however, still possible to align subscripts and other postfix operators by explicitly using the <i>long dot</i> syntax (see S02):</p>

<pre>     %monsters.{&#39;cookie&#39;} = Monster.new;
     %beatles\.{&#39;ringo&#39;}  = Beatle.new;
     %people\ .{&#39;john&#39;}   = Person.new;
     %cats\   .{&#39;fluffy&#39;} = Cat.new;</pre>

<p>Whitespace is in general required between any keyword and any opening bracket that is <i>not</i> introducing a subscript or function arguments. Any keyword followed directly by parentheses will be taken as a function call instead.</p>

<pre>    if $a == 1 { say &#34;yes&#34; }            # preferred syntax
    if ($a == 1) { say &#34;yes&#34; }          # P5-ish if construct
    if($a,$b,$c)                        # if function call</pre>

<p>It is possible for <code>if()</code> to also invoke a macro call, but if so, it&#39;s a <code>prefix:&#60;if&#62;</code> macro rather than a <code>statement_control:&#60;if&#62;</code> macro.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Precedence"
>Precedence</a></h1>

<a href="#" onclick="return tog_quote(76);">
<div ID="header_shown_76" style="display: none;">
- Hide the snippet from t/operators/precedence.t (line 12 ~ line 165) -
</div>
<div ID="header_hidden_76" style="display: block;">
- Show the snippet from t/operators/precedence.t (line 12 ~ line 165) -
</div>
</a>
<div ID="hide_76" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S03/&quot;Precedence&quot;&gt;

=cut

plan 41;


# 1. terms

# FIXME how do we test this?

# 2. postfix method

# this wants objects, but maybe it can also work like
# @sort.map binds tighter than ++ somehow?

# 3. autoincrement

my $i = 2;
is(++$i ** 2, 9, &quot;++ bind tighter than **&quot;);
is(--$i ** 2, 4, &quot;-- does too&quot;);

# 4. exponentiation

is(-2**2, -4, &quot;** bind tighter than unary -&quot;);
isa_ok(~2**4, &quot;Str&quot;, &quot;~4**4 is a string&quot;);

# 5. symbolic unary

is(-2 x 2, &quot;-2-2&quot;, &quot;unary - binds tighter than x&quot;);
is(-(2 x 2), &quot;-22&quot;, &quot;beh&quot;);
is(?2*2, 2, &quot;binary -&gt; numify causes reinterpretation as, binds tighter than *&quot;);

# 6. multiplicative

is(2 x 2 + 10, 32, &quot;x bind tighter than binary +&quot;);
is(4 + 3 * 2, 10, &quot;* binds tighter than binary +&quot;);
is(0 - 3 / 3, -1, &quot;/ bind tighter than binary -&quot;);

# 7. additive

is(1 ~ 2 * 3, 16, &quot;~ binds looser than *&quot;);
ok((1 ~ 2 &amp; 12) == 12, &quot;but tighter than &amp;&quot;);
ok((2 + 2 | 4) == 4, &quot;and + binds tigher than |&quot;);

# 8. junctive and

ok( &nbsp; &nbsp; &nbsp; (1 &amp; 2 | 3) !=3, '&amp; binds tighter than |');
ok((!(1 &amp; 2 | 3) &lt; 2), &quot;ditto&quot;);
ok(((1 &amp; 2 ^ 3) &lt; 3), &quot;and also ^&quot;);
ok( &nbsp; &nbsp; !(1 &amp; 2 ^ 4) != 3, &quot;blah blah blah&quot;);

# 9. junctive or

{ # test that | and ^ are on the same level
&nbsp; &nbsp; my $a = (1 | 2 ^ 3);
&nbsp; &nbsp; my $b = (1 ^ 2 | 3);

&nbsp; &nbsp; ok($a == 3, &quot;only one is eq 3&quot;);
&nbsp; &nbsp; ok($a != 3, &quot;either is ne 3&quot;);
&nbsp; &nbsp; ok($a == 1, &quot;either is eq 1&quot;);
&nbsp; &nbsp; ok($b == 2, &quot;either is eq 2, ne 3&quot;);
&nbsp; &nbsp; ok($b == 1, &quot;either is eq 1&quot;);
&nbsp; &nbsp; ok($b == 3, &quot;either is eq 3, of which only one is&quot;);
&nbsp; &nbsp; ok(!($b != 3), &quot;1 is ne 3, and (2 | 3) is both ne 3 and eq 3, so it's ne, so 1 ^ 2 | 3&quot;);
};

{
&nbsp; &nbsp; my $a = (abs -1 ^ -1); # read as abs(-1 ^ -1) -&gt; (1^1)
&nbsp; &nbsp; ok(!($a == 1), 'junctive or binds more tightly then abs (1)');

&nbsp; &nbsp; my $b = ((abs -1) ^ -1); # -&gt; (1 ^ -1)
&nbsp; &nbsp; ok($b == 1, &quot;this is true because only one is == 1&quot;);
};

# 10. named unary

is((abs -1 .. 3), (1 .. 3), &quot;abs binds tighter than ..&quot;);
is((rand 3 &lt;=&gt; 5), -1, &quot;rand binds tighter than &lt;=&gt;&quot;);

# 11. nonchaining binary

ok(0 &lt; 2 &lt;=&gt; 1 &lt; 2, &quot;0 &lt; 2 &lt;=&gt; 1 &lt; 2 means 0 &lt; 1 &lt; 2&quot;);

# 12. chaining binary

is((0 != 1 &amp;&amp; &quot;foo&quot;), &quot;foo&quot;, &quot;!= binds tigher than &amp;&amp;&quot;);
ok((0 || 1 == (2-1) == (0+1) || &quot;foo&quot;) ne &quot;foo&quot;, &quot;== binds tigher than || also when chaning&quot;);

# 13. tight and (&amp;&amp;)

# 14. tight or (||, ^^, //)

is((1 &amp;&amp; 0 ?? 2 !! 3), 3, &quot;&amp;&amp; binds tighter than ??&quot;);
### FIXME - need also ||, otherwise we don't prove || and ?? are diff

# 15. ternary

{
&nbsp; &nbsp; my $a = 0 ?? &quot;yes&quot; !! &quot;no&quot;;
&nbsp; &nbsp; is($a, &quot;no&quot;, &quot;??!! binds tighter than =&quot;);
# &nbsp; &nbsp;(my $b = 1) ?? &quot;true&quot; !! &quot;false&quot;;
# &nbsp; &nbsp;is($b, 1, &quot;?? !! just thrown away with = in parens&quot;);
};


# 16. assignment

{
&nbsp; &nbsp; my @c = 1, 2, 3;
&nbsp; &nbsp; is(@c, (1), &quot;= binds tighter than , (*sigh*)&quot;, :todo);
&nbsp; &nbsp; my @a = (1, 3) ¥ (2, 4);
&nbsp; &nbsp; is(@a, [1, 3], &quot;= binds tighter than yen&quot;);
};

{
&nbsp; &nbsp; my @b = ((1, 3) ¥ (2, 4));
&nbsp; &nbsp; is(@b, [1 .. 4], &quot;parens work around this&quot;);
};

# 17. list item separator

{
&nbsp; &nbsp; my @d;
&nbsp; &nbsp; ok eval('@d &lt;== (1, 3) ¥ (2, 4)'), &quot;left pointing pipe parses&quot;, :todo;
&nbsp; &nbsp; is(@d, [1 .. 4], &quot;to complicate things further, left pointing pipe *does* DWIM&quot;, :todo);
&nbsp; &nbsp; my $c = any 1, 2, 3;
&nbsp; &nbsp; ok($c == 2, &quot;any is less tight than comma&quot;);
}

# 18. rightward list op

{
&nbsp; &nbsp; my @e; eval '@e = (map { $_+1 } &lt;== (1, 2, 3) ==&gt; map { $_*2 })'; # =D
&nbsp; &nbsp; is(@e, [4, 6, 8], &quot;&lt;== is tighter than ==&gt;&quot;, :todo);
}

# 19. pipe forward

# 20. loose and

# 21. loose or

# 22. expr terminator

# 23. uc|ucfirst|lc|lcfirst
# t/builtins/strings/uc|ucfirst|lc|lcfirst.t didn't compile because of this bug.
# Compare:
# &nbsp; $ perl -we 'print uc &quot;a&quot; eq &quot;A&quot;'
# &nbsp; 1
# opposed to Pugs parses it:
# &nbsp; $ perl -we 'print uc(&quot;a&quot; eq &quot;A&quot;)'
# &nbsp; $ &nbsp; &nbsp;(no output)
ok (uc &quot;a&quot; eq &quot;A&quot;), &quot;uc has the correct precedence in comparision to eq&quot;;</pre>
</div>


<p>Perl 6 has 22 precedence levels (which is fewer than Perl 5):</p>

<pre>    terms               42 3.14 &#34;eek&#34; qq[&#34;foo&#34;] [1,2,3] {...} \(@a,$b,%c)
                            $x @y %z /abc/ MyType @@multidim $^a
                            (1+2) a(1) :by(2) :!verbose :(Dog $self:)
                            .meth with implicit invocant
                            listops leftward
    method postfix      .meth .+ .? .* .() .[] .{} .&#60;&#62; .&#171;&#187; .:: .= .^
    autoincrement       ++ --
    exponentiation      **
    symbolic unary      ! + - ~ ? $ @ % &#38; | +^ ~^ ?^ \ ^ =
    multiplicative      * / % x xx +&#38; +&#60; +&#62; ~&#38; ~&#60; ~&#62; ?&#38;
    additive            + - ~ +| +^ ~| ~^ ?| ?^
    junctive and (all)  &#38;
    junctive or (any)   | ^
    named unary         rand sleep abs etc. -e -r -w -x etc.
    nonchaining binary  but does &#60;=&#62; leg cmp
                            .. ^.. ..^ ^..^
                            ff ^ff ff^ ^ff^
                            fff ^fff fff^ ^fff^
    chaining binary     != == &#60; &#60;= &#62; &#62;=
                            eq ne lt le gt ge
                            ~~ =:= === eqv
                            !== !~~ !eq !=:= !=== !eqv etc.
    tight and           &#38;&#38;
    tight or            || ^^ //
    conditional         ?? !!
    assignment          := ::= =&#62;
                            (also = with simple lvalues)
                            += -= **= xx= .= etc.
    loose unary         true not</pre>

<a href="#" onclick="return tog_quote(75);">
<div ID="header_shown_75" style="display: none;">
- Hide the snippet from t/builtins/bool/not.t (line 5 ~ line 19) -
</div>
<div ID="header_hidden_75" style="display: block;">
- Show the snippet from t/builtins/bool/not.t (line 5 ~ line 19) -
</div>
</a>
<div ID="hide_75" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Precedence /loose unary/&gt;

is(not 1, &nbsp; &nbsp; False, &quot;not 1 is false&quot;);
is(not -1, &nbsp; &nbsp;False, &quot;not -1 is false&quot;);
is(!(not 0), &nbsp;False, &quot;!not 0 is false&quot;);
is(not sub{}, False, 'not sub{} is false');
is(not &quot;x&quot;, &nbsp; False, 'not &quot;x&quot; is false');

my $a = 1; is(not $a, &nbsp; &nbsp;False, 'not $not_var is false');
my $b = 0; is(!(not $b), False, 'not $false_var is not false');

is( not(not 42), True, &quot;not(not 42) is true&quot;);
is(!not(not &nbsp;0), True, &quot;not(not &nbsp;0) is true&quot;);

is(not True, False, &quot;bare 'True' is not false&quot;);</pre>
</div>


<a href="#" onclick="return tog_quote(74);">
<div ID="header_shown_74" style="display: none;">
- Hide the snippet from t/builtins/bool/true.t (line 5 ~ line 19) -
</div>
<div ID="header_hidden_74" style="display: block;">
- Show the snippet from t/builtins/bool/true.t (line 5 ~ line 19) -
</div>
</a>
<div ID="hide_74" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Precedence /loose unary/&gt;

ok(true 1, &nbsp; &nbsp; &quot;true 1 is true&quot;);
ok(true -1, &nbsp; &nbsp;&quot;true -1 is true&quot;);
ok(!(true 0), &nbsp;&quot;!true 0 is true&quot;);
ok(true sub{}, 'true sub{} is true');
ok(true &quot;x&quot;, &nbsp; 'true &quot;x&quot; is true');

my $a = 1; ok(true $a, &nbsp; &nbsp;'true $true_var is true');
my $b = 0; ok(!(true $b), 'true $false_var is not true');

ok( true(true 42), &quot;true(true 42) is true&quot;);
ok(!true(true &nbsp;0), &quot;true(true &nbsp;0) is false&quot;);

ok(true True, &quot;bare 'True' is true&quot;);</pre>
</div>


<pre>    list ops            , print push say join split substr open etc.
                            any all one none
                            die fail warn
                            !!! ...  ???
                            [+] [*] [&#60;] [\+] [\*] etc.
                            (also = as list assignment)
    list infix          &#165; &#60;== ==&#62; X XX X~X X*X XeqvX etc.
    loose and           and</pre>

<a href="#" onclick="return tog_quote(77);">
<div ID="header_shown_77" style="display: none;">
- Hide the snippet from t/operators/and_precedence.t (line 6 ~ line 14) -
</div>
<div ID="header_hidden_77" style="display: block;">
- Show the snippet from t/operators/and_precedence.t (line 6 ~ line 14) -
</div>
</a>
<div ID="hide_77" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S03/Precedence /loose and/&gt;
my $run = 1;

sub isfive (*@args) {
&nbsp; &nbsp; is(@args[0], 5, &quot;First arg is 5, run &quot; ~ $run++)
}

isfive(5) and isfive(5);
isfive 5 &nbsp;and isfive 5;</pre>
</div>


<pre>    loose or            or xor err
    expr terminator     ; {} as control block, statement modifiers
                            unmatched ), ], }, etc.</pre>

<p>Comma is the only listop that is allowed to occur where an operator is expected. All other listops function as a term within the list to the left.</p>

<!-- end doc -->

</body></html>
