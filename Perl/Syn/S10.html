<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
           "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>S10</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="http://dev.perl.org/css/perl.css">

<script type="text/javascript">
var agt = navigator.userAgent.toLowerCase();

var is_opera = (agt.indexOf("opera") != -1);
var is_ie = (agt.indexOf("msie") != -1) && document.all && !is_opera;
var is_ie5 = (agt.indexOf("msie 5") != -1) && document.all;

function tog() {
  // tog: toggle the visibility of html elements (arguments[1..]) from none to
  // arguments[0].  Return what should be returned in a javascript onevent().
  display = arguments[0];
  for( var i=1; i<arguments.length; i++ ) {
    var x = document.getElementById(arguments[i]);
    if (!x) continue;
    if (x.style.display == "none" || x.style.display == "") {
      x.style.display = display;
    } else {
      x.style.display = "none";
    }
  }

  var e = is_ie ? window.event : this;
  if (e) {
    if (is_ie) {
      e.cancelBubble = true;
      e.returnValue = false;
      return false;
    } else {
      return false;
    }
  }
}

function tog_quote( idnum ) {
  return tog( 'block', 'header_shown_' + idnum, 'header_hidden_' + idnum,
       'hide_' + idnum );
}

</script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.03,
  using Pod::Simple::PullParser v2.02,
  under Perl v5.008007 at Tue Sep  5 13:37:16 2006 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
            <I>This page was generated at 2006-09-05 13:37:16 GMT.
            (syn <strong>r11725</strong>, pugs <strong>r13036</strong>)</I>
        
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Overview'>Overview</a>
  <li class='indexItem indexItem1'><a href='#Packages'>Packages</a>
  <li class='indexItem indexItem1'><a href='#Autoloading'>Autoloading</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 10: Packages</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Larry Wall &#60;larry@wall.org&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre>  Maintainer: Larry Wall &#60;larry@wall.org&#62;
  Date: 27 Oct 2004
  Last Modified: 6 Apr 2006
  Number: 10
  Version: 6</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Overview"
>Overview</a></h1>

<p>This synopsis summarizes Apocalypse 10, which discusses packages despite never having been written.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Packages"
>Packages</a></h1>

<p>As in Perl 5, packages are the basis of modules and classes. Unlike in Perl 5, modules and classes are declared with separate keywords, but they&#39;re still just packages with extra behaviors.</p>

<p>An ordinary package is declared with the <code>package</code> keyword. It can only be used with a block:</p>

<pre>    package Bar {...}   # block is in package Bar</pre>

<p>A named package declaration can occur as part of an expression, just like named subroutine declarations.</p>

<p>As a special exception, if a braceless <code>package</code> declaration occurs as the first executable statement in a file, then it&#39;s taken to mean that the rest of the file is Perl 5 code.</p>

<pre>    package Foo;        # the entire file is Perl 5
    ...</pre>

<p>This form is illegal in the middle of a Perl 6 file.</p>

<p>Since there are no barewords in Perl 6, package names must be predeclared, or use the sigil-like <code>::PackageName</code> syntax. The <code>::</code> prefix does not imply top-levelness as it does in Perl 5. (Use <code>::*</code> for that.)</p>

<p>A bare <code>package</code> declarator declares an <code>our</code> package within the current package (or module, or class, or role, or...). Use <code>*</code> or <code>GLOBAL::</code> to declare a global package name.</p>

<p>To declare a lexically scoped package, use <code>my package</code>. Package names are always searched for from innermost scopes to outermost. As with an initial <code>::</code>, the presence of a <code>::</code> within the name does not imply globalness (unlike in Perl 5). True globals are always in the <code>GLOBAL::</code> namespace, which has the shortcut <code>*</code> where that is not ambiguous with &#34;real&#34; operators.</p>

<p>The <code>*</code> namespace is not &#34;main&#34;. The default namespace for the main program is <code>*Main</code> in Perl 6. All files start out being parsed in the <code>*</code> package, but switch to some other package scope depending on the first declaration. If that first declaration is not a package variant, then the parsing switches to the &#34;<code>*main</code>&#34; package for Perl 5 code and the &#34;<code>*Main</code>&#34; package for Perl 6 code.</p>

<p>Package traits are set using <code>is</code>:</p>

<pre>    package Foo is bar {...}</pre>

<p>All symbolic links are done with the <code>::($expr)</code> syntax, which is legal in any variable, package, module, or class name anywhere a <code>::Ident</code> is legal. The string returned by the expression will be parsed for <code>::</code> indicating subpackage names. Do not confuse this with the</p>

<pre>    Foo::{$key}</pre>

<p>syntax that lets you do a lookup in a particular symbol table. In this case, the key is not parsed for <code>::</code>. It&#39;s just a hash lookup.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Autoloading"
>Autoloading</a></h1>

<a href="#" onclick="return tog_quote(1);">
<div ID="header_shown_1" style="display: none;">
- Hide the snippet from t/builtins/undef.t (line 273 ~ line 315) -
</div>
<div ID="header_hidden_1" style="display: block;">
- Show the snippet from t/builtins/undef.t (line 273 ~ line 315) -
</div>
</a>
<div ID="hide_1" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S10/Autoloading&gt;

flunk(&quot;FIXME (autoload tests)&quot;, :todo&lt;parsefail&gt;);
# Currently waiting on
# - packages
# - symtable hash
# - autoloading itself

#{
# &nbsp; &nbsp;package AutoMechanic {
# &nbsp; &nbsp; &nbsp; &nbsp;AUTOSCALAR &nbsp; &nbsp;{ \my $_scalar }
# &nbsp; &nbsp; &nbsp; &nbsp;AUTOARRAY &nbsp; &nbsp; { \my @_array }
# &nbsp; &nbsp; &nbsp; &nbsp;AUTOHASH &nbsp; &nbsp; &nbsp;{ \my %_hash }
# &nbsp; &nbsp; &nbsp; &nbsp;AUTOSUB &nbsp; &nbsp; &nbsp; { { &quot;code&quot; } }
# &nbsp; &nbsp; &nbsp; &nbsp;AUTOMETH &nbsp; &nbsp; &nbsp;{ { &quot;code&quot; } }
#
# &nbsp; &nbsp; &nbsp; &nbsp;AUTOSCALARDEF { %::«{'$' ~ $_}» = &quot;autoscalardef&quot; }
# &nbsp; &nbsp; &nbsp; &nbsp;AUTOARRAYDEF &nbsp;{ %::«{'@' ~ $_}» = &quot;autoarraydef&quot;.split(&quot;&quot;) }
# &nbsp; &nbsp; &nbsp; &nbsp;AUTOHASHDEF &nbsp; { %::«{'%' ~ $_}» = &lt;autohashdef yes&gt; }
# &nbsp; &nbsp; &nbsp; &nbsp;AUTOSUBDEF &nbsp; &nbsp;{ %::«{'&amp;' ~ $_}» = { &quot;autosubdef&quot; } }
# &nbsp; &nbsp; &nbsp; &nbsp;AUTOMETHDEF &nbsp; { %::«{'&amp;' ~ $_}» = { &quot;automethdef&quot; } }
# &nbsp; &nbsp;}
#
# &nbsp; &nbsp;is(ref $AutoMechanic::scalar0, &nbsp; &nbsp;&quot;Scalar&quot;, &quot;autoload - scalar&quot;);
# &nbsp; &nbsp;is(ref @AutoMechanic::array0, &nbsp; &nbsp; &quot;Array&quot;, &nbsp;&quot;autoload - array&quot;);
# &nbsp; &nbsp;is(ref %AutoMechanic::hash, &nbsp; &nbsp; &nbsp; &quot;Hash&quot;, &nbsp; &quot;autoload - hash&quot;);
# &nbsp; &nbsp;is(ref &amp;AutoMechanic::sub0, &nbsp; &nbsp; &nbsp; &quot;Code&quot;, &nbsp; &quot;autoload - sub&quot;);
# &nbsp; &nbsp;is(ref AutoMechanic.can(&quot;meth0&quot;), &quot;Code&quot;, &nbsp; &quot;autoload - meth&quot;);
#
# &nbsp; &nbsp;is($AutoMechanic::scalar, &quot;autoscalardef&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;autoloaddef - scalar&quot;);
# &nbsp; &nbsp;is(~@AutoMechanic::ary, &nbsp; ~(&quot;autoarraydef&quot;.split(&quot;&quot;), &quot;autoloaddef - array&quot;);
# &nbsp; &nbsp;is(~%AutoMechanic::hash, &nbsp;~&lt;autohashdef yes&gt;, &nbsp; &nbsp; &nbsp; &nbsp; &quot;autoloaddef - hash&quot;);
# &nbsp; &nbsp;is(&amp;AutoMechanic::sub.(), &quot;autosubdef&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;autoloaddef - sub&quot;);
# &nbsp; &nbsp;is(AutoMechanic.meth(), &nbsp; &quot;automethdef&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;autoloaddef - method&quot;);
#}

# Extra tests added due to apparent bugs
is((undef) + 1, 1, 'undef + 1');
is(1 + (undef), 1, '1 + undef');
is((undef) * 2, 0, 'undef * 2');
is(2 * (undef), 0, '2 * undef');
is((undef) xx 2, [undef, undef], 'undef xx 2');
is((undef) * (undef), 0, 'undef * undef');</pre>
</div>


<p>A package (or any other similar namespace) can control autoloading. However, Perl 5&#39;s <code>AUTOLOAD</code> is being superseded by MMD autoloaders that distinguish declaration from definition, but are not restricted to declaring subs. A run-time declarator multisub is declared as:</p>

<pre>    multi CANDO ( MyPackage, $type, $name; *%args --&#62; Container)</pre>

<p>which stands in for the declaration of a container object within another container object; it is called when anyone is searching for a name in the package (or module, or class), and the name doesn&#39;t already exist in the package. (In particular, <code>.can</code> calls <code>CANDO</code> when trying to determine if a class supports a particular method.) The arguments to <code>CANDO</code> include type information on what kind of object is expected in context, or this may be intuited from the name requested. In any case, there may be multiple <code>CANDO</code> routines that are dispatched via MMD:</p>

<pre>    multi CANDO ( MyPackage, Item, $name; *%args --&#62; Container)
    multi CANDO ( MyPackage, Array, $name; *%args --&#62; Container)
    multi CANDO ( MyPackage, Hash, $name; *%args --&#62; Container)
    multi CANDO ( MyPackage, Code, $name; *%args --&#62; Container)</pre>

<p>The package itself is just passed as the first argument, since it&#39;s the container object. Subsequent arguments identify the desired type of the inner container and the &#34;name&#34; or &#34;key&#34; by which the object is to be looked up in the outer container. Such a name does not include its container name, unlike Perl 5&#39;s magical <code>$AUTOLOAD</code> variable.</p>

<p>The <code>CANDO</code> is expected to return an inner container object of the proper sort (i.e. a variable, subroutine, or method object), or to a proxy object that can &#34;autovivify&#34; lazily, or <code>undef</code> if that name is not to be considered declared in the namespace in question.</p>

<p>The declaration merely defines the interface to the new object. That object need not be completely defined yet, though the <code>CANDO</code> routine is certainly <i>allowed</i> to define it eagerly, and even install the inner object into the outer container (the symbol table) if it wants to cache the declaration.</p>

<p>At declaration time it might not yet be known whether the inner container object will be used in lvalue or rvalue context; the use of a proxy object can supply either readonly or rw semantics later.</p>

<p>When the package in question is a class, it is also possible to declare real methods or submethods:</p>

<pre>    multi method CANDO ($self: Code, $name; *%args --&#62; Container)

    multi submethod CANDO ($self: Item, $name; *%args --&#62; Container)</pre>

<p>The method form is inherited by subclasses. Submethods are never inherited but may still do MMD within the class. (Ordinary multisubs are inherited only to the extent allowed by the MMD mechanism.)</p>

<p>When someone tries to actually call or access an undefined object (which may have come from one of the routines above, or might have just been declared with a body of <code>{...}</code>), or might just be a variable declared without an initializer, a different hook is used to define actual behavior at the last moment:</p>

<pre>    submethod AUTODEF ($self:) { ... }</pre>

<p>(Unlike the <code>CANDO</code> interface, we do not pass the package.)</p>

<p>This routine is passed an uninitialized (or underinitialized) object, and is expected to define or build the object, but not to call it, since the call is already &#34;scheduled&#34; from somewhere else. (Perl 5&#39;s <code>goto &#38;$AUTOLOAD</code> is implicit, in other words. But you can hijack the call via the <code>call</code> builtin, in which case the autoloader behaves just like a wrapper--see S06.)</p>

<p>In any case, there is no longer any magical <code>$AUTOLOAD</code> variable. The <code>AUTODEF</code> is a mutator, and thus is not expected to return the object. No name is passed to <code>AUTODEF</code>--in a context where a name is being declared at call time, the name is automatically introduced with <code>CANDO</code> before <code>AUTODEF</code> is called. The outer container, if available, is accessed via <code>$+CONTAINER</code>. In the case of a sub call, the call&#39;s unbound <code>ArgList</code> object will be available via <code>$+ARGLIST</code>. <code>$+ARGLIST</code> is a rw variable, and mutations to it will be seen by the eventual &#34;real&#34; call.</p>

<p>If a <code>AUTODEF</code> submethod wishes merely to perform some action without defining <code>$self</code>, that is fine. It needs to signal that desire by use of an explicit &#34;return;&#34; statement.</p>

<p>A <code>AUTODEF</code> submethod is really just a variant of <code>BUILD</code> with no named arguments. As with <code>BUILD</code>, default values for attributes are applied at the end for any attributes not explicitly set. A typical <code>AUTODEF</code> definition might be:</p>

<pre>    submethod AUTODEF { self.=BUILD }</pre>

<p>or maybe even just:</p>

<pre>    our &#38;AUTODEF ::= &#38;BUILD;</pre>

<!-- end doc -->

</body></html>
