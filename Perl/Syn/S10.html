<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
           "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>S10</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="http://dev.perl.org/css/perl.css">

<script type="text/javascript">
var agt = navigator.userAgent.toLowerCase();

var is_opera = (agt.indexOf("opera") != -1);
var is_ie = (agt.indexOf("msie") != -1) && document.all && !is_opera;
var is_ie5 = (agt.indexOf("msie 5") != -1) && document.all;

function tog() {
  // tog: toggle the visibility of html elements (arguments[1..]) from none to
  // arguments[0].  Return what should be returned in a javascript onevent().
  display = arguments[0];
  for( var i=1; i<arguments.length; i++ ) {
    var x = document.getElementById(arguments[i]);
    if (!x) continue;
    if (x.style.display == "none" || x.style.display == "") {
      x.style.display = display;
    } else {
      x.style.display = "none";
    }
  }

  var e = is_ie ? window.event : this;
  if (e) {
    if (is_ie) {
      e.cancelBubble = true;
      e.returnValue = false;
      return false;
    } else {
      return false;
    }
  }
}

function tog_quote( idnum ) {
  return tog( 'block', 'header_shown_' + idnum, 'header_hidden_' + idnum,
       'hide_' + idnum );
}

</script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.03,
  using Pod::Simple::PullParser v2.02,
  under Perl v5.008007 at Thu Aug 24 14:07:11 2006 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
            <strong>S10.html</strong> - generated by smartlinks.pl at Thu Aug 24 14:07:11 2006 GMT.
        
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Overview'>Overview</a>
  <li class='indexItem indexItem1'><a href='#Packages'>Packages</a>
  <li class='indexItem indexItem1'><a href='#Autoloading'>Autoloading</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 10: Packages</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Larry Wall &#60;larry@wall.org&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre>  Maintainer: Larry Wall &#60;larry@wall.org&#62;
  Date: 27 Oct 2004
  Last Modified: 6 Apr 2006
  Number: 10
  Version: 6</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Overview"
>Overview</a></h1>

<p>This synopsis summarizes Apocalypse 10, which discusses packages despite never having been written.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Packages"
>Packages</a></h1>

<p>As in Perl 5, packages are the basis of modules and classes. Unlike in Perl 5, modules and classes are declared with separate keywords, but they&#39;re still just packages with extra behaviors.</p>

<p>An ordinary package is declared with the <code>package</code> keyword. It can only be used with a block:</p>

<pre>    package Bar {...}   # block is in package Bar</pre>

<p>A named package declaration can occur as part of an expression, just like named subroutine declarations.</p>

<p>As a special exception, if a braceless <code>package</code> declaration occurs as the first executable statement in a file, then it&#39;s taken to mean that the rest of the file is Perl 5 code.</p>

<pre>    package Foo;        # the entire file is Perl 5
    ...</pre>

<p>This form is illegal in the middle of a Perl 6 file.</p>

<p>Since there are no barewords in Perl 6, package names must be predeclared, or use the sigil-like <code>::PackageName</code> syntax. The <code>::</code> prefix does not imply top-levelness as it does in Perl 5. (Use <code>::*</code> for that.)</p>

<p>A bare <code>package</code> declarator declares an <code>our</code> package within the current package (or module, or class, or role, or...). Use <code>*</code> or <code>GLOBAL::</code> to declare a global package name.</p>

<p>To declare a lexically scoped package, use <code>my package</code>. Package names are always searched for from innermost scopes to outermost. As with an initial <code>::</code>, the presence of a <code>::</code> within the name does not imply globalness (unlike in Perl 5). True globals are always in the <code>GLOBAL::</code> namespace, which has the shortcut <code>*</code> where that is not ambiguous with &#34;real&#34; operators.</p>

<p>The <code>*</code> namespace is not &#34;main&#34;. The default namespace for the main program is <code>*Main</code> in Perl 6. All files start out being parsed in the <code>*</code> package, but switch to some other package scope depending on the first declaration. If that first declaration is not a package variant, then the parsing switches to the &#34;<code>*main</code>&#34; package for Perl 5 code and the &#34;<code>*Main</code>&#34; package for Perl 6 code.</p>

<p>Package traits are set using <code>is</code>:</p>

<pre>    package Foo is bar {...}</pre>

<p>All symbolic links are done with the <code>::($expr)</code> syntax, which is legal in any variable, package, module, or class name anywhere a <code>::Ident</code> is legal. The string returned by the expression will be parsed for <code>::</code> indicating subpackage names. Do not confuse this with the</p>

<pre>    Foo::{$key}</pre>

<p>syntax that lets you do a lookup in a particular symbol table. In this case, the key is not parsed for <code>::</code>. It&#39;s just a hash lookup.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Autoloading"
>Autoloading</a></h1>

<a name="msg_1"></a>
<a href="?hide_quotes=no#msg_1" onclick="return tog_quote(1);">
<div ID="header_shown_1" style="display: none;">
- Hide the snippet from t/builtins/undef.t (line 273 ~ line 315) -
</div>
<div ID="header_hidden_1" style="display: block;">
- Show the snippet from t/builtins/undef.t (line 273 ~ line 315, 43 lines) -
</div>
</a>
<div ID="hide_1" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S10/Autoloading&gt;

flunk("FIXME (autoload tests)", :todo&lt;parsefail&gt;);
# Currently waiting on
# - packages
# - symtable hash
# - autoloading itself

#{
#    package AutoMechanic {
#        AUTOSCALAR    { \my $_scalar }
#        AUTOARRAY     { \my @_array }
#        AUTOHASH      { \my %_hash }
#        AUTOSUB       { { "code" } }
#        AUTOMETH      { { "code" } }
#
#        AUTOSCALARDEF { %::«{'$' ~ $_}» = "autoscalardef" }
#        AUTOARRAYDEF  { %::«{'@' ~ $_}» = "autoarraydef".split("") }
#        AUTOHASHDEF   { %::«{'%' ~ $_}» = &lt;autohashdef yes&gt; }
#        AUTOSUBDEF    { %::«{'&amp;' ~ $_}» = { "autosubdef" } }
#        AUTOMETHDEF   { %::«{'&amp;' ~ $_}» = { "automethdef" } }
#    }
#
#    is(ref $AutoMechanic::scalar0,    "Scalar", "autoload - scalar");
#    is(ref @AutoMechanic::array0,     "Array",  "autoload - array");
#    is(ref %AutoMechanic::hash,       "Hash",   "autoload - hash");
#    is(ref &amp;AutoMechanic::sub0,       "Code",   "autoload - sub");
#    is(ref AutoMechanic.can("meth0"), "Code",   "autoload - meth");
#
#    is($AutoMechanic::scalar, "autoscalardef",            "autoloaddef - scalar");
#    is(~@AutoMechanic::ary,   ~("autoarraydef".split(""), "autoloaddef - array");
#    is(~%AutoMechanic::hash,  ~&lt;autohashdef yes&gt;,         "autoloaddef - hash");
#    is(&amp;AutoMechanic::sub.(), "autosubdef",               "autoloaddef - sub");
#    is(AutoMechanic.meth(),   "automethdef",              "autoloaddef - method");
#}

# Extra tests added due to apparent bugs
is((undef) + 1, 1, 'undef + 1');
is(1 + (undef), 1, '1 + undef');
is((undef) * 2, 0, 'undef * 2');
is(2 * (undef), 0, '2 * undef');
is((undef) xx 2, [undef, undef], 'undef xx 2');
is((undef) * (undef), 0, 'undef * undef');</pre>
</div>


<p>A package (or any other similar namespace) can control autoloading. However, Perl 5&#39;s <code>AUTOLOAD</code> is being superseded by MMD autoloaders that distinguish declaration from definition, but are not restricted to declaring subs. A run-time declarator multisub is declared as:</p>

<pre>    multi CANDO ( MyPackage, $type, $name; *%args --&#62; Container)</pre>

<p>which stands in for the declaration of a container object within another container object; it is called when anyone is searching for a name in the package (or module, or class), and the name doesn&#39;t already exist in the package. (In particular, <code>.can</code> calls <code>CANDO</code> when trying to determine if a class supports a particular method.) The arguments to <code>CANDO</code> include type information on what kind of object is expected in context, or this may be intuited from the name requested. In any case, there may be multiple <code>CANDO</code> routines that are dispatched via MMD:</p>

<pre>    multi CANDO ( MyPackage, Item, $name; *%args --&#62; Container)
    multi CANDO ( MyPackage, Array, $name; *%args --&#62; Container)
    multi CANDO ( MyPackage, Hash, $name; *%args --&#62; Container)
    multi CANDO ( MyPackage, Code, $name; *%args --&#62; Container)</pre>

<p>The package itself is just passed as the first argument, since it&#39;s the container object. Subsequent arguments identify the desired type of the inner container and the &#34;name&#34; or &#34;key&#34; by which the object is to be looked up in the outer container. Such a name does not include its container name, unlike Perl 5&#39;s magical <code>$AUTOLOAD</code> variable.</p>

<p>The <code>CANDO</code> is expected to return an inner container object of the proper sort (i.e. a 