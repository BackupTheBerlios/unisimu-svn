=head1 NAME

report - 计算机仿真实验报告

=head1 AUTHOR

章亦春 E<lt>agentzh@gmail.comE<gt>

3030602110 计算机0304班

计算机科学与通信工程学院 江苏大学

=head1 VERSION

   Maintainer: Agent Zhang <agentzh@gmail.com>
   Date: 23 Dec 2006
   Last Modified: 23 Dec 2006
   Version: 0.01

=head1 DESCRIPTION

在这篇报告中，我将描述我为计算机仿真课程开发的超市服务台仿真
系统。

老师制定的该系统的要求如下：

=over

=item 排队规则

先到先服务

=item 要求

建立仿真模型，确实系统的平均排队时间。顾客总选择最短的队列排队。

=back

我的系统实现了上述所有要求，并有以下亮点：

=over

=item *

开发了一个通用目的的基于事件调度的仿真引擎库 Sim.

关于 Sim 库的更多信息，请参阅 Sim 库中各个类的文档。

=item *

使用了我从前编写的 Tesla 系统（即通用目的数字逻辑电路仿真系统）对 Sim
库进行了比较彻底的单元测试和综合测试。

=item *

使用我的 Sim 库作为仿真引擎，实现了 G/G/m 多服务台排队仿真类库 SuperMarket (SM)。
而该类库自身只有 100 多行代码。

G/G/m 意味着不仅是多服务台，且顾客到达间隔和服务时间都允许用户指定任意的随机分布
函数或者固定取值。

有关 SuperMarket 类库的更多细节，请参阅 SuperMarket 库中各个类的文档。

=item *

基于 SM 库，开发了 M/M/m 仿真程序。当 m 取 1 时，该程序亦实现了 M/M/1 排队模型。

使用下面的动态网页对我的 M/M/1 系统的仿真行为进行简单评估：

 XXX url?

同时，我使用下面的 Mathworks 公司的 Simlink 教程中关于 M/M/m 排队模型的仿真和理论
结果对我的 M/M/m 系统的仿真行为进行了简单评估：

 XXX url?

=item *

在事件注册上使用了计算机科学中先进的 Continuation 技术。

简要言之，便是使用Continuation 来实现每当一个顾客到来时，才“计划”下一个顾客的到
来时刻的惰性行为。类似地，每当服务台开始服务下一个顾客的时候，才真正“计划”它服务完
该顾客所需的时间。

Continuation 的好处在于无需人为地推动这个惰性的传播链条，而实现自动的控制权传递。
这给仿真终止条件的确定带来极大的灵活性，同时也通过惰性行为显著地改善了仿真系统
的空间和时间效率。

=item *

使用“去随机性”的方法来对仿真器的行为进行综合测试。

虽然我们可以借助 M/M/1 和 M/M/m 排队模型的理论计算结果对我们的实际仿真结果进行某种
意义上的“检验”，但是鉴于随机行为固有的不确定性，即便是大量实验的统计行为也无法达到
与理论值的完全吻合。所以，为了测试仿真器自身的行为，必须去随机性，采用精确的顾客到达
间隔和服务台服务时间，以便能对仿真结果进行精确地预期。

=item *

将仿真逻辑与仿真结果的统计分离

对于一个仿真系统而言，仿真结果的统计可能是整个系统中最为复杂的部分。为了使仿真器的
源代码保持整洁，同时方便分别对仿真器和统计量计算部件进行单元测试，我在 SM 项目中
将二者的实现分离。

基本的仿真器运行过程如下：首先运行仿真器，将仿真结果以基本的事件日志的形式输出到 stdout
（或者重定向到管道和磁盘文件）。然后再将该输出作为输入喂给统计量计算程序，计算出所需的
平均排队时间、平均队长等一系统统计量。

=item *

使用我开发的 CPAN 模块 C<UML::Class::Simple> 自动通过运行 SM 和 Sim 类库绘制出整个仿真系统
的 UML 类图（简化版本）：

XXX test.png

使用 XXX 开发的 CPAN 模块 C<UML::Sequence> 自动通过运行 G/G/m 仿真代码绘制出仿真系统的
UML 序列图 (UML Sequence Diagram)：

XXX test2.png

=back

=head1 SEE ALSO

L<Sim::Dispatcher>, L<Sim::Clock>, L<SM>, L<SM::Client>, L<SM::Server>,
L<SM::Simulator>.
